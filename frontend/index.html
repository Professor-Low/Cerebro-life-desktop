<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#000000">
    <title>Cerebro</title>

    <!-- Favicon - Cerebro logo -->
    <link rel="icon" type="image/png" sizes="128x128" href="/static/cerebro-logo-128.png">
    <link rel="apple-touch-icon" sizes="192x192" href="icon-192.png">

    <!-- PWA Manifest -->
    <link rel="manifest" href="manifest.json">

    <!-- Markdown rendering -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <!-- HTML sanitization for safe markdown rendering -->
    <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.6/dist/purify.min.js"></script>

    <!-- GSAP Animation Library (100% free) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>

    <!-- tsParticles for ambient background -->
    <script src="https://cdn.jsdelivr.net/npm/tsparticles@2/tsparticles.bundle.min.js"></script>

    <!-- Lenis for smooth scrolling -->
    <script src="https://unpkg.com/lenis@1.1.18/dist/lenis.min.js"></script>

    <!-- Standalone performance mode: kill non-essential CSS animations to save CPU -->
    <style id="standalone-perf">
        body.standalone-mode *,
        body.standalone-mode *::before,
        body.standalone-mode *::after {
            animation-duration: 0s !important;
            transition-duration: 0.1s !important;
        }
        /* Keep essential UI feedback animations */
        body.standalone-mode .spin-loader,
        body.standalone-mode .loading-spinner,
        body.standalone-mode [class*="typing-dot"],
        body.standalone-mode .cursor-blink {
            animation-duration: 1s !important;
        }
    </style>
    <script>
        // Detect standalone early: Electron preload or Docker localhost:61000
        window.__STANDALONE = !!(window.cerebroDesktop) || (location.port === '61000' && location.hostname === 'localhost');
        if (window.__STANDALONE) {
            document.addEventListener('DOMContentLoaded', function() {
                document.body.classList.add('standalone-mode');
                console.log('[Perf] Standalone mode: CSS animations disabled');
            });
        }
    </script>

    <style>
        :root {
            /* === BACKGROUNDS (Deep space) === */
            --bg-primary: #050508;
            --bg-secondary: #08080e;
            --bg-card: #0c0c14;
            --bg-elevated: #10101c;
            --bg-hover: #1a1a2a;

            /* === ACCENT COLORS (Enhanced purple palette) === */
            --accent: #8b5cf6;
            --accent-light: #a78bfa;
            --accent-dark: #6d28d9;
            --accent-secondary: #6366f1;
            --accent-gradient: linear-gradient(135deg, #8b5cf6 0%, #6366f1 50%, #4f46e5 100%);
            --accent-glow: rgba(139, 92, 246, 0.25);
            --accent-glow-strong: rgba(139, 92, 246, 0.5);

            /* === ENERGY ACCENTS === */
            --energy-blue: #3b82f6;
            --energy-amber: #f59e0b;
            --energy-glow-blue: rgba(59, 130, 246, 0.4);
            --energy-glow-amber: rgba(245, 158, 11, 0.4);

            /* === GLOW EFFECTS (Expanded for glassmorphism) === */
            --glow-subtle: rgba(139, 92, 246, 0.15);
            --glow-medium: rgba(139, 92, 246, 0.35);
            --glow-strong: rgba(139, 92, 246, 0.55);
            --glow-intense: rgba(139, 92, 246, 0.8);

            /* === GLASSMORPHISM === */
            --glass-bg: rgba(12, 12, 20, 0.75);
            --glass-bg-light: rgba(16, 16, 28, 0.65);
            --glass-border: rgba(139, 92, 246, 0.2);
            --glass-border-hover: rgba(139, 92, 246, 0.45);
            --glass-blur: 20px;

            /* === SPECIAL OPS (Pink theme) === */
            --specops-pink: #ff2d78;
            --specops-pink-light: #ff5e9e;
            --specops-glow: rgba(255, 45, 120, 0.25);
            --specops-gradient: linear-gradient(135deg, #ff2d78, #ff006e, #e6005c);
            --specops-border: rgba(255, 45, 120, 0.3);

            /* === TEXT (High contrast) === */
            --text-primary: #f4f4f5;
            --text-secondary: #a1a1aa;
            --text-muted: #71717a;

            /* Status Colors */
            --green: #22c55e;
            --yellow: #eab308;
            --red: #ef4444;
            --blue: #3b82f6;
            --cyan: #22d3ee;

            /* === BORDERS (Softer) === */
            --border: rgba(255, 255, 255, 0.06);
            --border-light: rgba(255, 255, 255, 0.1);
            --border-accent: rgba(139, 92, 246, 0.3);
            --glass: rgba(255, 255, 255, 0.03);

            /* === SHADOWS (Layered depth) === */
            --shadow-sm: 0 2px 8px rgba(0, 0, 0, 0.4);
            --shadow-md: 0 4px 16px rgba(0, 0, 0, 0.5);
            --shadow-lg: 0 8px 32px rgba(0, 0, 0, 0.6);
            --shadow-glow: 0 0 40px var(--glow-medium);

            /* === ANIMATION TIMING === */
            --ease-out-expo: cubic-bezier(0.16, 1, 0.3, 1);
            --ease-out-back: cubic-bezier(0.34, 1.56, 0.64, 1);
            --ease-spring: cubic-bezier(0.175, 0.885, 0.32, 1.275);

            /* Sizing */
            --safe-bottom: env(safe-area-inset-bottom, 0px);
            --nav-height: 70px;
        }

        /* === GLASSMORPHISM UTILITIES === */
        .glass {
            background: var(--glass-bg);
            backdrop-filter: blur(var(--glass-blur));
            -webkit-backdrop-filter: blur(var(--glass-blur));
            border: 1px solid var(--glass-border);
            box-shadow:
                var(--shadow-lg),
                inset 0 1px 0 rgba(255, 255, 255, 0.05);
        }

        .glass:hover {
            border-color: var(--glass-border-hover);
            box-shadow:
                var(--shadow-lg),
                var(--shadow-glow),
                inset 0 1px 0 rgba(255, 255, 255, 0.08);
        }

        .glass-subtle {
            background: rgba(18, 18, 26, 0.5);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: 1px solid var(--border);
        }

        /* Backdrop-filter fallback */
        @supports not (backdrop-filter: blur(16px)) {
            .glass, .glass-subtle, .chat-input-wrapper, .message.assistant {
                background: var(--bg-card) !important;
            }
        }

        /* Ripple effect for buttons */
        .btn-primary, .btn-secondary {
            position: relative;
            overflow: hidden;
        }

        .ripple {
            position: absolute;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            width: 100px;
            height: 100px;
            margin-left: -50px;
            margin-top: -50px;
            pointer-events: none;
            animation: rippleAnim 0.6s ease-out forwards;
        }

        @keyframes rippleAnim {
            from {
                transform: scale(0);
                opacity: 0.5;
            }
            to {
                transform: scale(4);
                opacity: 0;
            }
        }

        /* === PROFESSIONAL CSS ICONS === */
        .icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 20px;
            height: 20px;
            flex-shrink: 0;
        }

        .icon-memory::before {
            content: '';
            width: 14px;
            height: 14px;
            border: 2px solid var(--accent);
            border-radius: 50%;
            box-shadow: 0 0 8px var(--glow-subtle);
        }

        .icon-agents::before {
            content: '';
            width: 12px;
            height: 12px;
            background: var(--accent-secondary);
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
        }

        .icon-health::before {
            content: '';
            width: 10px;
            height: 10px;
            background: var(--green);
            border-radius: 50%;
            box-shadow: 0 0 8px var(--green);
        }

        .icon-status::before {
            content: '';
            width: 0;
            height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-bottom: 10px solid var(--yellow);
            filter: drop-shadow(0 0 4px var(--yellow));
        }

        .icon-bell::before {
            content: none;
        }

        .icon-refresh::before {
            content: '';
            width: 12px;
            height: 12px;
            border: 2px solid var(--text-secondary);
            border-top-color: transparent;
            border-radius: 50%;
        }

        .icon-worker::before {
            content: '';
            width: 0;
            height: 0;
            border-left: 5px solid transparent;
            border-right: 5px solid transparent;
            border-bottom: 9px solid var(--yellow);
        }

        .icon-chat::before {
            content: '';
            width: 14px;
            height: 12px;
            background: var(--accent);
            border-radius: 4px 4px 4px 0;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        /* CRITICAL: Prevent text overflow everywhere */
        * {
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            min-height: 100dvh;
            overflow-x: hidden;
            -webkit-font-smoothing: antialiased;
            -webkit-overflow-scrolling: touch;
        }

        /* ==================== PARTICLE BACKGROUND ==================== */
        #particles-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            pointer-events: none;
        }

        /* ==================== APP CONTAINER ==================== */
        .app {
            display: flex;
            flex-direction: column;
            height: 100vh;
            height: 100dvh;
            position: relative;
            z-index: 1;
        }

        /* ==================== HEADER ==================== */
        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 56px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            background: var(--bg-primary);
            border-bottom: 1px solid var(--border);
            flex-shrink: 0;
            z-index: 500;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        /* Nav Orb - Mini version of Cerebro's avatar */
        .nav-orb-container {
            position: relative;
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }

        .nav-orb-img {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            object-fit: cover;
            filter: drop-shadow(0 0 10px rgba(167, 139, 250, 0.6))
                    drop-shadow(0 0 20px rgba(139, 92, 246, 0.4));
            animation: navOrbBreathe 4s ease-in-out infinite;
            position: relative;
        }

        .nav-orb-ring {
            position: absolute;
            border-radius: 50%;
            border: 1.5px solid transparent;
            border-top-color: rgba(139, 92, 246, 0.6);
            border-right-color: rgba(139, 92, 246, 0.3);
            animation: ringRotate 3s linear infinite;
        }

        .nav-orb-ring:nth-child(1) {
            width: 32px;
            height: 32px;
            animation-duration: 3s;
        }

        .nav-orb-ring:nth-child(2) {
            width: 36px;
            height: 36px;
            animation-duration: 4s;
            animation-direction: reverse;
            border-top-color: rgba(99, 102, 241, 0.4);
        }

        @keyframes navOrbBreathe {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        @keyframes navInnerPulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(0.85); opacity: 0.8; }
        }

        /* Nav orb active state when agents running */
        .nav-orb-container.active-agents .nav-orb-img {
            animation: navOrbActive 1.5s ease-in-out infinite;
            filter: drop-shadow(0 0 15px rgba(245, 158, 11, 0.6))
                    drop-shadow(0 0 30px rgba(245, 158, 11, 0.4))
                    hue-rotate(-40deg) saturate(1.3);
        }

        .nav-orb-container.active-agents .nav-orb-ring {
            border-top-color: #f59e0b;
            animation-duration: 1.5s;
        }

        @keyframes navOrbActive {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        /* Nav orb speaking state (TTS) */
        .nav-orb-container.speaking .nav-orb-img {
            animation: navOrbSpeaking 0.6s ease-in-out infinite;
            filter: drop-shadow(0 0 20px rgba(34, 197, 94, 0.6))
                    drop-shadow(0 0 40px rgba(34, 197, 94, 0.4))
                    hue-rotate(80deg) brightness(1.1);
        }

        .nav-orb-container.speaking .nav-orb-ring {
            border-top-color: #22c55e;
            animation-duration: 0.8s;
        }

        @keyframes navOrbSpeaking {
            0%, 100% { transform: scale(1); }
            25% { transform: scale(1.15); }
            75% { transform: scale(1.12); }
        }

        /* Conversational mode - cyan glow while listening */
        .nav-orb-container.conversational .nav-orb-img {
            filter: drop-shadow(0 0 20px rgba(34, 211, 238, 0.6))
                    drop-shadow(0 0 40px rgba(34, 211, 238, 0.4))
                    hue-rotate(120deg) brightness(1.1);
        }
        .nav-orb-container.conversational.listening .nav-orb-img {
            animation: navOrbListening 1s ease-in-out infinite;
        }
        .nav-orb-container.conversational .nav-orb-ring {
            border-top-color: #22d3ee;
        }
        @keyframes navOrbListening {
            0%, 100% { transform: scale(1); filter: drop-shadow(0 0 20px rgba(34, 211, 238, 0.6)) hue-rotate(120deg) brightness(1.1); }
            50% { transform: scale(1.08); filter: drop-shadow(0 0 30px rgba(34, 211, 238, 0.8)) hue-rotate(120deg) brightness(1.2); }
        }

        .logo-text {
            font-size: 1.1rem;
            font-weight: 600;
            background: var(--accent-gradient);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .header-status {
            display: flex;
            align-items: center;
            gap: 14px;
        }

        .header-agents-pill {
            background: var(--accent-glow);
            color: var(--accent);
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 600;
            white-space: nowrap;
        }

        .header-agents-pill.idle {
            background: var(--bg-card);
            color: var(--text-muted);
        }

        .status-badge {
            display: flex;
            align-items: center;
        }

        .status-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: var(--green);
            box-shadow: 0 0 8px var(--green);
        }

        .status-dot.offline {
            background: var(--red);
            box-shadow: 0 0 8px var(--red);
        }

        /* ==================== NOTIFICATION BELL ==================== */
        .notification-bell {
            position: relative;
            cursor: pointer;
            padding: 6px;
            border-radius: 10px;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .notification-bell:hover {
            background: rgba(139, 92, 246, 0.15);
        }

        .notification-bell:active {
            transform: scale(0.95);
        }

        .bell-icon-svg {
            stroke: var(--accent);
            display: block;
        }

        .notification-bell.has-new .bell-icon-svg {
            animation: bell-shake 0.5s ease-in-out;
            filter: drop-shadow(0 0 4px var(--accent-glow));
        }

        @keyframes bell-shake {
            0%, 100% { transform: rotate(0deg); }
            10%, 30%, 50%, 70%, 90% { transform: rotate(-10deg); }
            20%, 40%, 60%, 80% { transform: rotate(10deg); }
        }

        .notification-badge {
            position: absolute;
            top: 0px;
            right: -2px;
            background: var(--accent);
            color: white;
            font-size: 0.55rem;
            font-weight: 700;
            min-width: 14px;
            height: 14px;
            border-radius: 7px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0 3px;
            box-shadow: 0 0 6px var(--accent-glow);
        }

        .notification-badge.hidden {
            display: none;
        }

        /* Notification Panel Dropdown */
        .notification-panel {
            position: fixed;
            top: 56px;
            right: 10px;
            width: 320px;
            max-width: calc(100vw - 20px);
            max-height: 400px;
            background: var(--bg-elevated);
            border: 1px solid var(--border-light);
            border-radius: 16px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            z-index: 1001;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .notification-panel.hidden {
            display: none;
        }

        .notification-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 14px 16px;
            border-bottom: 1px solid var(--border);
            font-weight: 600;
        }

        .mark-all-read-btn {
            background: none;
            border: none;
            color: var(--accent);
            font-size: 0.8rem;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 6px;
        }

        .mark-all-read-btn:hover {
            background: var(--accent-glow);
        }

        .notification-list {
            flex: 1;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }

        .notification-item {
            display: flex;
            gap: 12px;
            padding: 12px 16px;
            border-bottom: 1px solid var(--border);
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .notification-item:hover {
            background: var(--bg-hover);
        }

        .notification-item.unread {
            background: rgba(139, 92, 246, 0.08);
        }

        .notification-item.unread::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 3px;
            background: var(--accent);
        }

        .notification-icon {
            font-size: 1.4rem;
            flex-shrink: 0;
        }

        .notification-content {
            flex: 1;
            min-width: 0;
        }

        .notification-title {
            font-weight: 500;
            font-size: 0.9rem;
            margin-bottom: 2px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .notification-message {
            font-size: 0.8rem;
            color: var(--text-secondary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .notification-time {
            font-size: 0.7rem;
            color: var(--text-muted);
            margin-top: 4px;
        }

        .no-notifications {
            padding: 40px 20px;
            text-align: center;
            color: var(--text-muted);
        }

        /* ==================== MAIN CONTENT ==================== */
        .main-content {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            padding-top: 56px; /* Space for fixed header */
            padding-bottom: calc(var(--nav-height) + var(--safe-bottom) + 20px);
            -webkit-overflow-scrolling: touch;
        }

        /* When chat is active, lock main-content scroll so only messages-container scrolls */
        .main-content:has(.chat-view.active) {
            overflow-y: hidden;
        }
        /* In split mode, reduce bottom padding to just the nav (no extra breathing room) */
        .main-content:has(.chat-view.active.split-mode) {
            padding-bottom: calc(var(--nav-height, 70px) + var(--safe-bottom, 0px)) !important;
            overflow: hidden !important;
        }

        .view {
            display: none !important;
            min-height: 100%;
            visibility: hidden;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            opacity: 0;
        }

        .view.active {
            display: flex !important;
            flex-direction: column;
            visibility: visible;
            position: relative;
            opacity: 1;
        }

        /* Smooth content fade-in when view activates after a slide */
        .view.active.view-entering > *:not(.slide-panel):not(.slide-panel-backdrop):not(.edge-indicator):not(.question-input-overlay):not(.questions-wizard-overlay):not(.hitl-popup-container):not(.findings-overlay) {
            opacity: 0;
            transform: translateY(6px);
        }
        .view.active.view-entered > *:not(.slide-panel):not(.slide-panel-backdrop):not(.edge-indicator):not(.question-input-overlay):not(.questions-wizard-overlay):not(.hitl-popup-container):not(.findings-overlay) {
            opacity: 1;
            transform: translateY(0);
            transition: opacity 0.3s ease, transform 0.3s ease;
        }

        /* ==================== VIEW TRANSITION OVERLAY ==================== */
        /* Simple translucent fade - lets content load behind it, then reveals */
        .view-transition-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 5000;
            pointer-events: all;
            background: rgba(10, 10, 20, 0.92);
            opacity: 0;
            transition: opacity 0.15s ease;
        }
        .view-transition-overlay.active {
            opacity: 1;
        }
        .view-transition-overlay.fade-out {
            opacity: 0;
            transition: opacity 0.28s ease;
        }

        /* ==================== STAGGER ENTRANCE ANIMATION ==================== */
        @keyframes staggerFadeSlideIn {
            from { opacity: 0; transform: translateY(12px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .stagger-in {
            opacity: 0;
            animation: staggerFadeSlideIn 0.35s ease-out forwards;
            animation-delay: calc(var(--si, 0) * 60ms);
        }

        /* Agent cards stagger (innerHTML-rendered) */
        .agent-card { opacity: 0; animation: staggerFadeSlideIn 0.35s ease-out forwards; }
        .agent-card:nth-child(1) { animation-delay: 0ms; }
        .agent-card:nth-child(2) { animation-delay: 60ms; }
        .agent-card:nth-child(3) { animation-delay: 120ms; }
        .agent-card:nth-child(4) { animation-delay: 180ms; }
        .agent-card:nth-child(5) { animation-delay: 240ms; }
        .agent-card:nth-child(n+6) { animation-delay: 300ms; }

        /* Interest cards stagger (innerHTML-rendered) */
        .interest-card { opacity: 0; animation: staggerFadeSlideIn 0.35s ease-out forwards; }
        .interest-card:nth-child(1) { animation-delay: 0ms; }
        .interest-card:nth-child(2) { animation-delay: 60ms; }
        .interest-card:nth-child(3) { animation-delay: 120ms; }

        /* ==================== ENHANCED BOTTOM NAVIGATION ==================== */
        .bottom-nav {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: calc(var(--nav-height) + var(--safe-bottom));
            padding-bottom: var(--safe-bottom);
            background: linear-gradient(
                to top,
                var(--bg-primary) 0%,
                rgba(10, 10, 15, 0.95) 50%,
                transparent 100%
            );
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            display: flex;
            justify-content: space-around;
            align-items: center;
            z-index: 1000;
        }

        .nav-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            padding: 8px 16px;
            border-radius: 16px;
            color: var(--text-muted);
            text-decoration: none;
            cursor: pointer;
            transition: all 0.2s var(--ease-out-expo);
            position: relative;
            min-width: 64px;
        }

        .nav-item.active {
            color: var(--accent-light);
        }

        .nav-item.active::before {
            content: '';
            position: absolute;
            top: -4px;
            left: 50%;
            transform: translateX(-50%);
            width: 24px;
            height: 3px;
            background: var(--accent-gradient);
            border-radius: 2px;
            box-shadow: 0 0 10px var(--glow-strong);
            animation: navIndicatorIn 0.3s ease-out forwards;
        }
        @keyframes navIndicatorIn {
            from { width: 0; opacity: 0; }
            to { width: 24px; opacity: 1; }
        }

        .nav-item:hover:not(.active) {
            color: var(--text-secondary);
            background: var(--bg-hover);
        }

        .nav-item:active {
            transform: scale(0.95);
        }

        .nav-icon {
            font-size: 1.4rem;
            transition: transform 0.2s var(--ease-spring);
        }

        .nav-item:hover .nav-icon {
            transform: scale(1.1);
        }

        .nav-item.active .nav-icon {
            transform: scale(1.15);
        }

        .nav-label {
            font-size: 0.7rem;
            font-weight: 500;
            transition: all 0.2s ease;
        }

        .nav-item.active .nav-label {
            color: var(--accent-light);
            font-weight: 600;
        }

        /* Mobile keyboard open state - hide bottom nav */
        body.keyboard-open .bottom-nav {
            display: none !important;
        }

        body.keyboard-open .chat-input-area {
            bottom: 0 !important;
            left: 0 !important;
            right: 0 !important;
            width: 100% !important;
            max-width: 100% !important;
            margin: 0 !important;
            border-radius: 0 !important;
        }

        body.keyboard-open .quick-action-pills {
            display: none !important;
        }

        body.keyboard-open .messages-container {
            padding-bottom: 100px !important;
        }

        /* ==================== HOME VIEW ==================== */
        .home-view {
            padding: 20px;
            gap: 20px;
            overflow-y: auto;
            min-height: min-content;
        }

        /* ==================== CEREBRO PRESENCE CARD ==================== */
        .cerebro-presence {
            background: linear-gradient(
                135deg,
                rgba(15, 15, 35, 0.9) 0%,
                rgba(26, 26, 46, 0.8) 50%,
                rgba(22, 33, 62, 0.9) 100%
            );
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border);
            border-radius: 28px;
            padding: 0;
            box-shadow:
                0 0 60px rgba(139, 92, 246, 0.15),
                0 0 120px rgba(139, 92, 246, 0.08),
                inset 0 1px 0 rgba(255, 255, 255, 0.05);
            position: relative;
            overflow: hidden;
        }

        /* Animated background particles */
        .presence-bg {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            overflow: hidden;
            pointer-events: none;
        }

        .particle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: rgba(139, 92, 246, 0.6);
            border-radius: 50%;
            animation: float-particle 8s infinite ease-in-out;
        }

        .particle:nth-child(1) { left: 10%; top: 20%; animation-delay: 0s; }
        .particle:nth-child(2) { left: 20%; top: 60%; animation-delay: 1s; }
        .particle:nth-child(3) { left: 40%; top: 30%; animation-delay: 2s; }
        .particle:nth-child(4) { left: 60%; top: 70%; animation-delay: 3s; }
        .particle:nth-child(5) { left: 80%; top: 40%; animation-delay: 4s; }
        .particle:nth-child(6) { left: 90%; top: 80%; animation-delay: 5s; }

        @keyframes float-particle {
            0%, 100% { transform: translateY(0) scale(1); opacity: 0.4; }
            50% { transform: translateY(-20px) scale(1.5); opacity: 0.8; }
        }

        /* Main content layout */
        .presence-content {
            position: relative;
            z-index: 1;
            display: flex;
            gap: 20px;
            padding: 24px;
            align-items: center;
        }

        /* The Core - Cerebro's Avatar (Enhanced) */
        .cerebro-core {
            position: relative;
            width: 120px;
            height: 120px;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .hero-orb-img {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            object-fit: cover;
            filter: drop-shadow(0 0 20px rgba(167, 139, 250, 0.6))
                    drop-shadow(0 0 40px rgba(139, 92, 246, 0.5))
                    drop-shadow(0 0 60px rgba(139, 92, 246, 0.3));
            animation: orbBreathe 4s ease-in-out infinite;
            position: relative;
        }

        /* Outer rotating rings */
        .core-ring {
            position: absolute;
            border-radius: 50%;
            border: 2px solid transparent;
            border-top-color: rgba(139, 92, 246, 0.6);
            border-right-color: rgba(139, 92, 246, 0.3);
            animation: ringRotate 3s linear infinite;
        }

        .core-ring:nth-child(1) {
            width: 100px;
            height: 100px;
            animation-duration: 3s;
        }

        .core-ring:nth-child(2) {
            width: 110px;
            height: 110px;
            animation-duration: 4s;
            animation-direction: reverse;
            border-top-color: rgba(99, 102, 241, 0.4);
        }

        .core-ring:nth-child(3) {
            width: 120px;
            height: 120px;
            animation-duration: 5s;
            border-top-color: rgba(79, 70, 229, 0.3);
        }

        @keyframes orbBreathe {
            0%, 100% {
                transform: scale(1);
                box-shadow:
                    0 0 20px rgba(167, 139, 250, 0.6),
                    0 0 40px rgba(139, 92, 246, 0.5),
                    0 0 60px rgba(139, 92, 246, 0.4),
                    0 0 80px rgba(124, 58, 237, 0.3),
                    0 0 120px rgba(91, 33, 182, 0.2);
            }
            50% {
                transform: scale(1.08);
                box-shadow:
                    0 0 30px rgba(167, 139, 250, 0.8),
                    0 0 60px rgba(139, 92, 246, 0.6),
                    0 0 90px rgba(139, 92, 246, 0.5),
                    0 0 120px rgba(124, 58, 237, 0.4),
                    0 0 160px rgba(91, 33, 182, 0.3);
            }
        }

        @keyframes innerPulse {
            0%, 100% {
                transform: scale(1);
                opacity: 1;
            }
            50% {
                transform: scale(0.85);
                opacity: 0.8;
            }
        }

        @keyframes ringRotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        /* Text content area */
        .presence-info {
            flex: 1;
            min-width: 0;
        }

        .presence-greeting {
            font-size: 1.5rem;
            font-weight: 700;
            margin-bottom: 2px;
            background: linear-gradient(135deg, #fff, #e9d5ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .presence-status {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 12px;
        }

        .status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #22c55e;
            box-shadow: 0 0 10px #22c55e;
            animation: status-pulse 2s ease-in-out infinite;
        }

        .status-indicator.thinking {
            background: #f59e0b;
            box-shadow: 0 0 10px #f59e0b;
        }

        .status-indicator.processing {
            background: #3b82f6;
            box-shadow: 0 0 10px #3b82f6;
            animation: status-blink 0.5s ease-in-out infinite;
        }

        @keyframes status-pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.6; transform: scale(0.9); }
        }

        @keyframes status-blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        .status-text {
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        /* Mood indicator */
        .mood-indicator {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            background: rgba(139, 92, 246, 0.15);
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.8rem;
            color: #c4b5fd;
            border: 1px solid rgba(139, 92, 246, 0.3);
        }

        .mood-emoji, .mood-dot {
            width: 8px;
            height: 8px;
            background: var(--green);
            border-radius: 50%;
            box-shadow: 0 0 8px var(--green);
        }

        /* Thought bubble - contextual message */
        .thought-bubble {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 10px 14px;
            margin-top: 12px;
            font-size: 0.85rem;
            color: var(--text-secondary);
            position: relative;
            animation: thought-fade 0.5s ease-out;
        }

        .thought-bubble::before {
            content: '';
            position: absolute;
            top: -10px;
            left: 12px;
            font-size: 0.9rem;
        }

        @keyframes thought-fade {
            from { opacity: 0; transform: translateY(5px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Stats strip at bottom */
        .presence-stats {
            display: flex;
            gap: 0;
            border-top: 1px solid rgba(139, 92, 246, 0.2);
            background: rgba(0, 0, 0, 0.2);
        }

        .presence-stat {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 14px;
            border-right: 1px solid rgba(139, 92, 246, 0.2);
            transition: background 0.2s;
        }

        .presence-stat:last-child {
            border-right: none;
        }

        .presence-stat:hover {
            background: rgba(139, 92, 246, 0.1);
        }

        .presence-stat-icon {
            font-size: 1.1rem;
        }

        .presence-stat-info {
            display: flex;
            flex-direction: column;
        }

        .presence-stat-value {
            font-weight: 700;
            font-size: 1rem;
            color: #fff;
        }

        .presence-stat-label {
            font-size: 0.65rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Active indicator when agents running */
        .cerebro-presence.active-agents .hero-orb-img {
            animation: core-breathe 2s ease-in-out infinite;
            filter: drop-shadow(0 0 15px rgba(245, 158, 11, 0.6))
                    drop-shadow(0 0 30px rgba(245, 158, 11, 0.4))
                    hue-rotate(-40deg) saturate(1.3);
        }

        .cerebro-presence.active-agents .core-ring {
            animation: ring-rotate 1.5s linear infinite;
            border-top-color: #f59e0b;
        }

        /* Legacy support - keep old classes working */
        .hero-card { display: none; }
        .hero-date { display: none; }
        .hero-stats { display: none; }
        .stat-badge { display: none; }
        .stat-icon { display: none; }
        .stat-info { display: none; }
        .stat-value { display: none; }
        .stat-label { display: none; }

        /* ==================== COMPACT HERO BAR ==================== */
        .hero-bar {
            background: linear-gradient(135deg, rgba(15,15,35,0.9) 0%, rgba(26,26,46,0.8) 50%, rgba(22,33,62,0.9) 100%);
            border-radius: 16px;
            border: 1px solid var(--glass-border);
            padding: 14px 18px 12px;
            position: relative;
            overflow: hidden;
        }
        .hero-bar::before {
            content: '';
            position: absolute;
            inset: 0;
            background: radial-gradient(ellipse at 20% 50%, rgba(139,92,246,0.08) 0%, transparent 60%);
            pointer-events: none;
        }
        .hero-bar-main {
            display: flex;
            align-items: center;
            gap: 14px;
            position: relative;
            z-index: 1;
        }
        .hero-orb-mini {
            width: 56px;
            height: 56px;
            position: relative;
            flex-shrink: 0;
        }
        .hero-orb-mini .hero-orb-img {
            width: 40px;
            height: 40px;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            filter: drop-shadow(0 0 10px rgba(167, 139, 250, 0.6))
                    drop-shadow(0 0 20px rgba(139, 92, 246, 0.4));
        }
        .hero-orb-mini .core-ring {
            width: 52px;
            height: 52px;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        .hero-orb-mini .core-ring:nth-child(2) { width: 48px; height: 48px; }
        .hero-info { flex: 1; min-width: 0; }
        .hero-greeting {
            display: block !important;
            font-size: 1.15rem;
            font-weight: 700;
            background: linear-gradient(135deg, #fff 0%, var(--accent-light) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .hero-status {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.78rem;
            color: var(--text-secondary);
            margin-top: 2px;
        }
        .hero-datetime {
            font-size: 0.72rem;
            color: var(--text-muted);
            text-align: right;
            white-space: nowrap;
            flex-shrink: 0;
        }
        .hero-pills {
            display: flex;
            gap: 6px;
            margin-top: 10px;
            flex-wrap: wrap;
            position: relative;
            z-index: 1;
        }
        .stat-pill {
            flex: 1;
            min-width: 70px;
            background: rgba(255,255,255,0.04);
            border: 1px solid rgba(255,255,255,0.06);
            border-radius: 10px;
            padding: 6px 8px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s ease;
            opacity: 0;
            animation: staggerFadeSlideIn 0.3s ease-out forwards;
        }
        .stat-pill:nth-child(1) { animation-delay: 50ms; }
        .stat-pill:nth-child(2) { animation-delay: 100ms; }
        .stat-pill:nth-child(3) { animation-delay: 150ms; }
        .stat-pill:nth-child(4) { animation-delay: 200ms; }
        .stat-pill:nth-child(5) { animation-delay: 250ms; }
        .stat-pill:nth-child(6) { animation-delay: 300ms; }
        .stat-pill:hover {
            background: rgba(139,92,246,0.1);
            border-color: var(--accent);
        }
        .stat-pill-value {
            display: block;
            font-size: 1rem;
            font-weight: 700;
            color: var(--text-primary);
        }
        .stat-pill-label {
            display: block;
            font-size: 0.6rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-top: 1px;
        }

        /* ==================== HOME SECTION SHARED ==================== */
        .home-section { margin-bottom: 4px; }
        .section-title-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        .section-link {
            font-size: 0.75rem;
            color: var(--accent-light);
            cursor: pointer;
            text-decoration: none;
        }
        .section-link:hover { text-decoration: underline; }

        /* ==================== SMART ACTIONS ==================== */
        .smart-actions-scroll {
            display: flex;
            gap: 12px;
            overflow-x: auto;
            padding-bottom: 6px;
            scroll-snap-type: x mandatory;
            -webkit-overflow-scrolling: touch;
        }
        .smart-actions-scroll::-webkit-scrollbar { height: 4px; }
        .smart-actions-scroll::-webkit-scrollbar-thumb { background: var(--border); border-radius: 4px; }
        .action-card {
            min-width: 220px;
            max-width: 260px;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 14px;
            padding: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
            scroll-snap-align: start;
            flex-shrink: 0;
        }
        .action-card:hover {
            transform: translateY(-2px);
            border-color: var(--accent);
            box-shadow: 0 6px 20px rgba(0,0,0,0.25);
        }
        .action-card-icon {
            width: 36px;
            height: 36px;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            margin-bottom: 10px;
        }
        .action-card-icon.rocket { background: rgba(139,92,246,0.15); }
        .action-card-icon.play { background: rgba(34,197,94,0.15); }
        .action-card-icon.target { background: rgba(59,130,246,0.15); }
        .action-card-icon.alert { background: rgba(245,158,11,0.15); }
        .action-card-icon.book { background: rgba(236,72,153,0.15); }
        .action-card-title {
            font-size: 0.88rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 4px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .action-card-desc {
            font-size: 0.75rem;
            color: var(--text-secondary);
            line-height: 1.4;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }
        .action-card-go {
            display: inline-block;
            margin-top: 10px;
            font-size: 0.72rem;
            font-weight: 600;
            color: var(--accent-light);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* ==================== LIVE ACTIVITY GRID ==================== */
        .live-activity-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
        }
        @media (max-width: 768px) {
            .live-activity-grid { grid-template-columns: 1fr; }
        }
        .live-card {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 14px;
            overflow: hidden;
        }
        .live-card-header {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 14px;
            border-bottom: 1px solid var(--border);
            font-size: 0.78rem;
            font-weight: 600;
            color: var(--text-secondary);
        }
        .live-card-icon { font-size: 1rem; }
        .live-card-title { font-size: 0.75rem; text-transform: uppercase; letter-spacing: 0.5px; }
        .live-card-body { padding: 12px 14px; min-height: 60px; }
        .live-empty {
            color: var(--text-muted);
            font-size: 0.8rem;
            text-align: center;
            padding: 10px 0;
        }
        .live-agent-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 0;
            font-size: 0.8rem;
        }
        .live-agent-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--accent);
            animation: pulse 2s infinite;
        }
        .live-agent-task { flex: 1; color: var(--text-primary); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .live-agent-time { color: var(--text-muted); font-size: 0.7rem; }

        /* ==================== DEVICE & MEMORY HEALTH STYLES ==================== */
        .device-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 0;
            font-size: 0.8rem;
            cursor: pointer;
            border-radius: 6px;
            transition: background 0.15s;
        }
        .device-item:hover { background: rgba(255,255,255,0.04); margin: 0 -6px; padding: 6px 6px; }
        .device-item-dot {
            width: 8px; height: 8px; border-radius: 50%; flex-shrink: 0;
        }
        .device-item-dot.online { background: var(--green); box-shadow: 0 0 6px var(--green); }
        .device-item-dot.stale { background: var(--yellow); box-shadow: 0 0 6px var(--yellow); }
        .device-item-dot.offline { background: var(--red); }
        .device-item-name { flex: 1; color: var(--text-primary); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .device-item-type { color: var(--text-muted); font-size: 0.7rem; }

        .live-card-add-btn {
            width: 22px; height: 22px; border-radius: 50%; border: 1px solid var(--border);
            background: transparent; color: var(--text-secondary); font-size: 0.9rem;
            cursor: pointer; display: flex; align-items: center; justify-content: center;
            margin-left: auto; transition: all 0.15s; line-height: 1;
        }
        .live-card-add-btn:hover { background: var(--accent); color: #fff; border-color: var(--accent); }

        .device-help-btn {
            width: 20px; height: 20px; border-radius: 50%; border: 1px solid var(--border);
            background: transparent; color: var(--text-muted); font-size: 0.7rem; font-weight: 700;
            cursor: pointer; display: flex; align-items: center; justify-content: center;
            transition: all 0.15s; position: relative; flex-shrink: 0;
        }
        .device-help-btn:hover { border-color: var(--accent); color: var(--accent); }
        .device-help-dropdown {
            position: absolute; top: calc(100% + 8px); right: 0; z-index: 100;
            width: 280px; padding: 14px 16px; border-radius: 12px;
            background: var(--bg-secondary); border: 1px solid var(--border);
            box-shadow: 0 8px 24px rgba(0,0,0,0.4); font-size: 0.78rem;
            color: var(--text-secondary); line-height: 1.5; display: none;
        }
        .device-help-dropdown.visible { display: block; }
        .device-help-dropdown strong { color: var(--text-primary); }
        .device-help-path { color: var(--accent); font-weight: 600; }

        .device-modal { width: 900px; max-width: 95vw; max-height: 92vh; overflow-y: auto; }
        .device-modal-section {
            padding: 14px 0; border-bottom: 1px solid var(--border);
        }
        .device-modal-section:last-child { border-bottom: none; }
        .device-modal-section-title {
            font-size: 0.72rem; text-transform: uppercase; letter-spacing: 0.5px;
            color: var(--text-muted); margin-bottom: 10px; font-weight: 600;
        }
        .ssh-config-grid {
            display: grid; grid-template-columns: 1fr 1fr; gap: 10px;
        }
        .ssh-config-grid label { font-size: 0.75rem; color: var(--text-secondary); display: block; margin-bottom: 4px; }
        .ssh-config-grid input {
            width: 100%; padding: 6px 10px; border-radius: 8px; border: 1px solid var(--border);
            background: var(--bg-secondary); color: var(--text-primary); font-size: 0.82rem;
        }
        .btn-test-connection {
            padding: 6px 14px; border-radius: 8px; border: 1px solid var(--accent);
            background: transparent; color: var(--accent); font-size: 0.78rem;
            cursor: pointer; transition: all 0.15s;
        }
        .btn-test-connection:hover { background: var(--accent); color: #fff; }
        .btn-test-connection.loading { opacity: 0.6; pointer-events: none; }
        .device-status-badge {
            display: inline-block; padding: 3px 10px; border-radius: 12px;
            font-size: 0.72rem; font-weight: 600;
        }
        .device-status-badge.online { background: rgba(34,197,94,0.15); color: var(--green); }
        .device-status-badge.stale { background: rgba(234,179,8,0.15); color: var(--yellow); }
        .device-status-badge.offline { background: rgba(239,68,68,0.15); color: var(--red); }
        .ping-results { margin-top: 10px; font-size: 0.78rem; }
        .ping-result-row { display: flex; align-items: center; gap: 8px; padding: 4px 0; }
        .ping-result-dot { width: 6px; height: 6px; border-radius: 50%; }
        .ping-result-dot.pass { background: var(--green); }
        .ping-result-dot.fail { background: var(--red); }

        /* Remote Terminal Styles */
        .terminal-section { margin-top: 4px; }
        .terminal-output {
            background: #0a0a0f; border: 1px solid rgba(255,255,255,0.08); border-radius: 8px;
            padding: 10px 12px; font-family: 'JetBrains Mono', 'Fira Code', monospace; font-size: 0.75rem;
            line-height: 1.5; max-height: 400px; overflow-y: auto; min-height: 200px;
            color: #c0c0c0; white-space: pre-wrap; word-break: break-all;
            resize: vertical; cursor: text;
        }
        .terminal-output .term-cmd { color: #22d3ee; }
        .terminal-output .term-prompt { color: #64748b; user-select: none; -webkit-user-select: none; }
        .terminal-output .term-err { color: #f87171; }
        .terminal-output .term-info { color: #64748b; font-style: italic; }
        .terminal-output .term-stdout { color: #e2e8f0; }
        .terminal-input-row {
            display: flex; gap: 6px; margin-top: 6px; align-items: center;
        }
        .terminal-input-row input {
            flex: 1; padding: 7px 10px; border-radius: 8px; border: 1px solid var(--border);
            background: #0a0a0f; color: #4ade80; font-family: 'JetBrains Mono', monospace;
            font-size: 0.78rem; outline: none;
        }
        .terminal-input-row input:focus { border-color: var(--accent); }
        .terminal-input-row input::placeholder { color: #475569; }
        .terminal-run-btn {
            padding: 7px 14px; border-radius: 8px; border: 1px solid var(--accent);
            background: rgba(99,102,241,0.15); color: var(--accent); font-size: 0.75rem;
            font-weight: 600; cursor: pointer; transition: all 0.15s; white-space: nowrap;
        }
        .terminal-run-btn:hover { background: var(--accent); color: #fff; }
        .terminal-run-btn:disabled { opacity: 0.4; pointer-events: none; }
        .terminal-status-bar {
            display: flex; justify-content: space-between; align-items: center;
            margin-top: 4px; font-size: 0.68rem; color: var(--text-muted); padding: 0 2px;
        }
        .terminal-status-dot {
            display: inline-block; width: 6px; height: 6px; border-radius: 50%;
            margin-right: 5px; vertical-align: middle;
        }
        .terminal-status-dot.ready { background: var(--green); }
        .terminal-status-dot.running { background: var(--yellow); animation: pulse 1s infinite; }
        .terminal-status-dot.error { background: var(--red); }
        @keyframes pulse { 0%,100% { opacity: 1; } 50% { opacity: 0.3; } }
        .terminal-ssh-warning {
            background: rgba(234,179,8,0.1); border: 1px solid rgba(234,179,8,0.25);
            border-radius: 8px; padding: 10px 14px; font-size: 0.75rem; color: var(--yellow);
            display: none;
        }
        .terminal-clear-btn {
            padding: 3px 8px; border-radius: 4px; border: 1px solid var(--border);
            background: transparent; color: var(--text-muted); font-size: 0.65rem;
            cursor: pointer; transition: all 0.15s;
        }
        .terminal-clear-btn:hover { border-color: var(--text-secondary); color: var(--text-secondary); }

        /* Device Stats Bar */
        .device-stats-bar {
            display: grid; grid-template-columns: repeat(4, 1fr); gap: 12px; margin-top: 8px;
        }
        .device-stat-item {
            background: var(--bg-secondary); border: 1px solid var(--border);
            border-radius: 10px; padding: 10px 12px; text-align: center;
        }
        .device-stat-label {
            font-size: 0.65rem; text-transform: uppercase; letter-spacing: 0.5px;
            color: var(--text-muted); margin-bottom: 4px;
        }
        .device-stat-value {
            font-size: 0.88rem; font-weight: 600; color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
        }
        .stat-loading {
            display: inline-block; width: 14px; height: 14px; border: 2px solid var(--border);
            border-top-color: var(--accent); border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* Device Connection Log */
        .device-connection-log {
            display: flex; align-items: center; gap: 10px; margin-top: 10px;
            padding: 8px 12px; background: var(--bg-secondary); border-radius: 8px;
            font-size: 0.78rem;
        }
        .connection-log-dot {
            width: 8px; height: 8px; border-radius: 50%; flex-shrink: 0;
        }
        .connection-log-dot.online { background: var(--green); box-shadow: 0 0 6px var(--green); }
        .connection-log-dot.stale { background: var(--yellow); }
        .connection-log-dot.offline { background: var(--red); }
        .connection-log-text { color: var(--text-primary); }
        .connection-log-time { color: var(--text-muted); font-size: 0.7rem; margin-left: auto; }

        /* Split Activity Layout */
        .device-activity-split {
            display: grid; grid-template-columns: 1fr 1fr; gap: 16px;
        }
        .device-activity-col-title {
            font-size: 0.65rem; text-transform: uppercase; letter-spacing: 0.5px;
            color: var(--accent); margin-bottom: 8px; font-weight: 600;
        }
        .device-cmd-item, .device-agent-item {
            padding: 6px 0; border-bottom: 1px solid rgba(255,255,255,0.04); font-size: 0.78rem;
        }
        .device-cmd-item:last-child, .device-agent-item:last-child { border-bottom: none; }
        .device-cmd-text {
            color: #4ade80; font-family: 'JetBrains Mono', monospace; font-size: 0.72rem;
            white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
        }
        .device-cmd-meta {
            font-size: 0.65rem; color: var(--text-muted); margin-top: 2px;
            display: flex; gap: 8px;
        }
        .device-cmd-exit { font-weight: 600; }
        .device-cmd-exit.ok { color: var(--green); }
        .device-cmd-exit.fail { color: var(--red); }
        .device-agent-status {
            display: inline-block; padding: 1px 7px; border-radius: 8px;
            font-size: 0.62rem; font-weight: 600; text-transform: uppercase;
        }
        .device-agent-status.completed { background: rgba(34,197,94,0.15); color: var(--green); }
        .device-agent-status.running { background: rgba(234,179,8,0.15); color: var(--yellow); }
        .device-agent-status.failed { background: rgba(239,68,68,0.15); color: var(--red); }
        .device-agent-status.queued { background: rgba(99,102,241,0.15); color: var(--accent); }
        .device-agent-name {
            color: var(--text-primary); font-weight: 500;
            white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
        }
        .device-agent-task {
            font-size: 0.68rem; color: var(--text-secondary); margin-top: 2px;
            white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
        }
        .device-activity-empty {
            font-size: 0.75rem; color: var(--text-muted); padding: 12px 0; text-align: center;
        }

        /* Command Approval Card (in chat) */
        .cmd-approval-card {
            background: rgba(99,102,241,0.08); border: 1px solid rgba(99,102,241,0.25);
            border-radius: 10px; padding: 12px 14px; margin: 8px 0; max-width: 420px;
        }
        .cmd-approval-card .cmd-label {
            font-size: 0.7rem; color: var(--text-muted); margin-bottom: 4px; text-transform: uppercase; letter-spacing: 0.5px;
        }
        .cmd-approval-card .cmd-text {
            font-family: 'JetBrains Mono', monospace; font-size: 0.8rem; color: #4ade80;
            background: #0a0a0f; padding: 6px 10px; border-radius: 6px; margin: 6px 0;
        }
        .cmd-approval-card .cmd-device {
            font-size: 0.72rem; color: var(--text-secondary); margin-bottom: 8px;
        }
        .cmd-approval-card .cmd-actions { display: flex; gap: 8px; }
        .cmd-approval-card .cmd-actions button {
            padding: 5px 14px; border-radius: 6px; font-size: 0.72rem; font-weight: 600;
            cursor: pointer; border: none; transition: all 0.15s;
        }
        .cmd-approve-btn { background: rgba(34,197,94,0.2); color: var(--green); }
        .cmd-approve-btn:hover { background: rgba(34,197,94,0.35); }
        .cmd-reject-btn { background: rgba(239,68,68,0.15); color: var(--red); }
        .cmd-reject-btn:hover { background: rgba(239,68,68,0.3); }
        .cmd-approval-card.resolved { opacity: 0.6; }
        .cmd-approval-card.resolved .cmd-actions { display: none; }
        .cmd-approval-card .cmd-status { font-size: 0.7rem; margin-top: 6px; }

        .device-activity-item {
            padding: 8px 0; border-bottom: 1px solid rgba(255,255,255,0.04);
            font-size: 0.78rem; color: var(--text-secondary);
        }
        .device-info-row { display: flex; justify-content: space-between; padding: 4px 0; font-size: 0.8rem; }
        .device-info-label { color: var(--text-muted); }
        .device-info-value { color: var(--text-primary); }
        .add-device-form label { font-size: 0.75rem; color: var(--text-secondary); display: block; margin-bottom: 4px; margin-top: 10px; }
        .add-device-form input, .add-device-form select {
            width: 100%; padding: 8px 10px; border-radius: 8px; border: 1px solid var(--border);
            background: var(--bg-secondary); color: var(--text-primary); font-size: 0.82rem;
        }
        .autonomy-status-row {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.82rem;
            color: var(--text-primary);
        }
        .autonomy-badge {
            font-size: 0.65rem;
            padding: 2px 8px;
            border-radius: 8px;
            font-weight: 600;
            text-transform: uppercase;
        }
        .autonomy-badge.running { background: rgba(34,197,94,0.2); color: var(--green); }
        .autonomy-badge.idle { background: rgba(255,255,255,0.06); color: var(--text-muted); }

        /* Badge smooth transitions */
        .project-status-badge,
        .goal-compact-badge,
        .goal-priority-dot,
        .autonomy-badge {
            transition: opacity 0.25s ease, transform 0.25s ease, background 0.25s ease;
        }

        /* ==================== HOME GOALS ==================== */
        .home-goals-list {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        .home-goal-card {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 14px;
            padding: 14px 16px;
            border-left: 4px solid var(--text-muted);
            transition: all 0.2s ease;
        }
        .home-goal-card:hover {
            border-color: var(--accent);
            box-shadow: 0 4px 16px rgba(0,0,0,0.2);
        }
        .home-goal-card.priority-high { border-left-color: var(--red); }
        .home-goal-card.priority-medium { border-left-color: #f59e0b; }
        .home-goal-card.priority-low { border-left-color: var(--green); }
        .goal-card-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 10px;
        }
        .goal-card-desc {
            font-size: 0.88rem;
            font-weight: 500;
            color: var(--text-primary);
            flex: 1;
            line-height: 1.4;
        }
        .goal-priority-badge {
            font-size: 0.6rem;
            padding: 2px 8px;
            border-radius: 8px;
            font-weight: 600;
            text-transform: uppercase;
            flex-shrink: 0;
        }
        .goal-priority-badge.high { background: rgba(239,68,68,0.2); color: var(--red); }
        .goal-priority-badge.medium { background: rgba(245,158,11,0.2); color: #f59e0b; }
        .goal-priority-badge.low { background: rgba(34,197,94,0.2); color: var(--green); }
        .goal-progress-bar {
            width: 100%;
            height: 4px;
            background: rgba(255,255,255,0.06);
            border-radius: 2px;
            margin-top: 10px;
            overflow: hidden;
        }
        .goal-progress-fill {
            height: 100%;
            background: var(--accent);
            border-radius: 2px;
            transition: width 0.4s ease;
        }
        .goal-blockers {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-top: 8px;
        }
        .goal-blocker-pill {
            font-size: 0.65rem;
            padding: 2px 8px;
            border-radius: 8px;
            background: rgba(239,68,68,0.15);
            color: var(--red);
        }
        .goal-card-actions {
            display: flex;
            gap: 8px;
            margin-top: 10px;
        }
        .goal-action-btn {
            font-size: 0.72rem;
            padding: 4px 12px;
            border-radius: 8px;
            border: 1px solid var(--border);
            background: transparent;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .goal-action-btn:hover { background: var(--bg-hover); color: var(--text-primary); }
        .goal-action-btn.primary {
            background: var(--accent);
            color: white;
            border-color: var(--accent);
        }
        .goal-action-btn.primary:hover { background: var(--accent-hover); }

        /* ==================== PROJECT TRACKER ==================== */
        .project-tracker-scroll {
            display: flex;
            gap: 12px;
            overflow-x: auto;
            padding-bottom: 6px;
            scroll-snap-type: x mandatory;
            -webkit-overflow-scrolling: touch;
        }
        .project-tracker-scroll::-webkit-scrollbar { height: 4px; }
        .project-tracker-scroll::-webkit-scrollbar-thumb { background: var(--border); border-radius: 4px; }
        .project-card {
            min-width: 260px;
            max-width: 300px;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 14px;
            padding: 16px;
            flex-shrink: 0;
            scroll-snap-align: start;
            transition: all 0.2s ease;
        }
        .project-card:hover {
            border-color: var(--accent);
            box-shadow: 0 6px 20px rgba(0,0,0,0.25);
        }
        .project-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        .project-card-name {
            font-size: 0.95rem;
            font-weight: 700;
            color: var(--text-primary);
        }
        .project-status-badge {
            font-size: 0.6rem;
            padding: 2px 8px;
            border-radius: 8px;
            font-weight: 600;
            text-transform: uppercase;
        }
        .project-status-badge.in_progress { background: rgba(139,92,246,0.2); color: var(--accent-light); }
        .project-status-badge.paused { background: rgba(245,158,11,0.2); color: #f59e0b; }
        .project-status-badge.completed { background: rgba(34,197,94,0.2); color: var(--green); }
        .project-card-summary {
            font-size: 0.78rem;
            color: var(--text-secondary);
            line-height: 1.4;
            margin-bottom: 10px;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }
        .project-next-action {
            font-size: 0.78rem;
            color: var(--text-primary);
            background: rgba(139,92,246,0.06);
            border-left: 3px solid var(--accent);
            padding: 8px 10px;
            border-radius: 0 8px 8px 0;
            margin-bottom: 12px;
            line-height: 1.4;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }
        .project-continue-btn {
            width: 100%;
            padding: 8px;
            border-radius: 10px;
            border: 1px solid var(--accent);
            background: transparent;
            color: var(--accent-light);
            font-size: 0.78rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .project-continue-btn:hover {
            background: var(--accent);
            color: white;
        }

        /* ==================== MEMORY INTELLIGENCE GRID ==================== */
        .mem-intel-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
        }
        @media (max-width: 768px) {
            .mem-intel-grid { grid-template-columns: repeat(2, 1fr); }
        }
        .mem-tile {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 14px;
            padding: 16px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .mem-tile:hover {
            border-color: var(--accent);
            box-shadow: 0 4px 16px rgba(0,0,0,0.2);
        }
        .mem-tile-value {
            font-size: 1.6rem;
            font-weight: 800;
            color: var(--text-primary);
            line-height: 1;
        }
        .mem-tile-label {
            font-size: 0.65rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-top: 4px;
        }
        .mem-tile-sub {
            font-size: 0.7rem;
            color: var(--text-secondary);
            margin-top: 2px;
        }

        /* ==================== HOMEPAGE V2: DETAIL MODAL ==================== */
        .home-detail-modal {
            max-width: 500px;
            width: 100%;
            border-radius: 20px;
            overflow: hidden;
            backdrop-filter: blur(20px);
        }
        .detail-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 18px 20px;
            border-bottom: 2px solid var(--accent);
            gap: 12px;
        }
        .detail-header-info {
            display: flex;
            align-items: center;
            gap: 12px;
            flex: 1;
            min-width: 0;
        }
        .detail-icon {
            font-size: 1.5rem;
            flex-shrink: 0;
        }
        .detail-titles { min-width: 0; flex: 1; }
        .detail-title {
            font-size: 1.05rem;
            font-weight: 700;
            color: var(--text-primary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .detail-subtitle {
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-top: 2px;
        }
        .detail-body {
            padding: 16px 20px;
            max-height: 50vh;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 14px;
        }
        .detail-section {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        .detail-section-label {
            font-size: 0.65rem;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .detail-section-content {
            font-size: 0.85rem;
            color: var(--text-primary);
            line-height: 1.5;
        }
        .detail-stat-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        .detail-stat-item {
            background: rgba(255,255,255,0.03);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 10px 12px;
            text-align: center;
        }
        .detail-stat-item-value {
            font-size: 1.2rem;
            font-weight: 700;
            color: var(--text-primary);
        }
        .detail-stat-item-label {
            font-size: 0.65rem;
            color: var(--text-muted);
            text-transform: uppercase;
            margin-top: 2px;
        }
        .detail-subgoal-list {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        .detail-subgoal-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.82rem;
            color: var(--text-secondary);
        }
        .detail-subgoal-item.done {
            text-decoration: line-through;
            opacity: 0.6;
        }
        .detail-subgoal-check {
            width: 16px;
            height: 16px;
            border-radius: 4px;
            border: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.6rem;
            flex-shrink: 0;
        }
        .detail-subgoal-item.done .detail-subgoal-check {
            background: var(--green);
            border-color: var(--green);
            color: white;
        }
        .detail-blocker-list {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }
        .detail-blocker-pill {
            font-size: 0.72rem;
            padding: 3px 10px;
            border-radius: 8px;
            background: rgba(239,68,68,0.12);
            color: var(--red);
        }
        .detail-file-list {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        .detail-file-item {
            font-size: 0.78rem;
            color: var(--accent-light);
            font-family: monospace;
            padding: 3px 8px;
            background: rgba(139,92,246,0.06);
            border-radius: 6px;
        }
        .detail-progress-bar {
            width: 100%;
            height: 6px;
            background: rgba(255,255,255,0.06);
            border-radius: 3px;
            overflow: hidden;
        }
        .detail-progress-fill {
            height: 100%;
            background: var(--accent);
            border-radius: 3px;
            transition: width 0.4s ease;
        }
        .detail-footer {
            display: flex;
            gap: 8px;
            padding: 14px 20px;
            border-top: 1px solid var(--border);
        }
        .detail-action-btn {
            flex: 1;
            padding: 9px 14px;
            border-radius: 10px;
            border: 1px solid var(--border);
            background: transparent;
            color: var(--text-secondary);
            font-size: 0.78rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
        }
        .detail-action-btn:hover {
            background: var(--bg-hover);
            color: var(--text-primary);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }
        .detail-action-btn:active {
            transform: scale(0.97);
        }
        .detail-action-btn.primary {
            background: var(--accent);
            color: white;
            border-color: var(--accent);
        }
        .detail-action-btn.primary:hover {
            background: var(--accent-dark);
            box-shadow: 0 4px 16px rgba(139, 92, 246, 0.3);
        }
        .detail-header.type-action { border-bottom-color: #8b5cf6; }
        .detail-header.type-goal { border-bottom-color: #f59e0b; }
        .detail-header.type-project { border-bottom-color: #3b82f6; }
        .detail-header.type-stat { border-bottom-color: #22c55e; }
        .detail-header.type-activity { border-bottom-color: #06b6d4; }

        @media (max-width: 500px) {
            .home-detail-modal {
                max-width: 100%;
                border-radius: 20px 20px 0 0;
                position: fixed;
                bottom: 0;
                margin: 0;
            }
            #home-detail-modal {
                align-items: flex-end;
            }
        }

        /* ==================== HOMEPAGE V2: SECTION CARD STYLING ==================== */
        .home-section {
            margin-bottom: 10px;
            background: rgba(12,12,20,0.6);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 14px 16px;
        }
        .home-section .section-title {
            border-left: 3px solid var(--accent);
            padding-left: 10px;
        }

        /* ==================== HOMEPAGE V2: COLLAPSIBLE SECTIONS ==================== */
        .section-collapse-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            user-select: none;
            -webkit-user-select: none;
        }
        .section-collapse-header:hover .section-title {
            color: var(--text-secondary);
        }
        .section-collapse-left {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .section-count-badge {
            font-size: 0.65rem;
            padding: 1px 7px;
            border-radius: 8px;
            background: rgba(139,92,246,0.15);
            color: var(--accent-light);
            font-weight: 600;
        }
        .section-chevron {
            font-size: 0.7rem;
            color: var(--text-muted);
            transition: transform 0.3s ease;
            flex-shrink: 0;
        }
        .home-section.collapsed .section-chevron {
            transform: rotate(-90deg);
        }
        .home-section-body {
            max-height: 1000px;
            overflow: hidden;
            transition: max-height 0.35s ease, opacity 0.25s ease, margin-top 0.3s ease;
            opacity: 1;
            margin-top: 10px;
        }
        .home-section.collapsed .home-section-body {
            max-height: 0;
            opacity: 0;
            margin-top: 0;
        }

        /* ==================== HOMEPAGE V2: COMPACT GOAL ROWS ==================== */
        .goal-compact-row {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 12px;
            background: rgba(255,255,255,0.02);
            border: 1px solid var(--border);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .goal-compact-row:hover {
            background: rgba(139,92,246,0.06);
            border-color: var(--accent);
        }
        .goal-priority-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            flex-shrink: 0;
        }
        .goal-priority-dot.high { background: var(--red); }
        .goal-priority-dot.medium { background: #f59e0b; }
        .goal-priority-dot.low { background: var(--green); }
        .goal-compact-desc {
            flex: 1;
            font-size: 0.82rem;
            color: var(--text-primary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            min-width: 0;
        }
        .goal-mini-progress {
            width: 50px;
            height: 4px;
            background: rgba(255,255,255,0.06);
            border-radius: 2px;
            overflow: hidden;
            flex-shrink: 0;
        }
        .goal-mini-progress-fill {
            height: 100%;
            background: var(--accent);
            border-radius: 2px;
        }
        .goal-compact-badge {
            font-size: 0.58rem;
            padding: 1px 6px;
            border-radius: 6px;
            font-weight: 600;
            text-transform: uppercase;
            flex-shrink: 0;
        }
        .goal-compact-badge.high { background: rgba(239,68,68,0.2); color: var(--red); }
        .goal-compact-badge.medium { background: rgba(245,158,11,0.2); color: #f59e0b; }
        .goal-compact-badge.low { background: rgba(34,197,94,0.2); color: var(--green); }

        /* ==================== HOMEPAGE V2: FIXED CARD HEIGHTS ==================== */
        .action-card {
            height: 150px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        .project-card {
            height: 210px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            cursor: pointer;
        }

        /* ==================== HOMEPAGE V2: MEMORY TILE ACCENTS ==================== */
        .mem-tile.green { border-left: 3px solid var(--green); }
        .mem-tile.amber { border-left: 3px solid #f59e0b; }
        .mem-tile.purple { border-left: 3px solid var(--accent); }

        /* ==================== HOMEPAGE V2: HERO BAR TIGHTER ==================== */
        .hero-bar { padding: 12px 16px 10px; }
        .hero-pills { margin-top: 8px; }
        .stat-pill { padding: 5px 6px; }

        /* ==================== HOMEPAGE V2: TIGHTER LIVE ACTIVITY ==================== */
        .live-card-header { padding: 8px 12px; }
        .live-card-body { padding: 10px 12px; min-height: 50px; }

        /* Active Work Card */
        .active-work-card {
            background: var(--bg-card);
            border-radius: 16px;
            padding: 20px;
            border: 1px solid var(--border);
            border-left: 3px solid var(--accent);
        }

        .active-work-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 12px;
        }

        .active-work-badge {
            font-size: 0.7rem;
            font-weight: 600;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .active-work-title {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 4px;
        }

        .active-work-phase {
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-bottom: 16px;
        }

        .active-work-actions {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        /* ==================== SMART SUMMARY CARD ==================== */
        .smart-summary-card {
            background: var(--bg-card);
            border-radius: 16px;
            border: 1px solid var(--border);
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .smart-summary-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .smart-summary-header:hover {
            background: var(--bg-hover);
        }

        .smart-summary-title-row {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .smart-summary-icon {
            width: 40px;
            height: 40px;
            border-radius: 12px;
            background: linear-gradient(135deg, var(--accent), var(--blue));
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
        }

        .smart-summary-title {
            font-weight: 600;
            font-size: 1rem;
            color: var(--text-primary);
        }

        .smart-summary-subtitle {
            font-size: 0.8rem;
            color: var(--text-muted);
            margin-top: 2px;
        }

        .smart-summary-badges {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .summary-badge {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 500;
        }

        .summary-badge.active {
            background: rgba(34, 197, 94, 0.15);
            color: var(--green);
        }

        .summary-badge.agents {
            background: rgba(59, 130, 246, 0.15);
            color: var(--blue);
        }

        .summary-badge.empty {
            background: var(--bg-elevated);
            color: var(--text-muted);
        }

        .smart-summary-toggle {
            background: none;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            padding: 8px;
            border-radius: 8px;
            transition: all 0.2s ease;
        }

        .smart-summary-toggle:hover {
            background: var(--bg-elevated);
            color: var(--text-primary);
        }

        .smart-summary-toggle svg {
            transition: transform 0.3s ease;
        }

        .smart-summary-card.expanded .smart-summary-toggle svg {
            transform: rotate(180deg);
        }

        .smart-summary-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }

        .smart-summary-card.expanded .smart-summary-content {
            max-height: 500px;
        }

        .smart-summary-inner {
            padding: 0 16px 16px;
        }

        .summary-section {
            margin-bottom: 16px;
        }

        .summary-section:last-child {
            margin-bottom: 0;
        }

        .summary-section-title {
            font-size: 0.7rem;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
        }

        .active-work-summary {
            background: var(--bg-elevated);
            border-radius: 12px;
            padding: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 1px solid transparent;
        }

        .active-work-summary:hover {
            border-color: var(--accent);
            background: var(--bg-hover);
        }

        .active-work-project {
            font-weight: 600;
            font-size: 0.9rem;
            color: var(--text-primary);
            margin-bottom: 4px;
        }

        .active-work-next {
            font-size: 0.8rem;
            color: var(--text-secondary);
            line-height: 1.4;
        }

        .active-work-phase {
            font-size: 0.7rem;
            color: var(--accent);
            margin-top: 6px;
        }

        .agents-review-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .agent-review-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 12px;
            background: var(--bg-elevated);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .agent-review-item:hover {
            background: var(--bg-hover);
        }

        .agent-review-info {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .agent-review-status {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }

        .agent-review-status.completed {
            background: var(--green);
        }

        .agent-review-status.running {
            background: var(--blue);
            animation: pulse 1.5s infinite;
        }

        .agent-review-name {
            font-size: 0.85rem;
            color: var(--text-primary);
        }

        .agent-review-action {
            font-size: 0.75rem;
            color: var(--accent);
        }

        .smart-summary-actions {
            display: flex;
            gap: 8px;
            margin-top: 16px;
            padding-top: 16px;
            border-top: 1px solid var(--border);
        }

        .summary-action-btn {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 12px 16px;
            border-radius: 12px;
            font-size: 0.85rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            border: none;
        }

        .summary-action-btn.primary {
            background: linear-gradient(135deg, var(--accent), var(--blue));
            color: white;
        }

        .summary-action-btn.primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(139, 92, 246, 0.4);
        }

        .summary-action-btn.secondary {
            background: var(--bg-elevated);
            color: var(--text-primary);
            border: 1px solid var(--border);
        }

        .summary-action-btn.secondary:hover {
            background: var(--bg-hover);
            border-color: var(--accent);
        }

        .no-items-message {
            text-align: center;
            padding: 20px;
            color: var(--text-muted);
            font-size: 0.85rem;
        }

        /* ==================== INTEREST SUGGESTIONS ==================== */
        .interest-suggestions-section {
            margin-bottom: 24px;
        }

        .interest-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .interest-title {
            font-size: 0.8rem;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .refresh-interests-btn {
            background: transparent;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            padding: 4px;
            border-radius: 4px;
            transition: all 0.2s ease;
        }

        .refresh-interests-btn:hover {
            color: var(--accent);
            background: var(--bg-hover);
        }

        .interest-cards {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
        }

        @media (max-width: 768px) {
            .interest-cards {
                grid-template-columns: 1fr;
            }
        }

        .interest-card {
            background: var(--bg-card);
            border-radius: 16px;
            padding: 16px;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
            border: 1px solid var(--border);
        }

        .interest-card:hover {
            transform: translateY(-2px);
            border-color: var(--accent);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
        }

        .interest-card.fun-project {
            border-top: 3px solid var(--green);
        }

        .interest-card.business-feature {
            border-top: 3px solid var(--blue);
        }

        .interest-card.claude-choice {
            border-top: 3px solid var(--accent);
        }

        .interest-type-badge {
            font-size: 0.65rem;
            padding: 2px 8px;
            border-radius: 10px;
            font-weight: 600;
            text-transform: uppercase;
            display: inline-block;
        }

        .fun-project .interest-type-badge {
            background: rgba(34, 197, 94, 0.2);
            color: var(--green);
        }

        .business-feature .interest-type-badge {
            background: rgba(59, 130, 246, 0.2);
            color: var(--blue);
        }

        .claude-choice .interest-type-badge {
            background: rgba(139, 92, 246, 0.2);
            color: var(--accent);
        }

        .interest-card-title {
            font-weight: 600;
            font-size: 0.9rem;
            margin: 8px 0 6px;
            color: var(--text-primary);
        }

        .interest-card-desc {
            font-size: 0.8rem;
            color: var(--text-secondary);
            line-height: 1.4;
            margin-bottom: 8px;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        .interest-card-reason {
            font-size: 0.7rem;
            color: var(--text-muted);
            font-style: italic;
        }

        .interest-dismiss-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: var(--bg-elevated);
            border: 1px solid var(--border);
            color: var(--text-muted);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: all 0.2s ease;
        }

        .interest-card:hover .interest-dismiss-btn {
            opacity: 1;
        }

        .interest-dismiss-btn:hover {
            background: var(--red);
            color: white;
            border-color: var(--red);
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        /* ==================== SUGGESTIONS LOADING STATE ==================== */
        .suggestions-loading {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 40px 20px;
            gap: 20px;
        }

        .loading-brain {
            position: relative;
            width: 80px;
            height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .brain-pulse {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: var(--accent-glow);
            animation: brainPulse 1.5s ease-in-out infinite;
        }

        @keyframes brainPulse {
            0%, 100% { transform: scale(0.8); opacity: 0.3; }
            50% { transform: scale(1.2); opacity: 0.6; }
        }

        .brain-icon {
            font-size: 2.5rem;
            z-index: 1;
            animation: brainFloat 2s ease-in-out infinite;
        }

        @keyframes brainFloat {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-5px); }
        }

        .loading-brain.complete .brain-pulse {
            animation: none;
            background: rgba(34, 197, 94, 0.3);
        }

        .loading-brain.complete .brain-icon {
            animation: none;
        }

        .suggestions-loading.complete {
            animation: fadeOut 0.5s ease-out forwards;
            animation-delay: 0.3s;
        }

        @keyframes fadeOut {
            to { opacity: 0; transform: scale(0.95); }
        }

        .loading-message {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 0.95rem;
            color: var(--text-secondary);
            animation: messageSlide 0.3s ease-out;
        }

        @keyframes messageSlide {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .loading-icon {
            font-size: 1.2rem;
        }

        .loading-progress {
            width: 200px;
            height: 4px;
            background: var(--bg-elevated);
            border-radius: 2px;
            overflow: hidden;
        }

        .loading-bar {
            height: 100%;
            width: 30%;
            background: var(--accent-gradient);
            border-radius: 2px;
            animation: loadingSlide 1.5s ease-in-out infinite;
        }

        @keyframes loadingSlide {
            0% { transform: translateX(-100%); }
            50% { transform: translateX(250%); }
            100% { transform: translateX(-100%); }
        }

        /* ==================== SUGGESTION CATEGORIES ==================== */
        .suggestion-category {
            margin-bottom: 20px;
            animation: categoryFadeIn 0.4s ease-out forwards;
            opacity: 0;
        }

        @keyframes categoryFadeIn {
            from { opacity: 0; transform: translateY(15px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .category-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 12px;
            padding: 0 4px;
        }

        .category-icon {
            font-size: 1rem;
        }

        .category-name {
            font-size: 0.8rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-muted);
        }

        .category-count {
            font-size: 0.7rem;
            padding: 2px 8px;
            border-radius: 10px;
            background: var(--bg-elevated);
            color: var(--text-muted);
        }

        .category-cards {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        /* Self-improvement category special styling */
        .suggestion-category:has(.category-name:contains('Self')) .suggestion-card {
            border-left: 3px solid var(--accent);
        }

        /* Animate suggestion cards on render */
        .suggestion-card {
            animation: cardSlideIn 0.3s ease-out forwards;
        }

        @keyframes cardSlideIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Device sync indicator */
        .sync-badge {
            display: none !important;
        }

        .sync-dot {
            width: 5px;
            height: 5px;
            border-radius: 50%;
            background: var(--green);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* ==================== AGENTS VIEW ==================== */
        .agents-view {
            padding: 20px;
            gap: 16px;
            overflow-y: auto;
            min-height: min-content;
        }

        .agents-header {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 8px;
        }

        .agents-header-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .agents-header-row > button,
        .agents-header-row > .btn {
            min-width: 110px;
            padding: 8px 0 !important;
            font-size: 0.8rem;
            text-align: center;
            justify-content: center;
            box-sizing: border-box;
        }

        .agents-count {
            font-size: 0.8rem;
            color: var(--text-muted);
            background: var(--bg-card);
            padding: 4px 10px;
            border-radius: 12px;
        }

        /* 3-segment tab control */
        .agents-tab-control {
            display: flex;
            background: rgba(139, 92, 246, 0.08);
            border: 1px solid rgba(139, 92, 246, 0.2);
            border-radius: 10px;
            padding: 3px;
            gap: 3px;
        }
        .agents-tab {
            flex: 1;
            padding: 8px 0;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.78rem;
            font-weight: 500;
            color: var(--text-muted);
            background: transparent;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
        }
        .agents-tab:hover { color: var(--text-secondary); background: rgba(139, 92, 246, 0.06); }
        .agents-tab.active {
            color: #fff;
            background: rgba(139, 92, 246, 0.25);
            box-shadow: 0 2px 8px rgba(139, 92, 246, 0.15);
        }

        /* View mode switcher (Grid | Project | List) */
        .agents-view-mode {
            display: flex;
            gap: 4px;
            margin-bottom: 10px;
        }
        .view-mode-btn {
            padding: 7px 12px;
            background: transparent;
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text-muted);
            cursor: pointer;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            font-weight: 500;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .view-mode-btn:hover {
            color: var(--text-secondary);
            border-color: rgba(139, 92, 246, 0.3);
        }
        .view-mode-btn.active {
            color: #fff;
            border-color: rgba(139, 92, 246, 0.5);
            background: rgba(139, 92, 246, 0.15);
            box-shadow: 0 0 12px rgba(139, 92, 246, 0.15);
        }

        /* Agent control bar  stop actions */
        .agent-control-bar {
            display: none;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: rgba(239, 68, 68, 0.06);
            border: 1px solid rgba(239, 68, 68, 0.15);
            border-radius: 10px;
            margin-bottom: 8px;
        }
        .agent-control-bar.visible {
            display: flex;
        }
        .agent-control-bar .control-label {
            font-size: 0.75rem;
            color: var(--text-secondary);
            white-space: nowrap;
        }
        .agent-control-bar .running-agent-chips {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            flex: 1;
            min-width: 0;
        }
        .agent-control-bar .agent-chip {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 3px 8px 3px 10px;
            background: rgba(139, 92, 246, 0.1);
            border: 1px solid rgba(139, 92, 246, 0.2);
            border-radius: 16px;
            font-size: 0.7rem;
            color: var(--text-secondary);
            cursor: default;
            max-width: 160px;
            overflow: hidden;
        }
        .agent-control-bar .agent-chip .chip-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: #22c55e;
            flex-shrink: 0;
            animation: pulse-dot 1.5s ease-in-out infinite;
        }
        @keyframes pulse-dot {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }
        .agent-control-bar .agent-chip .chip-stop {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            border: none;
            background: rgba(239, 68, 68, 0.2);
            color: #f87171;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            flex-shrink: 0;
            transition: background 0.15s;
        }
        .agent-control-bar .agent-chip .chip-stop:hover {
            background: rgba(239, 68, 68, 0.5);
            color: #fff;
        }
        .agent-control-bar .stop-all-btn {
            padding: 5px 12px;
            font-size: 0.7rem;
            font-weight: 600;
            background: rgba(239, 68, 68, 0.15);
            border: 1px solid rgba(239, 68, 68, 0.3);
            border-radius: 8px;
            color: #f87171;
            cursor: pointer;
            white-space: nowrap;
            transition: background 0.15s, color 0.15s;
        }
        .agent-control-bar .stop-all-btn:hover {
            background: rgba(239, 68, 68, 0.3);
            color: #fca5a5;
        }

        /* Search + sort toolbar */
        .agents-toolbar {
            display: flex;
            gap: 8px;
            margin-bottom: 10px;
            align-items: center;
        }
        .agents-search {
            flex: 1;
            padding: 8px 12px 8px 32px;
            background: var(--glass-bg);
            border: 1px solid var(--border);
            border-radius: 10px;
            color: #fff;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            outline: none;
            transition: border-color 0.2s ease;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='14' height='14' viewBox='0 0 24 24' fill='none' stroke='%236b7280' stroke-width='2'%3E%3Ccircle cx='11' cy='11' r='8'/%3E%3Cpath d='m21 21-4.35-4.35'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: 10px center;
        }
        .agents-search:focus {
            border-color: rgba(139, 92, 246, 0.5);
        }
        .agents-search::placeholder {
            color: var(--text-muted);
        }
        .agents-sort-toggle {
            display: flex;
            align-items: center;
            gap: 0;
            background: var(--glass-bg);
            border: 1px solid var(--border);
            border-radius: 10px;
            overflow: hidden;
        }
        .agents-sort-toggle .sort-arrow-btn {
            background: none;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            padding: 7px 10px;
            font-size: 0.9rem;
            line-height: 1;
            transition: all 0.15s;
        }
        .agents-sort-toggle .sort-arrow-btn:hover {
            color: var(--text-primary);
            background: rgba(139, 92, 246, 0.12);
        }
        .agents-sort-toggle .sort-arrow-btn.active {
            color: var(--accent);
            background: rgba(139, 92, 246, 0.15);
        }
        .agents-sort-toggle .sort-divider {
            width: 1px;
            height: 18px;
            background: var(--border);
        }

        /* Grid layout for agents container */
        #agents-container.grid-view {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }
        @media (min-width: 900px) {
            #agents-container.grid-view {
                grid-template-columns: repeat(3, 1fr);
            }
        }
        #agents-container.grid-view .agent-output,
        #agents-container.grid-view .agent-tools,
        #agents-container.grid-view .sub-agents-container,
        #agents-container.grid-view .agent-expand-hint {
            display: none;
        }
        #agents-container.grid-view .agent-card {
            margin-bottom: 0;
        }

        /* List layout */
        #agents-container.list-view .agent-card {
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 12px;
            padding: 10px 14px;
            margin-bottom: 4px;
            border-radius: 10px;
        }
        #agents-container.list-view .agent-header {
            margin-bottom: 0;
            min-width: 160px;
        }
        #agents-container.list-view .agent-task {
            flex: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-bottom: 0;
        }
        #agents-container.list-view .agent-output,
        #agents-container.list-view .agent-tools,
        #agents-container.list-view .sub-agents-container,
        #agents-container.list-view .agent-expand-hint {
            display: none;
        }
        #agents-container.list-view .agent-time {
            white-space: nowrap;
        }

        /* Compact agent card (used in grid + project views) */
        .agent-card-compact {
            background: var(--glass-bg);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid var(--border);
            border-radius: 14px;
            padding: 14px;
            cursor: pointer;
            transition: all 0.3s var(--ease-out-expo);
            position: relative;
            overflow: hidden;
        }
        .agent-card-compact:hover {
            transform: translateY(-2px);
            border-color: rgba(139, 92, 246, 0.3);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
        }
        .agent-card-compact.running {
            border-left: 3px solid var(--accent);
            animation: agentPulse 2s infinite;
        }
        .agent-card-compact.completed {
            border-left: 3px solid var(--green);
        }
        .agent-card-compact.failed {
            border-left: 3px solid var(--red);
        }
        .agent-card-compact .compact-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }
        .agent-card-compact .compact-name {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            font-weight: 600;
            color: #fff;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 70%;
        }
        .agent-card-compact .compact-status {
            font-size: 0.65rem;
            font-weight: 600;
            padding: 2px 6px;
            border-radius: 6px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .agent-card-compact .compact-status.running {
            color: var(--accent);
            background: rgba(139, 92, 246, 0.15);
            border: none;
            animation: none;
        }
        .agent-card-compact .compact-status.completed {
            color: var(--green);
            background: rgba(34, 197, 94, 0.15);
            border: none;
        }
        .agent-card-compact .compact-status.failed {
            color: var(--red);
            background: rgba(239, 68, 68, 0.15);
            border: none;
        }
        .agent-card-compact .compact-status.queued {
            color: var(--text-muted);
            background: rgba(107, 114, 128, 0.15);
            border: none;
        }
        .agent-card-compact .compact-status.cycling {
            color: var(--specops-pink-light);
            background: rgba(255, 45, 120, 0.15);
            border: none;
        }
        .agent-card-compact .compact-task {
            font-size: 0.78rem;
            color: var(--text-secondary);
            line-height: 1.4;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
            word-break: break-word;
            margin-bottom: 8px;
        }
        .agent-card-compact .compact-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .agent-card-compact .compact-time {
            font-size: 0.7rem;
            color: var(--text-muted);
        }
        .agent-card-compact .compact-project-badge {
            font-size: 0.65rem;
            color: var(--accent);
            background: rgba(139, 92, 246, 0.1);
            padding: 2px 6px;
            border-radius: 6px;
            max-width: 120px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .agent-card-compact .compact-retry-btn {
            font-size: 0.7rem;
            color: var(--accent);
            background: rgba(139, 92, 246, 0.1);
            border: 1px solid rgba(139, 92, 246, 0.3);
            padding: 3px 8px;
            border-radius: 6px;
            cursor: pointer;
        }
        .agent-card-compact .compact-retry-btn:hover {
            background: rgba(139, 92, 246, 0.2);
        }

        /* Project folder (Project view) */
        .project-folder {
            border: 1px solid var(--border);
            background: rgba(139, 92, 246, 0.03);
            border-radius: 14px;
            margin-bottom: 12px;
            overflow: hidden;
        }
        .project-folder-header {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px 16px;
            cursor: pointer;
            transition: background 0.2s ease;
            user-select: none;
        }
        .project-folder-header:hover {
            background: rgba(139, 92, 246, 0.06);
        }
        .project-folder-chevron {
            transition: transform 0.2s ease;
            color: var(--text-muted);
            flex-shrink: 0;
        }
        .project-folder-chevron.expanded {
            transform: rotate(90deg);
        }
        .project-folder-icon {
            color: var(--accent);
            flex-shrink: 0;
        }
        .project-folder-name {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            font-weight: 600;
            color: #fff;
            flex: 1;
        }
        .project-folder-count {
            font-size: 0.75rem;
            color: var(--text-muted);
        }
        .project-folder-running {
            font-size: 0.65rem;
            color: var(--accent);
            background: rgba(139, 92, 246, 0.15);
            padding: 2px 8px;
            border-radius: 10px;
            font-weight: 600;
        }
        .project-folder-tags {
            display: flex;
            gap: 4px;
            flex-wrap: wrap;
        }
        .project-folder-tag {
            font-size: 0.6rem;
            color: var(--text-muted);
            background: rgba(255, 255, 255, 0.05);
            padding: 1px 5px;
            border-radius: 4px;
        }
        .project-folder-agents {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            padding: 0 12px 12px;
        }
        @media (min-width: 900px) {
            .project-folder-agents {
                grid-template-columns: repeat(3, 1fr);
            }
        }
        .project-folder-agents.collapsed {
            display: none;
        }

        /* Project dropdown in detail view */
        .agent-project-select {
            padding: 6px 10px;
            background: var(--glass-bg);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: #fff;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.78rem;
            cursor: pointer;
            outline: none;
            min-width: 140px;
        }
        .agent-project-select option {
            background: #1a1a2e;
            color: #fff;
        }

        .agent-card {
            background: var(--glass-bg);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid var(--border);
            border-radius: 20px;
            padding: 20px;
            margin-bottom: 12px;
            transition: all 0.3s var(--ease-out-expo);
            position: relative;
            overflow: hidden;
            cursor: pointer;
        }

        .agent-card::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(
                90deg,
                transparent,
                rgba(255, 255, 255, 0.1),
                transparent
            );
        }

        .agent-card:hover {
            transform: translateY(-4px);
            border-color: var(--glass-border-hover);
            box-shadow:
                0 12px 40px rgba(0, 0, 0, 0.4),
                0 0 30px var(--glow-subtle);
        }

        .agent-card:active {
            transform: translateY(-2px);
        }

        .agent-card.running {
            border-left: 3px solid var(--accent);
            box-shadow:
                0 4px 20px rgba(0, 0, 0, 0.3),
                -4px 0 20px var(--glow-subtle);
            animation: agentPulse 2s infinite;
        }

        .agent-card.completed {
            border-left: 3px solid var(--green);
        }

        .agent-card.failed {
            border-left: 3px solid var(--red);
        }

        @keyframes agentPulse {
            0%, 100% { box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3), -4px 0 20px var(--glow-subtle); }
            50% { box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3), -4px 0 30px var(--glow-medium); }
        }

        /* === SPECIAL OPS CARD STYLES === */
        .agent-card.specops {
            border-left: 3px solid var(--specops-pink);
            background: linear-gradient(135deg, rgba(255, 45, 120, 0.05), var(--glass-bg));
        }
        .agent-card.specops.running {
            border-left: 3px solid var(--specops-pink);
            box-shadow: 0 4px 20px rgba(0,0,0,0.3), -4px 0 20px var(--specops-glow);
            animation: specOpsPulse 2s infinite;
        }
        .agent-card.specops.cycling {
            border-left: 3px solid var(--specops-pink-light);
            box-shadow: 0 4px 15px rgba(0,0,0,0.2), -4px 0 15px rgba(255,45,120,0.15);
            animation: specOpsCycling 4s ease-in-out infinite;
        }
        .agent-card.specops.completed {
            border-left: 3px solid var(--specops-pink);
            opacity: 0.85;
        }
        @keyframes specOpsPulse {
            0%, 100% { box-shadow: 0 4px 20px rgba(0,0,0,0.3), -4px 0 20px var(--specops-glow); }
            50% { box-shadow: 0 4px 20px rgba(0,0,0,0.3), -4px 0 35px rgba(255,45,120,0.4); }
        }
        @keyframes specOpsCycling {
            0%, 100% { opacity: 0.9; box-shadow: 0 4px 15px rgba(0,0,0,0.2), -4px 0 15px rgba(255,45,120,0.15); }
            50% { opacity: 0.7; box-shadow: 0 4px 15px rgba(0,0,0,0.2), -4px 0 10px rgba(255,45,120,0.1); }
        }
        .specops-badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 2px 8px;
            background: var(--specops-gradient);
            border-radius: 10px;
            font-size: 0.65rem;
            font-weight: 700;
            color: white;
            letter-spacing: 0.5px;
            text-transform: uppercase;
        }
        .specops-mission-name {
            font-family: 'JetBrains Mono', monospace;
            color: var(--specops-pink);
            text-transform: uppercase;
            font-size: 0.75rem;
            font-weight: 600;
            letter-spacing: 1px;
            margin-top: 4px;
        }
        .specops-metrics {
            display: flex;
            gap: 12px;
            margin-top: 8px;
            flex-wrap: wrap;
        }
        .specops-metric {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 6px 10px;
            background: rgba(255, 45, 120, 0.08);
            border: 1px solid rgba(255, 45, 120, 0.15);
            border-radius: 8px;
            min-width: 60px;
        }
        .specops-metric-value {
            font-size: 0.85rem;
            font-weight: 700;
            color: var(--specops-pink-light);
        }
        .specops-metric-label {
            font-size: 0.6rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .specops-journal-preview {
            margin-top: 8px;
            padding: 8px 12px;
            border-left: 2px solid var(--specops-pink);
            background: rgba(255, 45, 120, 0.04);
            border-radius: 0 6px 6px 0;
            font-size: 0.75rem;
            color: var(--text-muted);
            max-height: 60px;
            overflow: hidden;
        }
        /* Compact card specops variant */
        .agent-card-compact.specops {
            border-left: 2px solid var(--specops-pink);
            background: linear-gradient(135deg, rgba(255,45,120,0.05), var(--glass-bg));
        }
        .agent-card-compact.specops.running { animation: specOpsPulse 2s infinite; }
        .agent-card-compact.specops.cycling { animation: specOpsCycling 4s ease-in-out infinite; }
        .compact-specops-badge {
            display: inline-block;
            padding: 1px 6px;
            background: var(--specops-gradient);
            border-radius: 8px;
            font-size: 0.55rem;
            font-weight: 700;
            color: white;
            letter-spacing: 0.3px;
            margin-left: 6px;
        }
        /* Spawn form specops */
        .mode-btn[data-mode="specops"].active {
            background: var(--specops-gradient);
            color: white;
        }
        .specops-form-section {
            border: 1px solid var(--specops-border);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 16px;
            background: rgba(255, 45, 120, 0.03);
        }
        .specops-form-section .form-label {
            color: var(--specops-pink-light);
        }
        .specops-selector {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        .specops-selector .sel-btn {
            padding: 8px 14px;
            border: 1px solid var(--border);
            border-radius: 8px;
            background: var(--bg-elevated);
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.2s ease;
        }
        .specops-selector .sel-btn:hover {
            border-color: var(--specops-pink);
            color: var(--text-primary);
        }
        .specops-selector .sel-btn.active {
            background: rgba(255, 45, 120, 0.15);
            border-color: var(--specops-pink);
            color: var(--specops-pink-light);
            font-weight: 600;
        }
        /* Detail panel specops controls */
        .specops-controls {
            display: flex;
            gap: 12px;
            padding: 12px;
            border: 1px solid var(--specops-border);
            border-radius: 10px;
            margin-top: 12px;
            flex-wrap: wrap;
            align-items: center;
            background: rgba(255, 45, 120, 0.03);
        }
        .specops-controls select {
            padding: 6px 10px;
            background: var(--bg-elevated);
            border: 1px solid var(--specops-border);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 0.8rem;
        }
        .specops-controls .toggle-btn {
            padding: 6px 14px;
            border-radius: 6px;
            border: 1px solid var(--specops-border);
            cursor: pointer;
            font-size: 0.8rem;
            font-weight: 600;
            transition: all 0.2s ease;
        }
        .specops-controls .toggle-btn.on {
            background: var(--specops-pink);
            color: white;
            border-color: var(--specops-pink);
        }
        .specops-controls .toggle-btn.off {
            background: var(--bg-elevated);
            color: var(--text-muted);
        }
        /* Journal full display */
        .specops-journal {
            margin-top: 12px;
        }
        .specops-journal-entry {
            padding: 10px 14px;
            border-left: 2px solid var(--specops-pink);
            background: rgba(255, 45, 120, 0.04);
            border-radius: 0 8px 8px 0;
            margin-bottom: 8px;
        }
        .specops-journal-entry-header {
            display: flex;
            justify-content: space-between;
            font-size: 0.7rem;
            color: var(--specops-pink-light);
            font-weight: 600;
            margin-bottom: 4px;
        }
        .specops-journal-entry-body {
            font-size: 0.75rem;
            color: var(--text-secondary);
            line-height: 1.5;
        }

        /* ==================== SPECOPS TABBED PANEL ==================== */
        .specops-tabs {
            display: flex;
            gap: 0;
            border-bottom: 1px solid var(--border);
            margin-bottom: 12px;
        }
        .specops-tab {
            padding: 8px 16px;
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--text-muted);
            cursor: pointer;
            border-bottom: 2px solid transparent;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-family: 'JetBrains Mono', 'SF Mono', monospace;
        }
        .specops-tab:hover {
            color: var(--text-primary);
            background: rgba(255, 45, 120, 0.05);
        }
        .specops-tab.active {
            color: var(--specops-pink);
            border-bottom-color: var(--specops-pink);
        }
        .specops-tab-content {
            display: none;
            min-height: 200px;
            max-height: calc(100vh - 340px);
            overflow-y: auto;
        }
        .specops-tab-content.active {
            display: block;
        }
        .specops-debrief-stats {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
            margin-bottom: 16px;
            padding: 12px;
            background: rgba(255, 45, 120, 0.04);
            border: 1px solid rgba(255, 45, 120, 0.15);
            border-radius: 10px;
        }
        .specops-debrief-stat {
            text-align: center;
        }
        .specops-debrief-stat-value {
            font-size: 1rem;
            font-weight: 700;
            color: var(--specops-pink);
            font-family: 'JetBrains Mono', 'SF Mono', monospace;
        }
        .specops-debrief-stat-label {
            font-size: 0.6rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-top: 2px;
        }
        .specops-debrief-content {
            padding: 16px;
            background: var(--bg-primary);
            border-radius: 8px;
            color: var(--text-secondary);
            font-size: 0.85rem;
            line-height: 1.7;
        }
        .specops-debrief-content h2 {
            color: var(--specops-pink);
            font-size: 0.9rem;
            font-weight: 700;
            margin: 16px 0 8px 0;
            font-family: 'JetBrains Mono', 'SF Mono', monospace;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .specops-debrief-content h2:first-child {
            margin-top: 0;
        }
        .specops-debrief-content ul {
            margin: 4px 0 8px 0;
            padding-left: 20px;
        }
        .specops-debrief-content li {
            margin-bottom: 4px;
        }
        .specops-debrief-content p {
            margin-bottom: 8px;
        }
        .specops-debrief-generating {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 20px;
            color: var(--text-muted);
            font-size: 0.8rem;
            font-style: italic;
        }
        .specops-debrief-generating .agent-spinner {
            width: 16px;
            height: 16px;
        }
        .specops-pending-directive {
            background: rgba(251, 191, 36, 0.1);
            border: 1px solid rgba(251, 191, 36, 0.3);
            border-radius: 8px;
            padding: 8px 12px;
            margin: 8px 0;
            font-size: 0.8rem;
            color: var(--text-secondary);
        }
        .directive-badge {
            background: #fbbf24;
            color: #1a1a2e;
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: 700;
            font-size: 0.7rem;
            letter-spacing: 0.05em;
            margin-right: 6px;
        }
        .specops-completed-cycle-detail {
            animation: specops-fade-in 0.25s ease-out;
        }
        @keyframes specops-fade-in {
            from { opacity: 0; transform: translateY(8px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .specops-live-output {
            font-size: 0.85rem;
            line-height: 1.6;
            padding: 16px;
            background: var(--bg-primary);
            border-radius: 8px;
            min-height: 150px;
            max-height: calc(100vh - 400px);
            overflow-y: auto;
            color: var(--text-secondary);
        }
        .specops-live-output .agent-output-rendered {
            border: none;
            padding: 0;
            background: transparent;
        }
        .specops-live-output .agent-output-rendered p {
            margin-bottom: 12px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.06);
        }
        .specops-live-output .agent-output-rendered p:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }
        .specops-mission-header {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 16px;
            background: rgba(255, 45, 120, 0.06);
            border: 1px solid rgba(255, 45, 120, 0.15);
            border-radius: 10px;
            margin-bottom: 12px;
        }
        .specops-mission-header .agent-spinner {
            width: 20px;
            height: 20px;
            flex-shrink: 0;
        }
        .specops-mission-header-info {
            flex: 1;
        }
        .specops-mission-header-name {
            font-weight: 700;
            font-size: 0.85rem;
            color: var(--specops-pink);
            font-family: 'JetBrains Mono', 'SF Mono', monospace;
        }
        .specops-mission-header-status {
            font-size: 0.7rem;
            color: var(--text-muted);
            margin-top: 2px;
        }
        .specops-countdown {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 14px 16px;
            background: rgba(255, 45, 120, 0.08);
            border: 1px solid rgba(255, 45, 120, 0.2);
            border-radius: 10px;
            margin-bottom: 12px;
        }
        .specops-countdown-label {
            font-size: 0.65rem;
            font-weight: 700;
            color: var(--specops-pink-light);
            text-transform: uppercase;
            letter-spacing: 1px;
            font-family: 'JetBrains Mono', 'SF Mono', monospace;
        }
        .specops-countdown-timer {
            font-size: 1.6rem;
            font-weight: 800;
            color: var(--specops-pink);
            font-family: 'JetBrains Mono', 'SF Mono', monospace;
            letter-spacing: 2px;
        }
        .specops-action-btns {
            display: flex;
            gap: 8px;
            margin-left: auto;
        }
        .specops-action-btn {
            padding: 6px 14px;
            border-radius: 6px;
            font-size: 0.72rem;
            font-weight: 600;
            cursor: pointer;
            border: 1px solid var(--border);
            transition: all 0.2s ease;
            font-family: 'JetBrains Mono', 'SF Mono', monospace;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .specops-action-btn.force {
            background: var(--specops-pink);
            color: white;
            border-color: var(--specops-pink);
        }
        .specops-action-btn.force:hover {
            background: #e6266c;
            transform: translateY(-1px);
        }
        .specops-action-btn.pause {
            background: var(--bg-elevated);
            color: var(--text-secondary);
        }
        .specops-action-btn.pause:hover {
            background: var(--bg-secondary);
            border-color: var(--specops-pink);
            color: var(--specops-pink);
        }
        .specops-stats-row {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
            margin-bottom: 12px;
        }
        .specops-stat {
            text-align: center;
            padding: 8px;
            background: var(--bg-elevated);
            border-radius: 8px;
            border: 1px solid var(--border);
        }
        .specops-stat-value {
            font-size: 1rem;
            font-weight: 700;
            color: var(--text-primary);
            font-family: 'JetBrains Mono', 'SF Mono', monospace;
        }
        .specops-stat-label {
            font-size: 0.6rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-top: 2px;
        }
        .specops-full-output {
            font-size: 0.85rem;
            line-height: 1.6;
            padding: 16px;
            background: var(--bg-primary);
            border-radius: 8px;
            min-height: 150px;
            max-height: calc(100vh - 400px);
            overflow-y: auto;
            color: var(--text-secondary);
        }
        .specops-full-output .agent-output-rendered {
            border: none;
            padding: 0;
            background: transparent;
        }
        .specops-cycle-header {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            margin-top: 16px;
            margin-bottom: 8px;
            background: rgba(255, 45, 120, 0.08);
            border-left: 3px solid var(--specops-pink);
            border-radius: 0 6px 6px 0;
            font-family: 'JetBrains Mono', 'SF Mono', monospace;
            font-size: 0.72rem;
            font-weight: 700;
            color: var(--specops-pink-light);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .specops-cycle-header:first-child { margin-top: 0; }
        /* Journal entry clickable expand */
        .specops-journal-entry {
            cursor: pointer;
            transition: background 0.2s ease, border-color 0.2s ease;
        }
        .specops-journal-entry:hover {
            background: rgba(255, 45, 120, 0.06);
            border-color: rgba(255, 45, 120, 0.3);
        }
        .specops-journal-expand-hint {
            font-size: 0.65rem;
            color: var(--specops-pink);
            opacity: 0.6;
            margin-top: 6px;
            transition: opacity 0.2s ease;
        }
        .specops-journal-entry:hover .specops-journal-expand-hint {
            opacity: 1;
        }
        .specops-journal-entry-output {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid var(--border);
            max-height: 0;
            overflow: hidden;
            opacity: 0;
            transition: max-height 0.3s ease, opacity 0.3s ease, padding 0.3s ease;
        }
        .specops-journal-entry-output.expanded {
            max-height: 2000px;
            opacity: 1;
        }
        .specops-journal-entry-output .agent-output-rendered {
            border: none;
            padding: 8px 0;
            background: transparent;
            font-size: 0.8rem;
        }
        #specops-cycle-detail {
            animation: specops-slide-in 0.25s ease-out;
        }
        @keyframes specops-slide-in {
            from { opacity: 0; transform: translateX(20px); }
            to { opacity: 1; transform: translateX(0); }
        }
        #specops-cycle-back-btn:hover {
            background: rgba(255, 45, 120, 0.1) !important;
            border-color: var(--specops-pink) !important;
            color: var(--specops-pink) !important;
        }
        #specops-cycle-detail-body .agent-output-rendered p {
            margin-bottom: 12px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.06);
        }
        #specops-cycle-detail-body .agent-output-rendered p:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }
        /* Specops form redesign */
        .specops-briefing-section {
            border: 1px solid rgba(255, 45, 120, 0.2);
            background: rgba(255, 45, 120, 0.03);
            border-radius: 10px;
            padding: 14px 16px;
            margin-bottom: 12px;
        }
        .specops-briefing-header {
            font-size: 0.65rem;
            font-weight: 700;
            color: var(--specops-pink);
            text-transform: uppercase;
            letter-spacing: 1.5px;
            font-family: 'JetBrains Mono', 'SF Mono', monospace;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .specops-role-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 6px;
        }
        .specops-role-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            padding: 10px 6px;
            border: 1px solid var(--border);
            border-radius: 8px;
            background: var(--bg-elevated);
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.7rem;
            font-weight: 500;
            color: var(--text-secondary);
        }
        .specops-role-btn:hover {
            border-color: var(--specops-pink-light);
            background: rgba(255, 45, 120, 0.05);
        }
        .specops-role-btn.active {
            border-color: var(--specops-pink);
            background: rgba(255, 45, 120, 0.1);
            color: var(--specops-pink);
            font-weight: 600;
        }
        .specops-role-btn .role-icon {
            font-size: 1.2rem;
        }

        .agent-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 10px;
        }

        .agent-id {
            font-family: 'SF Mono', monospace;
            font-size: 0.7rem;
            color: var(--text-muted);
            background: var(--bg-elevated);
            padding: 2px 6px;
            border-radius: 4px;
        }

        .agent-parent-badge {
            font-size: 0.65rem;
            color: var(--cyan);
            background: rgba(34, 211, 238, 0.15);
            padding: 2px 6px;
            border-radius: 4px;
            margin-left: 6px;
            font-weight: 500;
        }

        .agent-card.follow-up {
            border-left: 3px solid var(--cyan);
        }

        /* ==================== AGENT SELECT MODE ==================== */
        .agent-select-checkbox {
            display: none;
            position: absolute;
            top: 14px;
            left: 14px;
            width: 22px;
            height: 22px;
            border-radius: 6px;
            border: 2px solid var(--border);
            background: var(--bg-elevated);
            cursor: pointer;
            z-index: 15;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }
        .agent-select-checkbox::after {
            content: '';
            display: none;
            width: 10px;
            height: 6px;
            border-left: 2.5px solid #fff;
            border-bottom: 2.5px solid #fff;
            transform: rotate(-45deg);
            margin-top: -2px;
        }
        .agent-select-checkbox.checked {
            background: var(--accent);
            border-color: var(--accent);
        }
        .agent-select-checkbox.checked::after {
            display: block;
        }
        .select-mode .agent-select-checkbox {
            display: flex;
        }
        .select-mode .agent-card {
            padding-left: 48px;
        }
        .agent-card.selected {
            border-color: var(--accent) !important;
            box-shadow: 0 0 12px rgba(139, 92, 246, 0.3), 0 0 24px rgba(139, 92, 246, 0.1);
        }
        .select-mode .agent-card-compact {
            padding-left: 48px;
        }
        .agent-card-compact.selected {
            border-color: var(--accent) !important;
            box-shadow: 0 0 12px rgba(139, 92, 246, 0.3), 0 0 24px rgba(139, 92, 246, 0.1);
        }
        .compact-source-badge {
            font-size: 0.6rem;
            color: var(--text-muted);
            background: rgba(255,255,255,0.05);
            padding: 1px 5px;
            border-radius: 4px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Select / Edit Groups buttons in agents header */
        .btn-select-header {
            font-size: 0.8rem;
            padding: 6px 0;
            border-radius: 10px;
            min-width: 100px;
            text-align: center;
        }

        /* Selection action bar */
        .selection-action-bar {
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--glass-bg);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid var(--accent);
            border-radius: 16px;
            padding: 12px 20px;
            display: flex;
            align-items: center;
            gap: 16px;
            z-index: 1000;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4), 0 0 20px rgba(139, 92, 246, 0.2);
            animation: slideUpIn 0.3s var(--ease-out-expo);
        }
        @keyframes slideUpIn {
            from { transform: translateX(-50%) translateY(20px); opacity: 0; }
            to { transform: translateX(-50%) translateY(0); opacity: 1; }
        }
        .selection-action-bar .selection-count {
            color: var(--accent);
            font-weight: 600;
            font-size: 0.9rem;
            white-space: nowrap;
        }
        .selection-action-bar .btn {
            font-size: 0.85rem;
            padding: 8px 16px;
            white-space: nowrap;
        }

        /* Merge spawn modal */
        .merge-agent-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 16px;
            max-height: 200px;
            overflow-y: auto;
        }
        .merge-agent-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 12px;
            background: var(--bg-elevated);
            border: 1px solid var(--border);
            border-radius: 10px;
            font-size: 0.85rem;
        }
        .merge-agent-item .agent-type-badge {
            font-size: 0.7rem;
            padding: 2px 8px;
            border-radius: 6px;
            background: rgba(139, 92, 246, 0.2);
            color: var(--accent);
            font-weight: 600;
        }
        .merge-agent-item .agent-callsign {
            font-weight: 600;
            color: var(--text-primary);
        }
        .merge-agent-item .agent-task-preview {
            color: var(--text-muted);
            font-size: 0.8rem;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            flex: 1;
        }

        /* ==================== SUB-AGENTS NESTED VIEW ==================== */
        .agent-card.has-children {
            padding-bottom: 12px;
        }

        .sub-agent-count-badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            font-size: 0.65rem;
            color: var(--accent);
            background: rgba(139, 92, 246, 0.2);
            padding: 2px 8px;
            border-radius: 10px;
            margin-left: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .sub-agent-count-badge:hover {
            background: rgba(139, 92, 246, 0.35);
            transform: scale(1.05);
        }

        .sub-agent-count-badge svg {
            width: 10px;
            height: 10px;
            transition: transform 0.2s ease;
        }

        .sub-agent-count-badge.expanded svg {
            transform: rotate(180deg);
        }

        .sub-agents-container {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid var(--border);
            display: none;
        }

        .sub-agents-container.expanded {
            display: block;
        }

        .sub-agents-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
            padding: 0 4px;
        }

        .sub-agents-title {
            font-size: 0.7rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 600;
        }

        .sub-agent-card {
            background: var(--bg-elevated);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 12px 14px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }

        .sub-agent-card:last-child {
            margin-bottom: 0;
        }

        .sub-agent-card:hover {
            background: var(--bg-hover);
            border-color: var(--border-light);
            transform: translateX(4px);
        }

        .sub-agent-card.running {
            border-left: 2px solid var(--accent);
        }

        .sub-agent-card.completed {
            border-left: 2px solid var(--green);
        }

        .sub-agent-card.failed {
            border-left: 2px solid var(--red);
        }

        .sub-agent-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }

        .sub-agent-name {
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .sub-agent-status {
            font-size: 0.65rem;
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: 500;
        }

        .sub-agent-status.running {
            background: rgba(139, 92, 246, 0.2);
            color: var(--accent);
        }

        .sub-agent-status.completed {
            background: rgba(34, 197, 94, 0.2);
            color: var(--green);
        }

        .sub-agent-status.failed {
            background: rgba(239, 68, 68, 0.2);
            color: var(--red);
        }

        .sub-agent-task {
            font-size: 0.7rem;
            color: var(--text-secondary);
            line-height: 1.4;
            overflow: hidden;
            text-overflow: ellipsis;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
        }

        .sub-agent-tools {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-top: 6px;
        }

        .sub-agent-tool {
            font-size: 0.6rem;
            background: var(--bg-card);
            padding: 2px 6px;
            border-radius: 4px;
            color: var(--text-muted);
        }

        /* ==================== CARD ACTION POPUP (replaces context-attach-menu) ==================== */
        .card-action-popup {
            position: absolute;
            background: rgba(30, 30, 50, 0.85);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border: 1px solid rgba(139, 92, 246, 0.25);
            border-radius: 12px;
            padding: 4px 0;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5), 0 0 0 1px rgba(139, 92, 246, 0.1);
            z-index: 10000;
            min-width: 180px;
            animation: popupFadeIn 0.15s ease-out;
        }
        @keyframes popupFadeIn {
            from { opacity: 0; transform: translateY(-4px) scale(0.96); }
            to { opacity: 1; transform: translateY(0) scale(1); }
        }
        .card-action-popup-item {
            padding: 10px 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 0.85rem;
            color: var(--text-primary);
            transition: background 0.15s;
            white-space: nowrap;
        }
        .card-action-popup-item:first-child { border-radius: 8px 8px 0 0; }
        .card-action-popup-item:last-child { border-radius: 0 0 8px 8px; }
        .card-action-popup-item:hover {
            background: rgba(139, 92, 246, 0.15);
        }
        .card-action-popup-item .popup-icon {
            width: 18px;
            text-align: center;
            flex-shrink: 0;
        }

        /* ==================== THREAD REPLY INPUT ==================== */
        .thread-reply-input {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            margin: 4px 0 8px 24px;
            background: rgba(30, 30, 50, 0.6);
            border: 1px solid rgba(139, 92, 246, 0.2);
            border-radius: 10px;
            animation: popupFadeIn 0.15s ease-out;
        }
        .thread-reply-input input {
            flex: 1;
            background: transparent;
            border: none;
            outline: none;
            color: var(--text-primary);
            font-size: 0.85rem;
            font-family: inherit;
        }
        .thread-reply-input input::placeholder {
            color: rgba(255, 255, 255, 0.35);
        }
        .thread-reply-input button {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 1rem;
            padding: 4px 6px;
            border-radius: 6px;
            transition: background 0.15s;
        }
        .thread-reply-input .thread-send-btn {
            color: rgba(139, 92, 246, 0.8);
        }
        .thread-reply-input .thread-send-btn:hover {
            background: rgba(139, 92, 246, 0.15);
            color: #8b5cf6;
        }
        .thread-reply-input .thread-cancel-btn {
            color: rgba(255, 255, 255, 0.4);
        }
        .thread-reply-input .thread-cancel-btn:hover {
            background: rgba(255, 255, 255, 0.08);
            color: rgba(255, 255, 255, 0.7);
        }

        /* ==================== THREAD CONTAINER ==================== */
        .thread-container {
            position: relative;
            margin: 2px 0 10px 20px;
            padding-left: 16px;
        }
        .thread-container::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 2px;
            background: linear-gradient(180deg, rgba(139, 92, 246, 0.4), rgba(139, 92, 246, 0.1));
            border-radius: 1px;
        }

        /* ==================== THREAD MESSAGES ==================== */
        .thread-message {
            padding: 8px 12px;
            border-radius: 10px;
            font-size: 0.85rem;
            margin-bottom: 4px;
            max-width: 85%;
            line-height: 1.45;
            word-wrap: break-word;
        }
        .thread-message.user {
            background: rgba(139, 92, 246, 0.15);
            border: 1px solid rgba(139, 92, 246, 0.2);
            margin-left: auto;
            color: var(--text-primary);
        }
        .thread-message.cerebro {
            background: rgba(30, 30, 50, 0.5);
            border: 1px solid rgba(100, 100, 130, 0.15);
            color: var(--text-secondary, rgba(255, 255, 255, 0.85));
        }
        .thread-message .thread-ts {
            font-size: 0.7rem;
            color: rgba(255, 255, 255, 0.3);
            margin-top: 4px;
        }

        /* ==================== THREAD COLLAPSE ==================== */
        .thread-collapse-btn {
            background: none;
            border: none;
            color: rgba(139, 92, 246, 0.6);
            font-size: 0.75rem;
            cursor: pointer;
            padding: 4px 8px;
            margin-bottom: 4px;
            transition: color 0.15s;
        }
        .thread-collapse-btn:hover {
            color: #8b5cf6;
        }

        /* ==================== MOBILE OVERRIDES FOR THREADS ==================== */
        @media (max-width: 600px) {
            .card-action-popup { min-width: 160px; }
            .card-action-popup-item { padding: 14px 16px; font-size: 0.9rem; }
            .thread-container { margin-left: 12px; padding-left: 12px; }
            .thread-reply-input { margin-left: 12px; }
            .thread-message { max-width: 92%; font-size: 0.82rem; }
        }

        .attached-contexts {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            padding: 10px 12px;
            background: var(--bg-elevated);
            border-radius: 10px 10px 0 0;
            border-bottom: 1px solid var(--border);
        }

        .attached-context-badge {
            display: flex;
            align-items: center;
            gap: 6px;
            background: rgba(34, 211, 238, 0.15);
            color: var(--text-primary);
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 0.75rem;
            max-width: 220px;
            border: 1px solid rgba(34, 211, 238, 0.3);
        }

        .attached-context-badge .badge-icon {
            color: var(--accent);
        }

        .attached-context-badge .preview {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            flex: 1;
        }

        .attached-context-badge .remove-btn {
            cursor: pointer;
            opacity: 0.6;
            color: var(--text-secondary);
            font-size: 0.9rem;
            padding: 0 2px;
        }

        .attached-context-badge .remove-btn:hover {
            opacity: 1;
            color: var(--red);
        }

        .message.attachable {
            cursor: pointer;
            transition: all 0.15s;
        }

        .message.attachable:hover {
            background: rgba(139, 92, 246, 0.05);
        }

        .message.attached {
            border-left: 3px solid var(--accent);
            padding-left: 13px;
        }

        .agent-chat-page-message.attachable:hover,
        .agent-chat-message.attachable:hover {
            background: rgba(139, 92, 246, 0.05);
        }

        .agent-chat-page-message.attached,
        .agent-chat-message.attached {
            border-left: 3px solid var(--accent);
        }

        .agent-status {
            font-size: 0.7rem;
            font-weight: 600;
            padding: 3px 8px;
            border-radius: 10px;
            text-transform: uppercase;
        }

        .agent-status.running {
            background: var(--accent-glow);
            color: var(--accent);
        }

        .agent-status.completed {
            background: rgba(34, 197, 94, 0.2);
            color: var(--green);
        }

        .agent-status.failed {
            background: rgba(239, 68, 68, 0.2);
            color: var(--red);
        }

        .agent-status.queued {
            background: rgba(234, 179, 8, 0.2);
            color: var(--yellow);
        }

        .agent-status.cycling {
            background: rgba(255, 45, 120, 0.2);
            color: var(--specops-pink-light);
        }

        .agent-status.operating {
            background: rgba(236, 72, 153, 0.2);
            color: #f472b6;
            animation: operatingPulse 2s ease-in-out infinite;
        }

        @keyframes operatingPulse {
            0%, 100% { opacity: 1; box-shadow: 0 0 4px rgba(244, 114, 182, 0.3); }
            50% { opacity: 0.85; box-shadow: 0 0 10px rgba(244, 114, 182, 0.5); }
        }

        .agent-task {
            font-size: 0.9rem;
            margin-bottom: 10px;
            line-height: 1.4;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        .agent-tools {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-bottom: 10px;
        }

        .agent-tool {
            font-size: 0.65rem;
            padding: 2px 8px;
            background: var(--bg-elevated);
            border-radius: 8px;
            color: var(--text-secondary);
        }

        .agent-output {
            font-size: 0.8rem;
            color: var(--text-secondary);
            background: var(--bg-elevated);
            padding: 10px;
            border-radius: 8px;
            max-height: 100px;
            overflow-y: auto;
            font-family: 'SF Mono', monospace;
            white-space: pre-wrap;
            word-break: break-word;
        }

        .agent-expand-hint {
            font-size: 0.7rem;
            color: var(--text-muted);
            margin-top: 8px;
            text-align: center;
        }

        /* Agent Detail Modal */
        .agent-detail-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }

        .agent-detail-meta {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            margin-bottom: 16px;
        }

        .agent-detail-meta-item {
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        .agent-detail-meta-item strong {
            color: var(--text-primary);
        }

        .agent-detail-task {
            background: var(--bg-elevated);
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 16px;
            line-height: 1.5;
        }

        .agent-detail-section {
            margin-bottom: 16px;
        }

        .agent-detail-section-title {
            font-size: 0.8rem;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            margin-bottom: 8px;
        }

        .agent-detail-output {
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 12px;
            max-height: 300px;
            overflow-y: auto;
            font-family: 'SF Mono', monospace;
            font-size: 0.85rem;
            white-space: pre-wrap;
            word-break: break-word;
            line-height: 1.5;
        }

        .agent-detail-tools {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .agent-detail-tool {
            background: var(--accent-glow);
            color: var(--accent);
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.8rem;
        }

        .agent-detail-error {
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid var(--red);
            padding: 12px;
            border-radius: 8px;
            color: var(--red);
        }

        .copy-btn {
            background: var(--bg-elevated);
            border: 1px solid var(--border);
            color: var(--text-secondary);
            padding: 6px 12px;
            border-radius: 8px;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .copy-btn:hover {
            background: var(--bg-hover);
            color: var(--text-primary);
        }

        .copy-btn.copied {
            background: var(--green);
            color: white;
            border-color: var(--green);
        }

        /* ==================== AGENT DETAIL MODAL ==================== */
        .agent-detail-page {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            z-index: 10000;
            display: none;
            align-items: center;
            justify-content: center;
        }

        .agent-detail-page.active {
            display: flex;
            animation: modalOverlayIn 0.25s ease-out;
        }

        @keyframes modalOverlayIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes modalIn {
            from { opacity: 0; transform: scale(0.95); }
            to { opacity: 1; transform: scale(1); }
        }

        .agent-detail-modal {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 20px;
            width: 90vw;
            max-width: 900px;
            max-height: 85vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            box-shadow: 0 24px 48px rgba(0, 0, 0, 0.4);
            animation: modalIn 0.25s ease-out;
        }

        .agent-detail-modal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px 20px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border);
            flex-shrink: 0;
        }

        .agent-detail-modal-header .agent-title {
            font-size: 1rem;
            font-weight: 600;
            flex: 1;
            margin-right: 12px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .agent-detail-modal-header .agent-status-badge {
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            flex-shrink: 0;
        }

        .agent-detail-modal-header .modal-close-btn {
            background: none;
            border: none;
            color: var(--text-muted);
            font-size: 1.4rem;
            cursor: pointer;
            padding: 4px 8px;
            margin-left: 12px;
            border-radius: 8px;
            transition: all 0.2s;
            flex-shrink: 0;
            line-height: 1;
        }

        .agent-detail-modal-header .modal-close-btn:hover {
            background: var(--bg-hover);
            color: var(--text-primary);
        }

        .agent-status-badge.completed {
            background: rgba(34, 197, 94, 0.2);
            color: var(--green);
        }

        .agent-status-badge.running {
            background: var(--accent-glow);
            color: var(--accent);
        }

        .agent-status-badge.failed {
            background: rgba(239, 68, 68, 0.2);
            color: var(--red);
        }

        .agent-status-badge.queued {
            background: rgba(234, 179, 8, 0.2);
            color: var(--yellow);
        }

        .agent-status-badge.thinking {
            background: var(--accent-glow);
            color: var(--accent);
            animation: badgeThinkingPulse 1.5s ease-in-out infinite;
        }

        .agent-status-badge.operating {
            background: rgba(236, 72, 153, 0.2);
            color: #f472b6;
            animation: operatingPulse 2s ease-in-out infinite;
        }

        @keyframes badgeThinkingPulse {
            0%, 100% { opacity: 1; box-shadow: 0 0 4px rgba(139, 92, 246, 0.3); }
            50% { opacity: 0.7; box-shadow: 0 0 12px rgba(139, 92, 246, 0.6); }
        }

        @keyframes panelContentFadeOut {
            from { opacity: 1; transform: translateX(0); }
            to { opacity: 0; transform: translateX(-20px); }
        }

        @keyframes panelContentFadeIn {
            from { opacity: 0; transform: translateX(20px); }
            to { opacity: 1; transform: translateX(0); }
        }

        @keyframes panelContentFadeBack {
            from { opacity: 0; transform: translateX(-20px); }
            to { opacity: 1; transform: translateX(0); }
        }

        .panel-thread-transitioning {
            animation: panelContentFadeOut 0.2s ease forwards;
        }

        .panel-thinking-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 16px;
            margin: 16px 0;
            background: rgba(139, 92, 246, 0.08);
            border: 1px solid rgba(139, 92, 246, 0.2);
            border-radius: 12px;
        }

        .panel-thinking-indicator .thinking-dots {
            display: flex;
            gap: 4px;
        }

        .panel-thinking-indicator .thinking-dots span {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: var(--accent);
            animation: thinkingDotBounce 1.2s ease-in-out infinite;
        }

        .panel-thinking-indicator .thinking-dots span:nth-child(2) {
            animation-delay: 0.2s;
        }

        .panel-thinking-indicator .thinking-dots span:nth-child(3) {
            animation-delay: 0.4s;
        }

        @keyframes thinkingDotBounce {
            0%, 80%, 100% { transform: translateY(0); opacity: 0.4; }
            40% { transform: translateY(-6px); opacity: 1; }
        }

        .panel-thinking-indicator .thinking-text {
            flex: 1;
            min-width: 0;
        }

        .panel-thinking-indicator .thinking-question {
            font-size: 0.85rem;
            color: rgba(255,255,255,0.9);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .panel-thinking-indicator .thinking-subtext {
            font-size: 0.75rem;
            color: var(--accent);
            margin-top: 2px;
        }

        /* Mind Agents Tab */
        .mind-agents-items {
            flex: 1;
            overflow-y: auto;
            padding: 12px 16px;
        }

        .mind-agents-queue-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 12px;
            margin-bottom: 10px;
            background: rgba(139, 92, 246, 0.08);
            border-radius: 10px;
            border: 1px solid rgba(139, 92, 246, 0.15);
        }

        .mind-agents-queue-header .queue-stats {
            font-size: 0.78rem;
            color: rgba(255,255,255,0.5);
        }

        .mind-agents-queue-header .queue-stats span {
            color: var(--accent);
            font-weight: 600;
        }

        .mind-agent-card {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 14px;
            margin-bottom: 8px;
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(255,255,255,0.06);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .mind-agent-card:hover {
            background: rgba(255,255,255,0.06);
            border-color: rgba(139, 92, 246, 0.3);
        }

        .mind-agent-card .agent-icon {
            font-size: 1.3rem;
            width: 32px;
            text-align: center;
            flex-shrink: 0;
        }

        .mind-agent-card .agent-info {
            flex: 1;
            min-width: 0;
        }

        .mind-agent-card .agent-callsign {
            font-size: 0.8rem;
            font-weight: 600;
            color: rgba(255,255,255,0.85);
        }

        .mind-agent-card .agent-task-preview {
            font-size: 0.72rem;
            color: rgba(255,255,255,0.4);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .mind-agent-card .agent-status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .mind-agent-card .agent-status-dot.running {
            background: var(--accent);
            box-shadow: 0 0 6px var(--accent);
            animation: pulse-dot 1.5s infinite;
        }

        .mind-agent-card .agent-status-dot.queued {
            background: var(--yellow);
            box-shadow: 0 0 4px rgba(234, 179, 8, 0.4);
        }

        @keyframes pulse-dot {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }

        .mind-agents-empty {
            text-align: center;
            padding: 40px 20px;
            color: rgba(255,255,255,0.3);
            font-size: 0.82rem;
        }

        .mind-agents-empty .empty-icon {
            font-size: 2rem;
            margin-bottom: 8px;
        }

        .agent-detail-content {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }

        .agent-info-card {
            background: var(--bg-card);
            border-radius: 16px;
            padding: 16px;
            margin-bottom: 16px;
            border: 1px solid var(--border);
        }

        .agent-info-row {
            display: flex;
            flex-wrap: wrap;
            gap: 16px;
            margin-bottom: 12px;
        }

        .agent-info-item {
            font-size: 0.85rem;
        }

        .agent-info-item .label {
            color: var(--text-muted);
            margin-right: 4px;
        }

        .agent-info-item .value {
            color: var(--text-primary);
            font-weight: 500;
        }

        .agent-task-box {
            background: var(--bg-elevated);
            padding: 14px;
            border-radius: 12px;
            line-height: 1.5;
            font-size: 0.95rem;
            max-height: 120px;
            overflow: hidden;
            position: relative;
            cursor: pointer;
            transition: max-height 0.3s ease;
        }
        .agent-task-box.expanded {
            max-height: none;
        }
        .agent-task-box:not(.expanded)::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 40px;
            background: linear-gradient(transparent, var(--bg-elevated));
            pointer-events: none;
        }
        .agent-task-toggle {
            text-align: center;
            padding: 4px 0;
            font-size: 0.75rem;
            color: var(--text-muted);
            cursor: pointer;
            user-select: none;
        }
        .agent-task-toggle:hover {
            color: var(--accent);
        }

        .agent-section {
            margin-bottom: 20px;
        }

        .agent-section-title {
            font-size: 0.8rem;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .agent-tools-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .agent-tool-badge {
            background: var(--accent-glow);
            color: var(--accent);
            padding: 6px 14px;
            border-radius: 16px;
            font-size: 0.8rem;
            font-weight: 500;
        }

        /* Sub-Agents Navigation in Detail Page */
        .sub-agents-nav {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 8px;
        }

        .sub-agent-nav-card {
            flex: 1;
            min-width: 140px;
            max-width: 200px;
            background: var(--bg-elevated);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .sub-agent-nav-card:hover {
            background: var(--bg-hover);
            border-color: var(--accent);
            transform: translateY(-2px);
        }

        .sub-agent-nav-card.running {
            border-left: 3px solid var(--accent);
        }

        .sub-agent-nav-card.completed {
            border-left: 3px solid var(--green);
        }

        .sub-agent-nav-card.failed {
            border-left: 3px solid var(--red);
        }

        .sub-agent-nav-name {
            font-weight: 600;
            font-size: 0.85rem;
            color: var(--text-primary);
            margin-bottom: 4px;
        }

        .sub-agent-nav-task {
            font-size: 0.7rem;
            color: var(--text-muted);
            overflow: hidden;
            text-overflow: ellipsis;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
        }

        .sub-agent-nav-status {
            font-size: 0.65rem;
            margin-top: 6px;
            padding: 2px 6px;
            border-radius: 4px;
            display: inline-block;
        }

        .sub-agent-nav-status.running {
            background: rgba(139, 92, 246, 0.2);
            color: var(--accent);
        }

        .sub-agent-nav-status.completed {
            background: rgba(34, 197, 94, 0.2);
            color: var(--green);
        }

        .sub-agent-nav-status.failed {
            background: rgba(239, 68, 68, 0.2);
            color: var(--red);
        }

        /* Rendered Markdown Output */
        .agent-output-rendered {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 20px;
            overflow-x: auto;
        }

        .agent-output-rendered h1,
        .agent-output-rendered h2,
        .agent-output-rendered h3 {
            color: var(--text-primary);
            margin-top: 1.5em;
            margin-bottom: 0.5em;
        }

        .agent-output-rendered h1:first-child,
        .agent-output-rendered h2:first-child,
        .agent-output-rendered h3:first-child {
            margin-top: 0;
        }

        .agent-output-rendered h1 { font-size: 1.4rem; }
        .agent-output-rendered h2 { font-size: 1.2rem; color: var(--accent); }
        .agent-output-rendered h3 { font-size: 1rem; }

        .agent-output-rendered p {
            margin-bottom: 1em;
            line-height: 1.6;
        }

        .agent-output-rendered ul,
        .agent-output-rendered ol {
            margin-left: 20px;
            margin-bottom: 1em;
        }

        .agent-output-rendered li {
            margin-bottom: 0.5em;
            line-height: 1.5;
        }

        .agent-output-rendered code {
            background: var(--bg-elevated);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'SF Mono', monospace;
            font-size: 0.85em;
            color: var(--accent);
        }

        .agent-output-rendered pre {
            background: var(--bg-primary);
            padding: 16px;
            border-radius: 8px;
            overflow-x: auto;
            margin-bottom: 1em;
        }

        .agent-output-rendered pre code {
            background: none;
            padding: 0;
            color: var(--text-primary);
        }

        .agent-output-rendered table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 1em;
            font-size: 0.85rem;
        }

        .agent-output-rendered th,
        .agent-output-rendered td {
            border: 1px solid var(--border);
            padding: 10px 12px;
            text-align: left;
        }

        .agent-output-rendered th {
            background: var(--bg-elevated);
            color: var(--accent);
            font-weight: 600;
        }

        .agent-output-rendered tr:nth-child(even) {
            background: var(--bg-secondary);
        }

        .agent-output-rendered a {
            color: var(--accent);
            text-decoration: none;
        }

        .agent-output-rendered a:hover {
            text-decoration: underline;
        }

        .agent-output-rendered blockquote {
            border-left: 3px solid var(--accent);
            padding-left: 16px;
            margin: 1em 0;
            color: var(--text-secondary);
        }

        .agent-output-rendered strong {
            color: var(--text-primary);
        }

        .agent-output-rendered hr {
            border: none;
            border-top: 1px solid var(--border);
            margin: 1.5em 0;
        }

        /* ==================== UNIFIED AGENT SPLIT PANEL ==================== */
        .agent-panel-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            z-index: 10000;
            display: none;
            align-items: center;
            justify-content: center;
        }

        .agent-panel-overlay.active {
            display: flex;
            animation: modalOverlayIn 0.25s ease-out;
        }

        .agent-panel {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 20px;
            width: 95vw;
            max-width: 1400px;
            max-height: 90vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            box-shadow: 0 24px 48px rgba(0, 0, 0, 0.4);
            animation: modalIn 0.25s ease-out;
        }

        .agent-panel-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px 24px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border);
            flex-shrink: 0;
        }

        .agent-panel-header .agent-title {
            font-size: 1.05rem;
            font-weight: 600;
            flex: 1;
            margin-right: 12px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .agent-panel-header .modal-close-btn {
            background: none;
            border: none;
            color: var(--text-muted);
            font-size: 1.4rem;
            cursor: pointer;
            padding: 4px 8px;
            margin-left: 12px;
            border-radius: 8px;
            transition: all 0.2s;
            flex-shrink: 0;
            line-height: 1;
        }

        .agent-panel-header .modal-close-btn:hover {
            background: var(--bg-hover);
            color: var(--text-primary);
        }

        .agent-panel-body {
            display: flex;
            flex: 1;
            overflow: hidden;
            min-height: 0;
        }

        .agent-panel-left {
            width: 420px;
            min-width: 420px;
            border-right: 1px solid var(--border);
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
        }

        .agent-panel-right {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            min-width: 0;
        }

        .agent-panel-footer {
            display: flex;
            align-items: center;
            justify-content: flex-end;
            gap: 12px;
            padding: 14px 24px;
            border-top: 1px solid var(--border);
            flex-shrink: 0;
        }

        /* Panel mode containers */
        .panel-mode { display: none; }
        .panel-mode.active { display: flex; flex-direction: column; flex: 1; }

        /* Tips section (right panel - create mode) */
        .tips-section {
            margin-bottom: 24px;
        }

        .tips-section-title {
            font-size: 0.8rem;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 12px;
        }

        .tip-card {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 14px;
            margin-bottom: 10px;
            font-size: 0.85rem;
            line-height: 1.5;
            color: var(--text-secondary);
        }

        .tip-card .tip-title {
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 4px;
        }

        /* Template gallery */
        .template-gallery {
            margin-bottom: 16px;
        }

        .template-gallery-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
        }

        .template-gallery-header .tips-section-title {
            margin-bottom: 0;
        }

        .template-save-btn {
            background: none;
            border: 1px solid var(--border);
            color: var(--text-secondary);
            padding: 4px 10px;
            border-radius: 8px;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .template-save-btn:hover {
            background: var(--accent-glow);
            color: var(--accent);
            border-color: var(--accent);
        }

        .template-card {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 14px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }

        .template-card:hover {
            border-color: var(--accent);
            background: var(--bg-hover);
        }

        .template-card .template-name {
            font-weight: 600;
            font-size: 0.85rem;
            color: var(--text-primary);
            margin-bottom: 4px;
        }

        .template-card .template-desc {
            font-size: 0.75rem;
            color: var(--text-muted);
        }

        /* template-delete button removed  delete via context menu */

        .template-empty {
            text-align: center;
            padding: 20px;
            color: var(--text-muted);
            font-size: 0.8rem;
        }

        /* Template context menu */
        .template-context-menu {
            position: absolute;
            background: rgba(30, 30, 50, 0.85);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border: 1px solid rgba(139, 92, 246, 0.25);
            border-radius: 12px;
            padding: 4px 0;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5), 0 0 0 1px rgba(139, 92, 246, 0.1);
            z-index: 10000;
            min-width: 140px;
            animation: popupFadeIn 0.15s ease-out;
        }
        .template-context-menu-item {
            padding: 10px 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 0.85rem;
            color: var(--text-primary);
            transition: background 0.15s;
            white-space: nowrap;
        }
        .template-context-menu-item:first-child { border-radius: 8px 8px 0 0; }
        .template-context-menu-item:last-child { border-radius: 0 0 8px 8px; }
        .template-context-menu-item:hover { background: rgba(139, 92, 246, 0.15); }
        .template-context-menu-item .popup-icon { width: 18px; text-align: center; flex-shrink: 0; }

        /* Template inline editor */
        .template-editor {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 16px;
        }
        .template-editor .editor-title {
            font-weight: 600;
            font-size: 0.9rem;
            color: var(--text-primary);
            margin-bottom: 12px;
        }
        .template-editor label {
            display: block;
            font-size: 0.75rem;
            color: var(--text-muted);
            margin-bottom: 4px;
            margin-top: 10px;
        }
        .template-editor label:first-of-type { margin-top: 0; }
        .template-editor input,
        .template-editor textarea,
        .template-editor select {
            width: 100%;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 8px 10px;
            color: var(--text-primary);
            font-size: 0.82rem;
            font-family: inherit;
            box-sizing: border-box;
        }
        .template-editor input:focus,
        .template-editor textarea:focus,
        .template-editor select:focus {
            outline: none;
            border-color: var(--accent);
        }
        .template-editor textarea { resize: vertical; min-height: 60px; }
        .template-editor-actions {
            display: flex;
            gap: 8px;
            margin-top: 14px;
        }
        .template-editor-actions button {
            flex: 1;
            padding: 8px 0;
            border-radius: 8px;
            font-size: 0.82rem;
            font-weight: 600;
            cursor: pointer;
            border: 1px solid var(--border);
            transition: all 0.2s;
        }
        .template-editor-actions .editor-save {
            background: var(--accent);
            color: #fff;
            border-color: var(--accent);
        }
        .template-editor-actions .editor-save:hover { opacity: 0.85; }
        .template-editor-actions .editor-cancel {
            background: transparent;
            color: var(--text-muted);
        }
        .template-editor-actions .editor-cancel:hover {
            background: var(--bg-hover);
            color: var(--text-primary);
        }

        /* Agent running indicator (right panel - running mode) */
        .agent-running-indicator {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            flex: 1;
            gap: 20px;
            padding: 40px;
        }

        .agent-spinner {
            width: 48px;
            height: 48px;
            border: 3px solid var(--border);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .agent-running-indicator .running-text {
            font-size: 0.95rem;
            color: var(--text-secondary);
        }

        .agent-running-indicator .running-task {
            font-size: 0.8rem;
            color: var(--text-muted);
            max-width: 400px;
            text-align: center;
            line-height: 1.5;
        }

        .agent-running-indicator .running-elapsed {
            font-size: 0.75rem;
            color: var(--text-muted);
            font-family: 'SF Mono', monospace;
        }

        /* Panel ask area (right side - detail mode) */
        .panel-ask-area {
            margin-top: 16px;
            display: flex;
            gap: 8px;
            flex-shrink: 0;
        }

        .panel-ask-area input {
            flex: 1;
            padding: 10px 14px;
            border-radius: 10px;
            border: 1px solid var(--border);
            background: var(--bg-primary);
            color: var(--text-primary);
            font-size: 0.85rem;
            outline: none;
        }

        .panel-ask-area input:focus {
            border-color: var(--accent);
        }

        .panel-ask-area button {
            padding: 10px 18px;
            border-radius: 10px;
            border: none;
            background: var(--accent);
            color: white;
            font-weight: 600;
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.2s;
        }

        .panel-ask-area button:hover {
            filter: brightness(1.15);
        }

        /* Left panel detail actions */
        .panel-left-actions {
            margin-top: auto;
            padding-top: 16px;
            border-top: 1px solid var(--border);
        }

        .panel-left-actions .followup-row {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .panel-left-actions textarea {
            width: 100%;
            padding: 10px;
            border-radius: 8px;
            border: 1px solid var(--border);
            background: var(--bg-primary);
            color: var(--text-primary);
            font-size: 0.85rem;
            resize: vertical;
            min-height: 50px;
        }

        .panel-left-actions .agent-action-btn {
            width: 100%;
        }

        /* Responsive - stack panels vertically */
        @media (max-width: 900px) {
            .agent-panel {
                max-width: 100%;
                width: 100%;
                max-height: 100vh;
                border-radius: 0;
            }

            .agent-panel-body {
                flex-direction: column;
            }

            .agent-panel-left {
                width: 100%;
                min-width: unset;
                border-right: none;
                border-bottom: 1px solid var(--border);
                max-height: 45vh;
            }

            .agent-panel-right {
                flex: 1;
            }
        }

        @media (max-width: 768px) {
            .agent-panel {
                border-radius: 0;
                max-height: 100vh;
                height: 100vh;
            }
        }

        /* Recommendations Section */
        .recommendations-section {
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.1), rgba(99, 102, 241, 0.1));
            border: 1px solid var(--accent);
            border-radius: 16px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .recommendations-title {
            font-size: 1rem;
            font-weight: 600;
            color: var(--accent);
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .recommendation-item {
            background: var(--bg-card);
            border-radius: 12px;
            padding: 14px;
            margin-bottom: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 12px;
        }

        .recommendation-item:last-child {
            margin-bottom: 0;
        }

        .recommendation-text {
            flex: 1;
            font-size: 0.9rem;
            line-height: 1.4;
        }

        .recommendation-btn {
            background: var(--accent-gradient);
            border: none;
            color: white;
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 0.8rem;
            font-weight: 600;
            cursor: pointer;
            white-space: nowrap;
            transition: all 0.2s;
        }

        .recommendation-btn:hover {
            transform: scale(1.02);
            box-shadow: 0 4px 15px var(--accent-glow);
        }

        /* Agent Actions Footer */
        .agent-actions-footer {
            background: var(--bg-secondary);
            border-top: 1px solid var(--border);
            padding: 16px 20px;
            display: flex;
            gap: 12px;
            flex-shrink: 0;
        }

        .agent-action-btn {
            flex: 1;
            padding: 14px 20px;
            border-radius: 12px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .agent-action-btn.primary {
            background: var(--accent-gradient);
            border: none;
            color: white;
        }

        .agent-action-btn.primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px var(--accent-glow);
        }

        .agent-action-btn.secondary {
            background: var(--bg-card);
            border: 1px solid var(--border);
            color: var(--text-primary);
        }

        /* Agent Inline Chat */
        /* === Thread Cards (Click Funnel) === */
        .thread-card {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 14px 18px;
            cursor: pointer;
            transition: all 0.2s ease;
            margin-bottom: 8px;
        }
        .thread-card:hover {
            border-color: var(--accent);
            transform: translateX(4px);
            background: var(--bg-elevated, var(--bg-card));
        }
        .thread-card:active {
            transform: translateX(2px);
        }
        .thread-card.loading {
            opacity: 0.6;
            pointer-events: none;
        }
        .thread-card .thread-question {
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 4px;
            font-size: 0.95rem;
        }
        .thread-card .thread-preview {
            font-size: 0.85rem;
            color: var(--text-muted);
            overflow: hidden;
            text-overflow: ellipsis;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            line-height: 1.4;
        }
        .thread-card .thread-meta {
            font-size: 0.75rem;
            color: var(--text-muted);
            margin-top: 8px;
            display: flex;
            gap: 12px;
            align-items: center;
        }
        .thread-card .thread-meta .reply-count {
            color: var(--accent);
            font-weight: 500;
        }
        .thread-card .thread-arrow {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--text-muted);
            font-size: 1.1rem;
        }

        /* Thread View (inside agent detail modal) */
        .thread-exchange {
            display: flex;
            flex-direction: column;
            gap: 16px;
            margin-bottom: 24px;
        }
        .thread-bubble {
            padding: 16px 20px;
            border-radius: 16px;
            line-height: 1.6;
        }
        .thread-bubble.user {
            background: linear-gradient(135deg, #8b5cf6, #7c3aed);
            color: white;
            align-self: flex-end;
            max-width: 90%;
            border-bottom-right-radius: 4px;
        }
        .thread-bubble.assistant {
            background: var(--bg-card);
            border: 1px solid var(--border);
            color: var(--text-primary);
            align-self: flex-start;
            max-width: 95%;
            border-bottom-left-radius: 4px;
        }
        .thread-bubble .chat-label {
            font-size: 0.7rem;
            font-weight: 600;
            text-transform: uppercase;
            margin-bottom: 6px;
            opacity: 0.7;
        }
        .thread-bubble.assistant .chat-content {
            font-size: 0.95rem;
        }
        .thread-bubble.assistant .chat-content p { margin: 0.5em 0; }
        .thread-bubble.assistant .chat-content code {
            background: rgba(139,92,246,0.1);
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.9em;
        }
        .thread-bubble.assistant .chat-content pre {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 12px;
            overflow-x: auto;
        }

        /* Thread back button in header */
        .thread-back-btn {
            cursor: pointer;
            font-size: 1.2rem;
            margin-right: 8px;
            opacity: 0.7;
            transition: opacity 0.2s;
        }
        .thread-back-btn:hover {
            opacity: 1;
        }

        /* Thread reply footer */
        #thread-reply-footer-actions {
            gap: 12px;
            align-items: center;
        }
        #thread-reply-footer-actions input {
            flex: 1;
        }

        .agent-chat-container {
            margin-top: 24px;
            padding-bottom: 20px;
            border-top: 1px solid var(--border);
            padding-top: 20px;
        }

        .agent-chat-container:empty {
            display: none;
            border-top: none;
            padding: 0;
            margin: 0;
        }

        .agent-chat-messages {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .agent-chat-messages:empty {
            display: none;
        }

        .agent-chat-message {
            padding: 14px 18px;
            border-radius: 16px;
            max-width: 90%;
            line-height: 1.5;
        }

        .agent-chat-message.user {
            background: linear-gradient(135deg, #8b5cf6, #7c3aed);
            color: white;
            align-self: flex-end;
            border-bottom-right-radius: 4px;
        }

        .agent-chat-message.assistant {
            background: var(--bg-card);
            border: 1px solid var(--border);
            color: var(--text-primary);
            align-self: flex-start;
            border-bottom-left-radius: 4px;
        }

        .agent-chat-message .chat-label {
            font-size: 0.7rem;
            font-weight: 600;
            text-transform: uppercase;
            margin-bottom: 6px;
            opacity: 0.7;
        }

        /* Agent Ask Input */
        .agent-ask-input-area {
            background: var(--bg-elevated);
            border-top: 1px solid var(--border);
            padding: 12px 16px;
            display: flex;
            gap: 10px;
            flex-shrink: 0;
        }

        .agent-ask-input {
            flex: 1;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 12px 16px;
            color: var(--text-primary);
            font-size: 0.95rem;
            outline: none;
        }

        .agent-ask-input:focus {
            border-color: var(--accent);
        }

        .agent-ask-send {
            background: var(--accent);
            border: none;
            border-radius: 12px;
            padding: 12px 24px;
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .agent-ask-send:hover {
            background: var(--accent-secondary);
        }

        .agent-ask-send:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .agent-action-btn.secondary:hover {
            background: var(--bg-hover);
        }

        /* ==================== AGENT CHAT PAGE ==================== */
        .agent-chat-page {
            position: fixed;
            inset: 0;
            background: var(--bg-primary);
            z-index: 1002;
            display: none;
            flex-direction: column;
            overflow: hidden;
        }

        .agent-chat-page.active {
            display: flex;
        }

        .agent-chat-page-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px 20px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border);
            flex-shrink: 0;
        }

        .agent-chat-page-header .back-btn {
            background: none;
            border: none;
            color: var(--accent);
            font-size: 1.1rem;
            cursor: pointer;
            padding: 8px;
            margin-left: -8px;
        }

        .agent-chat-page-title {
            font-size: 1rem;
            font-weight: 600;
        }

        /* Context Summary Collapse */
        .agent-context-summary {
            background: var(--bg-card);
            border-bottom: 1px solid var(--border);
            flex-shrink: 0;
        }

        .context-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 12px 20px;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 500;
            color: var(--text-secondary);
        }

        .context-toggle:hover {
            background: var(--bg-hover);
        }

        .context-toggle-icon {
            transition: transform 0.2s;
        }

        .context-toggle-icon.collapsed {
            transform: rotate(-90deg);
        }

        .context-details {
            padding: 0 20px 16px 20px;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }

        .context-details.collapsed {
            max-height: 0;
            padding-bottom: 0;
        }

        .context-task {
            background: var(--bg-elevated);
            padding: 12px;
            border-radius: 8px;
            font-size: 0.9rem;
            margin-bottom: 12px;
            line-height: 1.4;
        }

        .context-output-preview {
            font-size: 0.8rem;
            color: var(--text-secondary);
            max-height: 80px;
            overflow: hidden;
            position: relative;
        }

        .context-output-preview::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 30px;
            background: linear-gradient(transparent, var(--bg-card));
        }

        /* Chat Messages Area */
        .agent-chat-messages-area {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 16px;
            -webkit-overflow-scrolling: touch;
        }

        .agent-chat-page-message {
            padding: 14px 18px;
            border-radius: 16px;
            max-width: 85%;
            line-height: 1.5;
            font-size: 0.95rem;
        }

        .agent-chat-page-message.user {
            background: linear-gradient(135deg, #8b5cf6, #7c3aed);
            color: white;
            align-self: flex-end;
            border-bottom-right-radius: 4px;
        }

        .agent-chat-page-message.assistant {
            background: var(--bg-card);
            border: 1px solid var(--border);
            color: var(--text-primary);
            align-self: flex-start;
            border-bottom-left-radius: 4px;
        }

        .agent-chat-page-message.thinking {
            color: var(--text-muted);
            font-style: italic;
        }

        .agent-chat-page-message .chat-label {
            font-size: 0.7rem;
            font-weight: 600;
            text-transform: uppercase;
            margin-bottom: 6px;
            opacity: 0.7;
        }

        /* Chat Input Area */
        .agent-chat-input-area {
            background: var(--bg-secondary);
            border-top: 1px solid var(--border);
            padding: 16px 20px;
            padding-bottom: calc(16px + var(--safe-bottom));
            display: flex;
            gap: 12px;
            flex-shrink: 0;
        }

        .agent-chat-input {
            flex: 1;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 12px 16px;
            color: var(--text-primary);
            font-size: 0.95rem;
            outline: none;
        }

        .agent-chat-input:focus {
            border-color: var(--accent);
        }

        .agent-chat-send-btn {
            background: var(--accent-gradient);
            border: none;
            border-radius: 12px;
            padding: 12px 24px;
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .agent-chat-send-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px var(--accent-glow);
        }

        .agent-chat-send-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .agent-time {
            font-size: 0.7rem;
            color: var(--text-muted);
            margin-top: 8px;
        }

        .no-agents {
            text-align: center;
            padding: 40px 20px;
            color: var(--text-secondary);
        }

        .no-agents-icon {
            font-size: 3rem;
            margin-bottom: 12px;
            opacity: 0.5;
        }

        .btn-spawn-compact {
            background: var(--accent-gradient);
            color: white;
            border: none;
            padding: 6px 0;
            border-radius: 10px;
            font-size: 0.8rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            min-width: 100px;
            text-align: center;
        }

        .btn-spawn-compact:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px var(--accent-glow);
        }

        /* ==================== ARCHIVE SECTION ==================== */
        .archive-section {
            margin-top: 24px;
            border-top: 1px solid var(--border);
            padding-top: 16px;
        }

        .archive-toggle {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px 16px;
            background: var(--bg-card);
            border-radius: 12px;
            cursor: pointer;
            transition: background 0.2s;
            border: 1px solid var(--border);
        }

        .archive-toggle:hover {
            background: var(--bg-hover);
        }

        .archive-toggle-icon {
            transition: transform 0.2s;
            color: var(--text-muted);
        }

        .archive-toggle-icon.expanded {
            transform: rotate(90deg);
        }

        .archived-count {
            color: var(--text-muted);
            font-size: 0.85rem;
        }

        .archived-agents-container {
            margin-top: 12px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .archived-agents-container.hidden {
            display: none;
        }

        /* Archived agent cards - slightly dimmed */
        .agent-card.archived {
            opacity: 0.7;
            border-style: dashed;
        }

        .agent-card.archived:hover {
            opacity: 1;
        }

        /* Archive/Unarchive buttons on cards */
        .agent-archive-btn {
            position: absolute;
            top: 12px;
            right: 12px;
            background: var(--bg-elevated);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 4px 8px;
            font-size: 0.7rem;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.2s, background 0.2s;
            z-index: 10;
        }

        .agent-card:hover .agent-archive-btn {
            opacity: 1;
        }

        .agent-archive-btn:hover {
            background: var(--bg-hover);
        }

        /* ==================== MODAL ==================== */
        /* Prevent body scroll when modal is open */
        body.modal-open {
            overflow: hidden;
            position: fixed;
            width: 100%;
            height: 100%;
        }

        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 3000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
            padding: 20px;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }

        .modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .modal {
            background: var(--bg-card);
            border-radius: 20px;
            width: 100%;
            max-width: 400px;
            border: 1px solid var(--border);
            transform: translateY(20px);
            transition: transform 0.3s ease;
        }

        .modal-overlay.active .modal {
            transform: translateY(0);
        }

        .modal-header {
            padding: 20px;
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .modal-title {
            font-size: 1.1rem;
            font-weight: 600;
        }

        .modal-close {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: var(--bg-elevated);
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
        }

        .modal-body {
            padding: 20px;
        }

        .modal-footer {
            padding: 16px 20px;
            border-top: 1px solid var(--border);
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        .form-group {
            margin-bottom: 16px;
        }

        .form-label {
            display: block;
            font-size: 0.85rem;
            font-weight: 500;
            margin-bottom: 8px;
            color: var(--text-secondary);
        }

        .form-input {
            width: 100%;
            background: var(--bg-elevated);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 14px 16px;
            color: var(--text-primary);
            font-size: 1rem;
            font-family: inherit;
        }

        .form-input:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 3px var(--accent-glow);
        }

        .form-textarea {
            min-height: 100px;
            resize: vertical;
        }

        .modal-large {
            max-width: 600px;
            max-height: 90vh;
            overflow-y: auto;
        }

        /* ==================== CEREBRO CONFIRM DIALOG ==================== */
        .cerebro-confirm-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            opacity: 0;
            visibility: hidden;
            transition: all 0.2s ease;
            backdrop-filter: blur(4px);
        }
        .cerebro-confirm-overlay.active {
            opacity: 1;
            visibility: visible;
        }
        .cerebro-confirm-box {
            background: linear-gradient(145deg, rgba(30, 27, 50, 0.98), rgba(15, 12, 28, 0.98));
            border: 1px solid rgba(139, 92, 246, 0.25);
            border-radius: 16px;
            padding: 0;
            min-width: 340px;
            max-width: 420px;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.6), 0 0 30px rgba(139, 92, 246, 0.08);
            transform: scale(0.92) translateY(-10px);
            transition: all 0.25s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        .cerebro-confirm-overlay.active .cerebro-confirm-box {
            transform: scale(1) translateY(0);
        }
        .cerebro-confirm-header {
            padding: 20px 24px 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .cerebro-confirm-icon {
            width: 36px;
            height: 36px;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }
        .cerebro-confirm-icon.warn {
            background: rgba(251, 191, 36, 0.12);
            color: #fbbf24;
        }
        .cerebro-confirm-icon.danger {
            background: rgba(239, 68, 68, 0.12);
            color: #ef4444;
        }
        .cerebro-confirm-title {
            font-size: 1rem;
            font-weight: 600;
            color: var(--text-primary);
        }
        .cerebro-confirm-body {
            padding: 12px 24px 20px;
            color: var(--text-secondary);
            font-size: 0.88rem;
            line-height: 1.5;
        }
        .cerebro-confirm-actions {
            display: flex;
            gap: 10px;
            padding: 0 24px 20px;
            justify-content: flex-end;
        }
        .cerebro-confirm-btn {
            padding: 9px 20px;
            border-radius: 10px;
            font-size: 0.85rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s ease;
            border: none;
        }
        .cerebro-confirm-btn.cancel {
            background: rgba(255, 255, 255, 0.06);
            color: var(--text-secondary);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .cerebro-confirm-btn.cancel:hover {
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-primary);
        }
        .cerebro-confirm-btn.confirm {
            background: var(--accent);
            color: white;
        }
        .cerebro-confirm-btn.confirm:hover {
            filter: brightness(1.15);
            transform: translateY(-1px);
        }
        .cerebro-confirm-btn.confirm.danger {
            background: rgba(239, 68, 68, 0.85);
        }
        .cerebro-confirm-btn.confirm.danger:hover {
            background: #ef4444;
        }

        /* ==================== THOUGHT DETAIL MODAL ==================== */
        .thought-detail-modal {
            max-width: 550px;
            background: linear-gradient(145deg, rgba(30, 27, 45, 0.98), rgba(20, 18, 35, 0.98));
            border: 1px solid rgba(139, 92, 246, 0.3);
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5), 0 0 40px rgba(139, 92, 246, 0.1);
        }

        .thought-detail-modal .modal-header {
            background: linear-gradient(90deg, rgba(139, 92, 246, 0.1), transparent);
            border-bottom: 1px solid rgba(139, 92, 246, 0.2);
        }

        .thought-phase-icon {
            font-size: 1.3rem;
            margin-right: 10px;
        }

        .thought-detail-time {
            padding: 8px 20px;
            font-size: 0.8rem;
            color: var(--text-muted);
            background: rgba(0, 0, 0, 0.2);
            border-bottom: 1px solid rgba(139, 92, 246, 0.1);
        }

        .thought-detail-body {
            padding: 24px 20px;
        }

        .thought-detail-section {
            margin-bottom: 20px;
        }

        .thought-detail-section:last-child {
            margin-bottom: 0;
        }

        .thought-detail-label {
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: rgba(139, 92, 246, 0.8);
            margin-bottom: 8px;
        }

        .thought-detail-value {
            font-size: 0.95rem;
            line-height: 1.6;
            color: var(--text-primary);
            background: rgba(0, 0, 0, 0.2);
            padding: 14px 16px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        .thought-reasoning {
            font-style: italic;
            color: rgba(255, 255, 255, 0.85);
            border-left: 3px solid rgba(139, 92, 246, 0.5);
            padding-left: 16px;
            margin-left: 0;
        }

        .thought-detail-inline {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .thought-detail-inline .thought-detail-label {
            margin-bottom: 0;
        }

        .thought-type-badge {
            display: inline-block;
            padding: 4px 12px;
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.3), rgba(168, 85, 247, 0.2));
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 500;
            text-transform: capitalize;
        }

        .confidence-bar-container {
            width: 100%;
            height: 8px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 6px;
        }

        .confidence-bar {
            height: 100%;
            border-radius: 4px;
            transition: width 0.3s ease;
        }

        .confidence-text {
            font-size: 0.85rem;
            font-weight: 600;
        }

        .thought-metadata {
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 0.8rem;
        }

        .meta-item {
            padding: 4px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .meta-item:last-child {
            border-bottom: none;
        }

        .meta-key {
            color: rgba(139, 92, 246, 0.8);
            font-weight: 500;
        }

        .meta-value {
            color: rgba(255, 255, 255, 0.7);
        }

        /* Thought list items (opportunities, threats, priorities) */
        .thought-list {
            padding: 0 !important;
            background: transparent !important;
            border: none !important;
        }

        .list-item {
            padding: 8px 12px;
            margin: 4px 0;
            border-radius: 6px;
            font-size: 0.9rem;
        }

        .list-item.opportunity {
            background: rgba(16, 185, 129, 0.15);
            border-left: 3px solid #10b981;
        }

        .list-item.threat {
            background: rgba(239, 68, 68, 0.15);
            border-left: 3px solid #ef4444;
        }

        .list-item.priority {
            background: rgba(59, 130, 246, 0.15);
            border-left: 3px solid #3b82f6;
        }

        /* Decision details */
        .thought-decision {
            padding: 0 !important;
            background: transparent !important;
            border: none !important;
        }

        .decision-row {
            display: flex;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .decision-row:last-child {
            border-bottom: none;
        }

        .decision-key {
            color: rgba(255, 255, 255, 0.6);
            min-width: 120px;
            font-size: 0.85rem;
        }

        .decision-value {
            color: rgba(255, 255, 255, 0.95);
            font-weight: 500;
        }

        .action-badge {
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.4), rgba(168, 85, 247, 0.3));
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .risk-badge {
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 600;
            color: white;
        }

        /* Tool calls */
        .thought-tools {
            padding: 0 !important;
            background: transparent !important;
            border: none !important;
        }

        .tool-call-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 12px;
            margin: 4px 0;
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.3);
        }

        .tool-call-item.success {
            border-left: 3px solid #10b981;
        }

        .tool-call-item.failed {
            border-left: 3px solid #ef4444;
        }

        .tool-name {
            font-weight: 600;
            color: rgba(139, 92, 246, 0.9);
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 0.85rem;
        }

        .tool-query {
            flex: 1;
            color: rgba(255, 255, 255, 0.6);
            font-size: 0.8rem;
            font-style: italic;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .tool-status {
            font-size: 1rem;
        }

        /* Raw data section */
        .thought-raw pre {
            background: rgba(0, 0, 0, 0.4);
            padding: 12px;
            border-radius: 8px;
            color: rgba(255, 255, 255, 0.7);
            font-family: 'Monaco', 'Menlo', monospace;
        }

        /* Make modal scrollable and larger */
        .thought-detail-modal {
            max-width: 700px !important;
            max-height: 85vh;
            overflow-y: auto;
        }

        .thought-detail-body {
            max-height: none !important;
        }

        /* (Legacy .activity-log-item removed  replaced by .activity-log-line terminal style) */

        /* ==================== MOBILE MODAL & WIZARD FIXES ==================== */
        @media (max-width: 768px) {
            /* Modal overlay - no padding on mobile */
            .modal-overlay {
                padding: 0;
                align-items: flex-end;
            }

            /* Base modal - full width, slide up from bottom */
            .modal {
                max-width: 100%;
                width: 100%;
                border-radius: 20px 20px 0 0;
                max-height: 95vh;
                display: flex;
                flex-direction: column;
            }

            /* Large modals - nearly fullscreen */
            .modal-large {
                max-width: 100%;
                width: 100%;
                max-height: 95vh;
                border-radius: 20px 20px 0 0;
                display: flex;
                flex-direction: column;
            }

            /* Modal body scrolls, not the whole modal */
            .modal-body {
                flex: 1;
                overflow-y: auto;
                overflow-x: hidden;
                -webkit-overflow-scrolling: touch;
                padding: 16px;
            }

            /* Header/footer stay fixed */
            .modal-header {
                padding: 16px;
                flex-shrink: 0;
            }

            .modal-footer {
                padding: 12px 16px;
                flex-shrink: 0;
            }

            /* Wizard specific mobile fixes */
            .wizard-header {
                padding: 16px;
                flex-shrink: 0;
            }

            .wizard-header-content {
                gap: 12px;
            }

            .wizard-icon {
                width: 44px;
                height: 44px;
                font-size: 1.4rem;
            }

            .wizard-title {
                font-size: 1.1rem;
            }

            .wizard-subtitle {
                font-size: 0.75rem;
            }

            .wizard-body {
                flex: 1;
                overflow-y: auto;
                overflow-x: hidden;
                -webkit-overflow-scrolling: touch;
                padding: 16px;
            }

            .wizard-footer {
                padding: 14px 16px;
                flex-shrink: 0;
                flex-direction: column;
                gap: 12px;
            }

            .wizard-actions {
                width: 100%;
                justify-content: stretch;
            }

            .wizard-actions .btn {
                flex: 1;
            }

            /* Mode toggle on mobile */
            .wizard-mode-toggle {
                flex-direction: column;
                gap: 6px;
            }

            .mode-btn {
                padding: 10px 12px;
                font-size: 0.8rem;
            }

            /* Form inputs on mobile */
            .form-input {
                padding: 12px 14px;
                font-size: 16px; /* Prevents iOS zoom */
            }

            .form-textarea {
                min-height: 80px;
            }

            /* Role selector grid */
            .role-selector {
                grid-template-columns: 1fr;
            }

            /* Analytics grid on mobile */
            .wizard-analytics {
                grid-template-columns: repeat(2, 1fr);
                gap: 8px;
            }

            .analytics-card {
                padding: 10px;
            }

            .analytics-icon {
                font-size: 1.2rem;
            }

            .analytics-value {
                font-size: 0.95rem;
            }

            /* Recommended agent card */
            .rec-agent-card {
                flex-direction: column;
                text-align: center;
                padding: 14px;
            }

            .rec-agent-icon {
                width: 40px;
                height: 40px;
                font-size: 1.2rem;
            }

            /* Override options */
            .wizard-agent-override {
                flex-direction: column;
                align-items: stretch;
            }

            .override-options {
                justify-content: center;
            }

            /* Steps on mobile */
            .wizard-step {
                padding: 10px;
                gap: 10px;
            }

            .step-number {
                width: 24px;
                height: 24px;
                font-size: 0.75rem;
            }

            .step-title {
                font-size: 0.85rem;
            }

            .step-desc {
                font-size: 0.75rem;
            }

            /* Tools grid */
            .wizard-tools-grid {
                gap: 6px;
            }

            .wizard-tool {
                padding: 6px 10px;
                font-size: 0.75rem;
            }

            /* Team grid */
            .team-grid {
                grid-template-columns: 1fr;
            }

            /* Spawn mode toggle */
            .spawn-mode-toggle {
                flex-direction: column;
                gap: 4px;
            }

            /* Form row on mobile - stack vertically */
            .form-row {
                flex-direction: column;
                gap: 0;
            }

            .form-half {
                width: 100%;
            }

            /* Workflow type selector */
            .workflow-type-selector {
                flex-direction: column;
            }

            /* Advanced toggle */
            .advanced-toggle {
                font-size: 0.85rem;
            }

            /* Button sizing */
            .btn {
                padding: 10px 16px;
                font-size: 0.85rem;
            }

            .btn-primary, .btn-secondary {
                min-width: 100px;
            }

            /* ===== MULTI-AGENT WORKFLOW MOBILE FIXES ===== */

            /* Team quantity selector - single column on mobile */
            .team-quantity-selector {
                grid-template-columns: 1fr;
                gap: 8px;
            }

            .team-member-qty {
                padding: 10px 12px;
            }

            .agent-label {
                font-size: 0.85rem;
            }

            .qty-btn {
                width: 32px;
                height: 32px;
                font-size: 1.2rem;
            }

            .qty-input {
                width: 44px;
                height: 32px;
                font-size: 1rem;
            }

            /* Workflow type cards */
            .workflow-type {
                padding: 10px;
            }

            .workflow-type-icon {
                font-size: 1.2rem;
                margin-bottom: 2px;
            }

            .workflow-type-name {
                font-size: 0.85rem;
            }

            .workflow-type-desc {
                font-size: 0.65rem;
                line-height: 1.3;
            }

            /* Workflow preview diagram */
            .workflow-preview {
                padding: 12px;
                margin-top: 12px;
            }

            .workflow-preview-title {
                font-size: 0.75rem;
                margin-bottom: 10px;
            }

            .commander-node {
                padding: 10px 16px;
                font-size: 0.85rem;
            }

            .commander-node .node-icon svg {
                width: 12px;
                height: 12px;
            }

            .command-line {
                height: 16px;
            }

            .team-nodes {
                gap: 6px;
            }

            .team-node {
                padding: 6px 10px;
                font-size: 0.75rem;
            }

            /* Workflow type grid (used in orchestrator config) */
            .workflow-type-grid {
                grid-template-columns: 1fr;
                gap: 8px;
            }

            .workflow-type-card {
                padding: 10px;
            }

            .workflow-type-card .workflow-type-icon {
                font-size: 1.4rem;
                margin-bottom: 4px;
            }

            /* Role options in workflow */
            .role-option {
                padding: 10px;
            }

            .role-icon {
                font-size: 1.1rem;
            }

            .role-name {
                font-size: 0.85rem;
            }

            .role-desc {
                font-size: 0.7rem;
            }
        }

        /* Extra small screens */
        @media (max-width: 400px) {
            .modal {
                max-height: 100vh;
                border-radius: 0;
            }

            .modal-large {
                max-height: 100vh;
                border-radius: 0;
            }

            .wizard-analytics {
                grid-template-columns: 1fr 1fr;
            }

            .wizard-footer {
                padding: 12px;
            }

            .override-btn {
                padding: 5px 10px;
                font-size: 0.75rem;
            }

            /* Workflow extra small fixes */
            .team-member-qty {
                padding: 8px 10px;
            }

            .qty-btn {
                width: 28px;
                height: 28px;
            }

            .commander-node {
                padding: 8px 12px;
                font-size: 0.8rem;
            }

            .team-node {
                padding: 5px 8px;
                font-size: 0.7rem;
            }

            .workflow-type-desc {
                display: none;
            }

            .role-desc {
                display: none;
            }
        }

        .spawn-mode-toggle {
            display: flex;
            gap: 8px;
            margin-bottom: 20px;
            background: var(--bg-elevated);
            padding: 4px;
            border-radius: 10px;
        }

        .mode-btn {
            flex: 1;
            padding: 10px 16px;
            border: none;
            background: transparent;
            color: var(--text-dim);
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s ease;
        }

        .mode-btn:hover {
            color: var(--text);
        }

        .mode-btn.active {
            background: var(--accent);
            color: white;
        }

        .role-selector {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }

        .role-option {
            background: var(--bg-elevated);
            border: 2px solid var(--border);
            border-radius: 12px;
            padding: 14px;
            cursor: pointer;
            text-align: center;
            transition: all 0.2s ease;
        }

        .role-option:hover {
            border-color: var(--accent);
        }

        .role-option.selected {
            border-color: var(--accent);
            background: var(--accent-glow);
        }

        .role-desc {
            font-size: 0.7rem;
            color: var(--text-dim);
            margin-top: 4px;
        }

        .required {
            color: #ef4444;
        }

        .advanced-toggle {
            color: var(--text-dim);
            font-size: 0.85rem;
            cursor: pointer;
            padding: 10px 0;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: color 0.2s;
        }

        .advanced-toggle:hover {
            color: var(--accent);
        }

        .advanced-options {
            border-top: 1px solid var(--border);
            padding-top: 16px;
            margin-top: 8px;
        }

        .advanced-options.hidden {
            display: none;
        }

        .form-textarea-small {
            min-height: 60px;
        }

        .form-row {
            display: flex;
            gap: 12px;
        }

        .form-half {
            flex: 1;
        }

        /* Workflow styles */
        .workflow-type-selector {
            display: flex;
            gap: 10px;
        }

        .workflow-type {
            flex: 1;
            background: var(--bg-elevated);
            border: 2px solid var(--border);
            border-radius: 12px;
            padding: 12px;
            cursor: pointer;
            text-align: center;
            transition: all 0.2s ease;
        }

        .workflow-type:hover {
            border-color: var(--accent);
        }

        .workflow-type.selected {
            border-color: var(--accent);
            background: var(--accent-glow);
        }

        .workflow-type-icon {
            font-size: 1.5rem;
            margin-bottom: 4px;
        }

        .workflow-type-name {
            font-weight: 600;
            font-size: 0.9rem;
        }

        .workflow-type-desc {
            font-size: 0.65rem;
            color: var(--text-dim);
            margin-top: 4px;
        }

        .team-selector {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
        }

        .team-member {
            display: flex;
            align-items: center;
            gap: 6px;
            background: var(--bg-elevated);
            padding: 8px 12px;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .team-member:hover {
            background: var(--border);
        }

        .team-member input {
            accent-color: var(--accent);
        }

        /* Quantity selector styles */
        .team-quantity-selector {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }

        .team-member-qty {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: var(--bg-elevated);
            padding: 10px 14px;
            border-radius: 10px;
            border: 1px solid var(--border);
        }

        .agent-label {
            font-size: 0.9rem;
            font-weight: 500;
        }

        .qty-controls {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .qty-btn {
            width: 28px;
            height: 28px;
            border: none;
            border-radius: 6px;
            background: var(--accent);
            color: white;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.15s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .qty-btn:hover {
            background: var(--accent-hover);
            transform: scale(1.05);
        }

        .qty-btn:active {
            transform: scale(0.95);
        }

        .qty-input {
            width: 40px;
            height: 28px;
            text-align: center;
            border: 1px solid var(--border);
            border-radius: 6px;
            background: var(--bg-secondary);
            color: var(--text);
            font-size: 0.95rem;
            font-weight: 600;
        }

        .qty-input::-webkit-inner-spin-button,
        .qty-input::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .workflow-preview {
            margin-top: 16px;
            background: var(--bg-elevated);
            border-radius: 12px;
            padding: 16px;
        }

        .workflow-preview-title {
            font-size: 0.85rem;
            color: var(--text-dim);
            margin-bottom: 12px;
            text-align: center;
        }

        .workflow-diagram {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }

        .commander-node {
            background: linear-gradient(135deg, #8b5cf6, #7c3aed);
            color: white;
            padding: 12px 24px;
            border-radius: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 600;
        }

        .command-line {
            width: 2px;
            height: 20px;
            background: var(--accent);
        }

        .team-nodes {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .team-node {
            background: var(--bg-card);
            border: 1px solid var(--border);
            padding: 8px 14px;
            border-radius: 8px;
            font-size: 0.85rem;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .role-icon {
            font-size: 1.5rem;
            margin-bottom: 6px;
        }

        .role-name {
            font-size: 0.85rem;
            font-weight: 500;
        }

        /* Section Title */
        .section-title {
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 12px;
        }

        .section-title-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
        }

        .section-title-row .section-title {
            margin-bottom: 0;
        }

        .refresh-suggestions-btn {
            background: var(--bg-elevated);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 6px 10px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        .refresh-suggestions-btn:hover {
            background: var(--accent);
            color: white;
            border-color: var(--accent);
        }

        .refresh-suggestions-btn.spinning .refresh-icon {
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        /* ==================== TASK WIZARD MODAL ==================== */
        .task-wizard {
            background: var(--bg-secondary);
            border-radius: 24px;
            width: 95%;
            max-width: 650px;
            max-height: 90vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            box-shadow: 0 25px 80px rgba(0, 0, 0, 0.5), 0 0 40px rgba(139, 92, 246, 0.2);
            border: 1px solid rgba(139, 92, 246, 0.3);
        }

        .wizard-header {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            padding: 24px;
            display: flex;
            align-items: flex-start;
            justify-content: space-between;
            border-bottom: 1px solid rgba(139, 92, 246, 0.3);
        }

        .wizard-header-content {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .wizard-icon {
            width: 56px;
            height: 56px;
            border-radius: 16px;
            background: linear-gradient(135deg, #8b5cf6, #7c3aed);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.8rem;
            box-shadow: 0 8px 25px rgba(139, 92, 246, 0.4);
        }

        .wizard-title {
            font-size: 1.3rem;
            font-weight: 700;
            margin: 0;
            color: white;
        }

        .wizard-subtitle {
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-top: 4px;
        }

        .wizard-body {
            flex: 1;
            overflow-y: auto;
            padding: 24px;
        }

        .wizard-section {
            margin-bottom: 24px;
        }

        .wizard-section:last-child {
            margin-bottom: 0;
        }

        .wizard-section-title {
            font-size: 0.8rem;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 12px;
        }

        .wizard-task-box {
            background: var(--bg-elevated);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 16px;
            font-size: 0.95rem;
            line-height: 1.6;
            color: var(--text-primary);
        }

        /* Analytics Grid */
        .wizard-analytics {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 12px;
            margin-bottom: 24px;
        }

        @media (max-width: 600px) {
            .wizard-analytics {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        .analytics-card {
            background: var(--bg-elevated);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 14px;
            text-align: center;
            transition: all 0.2s ease;
        }

        .analytics-card:hover {
            border-color: var(--accent);
            transform: translateY(-2px);
        }

        .analytics-icon {
            font-size: 1.5rem;
            margin-bottom: 8px;
        }

        .analytics-value {
            font-size: 1.1rem;
            font-weight: 700;
            color: var(--accent);
        }

        .analytics-label {
            font-size: 0.7rem;
            color: var(--text-muted);
            text-transform: uppercase;
            margin-top: 4px;
        }

        /* Recommended Agent */
        .rec-agent-card {
            background: var(--bg-elevated);
            border: 2px solid var(--border);
            border-radius: 14px;
            padding: 16px;
            display: flex;
            align-items: center;
            gap: 14px;
            position: relative;
        }

        .rec-agent-card.selected {
            border-color: var(--accent);
            background: var(--accent-glow);
        }

        .rec-agent-icon {
            width: 48px;
            height: 48px;
            border-radius: 12px;
            background: linear-gradient(135deg, #8b5cf6, #7c3aed);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
        }

        .rec-agent-info {
            flex: 1;
        }

        .rec-agent-name {
            font-weight: 600;
            font-size: 1rem;
            margin-bottom: 4px;
        }

        .rec-agent-reason {
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        .rec-agent-badge {
            background: var(--accent);
            color: white;
            font-size: 0.7rem;
            font-weight: 600;
            padding: 4px 10px;
            border-radius: 20px;
            text-transform: uppercase;
        }

        /* Agent Override */
        .wizard-agent-override {
            margin-top: 12px;
            display: flex;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap;
        }

        .override-label {
            font-size: 0.8rem;
            color: var(--text-muted);
        }

        .override-options {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .override-btn {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 6px 12px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s ease;
            color: var(--text-secondary);
        }

        .override-btn:hover {
            border-color: var(--accent);
            color: var(--text-primary);
        }

        .override-btn.selected {
            background: var(--accent);
            border-color: var(--accent);
            color: white;
        }

        /* Wizard Steps */
        .wizard-steps {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .wizard-step {
            display: flex;
            align-items: flex-start;
            gap: 14px;
            padding: 12px;
            background: var(--bg-elevated);
            border-radius: 12px;
            border: 1px solid var(--border);
        }

        .step-number {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            background: var(--accent);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 0.85rem;
            flex-shrink: 0;
        }

        .step-content {
            flex: 1;
        }

        .step-title {
            font-weight: 600;
            font-size: 0.9rem;
            margin-bottom: 4px;
        }

        .step-desc {
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        /* Tools Grid */
        .wizard-tools-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .wizard-tool {
            background: var(--bg-elevated);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 8px 12px;
            font-size: 0.8rem;
            display: flex;
            align-items: center;
            gap: 6px;
            color: var(--text-secondary);
        }

        .wizard-tool span {
            font-size: 0.9rem;
        }

        /* Wizard Footer */
        .wizard-footer {
            padding: 20px 24px;
            border-top: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: var(--bg-secondary);
        }

        .wizard-actions {
            display: flex;
            gap: 10px;
        }

        /* ==================== WIZARD MODE TOGGLE ==================== */
        .wizard-mode-toggle {
            display: flex;
            gap: 0;
            background: var(--bg-elevated);
            border-radius: 12px;
            padding: 4px;
            margin-bottom: 24px;
            border: 1px solid var(--border);
        }

        .mode-btn {
            flex: 1;
            padding: 12px 16px;
            background: transparent;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            font-size: 0.85rem;
            font-weight: 500;
            color: var(--text-secondary);
            transition: all 0.2s ease;
        }

        .mode-btn:hover {
            color: var(--text-primary);
        }

        .mode-btn.active {
            background: var(--accent-gradient);
            color: white;
            box-shadow: 0 4px 15px rgba(139, 92, 246, 0.3);
        }

        .mode-btn-icon {
            font-size: 1.1rem;
        }

        .mode-hint {
            position: absolute;
            top: -4px;
            right: -4px;
            font-size: 0.8rem;
            animation: hintPulse 1.5s ease-in-out infinite;
        }

        @keyframes hintPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); }
        }

        .mode-btn {
            position: relative;
        }

        /* Orchestrator Configuration Section */
        .orchestrator-config {
            display: none;
            animation: fadeSlideIn 0.3s ease-out;
        }

        .orchestrator-config.active {
            display: block;
        }

        @keyframes fadeSlideIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Workflow Type Selection */
        .workflow-type-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-bottom: 20px;
        }

        @media (max-width: 500px) {
            .workflow-type-grid {
                grid-template-columns: 1fr;
            }
        }

        .workflow-type-card {
            background: var(--bg-elevated);
            border: 2px solid var(--border);
            border-radius: 12px;
            padding: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
        }

        .workflow-type-card:hover {
            border-color: rgba(139, 92, 246, 0.5);
            transform: translateY(-2px);
        }

        .workflow-type-card.selected {
            border-color: var(--accent);
            background: var(--accent-glow);
        }

        .workflow-type-icon {
            font-size: 1.8rem;
            margin-bottom: 8px;
        }

        .workflow-type-name {
            font-weight: 600;
            font-size: 0.9rem;
            margin-bottom: 4px;
        }

        .workflow-type-desc {
            font-size: 0.7rem;
            color: var(--text-secondary);
            line-height: 1.4;
        }

        /* Team Composition */
        .team-composition {
            margin-bottom: 20px;
        }

        .team-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }

        @media (max-width: 500px) {
            .team-grid {
                grid-template-columns: 1fr;
            }
        }

        .team-member-card {
            background: var(--bg-elevated);
            border: 2px solid var(--border);
            border-radius: 12px;
            padding: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .team-member-card:hover {
            border-color: rgba(139, 92, 246, 0.5);
        }

        .team-member-card.selected {
            border-color: var(--accent);
            background: var(--accent-glow);
        }

        .team-member-checkbox {
            width: 20px;
            height: 20px;
            border-radius: 6px;
            border: 2px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            color: transparent;
            flex-shrink: 0;
            transition: all 0.2s ease;
        }

        .team-member-card.selected .team-member-checkbox {
            background: var(--accent);
            border-color: var(--accent);
            color: white;
        }

        .team-member-icon {
            font-size: 1.3rem;
        }

        .team-member-info {
            flex: 1;
            min-width: 0;
        }

        .team-member-name {
            font-weight: 600;
            font-size: 0.85rem;
        }

        .team-member-role {
            font-size: 0.7rem;
            color: var(--text-secondary);
        }

        /* Workflow Preview */
        .workflow-preview {
            background: var(--bg-elevated);
            border: 1px solid var(--border);
            border-radius: 14px;
            padding: 20px;
            margin-top: 16px;
        }

        .workflow-preview-title {
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            margin-bottom: 16px;
            letter-spacing: 0.5px;
        }

        .workflow-diagram {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
        }

        .workflow-mother {
            background: linear-gradient(135deg, #8b5cf6, #7c3aed);
            border-radius: 16px;
            padding: 16px 24px;
            display: flex;
            align-items: center;
            gap: 12px;
            box-shadow: 0 8px 25px rgba(139, 92, 246, 0.3);
        }

        .mother-icon {
            font-size: 1.8rem;
        }

        .mother-info {
            text-align: left;
        }

        .mother-name {
            font-weight: 700;
            font-size: 1rem;
        }

        .mother-role {
            font-size: 0.75rem;
            opacity: 0.9;
        }

        .workflow-connector {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }

        .connector-line {
            width: 2px;
            height: 20px;
            background: var(--accent);
            opacity: 0.5;
        }

        .connector-arrows {
            display: flex;
            gap: 20px;
        }

        .connector-arrow {
            color: var(--accent);
            font-size: 1.2rem;
            opacity: 0.7;
        }

        .workflow-children {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .workflow-child {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 12px 16px;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.2s ease;
        }

        .workflow-child.parallel {
            animation: childPulse 2s ease-in-out infinite;
        }

        .workflow-child.sequential {
            opacity: 0.6;
        }

        .workflow-child.sequential.active {
            opacity: 1;
            border-color: var(--accent);
        }

        @keyframes childPulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(139, 92, 246, 0); }
            50% { box-shadow: 0 0 15px rgba(139, 92, 246, 0.3); }
        }

        .child-icon {
            font-size: 1.2rem;
        }

        .child-name {
            font-size: 0.8rem;
            font-weight: 500;
        }

        /* Single agent section toggle */
        .single-agent-config {
            display: block;
        }

        .single-agent-config.hidden {
            display: none;
        }

        .btn-outline {
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text-primary);
        }

        .btn-outline:hover {
            border-color: var(--accent);
            color: var(--accent);
        }

        .btn-glow {
            box-shadow: 0 4px 20px rgba(139, 92, 246, 0.4);
        }

        .btn-glow:hover {
            box-shadow: 0 6px 30px rgba(139, 92, 246, 0.6);
        }

        /* Quick Actions Grid */
        .quick-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
        }

        .quick-card {
            background: var(--bg-card);
            border-radius: 16px;
            padding: 20px;
            border: 1px solid var(--border);
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
        }

        .quick-card:active {
            transform: scale(0.97);
            background: var(--bg-hover);
        }

        .quick-icon {
            font-size: 1.8rem;
            margin-bottom: 8px;
        }

        .quick-label {
            font-size: 0.85rem;
            font-weight: 500;
            color: var(--text-secondary);
        }

        /* ==================== MEMORY SEARCH ==================== */
        .search-box {
            display: flex;
            gap: 8px;
            background: var(--bg-card);
            border-radius: 12px;
            padding: 8px 12px;
            border: 1px solid var(--border);
        }

        .search-box input {
            flex: 1;
            background: transparent;
            border: none;
            color: var(--text-primary);
            font-size: 0.95rem;
            outline: none;
        }

        .search-box input::placeholder {
            color: var(--text-muted);
        }

        .search-btn {
            background: var(--accent);
            border: none;
            border-radius: 8px;
            padding: 8px 14px;
            cursor: pointer;
            font-size: 1rem;
        }

        .search-results {
            margin-top: 12px;
            max-height: 300px;
            overflow-y: auto;
        }

        .search-result-item {
            background: var(--bg-card);
            border-radius: 10px;
            padding: 12px;
            margin-bottom: 8px;
            border: 1px solid var(--border);
            cursor: pointer;
            transition: background 0.2s;
        }

        .search-result-item:hover {
            background: var(--bg-hover);
        }

        .search-result-type {
            font-size: 0.7rem;
            color: var(--accent);
            text-transform: uppercase;
            font-weight: 600;
        }

        .search-result-title {
            font-weight: 500;
            margin: 4px 0;
            color: var(--text-primary);
        }

        .search-result-snippet {
            font-size: 0.8rem;
            color: var(--text-muted);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* ==================== SYSTEM STATUS ==================== */
        .status-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 8px;
            background: var(--bg-card);
            border-radius: 20px;
            padding: 8px 14px;
            border: 1px solid var(--border);
            font-size: 0.85rem;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--text-muted);
        }

        .status-dot.online {
            background: var(--green);
            box-shadow: 0 0 8px var(--green);
        }

        .status-dot.offline {
            background: var(--red);
        }

        .status-dot.unknown {
            background: var(--yellow);
        }

        .status-name {
            color: var(--text-secondary);
        }

        /* ==================== RECENT AGENTS ==================== */
        .recent-agents-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .recent-agent-item {
            background: var(--bg-card);
            border-radius: 12px;
            padding: 12px 16px;
            border: 1px solid var(--border);
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .recent-agent-item:hover {
            background: var(--bg-hover);
            transform: translateY(-1px);
        }

        .recent-agent-info {
            flex: 1;
            min-width: 0;
        }

        .recent-agent-task {
            font-size: 0.9rem;
            color: var(--text-primary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .recent-agent-meta {
            font-size: 0.75rem;
            color: var(--text-muted);
            margin-top: 4px;
        }

        .recent-agent-status {
            font-size: 0.7rem;
            padding: 4px 10px;
            border-radius: 12px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .recent-agent-status.completed {
            background: rgba(34, 197, 94, 0.15);
            color: var(--green);
        }

        /* ==================== QUICK COMMAND MODAL ==================== */
        .command-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .command-modal.active {
            display: flex;
        }

        .command-box {
            background: var(--bg-elevated);
            border-radius: 16px;
            padding: 20px;
            width: 100%;
            max-width: 500px;
            border: 1px solid var(--border);
        }

        .command-input {
            width: 100%;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 14px;
            color: var(--text-primary);
            font-size: 1rem;
            font-family: 'SF Mono', Monaco, monospace;
            outline: none;
        }

        .command-input:focus {
            border-color: var(--accent);
        }

        .command-suggestions {
            margin-top: 12px;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .command-suggestion {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 8px 12px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .command-suggestion:hover {
            background: var(--accent);
            color: white;
        }

        /* ==================== CHAT VIEW ==================== */
        .chat-view {
            display: flex;
            flex-direction: column;
            height: calc(100vh - 56px); /* viewport minus header */
            position: relative;
        }

        .messages-container {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
            padding-top: 16px;
            padding-bottom: 160px; /* Space for floating input (80px) + gap above nav (12px) + breathing (68px) */
            display: flex;
            flex-direction: column;
            gap: 0;
            align-items: center;
            -webkit-overflow-scrolling: touch;
        }

        /* Mobile improvements for chat */
        @media (max-width: 480px) {
            .messages-container {
                padding: 8px;
                padding-top: 8px;
                padding-bottom: 160px;
            }

            .message {
                padding: 16px 12px;
                font-size: 0.9rem;
            }

            .chat-input-wrapper {
                padding: 6px 8px;
            }

            .input-model-btn {
                padding: 5px 8px;
                font-size: 0.68rem;
            }

            .chat-header {
                padding: 10px 12px;
            }

            .chat-header-title {
                font-size: 0.95rem;
            }
        }

        /* === CLEAN MESSAGE ROWS (Claude-style) === */
        .message {
            max-width: 1000px;
            width: 100%;
            padding: 20px 16px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.06);
            font-size: 0.95rem;
            line-height: 1.6;
            position: relative;
            word-wrap: break-word;
            overflow-wrap: break-word;
            hyphens: auto;
            border-radius: 0;
            background: transparent;
        }

        .msg-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 8px;
        }
        .msg-sender {
            font-size: 0.82rem;
            font-weight: 600;
            color: var(--text-primary);
        }
        .message.assistant .msg-sender {
            color: var(--accent-light);
        }
        .msg-meta {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .msg-model {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            font-size: 0.65rem;
            color: var(--text-muted);
            opacity: 0.8;
        }
        .msg-model .model-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            flex-shrink: 0;
        }
        .msg-time {
            font-size: 0.65rem;
            color: var(--text-muted);
            opacity: 0.6;
        }

        .message.user {
            color: var(--text-primary);
            align-self: center;
        }

        .message.assistant {
            color: var(--text-primary);
            align-self: center;
            padding: 20px 16px;
            overflow: visible;
        }

        /* Streaming cursor  inline blinking caret at end of typed text */
        .streaming-cursor {
            display: inline-block;
            width: 2.5px;
            height: 1.15em;
            background: var(--accent);
            vertical-align: text-bottom;
            animation: blink-cursor 0.6s step-end infinite;
            margin-left: 1px;
            border-radius: 1px;
        }
        @keyframes blink-cursor {
            0%, 100% { opacity: 1; }
            50% { opacity: 0; }
        }

        /* === MESSAGE COPY BUTTON === */
        .msg-actions {
            display: flex;
            justify-content: flex-end;
            gap: 6px;
            margin-top: 8px;
            padding-top: 6px;
            opacity: 0;
            transition: opacity 0.2s ease;
        }
        .message.assistant:hover .msg-actions {
            opacity: 1;
        }
        .msg-copy-btn {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            background: rgba(255, 255, 255, 0.06);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: var(--text-muted);
            font-size: 0.72rem;
            padding: 4px 10px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .msg-copy-btn:hover {
            background: rgba(139, 92, 246, 0.15);
            border-color: rgba(139, 92, 246, 0.3);
            color: var(--text-secondary);
        }
        .msg-copy-btn.copied {
            background: rgba(34, 197, 94, 0.15);
            border-color: rgba(34, 197, 94, 0.3);
            color: #22c55e;
        }
        .msg-copy-btn svg {
            width: 13px;
            height: 13px;
            fill: none;
            stroke: currentColor;
            stroke-width: 2;
            stroke-linecap: round;
            stroke-linejoin: round;
        }

        /* === MESSAGE SPEAK BUTTON === */
        .msg-speak-btn {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            background: rgba(255, 255, 255, 0.06);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: var(--text-muted);
            font-size: 0.72rem;
            padding: 4px 10px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }
        .msg-speak-btn:hover {
            background: rgba(139, 92, 246, 0.15);
            border-color: rgba(139, 92, 246, 0.3);
            color: var(--text-secondary);
        }
        .msg-speak-btn svg {
            width: 13px;
            height: 13px;
            flex-shrink: 0;
        }
        .msg-speak-btn.speaking {
            background: rgba(139, 92, 246, 0.2);
            border-color: rgba(139, 92, 246, 0.4);
            color: var(--accent-light);
        }
        .msg-speak-btn.speaking svg {
            animation: speak-btn-pulse 1s ease-in-out infinite;
        }
        .msg-speak-btn.loading {
            pointer-events: none;
            color: transparent;
        }
        .msg-speak-btn.loading::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 12px;
            height: 12px;
            border: 2px solid rgba(139, 92, 246, 0.3);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin-loader 0.6s linear infinite;
        }
        @keyframes speak-btn-pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.15); opacity: 0.7; }
        }

        /* === CHAT CONTEXT MENU === */
        .chat-context-menu {
            position: fixed;
            background: rgba(20, 20, 40, 0.92);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(139, 92, 246, 0.25);
            border-radius: 12px;
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.55), 0 0 0 1px rgba(139, 92, 246, 0.1);
            z-index: 10001;
            min-width: 220px;
            padding: 6px 0;
            animation: popupFadeIn 0.15s ease-out;
        }
        .chat-context-menu-section {
            border-top: 1px solid rgba(255, 255, 255, 0.06);
            margin: 4px 0;
        }
        .chat-context-menu-item {
            padding: 9px 14px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 0.82rem;
            color: var(--text-primary);
            transition: background 0.15s;
            white-space: nowrap;
        }
        .chat-context-menu-item:hover {
            background: rgba(139, 92, 246, 0.15);
        }
        .chat-context-menu-item .ctx-icon {
            width: 18px;
            flex-shrink: 0;
            text-align: center;
            font-size: 14px;
            pointer-events: none;
        }
        .chat-context-menu-item .ctx-label {
            flex: 1;
            pointer-events: none;
        }
        .chat-context-menu-item .ctx-hint {
            font-size: 0.7rem;
            color: var(--text-muted);
            margin-left: auto;
            pointer-events: none;
        }
        /* Context menu toggle switch */
        .ctx-toggle {
            width: 34px;
            height: 18px;
            border-radius: 9px;
            background: rgba(255, 255, 255, 0.12);
            position: relative;
            flex-shrink: 0;
            margin-left: auto;
            transition: background 0.2s ease;
            cursor: pointer;
        }
        .ctx-toggle::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.5);
            transition: all 0.2s ease;
        }
        .ctx-toggle.active {
            background: var(--accent);
        }
        .ctx-toggle.active::after {
            left: 18px;
            background: white;
        }

        /* Launch button on agent/specops draft messages */
        .msg-launch-btn {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            background: rgba(34, 197, 94, 0.12);
            border: 1px solid rgba(34, 197, 94, 0.3);
            color: #22c55e;
            font-size: 0.75rem;
            font-weight: 600;
            padding: 5px 12px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .msg-launch-btn:hover {
            background: rgba(34, 197, 94, 0.2);
            border-color: rgba(34, 197, 94, 0.5);
            box-shadow: 0 0 12px rgba(34, 197, 94, 0.15);
        }
        .msg-launch-btn svg {
            width: 14px;
            height: 14px;
            fill: none;
            stroke: currentColor;
            stroke-width: 2;
        }

        /* ==================== CONTEXT SYSTEM BUBBLE ==================== */
        .message.context-system {
            background: rgba(12, 12, 25, 0.85);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border: 1px solid rgba(99, 102, 241, 0.35);
            border-left: 3px solid rgba(99, 102, 241, 0.7);
            color: var(--text-primary);
            align-self: stretch;
            border-radius: 14px;
            box-shadow: 0 4px 24px rgba(0, 0, 0, 0.3), 0 0 20px rgba(99, 102, 241, 0.08);
            padding: 0;
            overflow: hidden;
            animation: contextBubbleIn 0.45s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
            margin-bottom: 8px;
        }
        @keyframes contextBubbleIn {
            from { opacity: 0; transform: translateY(12px) scale(0.96); }
            to { opacity: 1; transform: translateY(0) scale(1); }
        }
        .message.context-system.dismissing {
            animation: contextBubbleOut 0.3s ease forwards;
            pointer-events: none;
        }
        @keyframes contextBubbleOut {
            from { opacity: 1; transform: translateY(0) scale(1); }
            to { opacity: 0; transform: translateY(-8px) scale(0.96); }
        }
        .context-system-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 14px;
            border-bottom: 1px solid rgba(99, 102, 241, 0.15);
            background: rgba(99, 102, 241, 0.06);
        }
        .context-system-label {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.78rem;
            font-weight: 600;
            color: rgba(129, 140, 248, 0.9);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .context-system-label svg {
            width: 14px;
            height: 14px;
            fill: currentColor;
            opacity: 0.8;
        }
        .context-system-dismiss {
            background: none;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            font-size: 1.1rem;
            padding: 2px 6px;
            border-radius: 6px;
            transition: all 0.2s ease;
            line-height: 1;
        }
        .context-system-dismiss:hover {
            background: rgba(255, 255, 255, 0.08);
            color: var(--text-primary);
        }
        .context-system-body {
            padding: 12px 14px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .context-project-name {
            font-size: 0.95rem;
            font-weight: 600;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .context-project-name .ctx-icon {
            font-size: 1.1rem;
        }
        .context-field {
            display: flex;
            flex-direction: column;
            gap: 3px;
        }
        .context-field-label {
            font-size: 0.68rem;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.4px;
        }
        .context-field-value {
            font-size: 0.82rem;
            color: var(--text-secondary);
            line-height: 1.45;
        }
        .context-field.next-action {
            padding: 8px 10px;
            background: rgba(99, 102, 241, 0.06);
            border-radius: 8px;
            border-left: 2px solid rgba(99, 102, 241, 0.4);
        }
        .context-field.next-action .context-field-value {
            color: var(--text-primary);
            font-weight: 500;
        }
        .context-files-row {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
        }
        .context-file-pill {
            font-family: 'SF Mono', 'Fira Code', monospace;
            font-size: 0.7rem;
            padding: 3px 8px;
            border-radius: 6px;
            background: rgba(99, 102, 241, 0.1);
            border: 1px solid rgba(99, 102, 241, 0.2);
            color: rgba(165, 180, 252, 0.9);
            white-space: nowrap;
            max-width: 200px;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* === ASSISTANT CARD STRUCTURE (legacy compat  kept for saveChatHistory) === */
        .assistant-card-header { display: none; }
        .assistant-card-meta { display: none; }
        .assistant-card-timestamp { display: none; }
        .assistant-card-model { display: none; }
        .assistant-card-body { padding: 0; }
        .assistant-card-actions { display: none; }

        .message.assistant pre {
            background: var(--bg-elevated);
            padding: 12px;
            border-radius: 8px;
            overflow-x: auto;
            font-size: 0.8rem;
            margin: 10px 0;
            border: 1px solid var(--border);
            max-width: 100%;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .message.assistant code {
            font-family: 'SF Mono', Monaco, 'Fira Code', monospace;
        }

        /* === MARKDOWN RENDERING IN ASSISTANT MESSAGES === */
        .message.assistant .message-content-wrapper h1,
        .message.assistant .message-content-wrapper h2,
        .message.assistant .message-content-wrapper h3 {
            margin: 16px 0 8px 0;
            line-height: 1.3;
            font-weight: 600;
        }
        .message.assistant .message-content-wrapper h1 { font-size: 1.25rem; color: var(--text-primary); }
        .message.assistant .message-content-wrapper h2 { font-size: 1.1rem; color: var(--accent-light); }
        .message.assistant .message-content-wrapper h3 { font-size: 0.95rem; color: var(--text-secondary); }
        .message.assistant .message-content-wrapper h1:first-child,
        .message.assistant .message-content-wrapper h2:first-child,
        .message.assistant .message-content-wrapper h3:first-child { margin-top: 0; }

        .message.assistant .message-content-wrapper p {
            margin: 8px 0;
        }
        .message.assistant .message-content-wrapper p:first-child { margin-top: 0; }
        .message.assistant .message-content-wrapper p:last-child { margin-bottom: 0; }

        .message.assistant .message-content-wrapper ul,
        .message.assistant .message-content-wrapper ol {
            margin: 8px 0;
            padding-left: 24px;
        }
        .message.assistant .message-content-wrapper li {
            margin: 4px 0;
        }
        .message.assistant .message-content-wrapper li > p {
            margin: 2px 0;
        }

        .message.assistant .message-content-wrapper blockquote {
            margin: 10px 0;
            padding: 8px 14px;
            border-left: 3px solid var(--accent);
            background: rgba(139, 92, 246, 0.08);
            border-radius: 0 8px 8px 0;
            color: var(--text-secondary);
        }

        .message.assistant .message-content-wrapper table {
            width: 100%;
            border-collapse: collapse;
            margin: 10px 0;
            font-size: 0.85rem;
        }
        .message.assistant .message-content-wrapper th {
            background: rgba(139, 92, 246, 0.15);
            color: var(--accent-light);
            padding: 8px 12px;
            text-align: left;
            border-bottom: 2px solid var(--border);
        }
        .message.assistant .message-content-wrapper td {
            padding: 6px 12px;
            border-bottom: 1px solid var(--border);
        }
        .message.assistant .message-content-wrapper tr:hover td {
            background: rgba(139, 92, 246, 0.05);
        }

        .message.assistant .message-content-wrapper code:not(pre code) {
            background: rgba(139, 92, 246, 0.15);
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.85em;
        }

        .message.assistant .message-content-wrapper hr {
            border: none;
            border-top: 1px solid var(--border);
            margin: 12px 0;
        }

        .message.assistant .message-content-wrapper a {
            color: var(--accent-light);
            text-decoration: none;
            border-bottom: 1px solid rgba(139, 92, 246, 0.3);
            transition: border-color 0.2s ease;
        }
        .message.assistant .message-content-wrapper a:hover {
            border-bottom-color: var(--accent-light);
        }

        /* Tool/system messages */
        .message.tool {
            background: rgba(139, 92, 246, 0.1);
            border: 1px solid rgba(139, 92, 246, 0.2);
            padding: 10px 18px;
            font-size: 0.85rem;
            color: var(--text-secondary);
            align-self: center;
            border-radius: 20px;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: opacity 0.3s ease;
        }

        .message.tool.done {
            opacity: 0.5;
        }

        .message.tool.done .tool-spinner {
            display: none;
        }

        .message.tool.done::before {
            content: '';
            color: var(--green);
            margin-right: 4px;
        }

        .tool-spinner {
            width: 14px;
            height: 14px;
            border: 2px solid var(--border);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        /* === TOOL TRACKER (Hidden in Claude-style redesign) === */
        .tool-tracker {
            display: none !important;
        }
        .tool-tracker-bar {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            cursor: pointer;
            transition: background 0.15s ease;
            user-select: none;
        }
        .tool-tracker-bar:hover {
            background: rgba(139, 92, 246, 0.06);
        }
        .tool-tracker-spinner {
            width: 12px;
            height: 12px;
            border: 2px solid var(--border);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            flex-shrink: 0;
        }
        .tool-tracker-spinner.done {
            display: none;
        }
        .tool-tracker-count {
            font-size: 0.75rem;
            color: var(--text-secondary);
            font-weight: 500;
        }
        .tool-tracker-current {
            font-size: 0.72rem;
            color: var(--text-muted);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            flex: 1;
        }
        .tool-tracker-chevron {
            width: 14px;
            height: 14px;
            color: var(--text-muted);
            transition: transform 0.2s ease;
            flex-shrink: 0;
        }
        .tool-tracker-bar.expanded .tool-tracker-chevron {
            transform: rotate(180deg);
        }
        .tool-tracker-list {
            display: none;
            padding: 0 16px 8px;
        }
        .tool-tracker-bar.expanded + .tool-tracker-list {
            display: block;
        }
        .tool-tracker-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 3px 0;
            font-size: 0.72rem;
            color: var(--text-muted);
        }
        .tool-tracker-item .tt-icon {
            width: 14px;
            text-align: center;
            flex-shrink: 0;
        }
        .tool-tracker-item .tt-icon.running {
            color: var(--accent-light);
        }
        .tool-tracker-item .tt-icon.done {
            color: var(--green);
        }
        .tool-tracker-item .tt-name {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .tool-tracker-done-check {
            color: var(--green);
            font-size: 0.75rem;
            margin-left: 4px;
        }

        /* === AGENT CHAIN NAV === */
        .agent-chain-nav {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 8px 14px;
            margin-bottom: 12px;
            background: rgba(139, 92, 246, 0.06);
            border: 1px solid rgba(139, 92, 246, 0.15);
            border-radius: 10px;
            font-size: 13px;
            flex-wrap: wrap;
        }
        .chain-nav-item {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 4px 10px;
            border-radius: 6px;
            cursor: pointer;
            color: var(--accent-light);
            transition: all 0.2s;
        }
        .chain-nav-item:hover {
            background: rgba(139, 92, 246, 0.15);
            color: #fff;
        }
        .chain-nav-item.current {
            background: rgba(139, 92, 246, 0.2);
            color: #fff;
            font-weight: 600;
            cursor: default;
        }
        .chain-nav-separator {
            color: var(--text-muted);
            font-size: 11px;
        }
        .rerun-link {
            text-align: center;
            margin-top: 8px;
            font-size: 12px;
            color: var(--text-muted);
            cursor: pointer;
            transition: color 0.2s;
        }
        .rerun-link:hover {
            color: var(--accent-light);
        }

        /* === GROUP EDITOR === */
        .group-editor-overlay {
            display: none;
            position: fixed;
            inset: 0;
            z-index: 10000;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            align-items: center;
            justify-content: center;
        }
        .group-editor-overlay.active {
            display: flex;
            animation: modalOverlayIn 0.25s ease-out;
        }
        .group-editor-modal {
            width: 92vw;
            max-width: 1100px;
            max-height: 85vh;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 16px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        }
        .group-editor-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px 20px;
            border-bottom: 1px solid var(--border);
        }
        .group-editor-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text-primary);
        }
        .group-editor-body {
            flex: 1;
            overflow-y: auto;
            padding: 16px 20px;
            display: flex;
            flex-direction: column;
            gap: 14px;
        }
        .group-zone {
            border: 2px dashed rgba(139, 92, 246, 0.2);
            border-radius: 12px;
            background: rgba(139, 92, 246, 0.03);
            padding: 12px 14px;
            min-height: 70px;
            transition: all 0.2s;
        }
        .group-zone.drag-over {
            border-color: var(--accent);
            background: rgba(139, 92, 246, 0.1);
            box-shadow: 0 0 20px rgba(139, 92, 246, 0.15);
        }
        .group-zone-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }
        .group-zone-name {
            font-weight: 600;
            font-size: 0.95rem;
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
        }
        .group-zone-name-input {
            background: transparent;
            border: 1px solid var(--accent);
            border-radius: 6px;
            padding: 2px 8px;
            color: var(--text-primary);
            font-weight: 600;
            font-size: 0.95rem;
            font-family: 'JetBrains Mono', monospace;
            outline: none;
            width: 200px;
        }
        .group-zone-count {
            font-size: 0.8rem;
            color: var(--text-muted);
        }
        .group-zone-actions {
            margin-left: auto;
            display: flex;
            gap: 6px;
        }
        .group-zone-action-btn {
            background: transparent;
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 6px;
            color: var(--text-muted);
            cursor: pointer;
            padding: 4px 8px;
            font-size: 0.75rem;
            transition: all 0.2s;
        }
        .group-zone-action-btn:hover {
            background: rgba(139, 92, 246, 0.15);
            color: var(--accent-light);
            border-color: rgba(139, 92, 246, 0.3);
        }
        .group-zone-action-btn.danger:hover {
            background: rgba(239, 68, 68, 0.15);
            color: var(--red);
            border-color: rgba(239, 68, 68, 0.3);
        }
        .group-zone-agents {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            min-height: 36px;
        }
        .group-agent-pill {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            border-radius: 8px;
            background: var(--bg-primary);
            border: 1px solid var(--border);
            cursor: grab;
            font-size: 0.82rem;
            color: var(--text-primary);
            transition: all 0.15s;
            user-select: none;
        }
        .group-agent-pill:hover {
            border-color: var(--accent);
            background: rgba(139, 92, 246, 0.08);
        }
        .group-agent-pill:active {
            cursor: grabbing;
        }
        .group-agent-pill.dragging {
            opacity: 0.4;
            transform: scale(0.95);
        }
        .group-agent-pill .pill-status {
            width: 7px;
            height: 7px;
            border-radius: 50%;
            flex-shrink: 0;
        }
        .group-agent-pill .pill-status.running { background: var(--accent); box-shadow: 0 0 6px var(--accent); }
        .group-agent-pill .pill-status.completed { background: var(--green); }
        .group-agent-pill .pill-status.failed { background: var(--red); }
        .group-agent-pill .pill-status.queued { background: var(--text-muted); }
        .group-zone-empty {
            color: var(--text-muted);
            font-size: 0.8rem;
            font-style: italic;
            padding: 8px;
        }
        .group-agent-pill .pill-star {
            cursor: pointer;
            font-size: 0.75rem;
            opacity: 0.3;
            transition: all 0.15s;
            margin-left: 2px;
        }
        .group-agent-pill .pill-star:hover {
            opacity: 0.7;
            transform: scale(1.2);
        }
        .group-agent-pill .pill-star.starred {
            opacity: 1;
            color: #fbbf24;
            text-shadow: 0 0 6px rgba(251, 191, 36, 0.4);
        }
        .group-clear-section {
            margin-top: 8px;
            padding-top: 12px;
            border-top: 1px solid rgba(239, 68, 68, 0.15);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        .group-clear-btn {
            background: transparent;
            border: 1px solid rgba(239, 68, 68, 0.3);
            border-radius: 8px;
            color: var(--text-muted);
            cursor: pointer;
            padding: 8px 16px;
            font-size: 0.82rem;
            transition: all 0.2s;
        }
        .group-clear-btn:hover {
            background: rgba(239, 68, 68, 0.12);
            color: var(--red);
            border-color: var(--red);
        }
        .group-clear-hint {
            font-size: 0.75rem;
            color: var(--text-muted);
            font-style: italic;
        }
        .group-editor-footer {
            padding: 14px 20px;
            border-top: 1px solid var(--border);
            display: flex;
            gap: 10px;
            justify-content: space-between;
        }
        .group-new-btn {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 8px 16px;
            border-radius: 8px;
            border: 1px dashed rgba(139, 92, 246, 0.4);
            background: transparent;
            color: var(--accent-light);
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.2s;
        }
        .group-new-btn:hover {
            background: rgba(139, 92, 246, 0.1);
            border-color: var(--accent);
        }

        /* === AGENT LINK BAR === */
        .agent-link-bar {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            margin-top: 6px;
            background: rgba(139, 92, 246, 0.08);
            border: 1px solid rgba(139, 92, 246, 0.25);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .agent-link-bar:hover {
            background: rgba(139, 92, 246, 0.15);
            border-color: rgba(139, 92, 246, 0.4);
        }
        .agent-link-bar.done { border-color: rgba(34, 197, 94, 0.3); }
        .agent-link-bar.failed { border-color: rgba(239, 68, 68, 0.3); }
        .agent-link-dot {
            font-size: 10px;
        }
        .agent-link-dot.running { color: #a78bfa; animation: pulse 1.5s ease-in-out infinite; }
        .agent-link-dot.done { color: #22c55e; }
        .agent-link-dot.failed { color: #ef4444; }
        .agent-link-name {
            flex: 1;
            font-size: 13px;
            color: rgba(255, 255, 255, 0.8);
            font-weight: 500;
        }
        .agent-link-chevron {
            opacity: 0.5;
            color: rgba(255, 255, 255, 0.6);
        }

        /* === DIRECTIVE WORKING CARD === */
        .directive-agent-tag {
            font-family: 'Space Mono', monospace;
            font-size: 0.6rem;
            color: #a78bfa;
            background: rgba(139, 92, 246, 0.12);
            padding: 2px 8px;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
            margin-left: 6px;
        }
        .directive-agent-tag:hover {
            background: rgba(139, 92, 246, 0.25);
        }

        /* === THINKING ORB === */
        .thinking-orb-container {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 4px 0;
        }
        .thinking-orb-dot {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: radial-gradient(circle at 35% 35%, #a78bfa, #7c3aed 50%, #4c1d95);
            animation: orbPulse 1.5s ease-in-out infinite;
            flex-shrink: 0;
        }
        .thinking-orb-label {
            font-size: 0.82rem;
            color: var(--text-muted);
            font-style: italic;
        }
        @keyframes orbPulse {
            0%, 100% {
                transform: scale(1);
                box-shadow: 0 0 8px rgba(167, 139, 250, 0.4);
            }
            50% {
                transform: scale(1.15);
                box-shadow: 0 0 20px rgba(167, 139, 250, 0.7), 0 0 40px rgba(124, 58, 237, 0.3);
            }
        }

        /* === AI THINKING ANIMATION (Orbital Dots) === */
        .thinking-indicator {
            display: flex;
            gap: 8px;
            padding: 16px 20px;
            align-items: center;
        }

        .thinking-orb {
            width: 40px;
            height: 40px;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .thinking-dot {
            position: absolute;
            width: 8px;
            height: 8px;
            background: var(--accent-gradient);
            border-radius: 50%;
            box-shadow: 0 0 10px var(--glow-medium);
        }

        .thinking-dot:nth-child(1) {
            animation: orbit 1.5s linear infinite;
        }

        .thinking-dot:nth-child(2) {
            animation: orbit 1.5s linear infinite;
            animation-delay: -0.5s;
        }

        .thinking-dot:nth-child(3) {
            animation: orbit 1.5s linear infinite;
            animation-delay: -1s;
        }

        @keyframes orbit {
            0% {
                transform: rotate(0deg) translateX(16px) rotate(0deg);
                opacity: 1;
            }
            50% {
                opacity: 0.5;
            }
            100% {
                transform: rotate(360deg) translateX(16px) rotate(-360deg);
                opacity: 1;
            }
        }

        .thinking-text {
            color: var(--text-secondary);
            font-size: 0.9rem;
            margin-left: 8px;
        }

        /* Chat Header - Sticky at top */
        .chat-header {
            position: fixed;
            top: 56px; /* Below main header */
            left: 0;
            right: 0;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 16px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border);
            flex-shrink: 0;
            z-index: 400;
        }

        /* Scroll to bottom button */
        .scroll-bottom-btn {
            position: fixed;
            bottom: 180px;
            right: 24px;
            width: 52px;
            height: 52px;
            border-radius: 50%;
            background: linear-gradient(135deg, #8b5cf6, #6366f1);
            border: 3px solid rgba(255,255,255,0.4);
            color: white;
            font-size: 1.6rem;
            font-weight: bold;
            cursor: pointer;
            display: none; /* Hidden by default, shown via JS in chat view */
            align-items: center;
            justify-content: center;
            box-shadow: 0 6px 24px rgba(139, 92, 246, 0.6);
            z-index: 9999;
            transition: opacity 0.2s ease, transform 0.2s ease;
        }

        .scroll-bottom-btn.at-bottom {
            opacity: 0.3;
            transform: scale(0.9);
        }

        .scroll-bottom-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 8px 28px rgba(139, 92, 246, 0.7);
        }

        .scroll-bottom-btn:active {
            transform: scale(0.95);
        }

        body.keyboard-open .scroll-bottom-btn {
            bottom: 100px;
        }

        /* Floating Chat Actions Menu */
        .chat-fab-container {
            position: fixed;
            top: 70px;
            right: 16px;
            z-index: 500;
            opacity: 0;
            transform: scale(0.8);
            pointer-events: none;
            transition: opacity 0.25s ease 0.1s, transform 0.25s ease 0.1s;
        }
        .chat-fab-container.visible {
            opacity: 1;
            transform: scale(1);
            pointer-events: auto;
        }

        .chat-fab-btn {
            width: 44px;
            height: 44px;
            border-radius: 12px;
            background: var(--bg-elevated);
            border: 1px solid var(--border);
            color: var(--text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .chat-fab-btn:hover {
            background: var(--bg-hover);
            color: var(--accent);
            border-color: var(--accent);
            transform: scale(1.05);
        }

        .chat-fab-btn.open {
            background: var(--accent);
            color: white;
            border-color: var(--accent);
        }

        .chat-fab-menu {
            position: absolute;
            top: 52px;
            right: 0;
            background: var(--bg-elevated);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 8px;
            opacity: 0;
            visibility: hidden;
            transform: translateY(-10px) scale(0.95);
            transition: all 0.2s ease;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
            min-width: 180px;
        }

        .chat-fab-menu.open {
            opacity: 1;
            visibility: visible;
            transform: translateY(0) scale(1);
        }

        .chat-fab-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 14px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.15s ease;
            color: var(--text-secondary);
            font-size: 0.9rem;
            border: none;
            background: transparent;
            width: 100%;
            text-align: left;
        }

        .chat-fab-item:hover {
            background: var(--bg-hover);
            color: var(--text-primary);
        }

        .chat-fab-item svg {
            flex-shrink: 0;
        }

        .chat-fab-item.danger:hover {
            background: rgba(239, 68, 68, 0.1);
            color: var(--red);
        }

        .chat-header-title {
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 600;
            font-size: 1rem;
        }

        .chat-header-icon {
            font-size: 1.2rem;
        }

        .chat-header-actions {
            display: flex;
            gap: 8px;
        }

        .chat-action-btn {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 8px 12px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s ease;
        }

        .chat-action-btn:hover {
            background: var(--bg-hover);
            border-color: var(--border-light);
        }

        .chat-action-btn:active {
            transform: scale(0.95);
        }

        /* === MODEL SELECTOR === */
        .model-selector-bar {
            position: fixed;
            top: 56px;
            left: 0;
            right: 0;
            display: flex !important;
            align-items: center;
            justify-content: center;
            padding: 8px 16px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border);
            z-index: 400;
            transform: translateY(-100%);
            opacity: 0;
            pointer-events: none;
            transition: transform 0.3s ease, opacity 0.3s ease;
        }

        .model-selector-bar.visible {
            transform: translateY(0);
            opacity: 1;
            pointer-events: auto;
        }

        .model-selector-wrapper {
            position: relative;
            display: inline-flex;
            align-items: center;
        }

        .model-selector-btn {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 14px;
            background: var(--bg-elevated);
            border: 1px solid var(--border);
            border-radius: 10px;
            color: var(--text-primary);
            font-size: 0.85rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: inherit;
        }

        .model-selector-btn:hover {
            background: var(--bg-hover);
            border-color: var(--glass-border-hover);
            box-shadow: 0 0 16px var(--glow-subtle);
        }

        .model-selector-btn .model-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .model-selector-btn .model-dot.opus { background: #a78bfa; box-shadow: 0 0 6px rgba(167, 139, 250, 0.5); }
        .model-selector-btn .model-dot.sonnet46 { background: #818cf8; box-shadow: 0 0 6px rgba(129, 140, 248, 0.5); }
        .model-selector-btn .model-dot.sonnet { background: #6366f1; box-shadow: 0 0 6px rgba(99, 102, 241, 0.5); }
        .model-selector-btn .model-dot.haiku { background: #22d3ee; box-shadow: 0 0 6px rgba(34, 211, 238, 0.5); }

        .model-selector-btn .chevron-icon {
            transition: transform 0.2s ease;
            opacity: 0.5;
        }

        .model-selector-btn.open .chevron-icon {
            transform: rotate(180deg);
        }

        .model-dropdown {
            position: absolute;
            top: calc(100% + 6px);
            left: 50%;
            transform: translateX(-50%) scale(0.95);
            min-width: 260px;
            background: var(--bg-elevated);
            border: 1px solid var(--glass-border);
            border-radius: 14px;
            padding: 6px;
            opacity: 0;
            visibility: hidden;
            transition: all 0.2s var(--ease-out-expo);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5), 0 0 24px var(--glow-subtle);
            z-index: 500;
        }

        .model-dropdown.open {
            opacity: 1;
            visibility: visible;
            transform: translateX(-50%) scale(1);
        }

        .model-option {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 14px;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.15s ease;
            border: none;
            background: transparent;
            width: 100%;
            text-align: left;
            font-family: inherit;
            color: var(--text-secondary);
        }

        .model-option:hover {
            background: var(--bg-hover);
            color: var(--text-primary);
        }

        .model-option.selected {
            background: rgba(139, 92, 246, 0.1);
            color: var(--text-primary);
            border: 1px solid var(--glass-border);
        }

        .model-option .model-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            flex-shrink: 0;
        }
        .model-dot.opus { background: #a78bfa; box-shadow: 0 0 6px rgba(167, 139, 250, 0.5); }
        .model-dot.sonnet46 { background: #818cf8; box-shadow: 0 0 6px rgba(129, 140, 248, 0.5); }
        .model-dot.sonnet { background: #6366f1; box-shadow: 0 0 6px rgba(99, 102, 241, 0.5); }
        .model-dot.haiku { background: #22d3ee; box-shadow: 0 0 6px rgba(34, 211, 238, 0.5); }

        .model-option .model-info {
            flex: 1;
            min-width: 0;
        }

        .model-option .model-name {
            font-size: 0.9rem;
            font-weight: 500;
            color: inherit;
        }

        .model-option .model-desc {
            font-size: 0.7rem;
            color: var(--text-muted);
            margin-top: 2px;
        }

        .model-option .model-check {
            opacity: 0;
            color: var(--accent);
            flex-shrink: 0;
        }

        .model-option.selected .model-check {
            opacity: 1;
        }

        @media (max-width: 600px) {
            .model-dropdown {
                min-width: 220px;
            }
            .model-selector-btn {
                font-size: 0.8rem;
                padding: 5px 10px;
            }
        }

        /* === FLOATING CHAT INPUT (Claude-style) === */
        .chat-input-area {
            position: fixed;
            bottom: calc(var(--nav-height) + var(--safe-bottom) + 12px);
            left: 0;
            right: 0;
            margin-left: auto;
            margin-right: auto;
            max-width: 1000px;
            width: calc(100% - 32px);
            z-index: 500;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 24px;
            box-shadow: 0 4px 24px rgba(0, 0, 0, 0.35), 0 0 0 1px rgba(139, 92, 246, 0.06);
            transition: opacity 0.15s ease, box-shadow 0.2s ease;
            overflow: visible;
            display: none; /* Hidden by default, shown by _switchViewCore */
        }

        /* When keyboard is open on mobile */
        @supports (padding-bottom: env(safe-area-inset-bottom)) {
            .chat-input-area {
                padding-bottom: env(safe-area-inset-bottom);
            }
        }

        /* Quick action pills  hidden in new design */
        .quick-action-pills {
            display: none;
        }

        .chat-input-wrapper {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            transition: all 0.3s var(--ease-out-expo);
        }

        .chat-input-wrapper:focus-within {
            background: rgba(139, 92, 246, 0.03);
        }

        /* Inline model selector in input bar */
        .input-model-selector {
            position: relative;
            flex-shrink: 0;
        }
        .input-model-btn {
            display: flex;
            align-items: center;
            gap: 5px;
            padding: 6px 10px;
            border-radius: 10px;
            border: 1px solid var(--border);
            background: transparent;
            color: var(--text-secondary);
            font-size: 0.72rem;
            font-family: inherit;
            cursor: pointer;
            transition: all 0.15s ease;
            white-space: nowrap;
        }
        .input-model-btn:hover {
            border-color: var(--accent);
            background: rgba(139, 92, 246, 0.08);
        }
        .input-model-btn .model-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
        }
        .input-model-btn .chevron-icon {
            width: 10px;
            height: 10px;
            transition: transform 0.2s ease;
        }
        .input-model-btn.open .chevron-icon {
            transform: rotate(180deg);
        }
        .input-model-dropdown {
            position: absolute;
            bottom: calc(100% + 8px);
            left: 0;
            min-width: 240px;
            background: var(--bg-elevated);
            border: 1px solid var(--glass-border);
            border-radius: 14px;
            padding: 6px;
            opacity: 0;
            visibility: hidden;
            transform: translateY(4px);
            transition: all 0.2s var(--ease-out-expo);
            box-shadow: 0 -8px 32px rgba(0, 0, 0, 0.5), 0 0 24px var(--glow-subtle);
            z-index: 1100;
        }
        .input-model-dropdown.open {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        .attach-btn {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border: none;
            background: transparent;
            color: var(--text-muted);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s ease;
            flex-shrink: 0;
        }
        .attach-btn:hover {
            color: var(--accent-light);
            background: rgba(139, 92, 246, 0.1);
        }

        .chat-input {
            flex: 1;
            background: transparent;
            border: none;
            color: var(--text-primary);
            font-size: 1rem;
            padding: 12px 16px;
            outline: none;
            resize: none;
            min-height: 48px;
            max-height: 120px;
            font-family: inherit;
        }

        .chat-input::placeholder {
            color: var(--text-muted);
        }
        .chat-view.active.split-mode .chat-input {
            display: none !important;
        }
        .chat-view.active.split-mode .chat-input-wrapper {
            justify-content: space-between;
        }

        .input-actions {
            display: flex;
            gap: 8px;
        }

        .send-btn {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s var(--ease-out-expo);
            flex-shrink: 0;
        }

        /* Layout Toggle Button */
        .layout-toggle-btn {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            border: 1px solid var(--border);
            background: var(--glass-bg);
            color: var(--text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s var(--ease-out-expo);
            flex-shrink: 0;
        }
        .layout-toggle-btn:hover {
            background: var(--bg-hover);
            color: var(--text-primary);
        }
        .layout-toggle-btn.active {
            background: rgba(139, 92, 246, 0.15);
            color: var(--accent-light);
            border-color: var(--accent);
            box-shadow: 0 0 12px var(--glow-subtle);
        }

        /* Split View Layout */
        .split-left-panel {
            display: none;
            flex-direction: column;
            background: var(--bg-secondary);
            border-right: 1px solid var(--border);
            overflow: hidden;
            transition: opacity 0.25s ease 0.1s;
        }
        .chat-view.active.split-mode .split-left-panel { opacity: 1; }
        .chat-view:not(.split-mode) .split-left-panel { opacity: 0; }

        .chat-view.active.split-mode {
            display: grid !important;
            grid-template-columns: 40% 60%;
            grid-template-rows: 1fr auto;
            grid-template-areas:
                "left-panel messages"
                "input      messages";
            flex-direction: unset !important;
            /* Fill exactly between header padding-top and nav padding-bottom on main-content */
            height: calc(100vh - 56px - var(--nav-height, 70px) - var(--safe-bottom, 0px)) !important;
            max-height: calc(100vh - 56px - var(--nav-height, 70px) - var(--safe-bottom, 0px)) !important;
            overflow: hidden;
        }
        .chat-view.active.split-mode .split-left-panel {
            grid-area: left-panel;
            display: flex;
            overflow: hidden;
            min-height: 0;
        }
        .chat-view.active.split-mode .messages-container {
            grid-area: messages;
            grid-row: 1 / -1;
            padding-bottom: 24px !important;
            overflow-y: auto;
            min-height: 0;
        }
        .chat-view.active.split-mode .chat-input-area {
            grid-area: input;
            position: relative !important;
            bottom: unset !important;
            left: unset !important;
            right: unset !important;
            margin: 0 !important;
            max-width: unset !important;
            width: 100% !important;
            z-index: auto;
            border-radius: 0;
            border-top: 1px solid var(--border);
            box-shadow: none;
        }

        /* Split Panel Internals */
        .split-left-tabs {
            display: flex;
            border-bottom: 1px solid var(--border);
            flex-shrink: 0;
            padding: 0 8px;
        }
        .split-tab {
            flex: 1;
            padding: 12px 16px;
            background: transparent;
            border: none;
            border-bottom: 2px solid transparent;
            color: var(--text-muted);
            font-size: 0.85rem;
            font-family: inherit;
            cursor: pointer;
            transition: all 0.15s ease;
        }
        .split-tab:hover { color: var(--text-secondary); }
        .split-tab.active {
            color: var(--accent-light);
            border-bottom-color: var(--accent);
        }
        .split-tab-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 12px;
            overflow-y: auto;
            min-height: 0;
        }
        .split-notepad, .split-compose {
            flex: 1;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 12px;
            color: var(--text-primary);
            font-size: 0.9rem;
            font-family: inherit;
            padding: 14px;
            resize: none;
            outline: none;
            min-height: 0;
        }
        .split-notepad:focus, .split-compose:focus {
            border-color: var(--accent);
        }
        .save-memory-btn {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            border: none;
            background: var(--accent-gradient);
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s var(--ease-out-expo);
            flex-shrink: 0;
            box-shadow: 0 4px 15px var(--glow-medium);
        }
        .save-memory-btn:hover {
            transform: scale(1.08);
            box-shadow: 0 6px 25px var(--glow-strong);
        }
        .browser-toggle-btn {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s var(--ease-out-expo);
            flex-shrink: 0;
            background: var(--glass-bg);
            color: var(--text-secondary);
            border: 1px solid var(--border);
            position: relative;
        }
        .browser-toggle-btn:hover {
            background: var(--bg-hover);
            color: var(--text-primary);
        }
        .browser-toggle-btn.browser-active {
            background: rgba(139, 92, 246, 0.15);
            color: var(--accent);
            border-color: rgba(139, 92, 246, 0.4);
            box-shadow: 0 0 12px var(--glow-subtle);
        }
        .chat-browser-dot {
            position: absolute;
            top: 4px;
            right: 4px;
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: transparent;
        }
        .chat-browser-dot.running {
            background: var(--accent);
            box-shadow: 0 0 6px var(--glow-medium);
        }
        .chat-browser-dot.paused {
            background: #eab308;
        }

        /* Chat Offload Routing Selector */
        .chat-offload-selector {
            position: relative;
        }
        .chat-offload-btn {
            display: flex;
            align-items: center;
            gap: 5px;
            padding: 4px 8px;
            border-radius: 8px;
            border: 1px solid var(--border);
            background: var(--glass-bg);
            color: var(--text-muted);
            cursor: pointer;
            font-size: 0.7rem;
            font-family: inherit;
            transition: all 0.2s ease;
            white-space: nowrap;
        }
        .chat-offload-btn:hover {
            background: var(--bg-hover);
            color: var(--text-primary);
        }
        .chat-offload-btn.offload-active {
            background: rgba(34, 197, 94, 0.12);
            color: #22c55e;
            border-color: rgba(34, 197, 94, 0.3);
        }
        .chat-offload-btn .offload-icon {
            font-size: 0.8rem;
            line-height: 1;
        }
        .chat-offload-dropdown {
            display: none;
            position: absolute;
            bottom: calc(100% + 8px);
            left: 0;
            min-width: 220px;
            background: var(--bg-elevated);
            border: 1px solid var(--border);
            border-radius: 12px;
            box-shadow: 0 -8px 32px rgba(0, 0, 0, 0.5);
            z-index: 1100;
            padding: 6px;
            opacity: 0;
            transform: translateY(8px);
            transition: opacity 0.15s ease, transform 0.15s ease;
        }
        .chat-offload-dropdown.open {
            display: block;
            opacity: 1;
            transform: translateY(0);
        }
        .offload-option {
            display: flex;
            align-items: center;
            gap: 10px;
            width: 100%;
            padding: 8px 12px;
            border: none;
            border-radius: 8px;
            background: transparent;
            color: var(--text-primary);
            cursor: pointer;
            font-family: inherit;
            font-size: 0.85rem;
            transition: background 0.15s ease;
        }
        .offload-option:hover {
            background: var(--bg-hover);
        }
        .offload-option.selected {
            background: rgba(139, 92, 246, 0.1);
            border: 1px solid rgba(139, 92, 246, 0.2);
        }
        .offload-option .offload-opt-icon {
            font-size: 1rem;
            flex-shrink: 0;
            width: 20px;
            text-align: center;
        }
        .offload-option .offload-opt-info {
            flex: 1;
            min-width: 0;
        }
        .offload-option .offload-opt-name {
            font-weight: 500;
        }
        .offload-option .offload-opt-detail {
            font-size: 0.7rem;
            color: var(--text-muted);
        }
        .offload-option .offload-check {
            opacity: 0;
            color: var(--accent);
            flex-shrink: 0;
        }
        .offload-option.selected .offload-check {
            opacity: 1;
        }

        .send-btn {
            background: var(--accent-gradient);
            color: white;
            box-shadow: 0 4px 15px var(--glow-medium);
        }

        .send-btn:hover:not(:disabled) {
            transform: scale(1.08);
            box-shadow: 0 6px 25px var(--glow-strong);
        }

        .send-btn:active:not(:disabled) {
            transform: scale(0.95);
        }

        .send-btn:disabled {
            background: var(--bg-card);
            color: var(--text-muted);
            box-shadow: none;
            opacity: 0.4;
            cursor: not-allowed;
        }

        /* ==================== QUICK ACTIONS VIEW ==================== */
        .quick-view {
            padding: 20px;
            gap: 24px;
            overflow-y: auto;
            min-height: min-content;
        }

        .action-section {
            margin-bottom: 24px;
        }

        .action-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 12px;
        }

        .action-btn {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 16px 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
        }

        .action-btn:active {
            transform: scale(0.95);
            background: var(--accent-glow);
            border-color: var(--accent);
        }

        .action-btn-icon {
            font-size: 1.6rem;
            margin-bottom: 6px;
        }

        .action-btn-label {
            font-size: 0.7rem;
            color: var(--text-secondary);
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 100%;
        }

        .action-row {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
        }

        .action-wide {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 16px 20px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .action-wide:active {
            transform: scale(0.98);
            background: var(--accent-glow);
            border-color: var(--accent);
        }

        .action-wide-icon {
            font-size: 1.4rem;
        }

        .action-wide-label {
            font-size: 0.9rem;
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            min-width: 0;
        }

        .action-wide {
            min-width: 0; /* Allow flex children to shrink */
        }

        /* ==================== SETTINGS VIEW ==================== */

        /* Voice Settings */
        .voice-settings-card {
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(255,255,255,0.08);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 12px;
        }
        .voice-option {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 12px;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.2s;
            margin-bottom: 4px;
        }
        .voice-option:hover {
            background: rgba(139, 92, 246, 0.1);
        }
        .voice-option.selected {
            background: rgba(139, 92, 246, 0.15);
            border: 1px solid rgba(139, 92, 246, 0.3);
        }
        .voice-option-radio {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            border: 2px solid rgba(255,255,255,0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }
        .voice-option.selected .voice-option-radio {
            border-color: var(--accent);
        }
        .voice-option.selected .voice-option-radio::after {
            content: '';
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: var(--accent);
        }
        .voice-option-info {
            flex: 1;
        }
        .voice-option-name {
            font-weight: 600;
            font-size: 0.9rem;
            color: var(--text-primary);
        }
        .voice-option-desc {
            font-size: 0.75rem;
            color: var(--text-muted);
            margin-top: 2px;
        }
        .voice-preview-btn {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            border: 1px solid rgba(255,255,255,0.15);
            background: rgba(255,255,255,0.05);
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            flex-shrink: 0;
        }
        .voice-preview-btn:hover {
            background: rgba(139, 92, 246, 0.2);
            border-color: var(--accent);
            color: var(--accent);
        }
        .voice-preview-btn.playing {
            background: rgba(139, 92, 246, 0.3);
            border-color: var(--accent);
            color: var(--accent);
            animation: speak-pulse 1.5s ease-in-out infinite;
        }
        .speed-slider-container {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 8px 0;
        }
        .speed-slider {
            flex: 1;
            -webkit-appearance: none;
            appearance: none;
            height: 4px;
            border-radius: 2px;
            background: rgba(255,255,255,0.1);
            outline: none;
        }
        .speed-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--accent);
            cursor: pointer;
        }
        .speed-value {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--accent);
            min-width: 40px;
            text-align: center;
        }
        .autospeak-toggle {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 0;
        }
        .toggle-switch {
            position: relative;
            width: 44px;
            height: 24px;
            background: rgba(255,255,255,0.1);
            border-radius: 12px;
            cursor: pointer;
            transition: background 0.3s;
        }
        .toggle-switch.active {
            background: var(--accent);
        }
        .toggle-switch::after {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: white;
            top: 2px;
            left: 2px;
            transition: transform 0.3s;
        }
        .toggle-switch.active::after {
            transform: translateX(20px);
        }
        .settings-view {
            padding: 0;
            gap: 0;
            overflow: hidden;
            min-height: 0 !important;
            height: calc(100vh - 56px - var(--nav-height, 70px) - var(--safe-bottom, 0px));
            height: calc(100dvh - 56px - var(--nav-height, 70px) - var(--safe-bottom, 0px));
        }
        .main-content:has(.settings-view.active) {
            overflow: hidden !important;
            padding-bottom: 0 !important;
        }

        /* ==================== SETTINGS SIDEBAR LAYOUT ==================== */
        .settings-layout {
            display: flex;
            flex: 1;
            width: 100%;
            min-height: 0;
        }
        .settings-sidebar {
            width: 200px;
            min-width: 200px;
            background: var(--bg-secondary);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            transition: width 0.25s ease, min-width 0.25s ease;
            overflow: hidden;
        }
        .settings-sidebar.collapsed {
            width: 52px;
            min-width: 52px;
        }
        .settings-sidebar-toggle {
            background: none;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            padding: 14px 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: color 0.2s;
        }
        .settings-sidebar-toggle:hover {
            color: var(--text-primary);
        }
        .settings-sidebar-nav {
            display: flex;
            flex-direction: column;
            gap: 2px;
            padding: 0 8px;
            flex: 1;
        }
        .settings-nav-item {
            position: relative;
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 12px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.85rem;
            color: var(--text-secondary);
            transition: background 0.15s, color 0.15s;
            white-space: nowrap;
            overflow: hidden;
        }
        .settings-nav-item:hover {
            background: var(--bg-hover);
            color: var(--text-primary);
        }
        .settings-nav-item.active {
            color: var(--text-primary);
            font-weight: 600;
            background: rgba(139, 92, 246, 0.08);
        }
        .settings-nav-item.active::before {
            content: '';
            position: absolute;
            left: 0;
            top: 6px;
            bottom: 6px;
            width: 3px;
            border-radius: 0 3px 3px 0;
            background: var(--accent);
        }
        .settings-nav-icon {
            width: 18px;
            height: 18px;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .settings-nav-label {
            overflow: hidden;
            text-overflow: ellipsis;
            transition: opacity 0.2s;
        }
        .settings-sidebar.collapsed .settings-nav-label {
            opacity: 0;
            width: 0;
        }
        .settings-sidebar.collapsed .settings-nav-item {
            justify-content: center;
            padding: 10px 0;
        }
        /* Tooltip for collapsed sidebar */
        .settings-sidebar-tooltip {
            position: fixed;
            background: var(--bg-elevated);
            color: var(--text-primary);
            font-size: 0.78rem;
            padding: 5px 10px;
            border-radius: 6px;
            border: 1px solid var(--border-light);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.15s;
            z-index: 1000;
            white-space: nowrap;
        }
        .settings-sidebar-tooltip.visible {
            opacity: 1;
        }

        /* Settings content area */
        .settings-content {
            flex: 1;
            overflow-y: auto;
            padding: 24px 32px;
            min-width: 0;
        }

        /* Profile card */
        .settings-profile-card {
            display: flex;
            align-items: center;
            gap: 16px;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 20px;
            margin-bottom: 24px;
        }
        .settings-profile-avatar {
            width: 52px;
            height: 52px;
            border-radius: 50%;
            background: var(--accent-gradient);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            font-weight: 700;
            color: #fff;
            flex-shrink: 0;
            text-transform: uppercase;
        }
        .settings-profile-info {
            flex: 1;
            min-width: 0;
        }
        .settings-profile-name {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 4px;
        }
        .settings-profile-meta {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
        }
        .settings-plan-badge {
            font-size: 0.7rem;
            font-weight: 600;
            padding: 2px 8px;
            border-radius: 10px;
            background: rgba(139, 92, 246, 0.15);
            color: var(--accent-light);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .settings-profile-files {
            font-size: 0.75rem;
            color: var(--text-muted);
        }

        /* Section panels */
        .settings-section {
            display: none;
        }
        .settings-section.active {
            display: block;
            animation: settingsFadeIn 0.2s ease;
        }
        @keyframes settingsFadeIn {
            from { opacity: 0; transform: translateY(6px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .settings-section-heading {
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 12px;
            margin-top: 20px;
        }
        .settings-section-heading:first-child {
            margin-top: 0;
        }
        .settings-group {
            margin-bottom: 20px;
        }
        .settings-group-title {
            font-size: 0.8rem;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 8px;
        }
        .settings-divider {
            height: 1px;
            background: var(--border);
            margin: 20px 0;
        }
        .settings-row-hint {
            font-size: 0.75rem;
            color: var(--text-muted);
            margin-top: 4px;
        }

        /* Responsive: auto-collapse sidebar on narrow windows */
        @media (max-width: 600px) {
            .settings-sidebar:not(.force-expanded) {
                width: 52px;
                min-width: 52px;
            }
            .settings-sidebar:not(.force-expanded) .settings-nav-label {
                opacity: 0;
                width: 0;
            }
            .settings-sidebar:not(.force-expanded) .settings-nav-item {
                justify-content: center;
                padding: 10px 0;
            }
            .settings-content {
                padding: 16px;
            }
        }

        .settings-card {
            background: var(--bg-card);
            border-radius: 16px;
            border: 1px solid var(--border);
            overflow: hidden;
        }

        .settings-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 20px;
            border-bottom: 1px solid var(--border);
        }

        .settings-row:last-child {
            border-bottom: none;
        }

        .settings-label {
            font-weight: 500;
            font-size: 0.95rem;
        }

        .settings-value {
            color: var(--text-secondary);
            font-size: 0.85rem;
            text-align: right;
            max-width: 55%;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            flex-shrink: 1;
            min-width: 0;
        }

        .settings-label {
            flex-shrink: 0;
        }

        .settings-row {
            min-width: 0; /* Allow text truncation */
        }

        .settings-value.success {
            color: var(--green);
        }

        .settings-select {
            background: var(--bg-secondary);
            border: 1px solid var(--border-light);
            border-radius: 6px;
            color: var(--text-primary);
            padding: 6px 10px;
            font-size: 0.85rem;
            max-width: 200px;
            cursor: pointer;
        }
        .settings-select:focus {
            outline: none;
            border-color: var(--purple);
        }
        .settings-select option {
            background: var(--bg-secondary);
            color: var(--text-primary);
        }

        /* ==================== FILE ACCESS SETTINGS ==================== */
        .file-mount-card {
            display: flex;
            align-items: center;
            padding: 14px 20px;
            border-bottom: 1px solid var(--border);
            gap: 12px;
        }
        .file-mount-card:last-child { border-bottom: none; }
        .file-mount-icon {
            width: 36px; height: 36px; border-radius: 10px;
            display: flex; align-items: center; justify-content: center;
            background: rgba(139,92,246,0.1); color: var(--purple); flex-shrink: 0;
        }
        .file-mount-info { flex: 1; min-width: 0; }
        .file-mount-label { font-weight: 600; font-size: 0.9rem; }
        .file-mount-path {
            font-size: 0.75rem; color: var(--text-muted);
            overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
        }
        .file-mount-badges { display: flex; gap: 0; align-items: center; flex-shrink: 0; }
        .file-mount-toggle {
            display: flex; border-radius: 8px; overflow: hidden;
            border: 1px solid var(--border);
        }
        .file-mount-toggle-btn {
            font-size: 0.65rem; font-weight: 600; padding: 4px 10px;
            white-space: nowrap; border: none; cursor: pointer;
            transition: all 0.2s; background: transparent; color: var(--text-muted);
        }
        .file-mount-toggle-btn.active-read {
            background: rgba(34,197,94,0.15); color: var(--green);
        }
        .file-mount-toggle-btn.active-write {
            background: rgba(234,179,8,0.15); color: var(--yellow);
        }
        .file-mount-remove {
            width: 28px; height: 28px; border-radius: 8px; border: none;
            background: rgba(239,68,68,0.08); color: var(--red);
            cursor: pointer; display: flex; align-items: center; justify-content: center;
            transition: background 0.2s; flex-shrink: 0;
        }
        .file-mount-remove:hover { background: rgba(239,68,68,0.2); }

        .risk-indicator {
            font-size: 0.7rem; font-weight: 600; padding: 3px 10px;
            border-radius: 20px; margin-left: 8px;
        }
        .risk-indicator.safe { background: rgba(34,197,94,0.12); color: var(--green); }
        .risk-indicator.standard { background: rgba(139,92,246,0.12); color: var(--purple); }
        .risk-indicator.extended { background: rgba(234,179,8,0.12); color: var(--yellow); }
        .risk-indicator.full { background: rgba(239,68,68,0.12); color: var(--red); }

        /* ===== Storage Config Styles ===== */
        .storage-config-card {
            background: var(--card-bg); border: 1px solid var(--border);
            border-radius: 14px; padding: 18px 20px; margin-bottom: 14px;
        }
        .storage-config-card .config-card-header {
            display: flex; align-items: center; gap: 10px; margin-bottom: 12px;
        }
        .storage-config-card .config-card-header svg { color: var(--purple); flex-shrink: 0; }
        .storage-config-card .config-card-header .config-title {
            font-size: 0.95rem; font-weight: 600; color: var(--text);
        }
        .storage-config-card .config-card-header .config-desc {
            font-size: 0.78rem; color: var(--text-muted); margin-top: 2px;
        }
        .storage-path-row {
            display: flex; align-items: center; gap: 10px; margin-bottom: 12px;
        }
        .storage-path-display {
            flex: 1; font-family: 'SF Mono', 'Cascadia Code', monospace;
            font-size: 0.82rem; color: var(--text-muted); background: rgba(255,255,255,0.03);
            border: 1px solid var(--border); border-radius: 8px; padding: 8px 12px;
            overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
        }
        .storage-path-row .btn-sm {
            padding: 6px 14px; font-size: 0.78rem; border-radius: 8px;
            background: rgba(139,92,246,0.12); color: var(--purple); border: none;
            cursor: pointer; font-weight: 600; transition: background 0.2s; white-space: nowrap;
        }
        .storage-path-row .btn-sm:hover { background: rgba(139,92,246,0.25); }
        .storage-source-label {
            font-size: 0.72rem; color: var(--text-muted); padding: 0 2px 8px;
            display: none; align-items: center; gap: 5px;
        }
        .storage-source-label.visible { display: flex; }
        .storage-source-label code {
            font-family: 'SF Mono', 'Cascadia Code', monospace; font-size: 0.7rem;
            background: rgba(139,92,246,0.1); color: var(--purple); padding: 1px 6px;
            border-radius: 4px;
        }
        .storage-stats-row {
            display: flex; gap: 20px; margin-bottom: 12px;
        }
        .storage-stat {
            display: flex; flex-direction: column; gap: 2px;
        }
        .storage-stat .stat-label {
            font-size: 0.7rem; text-transform: uppercase; letter-spacing: 0.5px;
            color: var(--text-muted); font-weight: 600;
        }
        .storage-stat .stat-value {
            font-size: 1.1rem; font-weight: 700; color: var(--text);
        }
        .storage-warning {
            display: none; background: rgba(234,179,8,0.08); border: 1px solid rgba(234,179,8,0.2);
            border-radius: 10px; padding: 10px 14px; font-size: 0.78rem; color: var(--yellow);
            line-height: 1.4;
        }
        .storage-warning.visible { display: flex; gap: 8px; align-items: flex-start; }
        .storage-warning svg { flex-shrink: 0; margin-top: 1px; }
        .storage-warning.error {
            background: rgba(239,68,68,0.08); border-color: rgba(239,68,68,0.3);
            color: var(--red);
        }
        .storage-warning.error.visible { display: flex; gap: 8px; align-items: flex-start; }

        /* ===== Offload Config Styles ===== */
        .offload-config-card {
            background: var(--card-bg); border: 1px solid var(--border);
            border-radius: 14px; padding: 18px 20px; margin-bottom: 14px;
        }
        .offload-current {
            display: flex; align-items: center; gap: 10px; padding: 10px 14px;
            background: rgba(139,92,246,0.08); border: 1px solid rgba(139,92,246,0.2);
            border-radius: 10px; margin-bottom: 12px;
        }
        .offload-current .device-name { font-weight: 600; color: var(--text); flex: 1; }
        .offload-current .btn-disable {
            padding: 5px 12px; font-size: 0.75rem; border-radius: 8px;
            background: rgba(239,68,68,0.1); color: var(--red); border: none;
            cursor: pointer; font-weight: 600; transition: background 0.2s;
        }
        .offload-current .btn-disable:hover { background: rgba(239,68,68,0.25); }
        .offload-device-list {
            display: flex; flex-direction: column; gap: 8px;
        }
        .offload-device-card {
            display: flex; align-items: center; gap: 12px; padding: 10px 14px;
            background: rgba(255,255,255,0.02); border: 1px solid var(--border);
            border-radius: 10px; transition: border-color 0.2s;
        }
        .offload-device-card:hover { border-color: rgba(139,92,246,0.4); }
        .offload-device-card .device-status-dot {
            width: 8px; height: 8px; border-radius: 50%; flex-shrink: 0;
        }
        .offload-device-card .device-status-dot.online { background: var(--green); }
        .offload-device-card .device-status-dot.stale { background: var(--yellow); }
        .offload-device-card .device-info { flex: 1; }
        .offload-device-card .device-info .dname { font-size: 0.88rem; font-weight: 600; color: var(--text); }
        .offload-device-card .device-info .dhost { font-size: 0.75rem; color: var(--text-muted); font-family: monospace; }
        .offload-select-btn {
            padding: 5px 14px; font-size: 0.75rem; border-radius: 8px;
            background: rgba(139,92,246,0.12); color: var(--purple); border: none;
            cursor: pointer; font-weight: 600; transition: background 0.2s;
        }
        .offload-select-btn:hover { background: rgba(139,92,246,0.25); }
        .offload-empty {
            font-size: 0.82rem; color: var(--text-muted); padding: 12px 0; text-align: center;
        }
        .conversations-link-row {
            cursor: pointer; transition: background 0.2s; border-radius: 10px;
        }
        .conversations-link-row:hover { background: rgba(139,92,246,0.06); }

        /* ===== Offload badge on agent cards ===== */
        .agent-offload-badge {
            display: inline-flex; align-items: center; gap: 4px;
            font-size: 0.68rem; font-weight: 600; padding: 2px 8px;
            border-radius: 12px; background: rgba(139,92,246,0.1); color: var(--purple);
            margin-left: 6px; vertical-align: middle;
        }
        .agent-offload-badge svg { width: 10px; height: 10px; }

        .file-access-restart-bar {
            position: fixed; bottom: 0; left: 0; right: 0; z-index: 1000;
            background: rgba(234,179,8,0.15); backdrop-filter: blur(12px);
            border-top: 1px solid rgba(234,179,8,0.3);
            padding: 12px 20px; display: flex; align-items: center;
            justify-content: space-between; gap: 12px;
        }
        .file-access-restart-bar .restart-msg {
            font-size: 0.85rem; font-weight: 500; color: var(--yellow);
        }
        .file-access-restart-bar .btn { padding: 8px 16px; font-size: 0.8rem; }

        .update-available-bar {
            position: fixed; top: 0; left: 0; right: 0; z-index: 10000;
            background: rgba(139,92,246,0.15); backdrop-filter: blur(12px);
            border-bottom: 1px solid rgba(139,92,246,0.3);
            padding: 10px 20px; display: flex; align-items: center;
            justify-content: center; gap: 16px;
            animation: slideDown 0.4s ease;
        }
        .update-available-bar .update-msg {
            font-size: 0.85rem; font-weight: 500; color: var(--purple);
        }
        .update-available-bar .btn { padding: 6px 16px; font-size: 0.8rem; }
        .update-dismiss-btn {
            background: none; border: none; color: var(--purple); font-size: 1.2rem;
            cursor: pointer; padding: 2px 8px; opacity: 0.7; line-height: 1;
        }
        .update-dismiss-btn:hover { opacity: 1; }
        @keyframes slideDown {
            from { transform: translateY(-100%); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        @keyframes updateSpin {
            to { transform: rotate(360deg); }
        }
        .update-spinner {
            display: inline-block; width: 14px; height: 14px;
            border: 2px solid rgba(255,255,255,0.3);
            border-top-color: #fff;
            border-radius: 50%;
            animation: updateSpin 0.8s linear infinite;
            vertical-align: middle; margin-right: 6px;
        }
        #update-apply-btn.updating {
            pointer-events: none; opacity: 0.85;
        }

        .file-access-warning {
            background: rgba(234,179,8,0.08); border: 1px solid rgba(234,179,8,0.2);
            border-radius: 12px; padding: 12px 16px; margin-bottom: 12px;
            font-size: 0.8rem; color: var(--yellow); display: none;
        }
        .file-access-warning svg { vertical-align: middle; margin-right: 6px; }

        .file-access-not-available {
            text-align: center; padding: 40px 20px; color: var(--text-muted);
            font-size: 0.9rem;
        }

        /* ==================== BUTTONS ==================== */
        .btn {
            padding: 12px 20px;
            border-radius: 12px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            border: none;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .btn:active {
            transform: scale(0.97);
        }

        /* === PREMIUM BUTTONS === */
        .btn-primary {
            background: var(--accent-gradient);
            color: white;
            border: none;
            padding: 12px 28px;
            border-radius: 14px;
            font-weight: 600;
            font-size: 0.9rem;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            transition: all 0.3s var(--ease-out-expo);
            box-shadow:
                0 4px 15px var(--glow-medium),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }

        .btn-primary::before {
            content: '';
            position: absolute;
            inset: -2px;
            background: var(--accent-gradient);
            filter: blur(15px);
            opacity: 0;
            z-index: -1;
            transition: opacity 0.3s ease;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow:
                0 8px 30px var(--glow-strong),
                inset 0 1px 0 rgba(255, 255, 255, 0.3);
        }

        .btn-primary:hover::before {
            opacity: 0.6;
        }

        .btn-primary:active {
            transform: translateY(0) scale(0.98);
        }

        .btn-secondary {
            background: var(--glass-bg);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            color: var(--text-primary);
            border: 1px solid var(--border-light);
            padding: 12px 28px;
            border-radius: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s var(--ease-out-expo);
        }

        .btn-secondary:hover {
            border-color: var(--glass-border-hover);
            background: var(--glass-bg-light);
            box-shadow: 0 0 20px var(--glow-subtle);
        }
        .btn-secondary:active,
        .chat-fab-item:active,
        .slide-panel-close:active {
            transform: scale(0.95);
            transition: transform 0.1s ease;
        }

        .btn-danger {
            background: var(--bg-elevated);
            color: var(--red);
            border: 1px solid var(--border);
            transition: all 0.3s var(--ease-out-expo);
        }

        .btn-danger:hover {
            background: rgba(239, 68, 68, 0.15);
            border-color: rgba(239, 68, 68, 0.4);
            box-shadow: 0 0 20px rgba(239, 68, 68, 0.2);
        }

        .btn-block {
            width: 100%;
        }

        /* Icon button (circular) */
        .btn-icon {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--glass-bg);
            border: 1px solid var(--border);
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s var(--ease-out-expo);
        }

        .btn-icon:hover {
            background: var(--bg-hover);
            border-color: var(--glass-border);
            color: var(--accent-light);
            transform: scale(1.05);
            box-shadow: 0 0 20px var(--glow-subtle);
        }

        /* ==================== LOGIN VIEW ==================== */
        .login-view {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
            height: 100dvh;
            padding: 20px;
            background: var(--bg-primary);
        }

        .login-card {
            background: var(--bg-card);
            border-radius: 24px;
            padding: 40px 32px;
            width: 100%;
            max-width: 380px;
            border: 1px solid var(--border);
            text-align: center;
        }

        .login-logo {
            width: 80px;
            height: 80px;
            background: var(--accent-gradient);
            border-radius: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            font-weight: 700;
            margin: 0 auto 24px;
            box-shadow: 0 8px 30px var(--accent-glow-strong);
        }

        .login-title {
            font-size: 1.8rem;
            font-weight: 700;
            margin-bottom: 8px;
            background: var(--accent-gradient);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .login-subtitle {
            color: var(--text-secondary);
            margin-bottom: 32px;
            font-size: 0.95rem;
        }

        .login-input {
            width: 100%;
            background: var(--bg-elevated);
            border: 1px solid var(--border);
            border-radius: 14px;
            padding: 16px 20px;
            color: var(--text-primary);
            font-size: 1rem;
            margin-bottom: 16px;
            transition: all 0.2s;
        }

        .login-input:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 3px var(--accent-glow);
        }

        .login-btn {
            width: 100%;
            padding: 16px;
            background: var(--accent-gradient);
            color: white;
            border: none;
            border-radius: 14px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 4px 20px var(--accent-glow);
        }

        .login-btn:active {
            transform: scale(0.98);
        }

        .login-error {
            color: var(--red);
            font-size: 0.85rem;
            margin-top: 12px;
            display: none;
        }

        /* ==================== CINEMATIC ONBOARDING ==================== */
        .cin-onboard {
            position: fixed;
            inset: 0;
            z-index: 10000;
            display: flex;
            flex-direction: column;
            align-items: center;
            overflow: hidden;
        }
        .cin-backdrop {
            position: absolute;
            inset: 0;
            background: radial-gradient(ellipse at 50% 30%, rgba(88, 28, 135, 0.15) 0%, rgba(15, 3, 30, 0.8) 50%, #000 100%);
            z-index: 0;
        }
        /* Ambient floating particles */
        .cin-backdrop::before {
            content: '';
            position: absolute;
            inset: 0;
            background-image:
                radial-gradient(1.5px 1.5px at 10% 20%, rgba(167,139,250,0.4) 50%, transparent 100%),
                radial-gradient(1px 1px at 25% 60%, rgba(139,92,246,0.3) 50%, transparent 100%),
                radial-gradient(2px 2px at 40% 15%, rgba(196,181,253,0.35) 50%, transparent 100%),
                radial-gradient(1px 1px at 55% 75%, rgba(167,139,250,0.25) 50%, transparent 100%),
                radial-gradient(1.5px 1.5px at 70% 35%, rgba(139,92,246,0.4) 50%, transparent 100%),
                radial-gradient(1px 1px at 85% 55%, rgba(196,181,253,0.3) 50%, transparent 100%),
                radial-gradient(2px 2px at 15% 85%, rgba(139,92,246,0.2) 50%, transparent 100%),
                radial-gradient(1px 1px at 90% 10%, rgba(167,139,250,0.35) 50%, transparent 100%),
                radial-gradient(1.5px 1.5px at 60% 90%, rgba(139,92,246,0.3) 50%, transparent 100%),
                radial-gradient(1px 1px at 35% 45%, rgba(196,181,253,0.2) 50%, transparent 100%);
            animation: cinParticleDrift 20s ease-in-out infinite alternate;
        }
        .cin-backdrop::after {
            content: '';
            position: absolute;
            inset: 0;
            background-image:
                radial-gradient(1px 1px at 5% 50%, rgba(192,132,252,0.3) 50%, transparent 100%),
                radial-gradient(1.5px 1.5px at 20% 30%, rgba(139,92,246,0.25) 50%, transparent 100%),
                radial-gradient(1px 1px at 45% 80%, rgba(167,139,250,0.35) 50%, transparent 100%),
                radial-gradient(2px 2px at 65% 10%, rgba(196,181,253,0.2) 50%, transparent 100%),
                radial-gradient(1px 1px at 80% 70%, rgba(139,92,246,0.3) 50%, transparent 100%),
                radial-gradient(1.5px 1.5px at 95% 40%, rgba(167,139,250,0.25) 50%, transparent 100%),
                radial-gradient(1px 1px at 50% 50%, rgba(192,132,252,0.15) 50%, transparent 100%);
            animation: cinParticleDrift2 25s ease-in-out infinite alternate;
        }
        .cin-dissolve {
            position: absolute;
            inset: 0;
            z-index: 100;
            pointer-events: none;
            opacity: 0;
        }
        .cin-dissolve.active {
            animation: cinDissolve 2s ease-in forwards;
        }
        .cin-orb-wrap {
            position: relative;
            z-index: 1;
            width: min(160px, 30vw);
            height: min(160px, 30vw);
            margin-top: 20vh;
            transition: margin-top 1s cubic-bezier(0.4, 0, 0.2, 1), width 1s ease, height 1s ease;
            flex-shrink: 0;
            opacity: 0;
        }
        .cin-orb-wrap.cin-orb-visible {
            opacity: 1;
        }
        .cin-orb-wrap.cin-orb-docked {
            margin-top: clamp(30px, 5vh, 60px);
            width: min(90px, 18vw);
            height: min(90px, 18vw);
        }
        .cin-orb-img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            filter: drop-shadow(0 0 25px rgba(147, 51, 234, 0.7)) drop-shadow(0 0 50px rgba(139, 92, 246, 0.4)) drop-shadow(0 0 80px rgba(88, 28, 135, 0.3));
            animation: cinOrbBreathe 4s ease-in-out infinite;
        }
        .cin-orb-wrap.cin-orb-surge .cin-orb-img {
            animation: cinOrbSurge 1.5s ease-out forwards;
        }
        .cin-ring {
            position: absolute;
            top: 50%;
            left: 50%;
            border-radius: 50%;
            border: 1px solid rgba(139, 92, 246, 0.15);
            transform: translate(-50%, -50%);
        }
        .cin-ring-1 {
            width: 150%;
            height: 150%;
            animation: cinRingRotate 12s linear infinite;
            border-color: rgba(192, 132, 252, 0.25);
            border-style: dashed;
        }
        .cin-ring-2 {
            width: 185%;
            height: 185%;
            animation: cinRingRotate 18s linear infinite reverse;
            border-color: rgba(167, 139, 250, 0.18);
        }
        .cin-ring-3 {
            width: 220%;
            height: 220%;
            animation: cinRingRotate 25s linear infinite;
            border-color: rgba(139, 92, 246, 0.1);
            border-style: dotted;
        }
        #cin-conversation {
            position: relative;
            z-index: 1;
            width: 100%;
            max-width: min(640px, 90vw);
            padding: 24px 20px 180px;
            overflow-y: auto;
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 10px;
            opacity: 0;
            transition: opacity 0.8s ease;
            scrollbar-width: thin;
            scrollbar-color: rgba(139,92,246,0.2) transparent;
        }
        #cin-conversation.cin-conv-visible {
            opacity: 1;
        }
        .cin-line-cerebro {
            color: #c4b5fd;
            font-family: 'Inter', -apple-system, sans-serif;
            font-size: clamp(0.95rem, 2.5vw, 1.1rem);
            line-height: 1.65;
            animation: cinLineFadeIn 0.3s ease-out;
            text-shadow: 0 0 20px rgba(139, 92, 246, 0.15);
        }
        /* --- Input bar (slides up from bottom) --- */
        .cin-input-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            z-index: 10001;
            padding: 30px 20px 36px;
            display: flex;
            justify-content: center;
            background: linear-gradient(transparent, rgba(10,0,20,0.85) 30%, rgba(10,0,20,0.98) 100%);
            transform: translateY(100%);
            opacity: 0;
            transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.3s ease;
            pointer-events: none;
        }
        .cin-input-bar.active {
            transform: translateY(0);
            opacity: 1;
            pointer-events: auto;
        }
        .cin-input-content {
            width: 100%;
            max-width: min(640px, 90vw);
        }
        .cin-bar-input-wrap {
            display: flex;
            align-items: center;
            background: rgba(30, 15, 60, 0.8);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(139, 92, 246, 0.4);
            border-radius: 14px;
            padding: 16px 22px;
            gap: 10px;
            animation: cinLineFadeIn 0.3s ease-out;
            box-shadow: 0 0 30px rgba(139, 92, 246, 0.1), inset 0 1px 0 rgba(255,255,255,0.05);
        }
        .cin-bar-input-wrap .cin-prompt {
            color: #a78bfa;
            font-family: 'JetBrains Mono', 'Fira Code', monospace;
            font-size: 1.05rem;
            user-select: none;
            flex-shrink: 0;
            text-shadow: 0 0 8px rgba(167, 139, 250, 0.5);
        }
        .cin-bar-input {
            background: transparent;
            border: none;
            outline: none;
            color: #e9d5ff;
            font-family: 'JetBrains Mono', 'Fira Code', monospace;
            font-size: 1rem;
            width: 100%;
            caret-color: #a78bfa;
        }
        .cin-bar-input::placeholder {
            color: rgba(167, 139, 250, 0.25);
        }
        .cin-bar-chips {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            animation: cinLineFadeIn 0.3s ease-out;
        }
        .cin-bar-options {
            display: flex;
            flex-direction: column;
            gap: 10px;
            animation: cinLineFadeIn 0.3s ease-out;
        }
        .cin-chip {
            padding: 11px 22px;
            border-radius: 28px;
            border: 1px solid rgba(139, 92, 246, 0.35);
            background: linear-gradient(135deg, rgba(88, 28, 135, 0.25) 0%, rgba(139, 92, 246, 0.12) 100%);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            color: #c4b5fd;
            cursor: pointer;
            font-size: clamp(0.82rem, 2vw, 0.92rem);
            transition: all 0.25s ease;
            user-select: none;
            opacity: 0;
            animation: cinChipIn 0.4s ease-out forwards;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.06);
        }
        .cin-chip:hover {
            border-color: rgba(167, 139, 250, 0.7);
            background: linear-gradient(135deg, rgba(88, 28, 135, 0.4) 0%, rgba(139, 92, 246, 0.25) 100%);
            color: #e9d5ff;
            transform: translateY(-1px);
            box-shadow: 0 4px 20px rgba(139, 92, 246, 0.25), inset 0 1px 0 rgba(255,255,255,0.08);
        }
        .cin-chip.selected {
            border-color: #a78bfa;
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.5) 0%, rgba(88, 28, 135, 0.4) 100%);
            color: #fff;
            box-shadow: 0 0 20px rgba(139, 92, 246, 0.4), 0 4px 15px rgba(88, 28, 135, 0.3), inset 0 1px 0 rgba(255,255,255,0.1);
            text-shadow: 0 0 10px rgba(196, 181, 253, 0.5);
        }
        .cin-continue-btn {
            padding: 12px 32px;
            border-radius: 28px;
            border: 1px solid rgba(139, 92, 246, 0.5);
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.35) 0%, rgba(88, 28, 135, 0.3) 100%);
            color: #e9d5ff;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            margin-top: 14px;
            transition: all 0.3s ease;
            opacity: 0;
            animation: cinChipIn 0.4s ease-out forwards;
            align-self: center;
            letter-spacing: 0.5px;
            box-shadow: 0 2px 15px rgba(139, 92, 246, 0.2);
        }
        .cin-continue-btn:hover {
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.55) 0%, rgba(88, 28, 135, 0.45) 100%);
            color: #fff;
            box-shadow: 0 4px 25px rgba(139, 92, 246, 0.35);
            transform: translateY(-1px);
        }
        .cin-option {
            padding: 15px 22px;
            border-radius: 12px;
            border: 1px solid rgba(139, 92, 246, 0.25);
            background: linear-gradient(135deg, rgba(30, 15, 60, 0.6) 0%, rgba(88, 28, 135, 0.15) 100%);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            color: #c4b5fd;
            cursor: pointer;
            font-size: clamp(0.88rem, 2.2vw, 0.98rem);
            transition: all 0.3s ease;
            user-select: none;
            opacity: 0;
            animation: cinChipIn 0.4s ease-out forwards;
            box-shadow: 0 2px 10px rgba(0,0,0,0.25), inset 0 1px 0 rgba(255,255,255,0.04);
        }
        .cin-option:hover {
            border-color: rgba(167, 139, 250, 0.6);
            background: linear-gradient(135deg, rgba(88, 28, 135, 0.35) 0%, rgba(139, 92, 246, 0.2) 100%);
            color: #e9d5ff;
            transform: translateY(-1px);
            box-shadow: 0 4px 20px rgba(139, 92, 246, 0.2), inset 0 1px 0 rgba(255,255,255,0.06);
        }
        .cin-option.selected {
            border-color: #a78bfa;
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.45) 0%, rgba(88, 28, 135, 0.35) 100%);
            color: #fff;
            box-shadow: 0 0 25px rgba(139, 92, 246, 0.35), inset 0 1px 0 rgba(255,255,255,0.1);
            text-shadow: 0 0 8px rgba(196, 181, 253, 0.4);
        }
        .cin-option.dimmed {
            opacity: 0.2;
            pointer-events: none;
            filter: grayscale(0.5);
        }
        .cin-error {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(220, 38, 38, 0.9) 0%, rgba(185, 28, 28, 0.9) 100%);
            color: #fff;
            padding: 12px 28px;
            border-radius: 28px;
            font-size: 0.85rem;
            z-index: 10002;
            opacity: 0;
            transition: opacity 0.3s;
            box-shadow: 0 4px 20px rgba(220, 38, 38, 0.3);
            backdrop-filter: blur(10px);
        }
        .cin-error.visible {
            opacity: 1;
        }
        /* Responsive adjustments */
        @media (max-width: 600px) {
            .cin-input-bar { padding: 20px 12px 28px; }
            .cin-bar-input-wrap { padding: 12px 16px; }
            .cin-chip { padding: 9px 16px; }
            .cin-option { padding: 13px 18px; }
            #cin-conversation { padding: 20px 16px 180px; gap: 8px; }
        }
        @media (max-height: 500px) {
            .cin-orb-wrap { margin-top: 10vh !important; }
            .cin-orb-wrap.cin-orb-docked { margin-top: 15px !important; width: 50px !important; height: 50px !important; }
            #cin-conversation { padding-top: 10px; }
        }
        @keyframes cinOrbBreathe {
            0%, 100% { filter: drop-shadow(0 0 25px rgba(147, 51, 234, 0.7)) drop-shadow(0 0 50px rgba(139, 92, 246, 0.4)) drop-shadow(0 0 80px rgba(88, 28, 135, 0.3)); }
            50% { filter: drop-shadow(0 0 35px rgba(147, 51, 234, 0.9)) drop-shadow(0 0 70px rgba(139, 92, 246, 0.5)) drop-shadow(0 0 100px rgba(88, 28, 135, 0.4)); }
        }
        @keyframes cinOrbSurge {
            0% { filter: drop-shadow(0 0 25px rgba(147, 51, 234, 0.7)) drop-shadow(0 0 50px rgba(139, 92, 246, 0.4)); }
            50% { filter: drop-shadow(0 0 80px rgba(147, 51, 234, 1)) drop-shadow(0 0 140px rgba(192, 132, 252, 0.8)) drop-shadow(0 0 220px rgba(139, 92, 246, 0.5)); }
            100% { filter: drop-shadow(0 0 50px rgba(147, 51, 234, 0.8)) drop-shadow(0 0 90px rgba(139, 92, 246, 0.5)); }
        }
        @keyframes cinLineFadeIn {
            from { opacity: 0; transform: translateY(8px); }
            to { opacity: 1; transform: translateY(0); }
        }
        @keyframes cinChipIn {
            from { opacity: 0; transform: translateY(6px) scale(0.95); }
            to { opacity: 1; transform: translateY(0) scale(1); }
        }
        @keyframes cinCursorBlink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0; }
        }
        @keyframes cinDissolve {
            0% { opacity: 0; background: transparent; }
            40% { opacity: 1; background: rgba(88, 28, 135, 0.9); }
            70% { opacity: 1; background: rgba(192, 132, 252, 0.6); }
            100% { opacity: 1; background: #0a0a0f; }
        }
        @keyframes cinRingRotate {
            from { transform: translate(-50%, -50%) rotate(0deg); }
            to { transform: translate(-50%, -50%) rotate(360deg); }
        }
        @keyframes cinParticleDrift {
            0% { transform: translate(0, 0); }
            100% { transform: translate(15px, -20px); }
        }
        @keyframes cinParticleDrift2 {
            0% { transform: translate(0, 0); }
            100% { transform: translate(-10px, 15px); }
        }

        /* ==================== UTILITIES ==================== */
        .spinner {
            width: 24px;
            height: 24px;
            border: 3px solid var(--border);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        .spinner-sm {
            width: 16px;
            height: 16px;
            border: 2px solid var(--border);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            flex-shrink: 0;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-container {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 40px;
        }

        .empty-state {
            text-align: center;
            padding: 40px 20px;
            color: var(--text-secondary);
        }

        .empty-icon {
            font-size: 3rem;
            margin-bottom: 12px;
            opacity: 0.5;
        }

        .hidden {
            display: none !important;
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 4px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border-light);
            border-radius: 4px;
        }

        /* Split View Responsive */
        @media (max-width: 768px) {
            .chat-view.active.split-mode {
                grid-template-columns: 1fr !important;
                grid-template-rows: 1fr auto auto;
                grid-template-areas:
                    "messages"
                    "left-panel"
                    "input" !important;
            }
            .chat-view.active.split-mode .split-left-panel {
                max-height: 200px;
                border-right: none;
                border-top: 1px solid var(--border);
            }
            .chat-view.active.split-mode .messages-container { border-left: none; }
            .chat-view.active.split-mode .chat-input-area { border-radius: 0; border-right: none; }
        }
        @media (max-width: 480px) {
            .layout-toggle-btn { display: none; }
        }

        /* ==================== RESPONSIVE ==================== */
        @media (max-width: 380px) {
            .action-grid {
                grid-template-columns: repeat(3, 1fr);
            }

            .hero-stats {
                flex-direction: column;
            }
        }

        /* ==================== GOALS VIEW ==================== */
        .goals-view {
            padding: 20px;
            gap: 16px;
            overflow-y: auto;
        }

        .goals-view .view-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .goals-view .view-title {
            font-size: 1.5rem;
            font-weight: 700;
        }

        /* Goals Grid - Kanban Style */
        .goals-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 16px;
        }

        .goals-column {
            background: var(--glass-bg);
            backdrop-filter: blur(var(--glass-blur));
            -webkit-backdrop-filter: blur(var(--glass-blur));
            border-radius: 16px;
            padding: 16px;
            border: 1px solid var(--glass-border);
            min-height: 200px;
        }

        .goals-column h3 {
            font-size: 0.9rem;
            font-weight: 600;
            margin-bottom: 12px;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .goals-column.blocked h3 {
            color: var(--yellow);
        }

        .goals-column.completed h3 {
            color: var(--green);
        }

        /* Goal Card */
        .goal-card {
            background: var(--bg-card);
            border-radius: 12px;
            padding: 14px;
            margin-bottom: 12px;
            border: 1px solid var(--border);
            transition: all 0.2s ease;
            cursor: pointer;
        }

        .goal-card:hover {
            border-color: var(--accent);
            box-shadow: 0 0 0 1px var(--accent), var(--shadow-md);
            transform: translateY(-2px);
        }

        .goal-card.active {
            border-left: 3px solid var(--accent);
        }

        .goal-card.blocked {
            border-left: 3px solid var(--yellow);
        }

        .goal-card.completed {
            border-left: 3px solid var(--green);
            opacity: 0.8;
        }

        .goal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .goal-priority {
            font-size: 0.7rem;
            padding: 2px 8px;
            border-radius: 10px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .goal-priority.high {
            background: rgba(239, 68, 68, 0.2);
            color: var(--red);
        }

        .goal-priority.medium {
            background: rgba(234, 179, 8, 0.2);
            color: var(--yellow);
        }

        .goal-priority.low {
            background: rgba(34, 197, 94, 0.2);
            color: var(--green);
        }

        .goal-progress {
            font-size: 0.75rem;
            color: var(--text-muted);
        }

        .goal-title {
            font-size: 0.95rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 8px;
            line-height: 1.3;
        }

        .goal-subtasks {
            margin: 10px 0;
        }

        .subtask {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.8rem;
            color: var(--text-secondary);
            padding: 4px 0;
        }

        .subtask.done {
            text-decoration: line-through;
            opacity: 0.6;
        }

        .subtask-check {
            font-size: 0.9rem;
        }

        .goal-blockers {
            margin-top: 8px;
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .blocker-tag {
            font-size: 0.7rem;
            padding: 3px 8px;
            border-radius: 8px;
            background: rgba(234, 179, 8, 0.15);
            color: var(--yellow);
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .goal-actions {
            display: flex;
            gap: 8px;
            margin-top: 12px;
            padding-top: 10px;
            border-top: 1px solid var(--border);
        }

        .goal-actions button {
            flex: 1;
            padding: 6px 12px;
            font-size: 0.75rem;
            border-radius: 8px;
            border: 1px solid var(--border);
            background: var(--bg-elevated);
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .goal-actions button:hover {
            background: var(--accent);
            color: white;
            border-color: var(--accent);
        }

        /* Goal Creation Modal */
        .goal-form-group {
            margin-bottom: 16px;
        }

        .goal-form-label {
            display: block;
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-bottom: 6px;
        }

        .goal-form-input {
            width: 100%;
            padding: 10px 14px;
            border-radius: 10px;
            border: 1px solid var(--border);
            background: var(--bg-elevated);
            color: var(--text-primary);
            font-size: 0.9rem;
        }

        .goal-form-input:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 3px var(--accent-glow);
        }

        /* Empty state for goals */
        .goals-empty {
            text-align: center;
            padding: 40px 20px;
            color: var(--text-muted);
        }

        .goals-empty-icon {
            font-size: 3rem;
            margin-bottom: 12px;
            opacity: 0.5;
        }

        /* ==================== CEREBRO CONSCIOUSNESS INTERFACE ==================== */
        /* An ethereal window into a living mind */

        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;600;700;900&family=Rajdhani:wght@300;400;500;600;700&family=Space+Mono:wght@400;700&display=swap');

        .autonomy-view {
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 0 !important;
            height: calc(100vh - 56px - var(--nav-height, 70px) - var(--safe-bottom, 0px));
            height: calc(100dvh - 56px - var(--nav-height, 70px) - var(--safe-bottom, 0px));
            max-height: calc(100vh - 56px - var(--nav-height, 70px) - var(--safe-bottom, 0px));
            max-height: calc(100dvh - 56px - var(--nav-height, 70px) - var(--safe-bottom, 0px));
            background: radial-gradient(ellipse 120% 100% at 50% -20%, rgba(88, 28, 135, 0.18) 0%, transparent 50%),
                        radial-gradient(ellipse 80% 60% at 80% 100%, rgba(30, 58, 138, 0.12) 0%, transparent 40%);
            position: relative;
            overflow: hidden;
        }

        /* Kill ALL scroll when Mind page is active  targets every ancestor */
        html:has(.autonomy-view.active),
        html:has(.autonomy-view.active) body,
        html:has(.autonomy-view.active) #app,
        html:has(.autonomy-view.active) #main-app,
        .main-content:has(.autonomy-view.active) {
            overflow: hidden !important;
        }
        .main-content:has(.autonomy-view.active) {
            padding-bottom: 0 !important;
            height: 100dvh !important;
            max-height: 100dvh !important;
        }

        /* Subtle noise texture overlay */
        .autonomy-view > * {
            position: relative;
            z-index: 1;
        }

        /* Cosmic dust particles floating */
        .autonomy-view::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image:
                radial-gradient(1px 1px at 20% 30%, rgba(255,255,255,0.3) 0%, transparent 100%),
                radial-gradient(1px 1px at 40% 70%, rgba(255,255,255,0.2) 0%, transparent 100%),
                radial-gradient(1px 1px at 80% 40%, rgba(255,255,255,0.25) 0%, transparent 100%),
                radial-gradient(2px 2px at 60% 80%, rgba(139,92,246,0.3) 0%, transparent 100%),
                radial-gradient(1px 1px at 10% 90%, rgba(255,255,255,0.15) 0%, transparent 100%),
                radial-gradient(1px 1px at 90% 10%, rgba(255,255,255,0.2) 0%, transparent 100%);
            background-size: 550px 550px;
            animation: cosmicDrift 120s linear infinite;
            pointer-events: none;
            z-index: 0;
            opacity: 0.6;
        }

        @keyframes cosmicDrift {
            0% { background-position: 0 0, 100px 100px, 200px 50px, 50px 200px, 300px 150px, 150px 300px; }
            100% { background-position: 550px 550px, 650px 650px, 750px 600px, 600px 750px, 850px 700px, 700px 850px; }
        }

        /* Vertical scan line effect */
        .autonomy-view::after {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent 0%, rgba(139, 92, 246, 0.02) 50%, transparent 100%);
            animation: scanLine 8s ease-in-out infinite;
            pointer-events: none;
            z-index: 0;
        }

        @keyframes scanLine {
            0%, 100% { transform: translateX(-100%); opacity: 0; }
            50% { transform: translateX(100%); opacity: 1; }
        }

        /* ===== COMPACT STATUS BAR (Top of Mind view) ===== */
        .mind-status-bar {
            display: flex;
            gap: 10px;
            padding: 16px 20px 8px;
            width: 100%;
            max-width: 1400px;
            z-index: 2;
            flex-wrap: wrap;
            justify-content: center;
            flex-shrink: 0;
        }

        @media (min-width: 1024px) {
            .mind-status-bar {
                padding: 10px 20px 6px;
            }
            .status-card {
                padding: 8px 14px;
            }
        }

        .status-card {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 16px;
            background: rgba(12, 12, 20, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.06);
            border-radius: 12px;
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            flex: 1;
            min-width: 120px;
            max-width: 200px;
            transition: all 0.3s ease;
            cursor: default;
        }

        .status-card:hover {
            border-color: rgba(139, 92, 246, 0.3);
            background: rgba(16, 16, 28, 0.9);
            transform: translateY(-1px);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        .status-card-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            flex-shrink: 0;
            box-shadow: 0 0 8px currentColor;
        }

        .status-card-dot.phase-observe { background: #3b82f6; color: #3b82f6; }
        .status-card-dot.phase-orient { background: #8b5cf6; color: #8b5cf6; }
        .status-card-dot.phase-decide { background: #f59e0b; color: #f59e0b; }
        .status-card-dot.phase-act { background: #f97316; color: #f97316; }
        .status-card-dot.phase-reflect { background: #10b981; color: #10b981; }
        .status-card-dot.phase-idle { background: #6b7280; color: #6b7280; }
        .status-card-dot.phase-dormant { background: #4b5563; color: #4b5563; }

        .status-card-info {
            display: flex;
            flex-direction: column;
            gap: 1px;
            min-width: 0;
        }

        .status-card-label {
            font-family: 'Space Mono', monospace;
            font-size: 0.55rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-muted);
        }

        .status-card-value {
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.95rem;
            font-weight: 600;
            color: var(--text-primary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* ===== INTEGRATED STATUS STRIP (Below orb) ===== */
        .mind-status-strip {
            display: flex;
            align-items: center;
            gap: 16px;
            padding: 12px 20px;
            width: 100%;
            max-width: 700px;
            z-index: 2;
            justify-content: center;
            flex-wrap: wrap;
            box-sizing: border-box;
        }

        @media (min-width: 1024px) {
            .mind-status-strip {
                max-width: 420px;
            }
        }

        .strip-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 14px;
            background: rgba(12, 12, 20, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.25s ease;
            max-width: 280px;
        }

        .strip-item:hover {
            border-color: rgba(139, 92, 246, 0.3);
            background: rgba(16, 16, 28, 0.8);
        }

        .strip-item-icon {
            font-size: 0.85rem;
            flex-shrink: 0;
        }

        .strip-item-text {
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.8rem;
            color: var(--text-secondary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .strip-badge {
            font-family: 'Space Mono', monospace;
            font-size: 0.65rem;
            font-weight: 700;
            padding: 2px 7px;
            border-radius: 8px;
            background: rgba(139, 92, 246, 0.2);
            color: var(--accent-light);
            flex-shrink: 0;
        }

        .strip-badge.green { background: rgba(34, 197, 94, 0.2); color: #4ade80; }

        /* ===== 2-COLUMN LAYOUT ===== */
        .mind-columns {
            display: flex;
            flex-direction: column;
            width: 100%;
            max-width: min(96vw, 1800px);
            padding: 27px 20px 32px;
            gap: 24px;
            flex: 1;
            min-height: 0;
            overflow: hidden;
            z-index: 2;
        }

        /* Translucent fade edges at top/bottom of Mind view */
        .autonomy-view .mind-edge-fade-top,
        .autonomy-view .mind-edge-fade-bottom {
            position: absolute;
            left: 0;
            right: 0;
            height: 40px;
            pointer-events: none;
            z-index: 3;
        }
        .autonomy-view .mind-edge-fade-top {
            top: 0;
            background: linear-gradient(to bottom, rgba(10, 10, 15, 0.7) 0%, transparent 100%);
        }
        .autonomy-view .mind-edge-fade-bottom {
            bottom: 0;
            background: linear-gradient(to top, rgba(10, 10, 15, 0.7) 0%, transparent 100%);
        }

        @media (min-width: 1024px) {
            .mind-columns {
                flex-direction: row;
                align-items: stretch;
                padding-top: 23px;
                padding-bottom: 32px;
                gap: 20px;
            }
            .mind-col-chat {
                flex: 1;
                min-width: 0;
                display: flex;
                flex-direction: column;
                overflow: hidden;
            }
            .mind-col-orb {
                width: clamp(420px, 35vw, 600px);
                flex-shrink: 0;
                display: flex;
                flex-direction: column;
                align-items: center;
                overflow: hidden;
            }
        }

        @media (max-width: 1023px) {
            .mind-col-orb { order: -1; flex-shrink: 0; }
            .mind-col-chat { order: 1; flex: 1; min-height: 0; overflow: hidden; }
        }

        /* ===== CENTERED CHAT SECTION ===== */
        .mind-chat-section {
            width: 100%;
            padding: 0 0 20px;
            z-index: 2;
            display: flex;
            flex-direction: column;
            flex: 1;
            min-height: 0;
        }

        @media (max-width: 1023px) {
            .mind-chat-section {
                max-width: 700px;
                margin: 0 auto;
            }
        }

        .mind-chat-container {
            position: relative;
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.06);
            border-radius: 20px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            flex: 1;
            min-height: 0;
        }

        /* Mind chat tab bar (Chat | Stored) */
        .mind-chat-tabs {
            display: flex;
            gap: 0;
            border-bottom: 1px solid rgba(255,255,255,0.06);
            padding: 0 16px;
            background: transparent;
            flex-shrink: 0;
        }
        .mind-chat-tab {
            padding: 10px 20px;
            background: none;
            border: none;
            color: rgba(255,255,255,0.4);
            font-size: 0.82rem;
            font-weight: 600;
            cursor: pointer;
            border-bottom: 2px solid transparent;
            transition: all 0.2s;
        }
        .mind-chat-tab.active {
            color: #8b5cf6;
            border-bottom-color: #8b5cf6;
        }
        .mind-chat-tab:hover:not(.active) {
            color: rgba(255,255,255,0.6);
        }
        .stored-badge {
            background: #8b5cf6;
            color: white;
            font-size: 0.65rem;
            padding: 1px 6px;
            border-radius: 10px;
            margin-left: 6px;
            vertical-align: middle;
        }
        .answers-badge {
            background: #f59e0b;
            color: #1a1a2e;
            font-size: 0.65rem;
            padding: 1px 6px;
            border-radius: 10px;
            margin-left: 6px;
            vertical-align: middle;
            font-weight: 600;
        }

        .wallet-badge {
            background: #22c55e;
            color: #0a0a1a;
            font-weight: 700;
        }

        /* Wallet tab pane */
        .mind-wallet-items {
            flex: 1;
            overflow-y: auto;
            padding: 12px 16px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .mind-wallet-items.hidden { display: none; }

        .wallet-pnl-header {
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(255,255,255,0.06);
            border-radius: 14px;
            padding: 20px;
            text-align: center;
            backdrop-filter: blur(12px);
        }
        .wallet-pnl-label {
            font-size: 0.7rem;
            color: rgba(255,255,255,0.35);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 4px;
        }
        .wallet-pnl-amount {
            font-size: 1.8rem;
            font-weight: 700;
            font-variant-numeric: tabular-nums;
        }
        .wallet-pnl-amount.positive { color: #22c55e; }
        .wallet-pnl-amount.negative { color: #ef4444; }
        .wallet-pnl-amount.zero { color: rgba(255,255,255,0.5); }
        .wallet-pnl-unrealized {
            font-size: 0.72rem;
            color: rgba(255,255,255,0.35);
            margin-top: 4px;
        }
        .wallet-period-bar {
            display: flex;
            gap: 4px;
            justify-content: center;
            margin-top: 12px;
        }
        .wallet-period-btn {
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.08);
            color: rgba(255,255,255,0.45);
            padding: 4px 14px;
            border-radius: 8px;
            font-size: 0.72rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.15s;
        }
        .wallet-period-btn.active {
            background: rgba(139, 92, 246, 0.2);
            border-color: rgba(139, 92, 246, 0.4);
            color: #c4b5fd;
        }
        .wallet-columns {
            display: flex;
            gap: 0;
            flex: 1;
            min-height: 0;
            overflow: hidden;
        }
        .wallet-col {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 0;
            overflow-y: auto;
            padding: 0 4px;
        }
        .wallet-col + .wallet-col {
            border-left: 1px solid rgba(255,255,255,0.06);
        }
        .wallet-col-header {
            font-size: 0.68rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: rgba(255,255,255,0.3);
            padding: 8px 8px 6px;
            border-bottom: 1px solid rgba(255,255,255,0.04);
            flex-shrink: 0;
        }
        .wallet-col-content {
            flex: 1;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 6px;
            padding: 6px 2px;
        }
        .wallet-position-card {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 10px;
            background: rgba(255,255,255,0.025);
            border: 1px solid rgba(255,255,255,0.05);
            border-radius: 10px;
            border-left: 3px solid #22c55e;
        }
        .wallet-position-card .pos-symbol {
            font-size: 0.8rem;
            font-weight: 700;
            color: rgba(255,255,255,0.85);
        }
        .wallet-position-card .pos-detail {
            font-size: 0.65rem;
            color: rgba(255,255,255,0.3);
            margin-top: 1px;
        }
        .wallet-position-card .pos-pnl {
            margin-left: auto;
            font-size: 0.8rem;
            font-weight: 700;
            font-variant-numeric: tabular-nums;
            flex-shrink: 0;
        }
        .wallet-position-card .pos-pnl.positive { color: #22c55e; }
        .wallet-position-card .pos-pnl.negative { color: #ef4444; }
        .wallet-col-empty {
            color: rgba(255,255,255,0.2);
            font-size: 0.75rem;
            text-align: center;
            padding: 20px 8px;
        }
        .wallet-entry-card {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 12px;
            background: rgba(255,255,255,0.025);
            border: 1px solid rgba(255,255,255,0.05);
            border-radius: 10px;
            border-left: 3px solid rgba(255,255,255,0.1);
            transition: background 0.15s;
        }
        .wallet-entry-card:hover { background: rgba(255,255,255,0.05); }
        .wallet-entry-card.cat-trade { border-left-color: #22c55e; }
        .wallet-entry-card.cat-backtest { border-left-color: #a78bfa; }
        .wallet-entry-card.cat-bet { border-left-color: #eab308; }
        .wallet-entry-card.cat-other { border-left-color: #3b82f6; }
        .wallet-entry-info {
            flex: 1;
            min-width: 0;
        }
        .wallet-entry-desc {
            font-size: 0.78rem;
            color: rgba(255,255,255,0.8);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .wallet-entry-meta {
            font-size: 0.65rem;
            color: rgba(255,255,255,0.25);
            margin-top: 2px;
            display: flex;
            gap: 8px;
            align-items: center;
        }
        .wallet-entry-category {
            font-size: 0.6rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            padding: 1px 6px;
            border-radius: 6px;
        }
        .wallet-entry-category.cat-trade { background: rgba(34,197,94,0.15); color: #22c55e; }
        .wallet-entry-category.cat-backtest { background: rgba(167,139,250,0.15); color: #a78bfa; }
        .wallet-entry-category.cat-bet { background: rgba(234,179,8,0.15); color: #eab308; }
        .wallet-entry-category.cat-other { background: rgba(59,130,246,0.15); color: #3b82f6; }
        .wallet-entry-pnl {
            font-size: 0.82rem;
            font-weight: 700;
            font-variant-numeric: tabular-nums;
            flex-shrink: 0;
        }
        .wallet-entry-pnl.positive { color: #22c55e; }
        .wallet-entry-pnl.negative { color: #ef4444; }
        .wallet-entry-pnl.zero { color: rgba(255,255,255,0.3); }
        .wallet-empty {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            flex: 1;
            color: rgba(255,255,255,0.25);
            font-size: 0.85rem;
            padding-top: 40px;
        }
        .wallet-empty .empty-icon { font-size: 2rem; margin-bottom: 8px; }

        /* Answers items container */
        .mind-answers-items {
            flex: 1;
            overflow-y: auto;
            padding: 12px 16px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .mind-answers-items.hidden { display: none; }

        /* Stored items container */
        .mind-stored-items {
            flex: 1;
            overflow-y: auto;
            padding: 12px 16px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .mind-stored-items.hidden { display: none; }
        .mind-stored-items-empty {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            flex: 1;
            color: var(--text-muted);
            font-size: 0.85rem;
            gap: 8px;
            padding: 40px 0;
        }
        .mind-stored-items-empty-icon { font-size: 2rem; opacity: 0.4; }

        /* Stored item card */
        .stored-item-card {
            background: rgba(15, 15, 25, 0.6);
            border: 1px solid rgba(255,255,255,0.06);
            border-radius: 12px;
            padding: 12px 14px;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }
        .stored-item-card:hover {
            background: rgba(20, 20, 35, 0.8);
            border-color: rgba(255,255,255,0.12);
        }
        .stored-item-card.type-question,
        .stored-item-card.type-approval {
            border-left: 3px solid #eab308;
        }
        .stored-item-card.type-simulation {
            border-left: 3px solid #8b5cf6;
        }
        .stored-item-card.type-agent_result {
            border-left: 3px solid #22c55e;
        }
        .stored-item-card.type-finding {
            border-left: 3px solid #3b82f6;
        }
        .stored-item-card.type-alert {
            border-left: 3px solid #ef4444;
        }
        .stored-item-card.type-goal_progress {
            border-left: 3px solid #eab308;
        }
        .stored-item-card.type-goal_complete {
            border-left: 3px solid #22c55e;
        }
        .stored-item-card.type-quick_task {
            border-left: 3px solid #14b8a6;
        }
        .stored-item-card-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 6px;
        }
        .stored-item-badge {
            font-size: 0.6rem;
            font-weight: 700;
            padding: 2px 8px;
            border-radius: 6px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .stored-item-badge.question { background: rgba(234,179,8,0.15); color: #eab308; }
        .stored-item-badge.approval { background: rgba(139,92,246,0.15); color: #a78bfa; }
        .stored-item-badge.simulation { background: rgba(139,92,246,0.15); color: #a78bfa; }
        .stored-item-badge.agent_result { background: rgba(34,197,94,0.15); color: #22c55e; }
        .stored-item-badge.finding { background: rgba(59,130,246,0.15); color: #3b82f6; }
        .stored-item-badge.alert { background: rgba(239,68,68,0.15); color: #ef4444; }
        .stored-item-badge.goal_progress { background: rgba(234,179,8,0.15); color: #eab308; }
        .stored-item-badge.goal_complete { background: rgba(34,197,94,0.15); color: #22c55e; }
        .stored-item-badge.quick_task { background: rgba(20,184,166,0.15); color: #14b8a6; }
        .stored-item-status-dot {
            width: 6px; height: 6px; border-radius: 50%;
            flex-shrink: 0;
        }
        .stored-item-status-dot.pending { background: #eab308; }
        .stored-item-status-dot.answered { background: #22c55e; }
        .stored-item-status-dot.viewed { background: #22c55e; }
        .stored-item-time {
            font-size: 0.68rem;
            color: var(--text-muted);
            margin-left: auto;
        }
        .stored-item-title {
            font-size: 0.82rem;
            color: var(--text-primary);
            margin-bottom: 4px;
            line-height: 1.3;
        }
        .stored-item-content-preview {
            font-size: 0.75rem;
            color: var(--text-secondary);
            line-height: 1.3;
            overflow: hidden;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
        }
        .stored-item-delete {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 22px; height: 22px;
            background: none;
            border: none;
            color: var(--text-muted);
            font-size: 0.9rem;
            cursor: pointer;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: all 0.15s;
        }
        .stored-item-card:hover .stored-item-delete { opacity: 1; }
        .stored-item-delete:hover { background: rgba(239,68,68,0.15); color: var(--red); }

        /* HITL secondary action buttons (Skip / Delay) */
        .hitl-secondary-actions {
            display: flex;
            gap: 8px;
            margin-top: 8px;
            padding: 0 16px 16px;
        }
        .hitl-action-btn.secondary {
            flex: 1;
            padding: 8px 16px;
            font-size: 0.78rem;
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            color: rgba(255,255,255,0.5);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .hitl-action-btn.secondary:hover {
            background: rgba(255,255,255,0.1);
            color: rgba(255,255,255,0.7);
        }
        .hitl-action-btn.secondary.delay:hover {
            border-color: rgba(234,179,8,0.4);
            color: #eab308;
        }

        /* Mind chat floating action button */
        .mind-fab-container {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 10;
        }
        .mind-fab-btn {
            width: 36px;
            height: 36px;
            border-radius: 10px;
            background: rgba(15, 10, 30, 0.85);
            border: 1px solid var(--border);
            color: var(--text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(12px);
        }
        .mind-fab-btn:hover {
            background: var(--bg-hover);
            color: var(--accent);
            border-color: var(--accent);
            transform: scale(1.05);
        }
        .mind-fab-btn.open {
            background: var(--accent);
            color: white;
            border-color: var(--accent);
        }
        .mind-fab-menu {
            position: absolute;
            top: 42px;
            right: 0;
            background: rgba(15, 10, 30, 0.95);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 6px;
            opacity: 0;
            visibility: hidden;
            transform: translateY(-8px) scale(0.95);
            transition: all 0.2s ease;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
            min-width: 170px;
            backdrop-filter: blur(20px);
        }
        .mind-fab-menu.open {
            opacity: 1;
            visibility: visible;
            transform: translateY(0) scale(1);
        }
        .mind-fab-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 12px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.15s ease;
            color: var(--text-secondary);
            font-size: 0.82rem;
            border: none;
            background: transparent;
            width: 100%;
            text-align: left;
        }
        .mind-fab-item:hover {
            background: var(--bg-hover);
            color: var(--text-primary);
        }
        .mind-fab-item svg { flex-shrink: 0; }
        .mind-fab-item.danger:hover {
            background: rgba(239, 68, 68, 0.1);
            color: var(--red);
        }

        .mind-chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 16px 18px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-height: 280px;
            min-height: 120px;
        }

        @media (min-width: 1024px) {
            .mind-chat-section {
                padding: 0;
            }
            .mind-chat-container {
                min-height: 0;
            }
            .mind-chat-messages {
                max-height: none;
                flex: 1;
            }
        }

        .mind-chat-messages::-webkit-scrollbar { width: 3px; }
        .mind-chat-messages::-webkit-scrollbar-track { background: transparent; }
        .mind-chat-messages::-webkit-scrollbar-thumb {
            background: rgba(139, 92, 246, 0.3);
            border-radius: 2px;
        }

        .mind-chat-input-bar {
            display: flex;
            gap: 10px;
            padding: 12px 16px;
            border-top: 1px solid rgba(255, 255, 255, 0.05);
            background: transparent;
            align-items: center;
        }

        .mind-chat-input-bar input {
            flex: 1;
            background: rgba(255, 255, 255, 0.06);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 24px;
            padding: 12px 20px;
            color: var(--text-primary);
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.9rem;
            font-weight: 500;
            outline: none;
            transition: all 0.25s ease;
        }

        .mind-chat-input-bar input:focus {
            border-color: var(--accent);
            background: rgba(139, 92, 246, 0.08);
            box-shadow: 0 0 20px rgba(139, 92, 246, 0.1);
        }

        .mind-chat-input-bar input::placeholder {
            color: var(--text-muted);
        }

        .mind-chat-send-btn {
            width: 42px;
            height: 42px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--accent) 0%, var(--accent-dark) 100%);
            border: none;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.25s ease;
            flex-shrink: 0;
        }

        .mind-chat-send-btn:hover {
            transform: scale(1.08);
            box-shadow: 0 0 20px rgba(139, 92, 246, 0.4);
        }

        .mind-chat-send-btn:active {
            transform: scale(0.95);
        }

        /* Chat message styles for centered chat */
        .mind-chat-msg {
            max-width: 80%;
            padding: 10px 16px;
            border-radius: 16px;
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.85rem;
            line-height: 1.5;
            animation: msg-fade-in 0.25s ease;
        }

        .mind-chat-msg.user {
            align-self: flex-end;
            background: linear-gradient(135deg, var(--accent) 0%, var(--accent-dark) 100%);
            color: white;
            border-bottom-right-radius: 4px;
        }

        .mind-chat-msg.cerebro {
            align-self: flex-start;
            background: rgba(255, 255, 255, 0.06);
            border: 1px solid rgba(255, 255, 255, 0.08);
            color: var(--text-primary);
            border-bottom-left-radius: 4px;
            cursor: pointer;
            transition: border-color 0.15s ease;
        }
        .mind-chat-msg.cerebro:hover {
            border-color: rgba(139,92,246,0.3);
        }

        /* Timestamps under messages */
        .msg-timestamp {
            font-size: 0.6rem;
            color: var(--text-muted);
            opacity: 0.5;
            margin-top: 2px;
            font-family: 'Space Mono', monospace;
            letter-spacing: 0.3px;
        }
        .mind-chat-msg.user + .msg-timestamp { align-self: flex-end; text-align: right; }
        .mind-chat-msg.cerebro + .msg-timestamp,
        .mind-chat-msg.card + .msg-timestamp,
        .mind-chat-msg.status + .msg-timestamp { align-self: flex-start; }

        /* Reply-to banner inside messages */
        .msg-reply-banner {
            font-size: 0.65rem;
            color: rgba(139,92,246,0.7);
            border-left: 2px solid rgba(139,92,246,0.4);
            padding: 2px 8px;
            margin-bottom: 6px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            max-width: 100%;
        }

        .mind-chat-msg.typing {
            background: rgba(139, 92, 246, 0.08);
            border: 1px solid rgba(139, 92, 246, 0.15);
        }

        .mind-chat-welcome {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 30px 20px;
            opacity: 0.5;
            text-align: center;
        }

        .mind-chat-welcome-icon { font-size: 1.5rem; margin-bottom: 8px; }
        .mind-chat-welcome-text { font-size: 0.85rem; color: var(--text-secondary); }
        .mind-chat-welcome-hint { font-size: 0.7rem; color: var(--text-muted); margin-top: 4px; }

        /* Status messages in chat (Cerebro's thoughts/voice) */
        .mind-chat-msg.status {
            align-self: flex-start;
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.06), rgba(59, 130, 246, 0.04));
            border: 1px solid rgba(139, 92, 246, 0.12);
            color: var(--text-secondary);
            font-size: 0.8rem;
            font-style: italic;
            opacity: 0.85;
            max-width: 90%;
            transition: opacity 0.3s ease;
        }

        .mind-chat-msg.status .status-label {
            font-family: 'Space Mono', monospace;
            font-size: 0.6rem;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 0.15em;
            margin-bottom: 4px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .mind-chat-msg.status .status-label .status-dot {
            width: 5px;
            height: 5px;
            background: var(--accent);
            border-radius: 50%;
            animation: voicePulse 1.5s ease-in-out infinite;
            box-shadow: 0 0 6px var(--accent);
        }

        /* Narration messages in chat (Cerebro live narration) */
        .mind-chat-msg.narration {
            align-self: flex-start;
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.10), rgba(99, 60, 200, 0.06));
            border: 1px solid rgba(139, 92, 246, 0.18);
            border-left: 2px solid rgba(139, 92, 246, 0.5);
            color: var(--text-secondary);
            font-size: 0.83rem;
            max-width: 92%;
        }
        .narration-label {
            font-family: 'Space Mono', monospace;
            font-size: 0.55rem;
            color: rgba(139, 92, 246, 0.8);
            text-transform: uppercase;
            letter-spacing: 0.18em;
            margin-bottom: 4px;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .narration-dot {
            width: 5px;
            height: 5px;
            background: #8b5cf6;
            border-radius: 50%;
            animation: voicePulse 1.5s ease-in-out infinite;
            box-shadow: 0 0 6px rgba(139, 92, 246, 0.6);
        }
        .narration-content {
            line-height: 1.45;
        }
        .mind-chat-load-more {
            text-align: center;
            color: var(--text-muted);
            font-size: 0.7rem;
            padding: 6px 0;
            cursor: pointer;
            opacity: 0.7;
        }
        .mind-chat-load-more:hover { opacity: 1; text-decoration: underline; }

        /* ==================== STRUCTURED CARD CHAT ==================== */
        .mind-chat-msg.card {
            align-self: flex-start;
            max-width: 95%;
            width: 95%;
            padding: 0;
            border-radius: 12px;
            border: 1px solid rgba(139, 92, 246, 0.18);
            background: rgba(15, 12, 35, 0.45);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            overflow: hidden;
            flex-shrink: 0;
            cursor: pointer;
            transition: border-color 0.15s ease;
        }
        .card-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 6px 14px;
            background: rgba(139, 92, 246, 0.06);
            border-bottom: 1px solid rgba(139, 92, 246, 0.12);
        }
        .card-header-left {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .card-phase {
            font-family: 'Space Mono', monospace;
            font-size: 0.6rem;
            text-transform: uppercase;
            letter-spacing: 0.12em;
            padding: 3px 10px;
            border-radius: 6px;
            font-weight: 600;
        }
        .card-phase.observe { background: rgba(59, 130, 246, 0.15); color: #60a5fa; }
        .card-phase.orient  { background: rgba(234, 179, 8, 0.15); color: #facc15; }
        .card-phase.decide  { background: rgba(139, 92, 246, 0.15); color: #a78bfa; }
        .card-phase.act     { background: rgba(34, 197, 94, 0.15); color: #4ade80; }
        .card-phase.reflect { background: rgba(236, 72, 153, 0.15); color: #f472b6; }
        .card-phase.idle    { background: rgba(148, 163, 184, 0.12); color: #94a3b8; }
        /* Message type badges  new color spectrum */
        .card-phase.thought   { background: rgba(167, 139, 250, 0.15); color: #a78bfa; }
        .card-phase.action    { background: rgba(34, 211, 238, 0.15); color: #22d3ee; }
        .card-phase.message   { background: rgba(251, 113, 133, 0.15); color: #fb7185; }
        .card-phase.alert     { background: rgba(248, 113, 113, 0.15); color: #f87171; }
        .card-phase.summary   { background: rgba(52, 211, 153, 0.15); color: #34d399; }
        .card-phase.question  { background: rgba(251, 191, 36, 0.15); color: #fbbf24; }
        .card-phase.system    { background: rgba(100, 116, 139, 0.15); color: #64748b; }
        .card-phase.progress  { background: rgba(129, 140, 248, 0.15); color: #818cf8; }
        .card-timestamp {
            font-family: 'Space Mono', monospace;
            font-size: 0.5rem;
            color: var(--text-muted);
            letter-spacing: 0.05em;
        }
        .card-live-dot {
            width: 5px;
            height: 5px;
            background: #8b5cf6;
            border-radius: 50%;
            animation: voicePulse 1.5s ease-in-out infinite;
            box-shadow: 0 0 6px rgba(139, 92, 246, 0.6);
        }
        .card-body {
            padding: 10px 14px;
        }
        .card-content {
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.85rem;
            line-height: 1.55;
            color: var(--text-primary);
        }
        /* Reuse agent-output-rendered patterns for card markdown */
        .card-content h1,
        .card-content h2,
        .card-content h3 {
            color: var(--text-primary);
            margin-top: 0.8em;
            margin-bottom: 0.3em;
        }
        .card-content h1:first-child,
        .card-content h2:first-child,
        .card-content h3:first-child { margin-top: 0; }
        .card-content h1 { font-size: 1.1rem; }
        .card-content h2 { font-size: 1rem; color: var(--accent); }
        .card-content h3 { font-size: 0.9rem; }
        .card-content p { margin-bottom: 0.6em; line-height: 1.55; }
        .card-content ul, .card-content ol { margin-left: 16px; margin-bottom: 0.6em; }
        .card-content li { margin-bottom: 0.3em; }
        .card-content code {
            background: var(--bg-elevated);
            padding: 1px 5px;
            border-radius: 3px;
            font-family: 'SF Mono', monospace;
            font-size: 0.82em;
            color: var(--accent);
        }
        .card-content pre {
            background: var(--bg-primary);
            padding: 10px;
            border-radius: 6px;
            overflow-x: auto;
            margin-bottom: 0.6em;
        }
        .card-content pre code { background: none; padding: 0; color: var(--text-primary); }
        .card-content blockquote {
            border-left: 2px solid rgba(139, 92, 246, 0.4);
            padding-left: 10px;
            color: var(--text-muted);
            margin: 0.5em 0;
            font-style: italic;
        }
        .card-content strong { color: var(--text-primary); }
        .card-content a { color: var(--accent-light); text-decoration: underline; }

        /* ===== CARD TYPE STYLES  New Color Spectrum ===== */
        .mind-chat-msg.card {
            background: rgba(12, 12, 20, 0.85);
            backdrop-filter: blur(8px);
            border-left: 3px solid rgba(100, 100, 130, 0.2);
        }
        .mind-chat-msg.card.idle-card {
            opacity: 0.65;
            border-left-color: rgba(148, 163, 184, 0.3);
            background: rgba(12, 12, 20, 0.6);
        }
        .mind-chat-msg.card.idle-card .card-live-dot { background: #94a3b8; box-shadow: 0 0 4px rgba(148, 163, 184, 0.4); }
        .mind-chat-msg.card.thought-card {
            border-left-color: rgba(167, 139, 250, 0.6);
            background: rgba(167, 139, 250, 0.05);
        }
        .mind-chat-msg.card.thought-card .card-header { border-bottom-color: rgba(167, 139, 250, 0.12); }
        .mind-chat-msg.card.thought-card .card-live-dot { background: #a78bfa; box-shadow: 0 0 6px rgba(167, 139, 250, 0.6); }
        .mind-chat-msg.card.action-card {
            border-left-color: rgba(34, 211, 238, 0.6);
            background: rgba(34, 211, 238, 0.04);
        }
        .mind-chat-msg.card.action-card .card-header { border-bottom-color: rgba(34, 211, 238, 0.12); }
        .mind-chat-msg.card.action-card .card-live-dot { background: #22d3ee; box-shadow: 0 0 6px rgba(34, 211, 238, 0.6); }
        .mind-chat-msg.card.message-card {
            border-left-color: rgba(251, 113, 133, 0.6);
            background: rgba(251, 113, 133, 0.05);
        }
        .mind-chat-msg.card.message-card .card-header { border-bottom-color: rgba(251, 113, 133, 0.12); }
        .mind-chat-msg.card.message-card .card-live-dot { background: #fb7185; box-shadow: 0 0 6px rgba(251, 113, 133, 0.6); }
        .mind-chat-msg.card.summary-card {
            border-left-color: rgba(52, 211, 153, 0.6);
            background: rgba(52, 211, 153, 0.05);
        }
        .mind-chat-msg.card.summary-card .card-header { border-bottom-color: rgba(52, 211, 153, 0.12); }
        .mind-chat-msg.card.summary-card .card-live-dot { background: #34d399; box-shadow: 0 0 6px rgba(52, 211, 153, 0.6); }
        .mind-chat-msg.card.question-card {
            border-left-color: rgba(251, 191, 36, 0.6);
            background: rgba(251, 191, 36, 0.04);
        }
        .mind-chat-msg.card.question-card .card-header { border-bottom-color: rgba(251, 191, 36, 0.15); }
        .mind-chat-msg.card.question-card .card-live-dot { background: #fbbf24; box-shadow: 0 0 6px rgba(251, 191, 36, 0.6); }
        .question-card .card-body { padding-bottom: 8px; }
        .question-card-context {
            font-size: 0.75rem; color: var(--text-muted); font-style: italic;
            margin-top: 6px; padding-left: 10px;
            border-left: 2px solid rgba(251, 191, 36, 0.3); line-height: 1.4;
        }
        .question-reply-btn {
            display: inline-flex; align-items: center; gap: 5px;
            margin-top: 10px; padding: 5px 12px;
            background: rgba(251, 191, 36, 0.12); border: 1px solid rgba(251, 191, 36, 0.3);
            border-radius: 8px; color: #fbbf24;
            font-family: 'Rajdhani', sans-serif; font-size: 0.75rem; font-weight: 600;
            cursor: pointer; transition: all 0.2s ease;
        }
        .question-reply-btn:hover { background: rgba(251, 191, 36, 0.22); border-color: rgba(251, 191, 36, 0.5); }

        /* Observation cards */
        .mind-chat-msg.card.observation-card {
            border-left-color: rgba(251, 191, 36, 0.6);
            background: rgba(251, 191, 36, 0.04);
        }
        .mind-chat-msg.card.observation-card .card-header { border-bottom-color: rgba(251, 191, 36, 0.15); }
        .mind-chat-msg.card.observation-card .card-live-dot { background: #fbbf24; box-shadow: 0 0 6px rgba(251, 191, 36, 0.6); }
        .observation-screenshot { max-width: 100%; border-radius: 8px; cursor: pointer; margin-top: 8px; transition: transform 0.15s; }
        .observation-screenshot:hover { transform: scale(1.02); }

        /* Image upload */
        .image-upload-preview { display: none; align-items: center; gap: 8px; padding: 6px 12px; background: rgba(255,255,255,0.03); border-radius: 8px; margin-bottom: 4px; }
        .image-upload-preview.has-image { display: flex; }
        .upload-thumb { width: 48px; height: 48px; border-radius: 6px; object-fit: cover; border: 1px solid rgba(255,255,255,0.1); }
        .upload-remove-btn { width: 20px; height: 20px; border-radius: 50%; background: #ef4444; color: white; border: none; cursor: pointer; font-size: 12px; display: flex; align-items: center; justify-content: center; }
        .chat-image-thumb { max-width: 200px; max-height: 150px; border-radius: 8px; cursor: pointer; margin-top: 6px; }
        .drag-over { border: 2px dashed rgba(139, 92, 246, 0.5) !important; background: rgba(139, 92, 246, 0.05) !important; }
        .mind-attach-btn { background: none; border: none; color: rgba(255,255,255,0.4); cursor: pointer; padding: 4px; display: flex; align-items: center; }
        .mind-attach-btn:hover { color: rgba(255,255,255,0.7); }

        /* Image modal */
        .image-modal-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.9); z-index: 10000; display: flex; align-items: center; justify-content: center; cursor: pointer; }
        .image-modal-overlay img { max-width: 95vw; max-height: 95vh; border-radius: 8px; }

        .mind-chat-msg.card.alert-card {
            border-left-color: rgba(248, 113, 113, 0.6);
            background: rgba(248, 113, 113, 0.05);
        }
        .mind-chat-msg.card.alert-card .card-header { border-bottom-color: rgba(248, 113, 113, 0.15); }
        .mind-chat-msg.card.alert-card .card-live-dot { background: #f87171; box-shadow: 0 0 6px rgba(248, 113, 113, 0.6); }
        .mind-chat-msg.card.system-card {
            border-left-color: rgba(100, 116, 139, 0.6);
            background: rgba(100, 116, 139, 0.04);
        }
        .mind-chat-msg.card.system-card .card-header { border-bottom-color: rgba(100, 116, 139, 0.12); }
        .mind-chat-msg.card.progress-card {
            border-left-color: rgba(129, 140, 248, 0.6);
            background: rgba(129, 140, 248, 0.04);
        }
        .mind-chat-msg.card.progress-card .card-header { border-bottom-color: rgba(129, 140, 248, 0.12); }
        .mind-chat-msg.card.progress-card .card-live-dot { background: #818cf8; box-shadow: 0 0 6px rgba(129, 140, 248, 0.6); }

        /* ===== DIRECTIVE PROGRESS BAR ===== */
        .directive-progress-bar {
            display: flex; align-items: center; gap: 10px;
            padding: 10px 14px; margin: 6px 0;
            background: rgba(129, 140, 248, 0.06);
            border: 1px solid rgba(129, 140, 248, 0.2);
            border-radius: 10px; cursor: pointer;
            transition: all 0.25s ease; animation: msg-fade-in 0.3s ease;
        }
        .directive-progress-bar:hover { background: rgba(129, 140, 248, 0.1); border-color: rgba(129, 140, 248, 0.35); }
        .progress-bar-info { flex: 1; min-width: 0; }
        .progress-bar-directive { font-family: 'Rajdhani', sans-serif; font-size: 0.78rem; font-weight: 600; color: var(--text-primary); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .progress-bar-step { font-family: 'Space Mono', monospace; font-size: 0.6rem; color: #818cf8; margin-top: 2px; letter-spacing: 0.05em; }
        .progress-bar-track { flex: 0 0 120px; height: 4px; background: rgba(100, 100, 130, 0.3); border-radius: 2px; overflow: hidden; }
        .progress-bar-fill { height: 100%; background: linear-gradient(90deg, #818cf8, #a78bfa); border-radius: 2px; transition: width 0.4s ease; box-shadow: 0 0 6px rgba(129, 140, 248, 0.4); }
        .progress-phase-dots { display: flex; gap: 4px; align-items: center; }
        .progress-phase-dot { width: 6px; height: 6px; border-radius: 50%; background: rgba(100, 100, 130, 0.4); transition: all 0.3s ease; }
        .progress-phase-dot.active { background: #818cf8; box-shadow: 0 0 6px rgba(129, 140, 248, 0.6); }
        .progress-phase-dot.done { background: #34d399; }
        /* ===== PROGRESS MODAL ===== */
        .progress-modal-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.65); backdrop-filter: blur(4px); z-index: 9999; display: flex; align-items: center; justify-content: center; animation: msg-fade-in 0.2s ease; }
        .progress-modal { width: 80vw; max-width: 800px; max-height: 80vh; background: rgba(12,12,20,0.95); border: 1px solid rgba(129,140,248,0.25); border-radius: 14px; display: flex; flex-direction: column; box-shadow: 0 20px 60px rgba(0,0,0,0.5); }
        .progress-modal-header { display: flex; align-items: center; justify-content: space-between; padding: 16px 20px; border-bottom: 1px solid rgba(129,140,248,0.15); }
        .progress-modal-title { font-family: 'Rajdhani', sans-serif; font-size: 1rem; font-weight: 600; color: var(--text-primary); flex: 1; min-width: 0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .progress-modal-meta { font-family: 'Space Mono', monospace; font-size: 0.6rem; color: #818cf8; margin-left: 12px; white-space: nowrap; }
        .progress-modal-close { background: none; border: none; color: var(--text-muted); font-size: 1.2rem; cursor: pointer; padding: 0 0 0 12px; line-height: 1; }
        .progress-modal-close:hover { color: var(--text-primary); }
        .progress-modal-body { flex: 1; overflow-y: auto; padding: 12px 20px; }
        .progress-modal-entry { display: flex; gap: 10px; padding: 6px 0; border-bottom: 1px solid rgba(100,100,130,0.1); animation: msg-fade-in 0.2s ease; }
        .progress-modal-entry-time { font-family: 'Space Mono', monospace; font-size: 0.55rem; color: var(--text-muted); white-space: nowrap; padding-top: 2px; flex-shrink: 0; }
        .progress-modal-entry-badge { flex-shrink: 0; }
        .progress-modal-entry-content { font-family: 'Rajdhani', sans-serif; font-size: 0.8rem; color: var(--text-secondary); line-height: 1.4; min-width: 0; }
        /* ===== CREDENTIAL EXPIRY MODAL ===== */
        .cred-modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.75); backdrop-filter: blur(6px); z-index: 10001; display: flex; align-items: center; justify-content: center; animation: msg-fade-in 0.2s ease; }
        .cred-modal { width: 90vw; max-width: 400px; background: rgba(12,12,20,0.97); border: 1px solid rgba(239,68,68,0.35); border-radius: 16px; padding: 28px 24px; text-align: center; box-shadow: 0 20px 60px rgba(0,0,0,0.5), 0 0 40px rgba(239,68,68,0.08); }
        .cred-modal-icon { font-size: 2.2rem; margin-bottom: 12px; }
        .cred-modal-title { font-family: 'Rajdhani', sans-serif; font-size: 1.15rem; font-weight: 700; color: var(--text-primary); margin-bottom: 8px; }
        .cred-modal-desc { font-size: 0.82rem; color: var(--text-muted); line-height: 1.5; margin-bottom: 20px; }
        .cred-modal-actions { display: flex; gap: 10px; justify-content: center; }
        .cred-modal-actions button { padding: 10px 20px; border-radius: 10px; font-size: 0.85rem; font-weight: 600; cursor: pointer; transition: all 0.2s; border: 1px solid var(--border); }
        .cred-modal-btn-login { background: var(--accent-gradient); color: #fff; border-color: var(--accent) !important; }
        .cred-modal-btn-login:hover { opacity: 0.85; transform: translateY(-1px); }
        .cred-modal-btn-dismiss { background: transparent; color: var(--text-muted); }
        .cred-modal-btn-dismiss:hover { background: var(--bg-hover); color: var(--text-primary); }
        .cred-modal-status { font-size: 0.78rem; color: var(--text-muted); margin-top: 14px; min-height: 20px; }
        /* ===== GUIDE MODAL ===== */
        .guide-modal-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.7); backdrop-filter: blur(4px); z-index: 10000; display: flex; align-items: center; justify-content: center; animation: msg-fade-in 0.2s ease; }
        .guide-modal { width: 85vw; max-width: 700px; max-height: 85vh; background: rgba(12,12,20,0.97); border: 1px solid rgba(139,92,246,0.2); border-radius: 14px; display: flex; flex-direction: column; box-shadow: 0 20px 60px rgba(0,0,0,0.5); }
        .guide-modal-header { display: flex; align-items: center; justify-content: space-between; padding: 18px 24px; border-bottom: 1px solid rgba(139,92,246,0.15); }
        .guide-modal-header h2 { font-family: 'Rajdhani', sans-serif; font-size: 1.2rem; font-weight: 700; color: var(--text-primary); margin: 0; }
        .guide-modal-close { background: none; border: none; color: var(--text-muted); font-size: 1.3rem; cursor: pointer; line-height: 1; }
        .guide-modal-close:hover { color: var(--text-primary); }
        .guide-modal-body { flex: 1; overflow-y: auto; padding: 20px 24px; }
        .guide-section { margin-bottom: 28px; }
        .guide-section h3 { font-family: 'Rajdhani', sans-serif; font-size: 1rem; font-weight: 700; color: var(--accent-light); margin: 0 0 8px 0; border-bottom: 1px solid rgba(139,92,246,0.15); padding-bottom: 6px; }
        .guide-section p, .guide-section li { font-family: 'Inter', 'Rajdhani', sans-serif; font-size: 0.82rem; color: var(--text-secondary); line-height: 1.6; margin: 4px 0; }
        .guide-section ul { padding-left: 18px; margin: 6px 0; }
        .guide-color-row { display: flex; align-items: center; gap: 10px; padding: 4px 0; }
        .guide-color-swatch { width: 14px; height: 14px; border-radius: 3px; flex-shrink: 0; }
        .guide-color-label { font-family: 'Space Mono', monospace; font-size: 0.7rem; color: var(--text-secondary); flex: 0 0 100px; }
        .guide-color-desc { font-family: 'Rajdhani', sans-serif; font-size: 0.78rem; color: var(--text-muted); }
        .guide-nav { display: flex; flex-wrap: wrap; gap: 6px; margin-bottom: 18px; }
        .guide-nav-btn { padding: 4px 10px; background: rgba(139,92,246,0.08); border: 1px solid rgba(139,92,246,0.2); border-radius: 6px; color: var(--accent-light); font-family: 'Space Mono', monospace; font-size: 0.6rem; cursor: pointer; transition: all 0.2s ease; }
        .guide-nav-btn:hover { background: rgba(139,92,246,0.15); border-color: rgba(139,92,246,0.4); }

        /* Collapsible card content */
        .card-content.collapsed {
            max-height: 120px;
            overflow: hidden;
            position: relative;
        }
        .card-content.collapsed::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 40px;
            background: linear-gradient(transparent, rgba(15, 12, 35, 0.6));
            pointer-events: none;
        }
        .card-expand-btn {
            display: block;
            width: 100%;
            text-align: center;
            background: none;
            border: none;
            color: var(--accent-light);
            font-family: 'Space Mono', monospace;
            font-size: 0.6rem;
            cursor: pointer;
            padding: 4px 0;
            letter-spacing: 0.1em;
        }
        .card-expand-btn:hover { text-decoration: underline; }

        /* Reply context bar */
        .reply-context-bar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 6px 14px;
            background: rgba(234, 179, 8, 0.08);
            border: 1px solid rgba(234, 179, 8, 0.2);
            border-radius: 8px;
            margin-bottom: 6px;
            animation: msg-fade-in 0.2s ease;
        }
        .reply-context-text {
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.75rem;
            color: #facc15;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            flex: 1;
        }
        .reply-context-close {
            background: none;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            font-size: 1rem;
            padding: 0 0 0 10px;
            line-height: 1;
        }
        .reply-context-close:hover { color: var(--text-primary); }

        /* Chat page narration style */
        .chat-message.narration {
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.08), rgba(99, 60, 200, 0.04));
            border-left: 2px solid rgba(139, 92, 246, 0.5);
        }
        .chat-message.narration .narration-label {
            font-family: 'Space Mono', monospace;
            font-size: 0.55rem;
            color: rgba(139, 92, 246, 0.8);
            text-transform: uppercase;
            letter-spacing: 0.18em;
            margin-bottom: 2px;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .chat-message.narration .narration-dot {
            width: 5px;
            height: 5px;
            background: #8b5cf6;
            border-radius: 50%;
            animation: voicePulse 1.5s ease-in-out infinite;
            box-shadow: 0 0 6px rgba(139, 92, 246, 0.6);
        }
        .chat-message.narration .narration-content {
            font-size: 0.83rem;
            line-height: 1.45;
        }

        /* ===== HIDE VOICE STREAM & DIRECTIVE WHISPER ===== */
        .voice-stream { display: none; }
        .directive-whisper { display: none; }

        /* ===== CONSCIOUSNESS CHAMBER in column  exact nav-orb replica (1.5x) ===== */
        @media (min-width: 1024px) {
            .consciousness-chamber {
                max-width: none;
                padding: 6px 0 2px;
                flex-shrink: 0;
            }
            /* Kill the 800px ambient glow on desktop */
            .consciousness-chamber::before { display: none !important; }
            /* Hide all decorative layers  we rebuild as nav-orb style */
            .orbital-system,
            .orb-particles,
            .orb-aura { display: none !important; }

            /* Container  like nav-orb-container (36px  54px) */
            .consciousness-orb {
                width: 54px !important;
                height: 54px !important;
                background: none !important;
                box-shadow: none !important;
                border-radius: 50%;
                display: flex;
                align-items: center;
                justify-content: center;
                position: relative;
            }
            .consciousness-orb:hover {
                transform: scale(1.08);
            }
            /* Ring 1  like nav-orb-ring:nth-child(1) (32px  48px) */
            .consciousness-orb::before {
                content: '';
                position: absolute;
                width: 48px;
                height: 48px;
                border-radius: 50%;
                border: 1.5px solid transparent;
                border-top-color: rgba(139, 92, 246, 0.6);
                border-right-color: rgba(139, 92, 246, 0.3);
                animation: ringRotate 3s linear infinite;
                pointer-events: none;
            }
            /* Ring 2  like nav-orb-ring:nth-child(2) (36px  54px) */
            .consciousness-orb::after {
                content: '';
                position: absolute;
                width: 54px;
                height: 54px;
                border-radius: 50%;
                border: 1.5px solid transparent;
                border-top-color: rgba(99, 102, 241, 0.4);
                border-right-color: rgba(99, 102, 241, 0.2);
                animation: ringRotate 4s linear infinite reverse;
                pointer-events: none;
            }

            /* Main sphere  logo image (42px on mobile) */
            .orb-essence.orb-logo-img {
                width: 42px !important;
                height: 42px !important;
                position: absolute !important;
                top: 50% !important;
                left: 50% !important;
                transform: translate(-50%, -50%) !important;
                border-radius: 50% !important;
                object-fit: cover !important;
                filter: drop-shadow(0 0 10px rgba(167, 139, 250, 0.6))
                        drop-shadow(0 0 20px rgba(139, 92, 246, 0.4)) !important;
                animation: navOrbBreathe 4s ease-in-out infinite !important;
                opacity: 1 !important;
                z-index: 1;
            }

            /* Dormant state  deep sleep, faint pulse */
            .consciousness-orb.dormant .orb-essence {
                opacity: 0.2 !important;
                filter: grayscale(0.5) brightness(0.5) !important;
                animation: navOrbBreathe 8s ease-in-out infinite !important;
            }
            .consciousness-orb.dormant .orb-inner-light {
                opacity: 0.15 !important;
            }
            .consciousness-orb.dormant::before,
            .consciousness-orb.dormant::after {
                opacity: 0.15;
                animation-duration: 8s !important;
            }

            /* Active state  bright, faster rings */
            .consciousness-orb.active .orb-essence,
            .consciousness-orb.autonomous .orb-essence {
                opacity: 1 !important;
                filter: drop-shadow(0 0 10px rgba(167, 139, 250, 0.6))
                        drop-shadow(0 0 20px rgba(139, 92, 246, 0.4)) !important;
            }
            .consciousness-orb.active::before,
            .consciousness-orb.autonomous::before {
                opacity: 1;
                animation-duration: 2s;
            }
            .consciousness-orb.active::after,
            .consciousness-orb.autonomous::after {
                opacity: 1;
                animation-duration: 2.5s;
            }
            /* Phase: acting  amber rings like nav-orb active-agents */
            .consciousness-orb.acting::before,
            .consciousness-orb.acting::after {
                border-top-color: rgba(245, 158, 11, 0.6) !important;
                animation-duration: 1.5s !important;
            }
            .consciousness-orb.acting .orb-essence {
                filter: drop-shadow(0 0 15px rgba(245, 158, 11, 0.5))
                        drop-shadow(0 0 25px rgba(245, 158, 11, 0.3))
                        hue-rotate(-50deg) saturate(1.6) !important;
            }
            /* Phase: observing  cyan rings */
            .consciousness-orb.observing::before,
            .consciousness-orb.observing::after {
                border-top-color: rgba(34, 211, 238, 0.6) !important;
            }
            /* Phase: thinking/deciding  default purple (no override needed) */

            /* ===== ORB MOOD STATES (Tamagotchi) ===== */
            @keyframes orbShake {
                0%, 100% { transform: translateX(0); }
                20% { transform: translateX(-2px) rotate(-1deg); }
                40% { transform: translateX(2px) rotate(1deg); }
                60% { transform: translateX(-1px) rotate(-0.5deg); }
                80% { transform: translateX(1px) rotate(0.5deg); }
            }
            @keyframes orbPulseExcited {
                0%, 100% { transform: scale(1); }
                50% { transform: scale(1.08); }
            }
            @keyframes amberFlicker {
                0%, 100% { opacity: 1; }
                30% { opacity: 0.7; }
                60% { opacity: 0.9; }
                80% { opacity: 0.65; }
            }

            /* Excited: bright green aura, fast orbits, pulsing */
            .consciousness-orb.mood-excited .orb-essence {
                filter: drop-shadow(0 0 18px rgba(74, 222, 128, 0.7))
                        drop-shadow(0 0 35px rgba(74, 222, 128, 0.4))
                        hue-rotate(80deg) brightness(1.1) !important;
                animation: orbPulseExcited 1s ease-in-out infinite !important;
            }
            .consciousness-orb.mood-excited::before,
            .consciousness-orb.mood-excited::after {
                border-top-color: rgba(74, 222, 128, 0.7) !important;
                animation-duration: 1.2s !important;
            }

            /* Happy: warm purple glow, gentle pulse */
            .consciousness-orb.mood-happy .orb-essence {
                filter: drop-shadow(0 0 16px rgba(167, 139, 250, 0.8))
                        drop-shadow(0 0 30px rgba(139, 92, 246, 0.5))
                        brightness(1.1) !important;
                animation: navOrbBreathe 2.5s ease-in-out infinite !important;
            }
            .consciousness-orb.mood-happy::before,
            .consciousness-orb.mood-happy::after {
                border-top-color: rgba(167, 139, 250, 0.7) !important;
                animation-duration: 2s !important;
            }

            /* Content: default purple  no overrides */

            /* Bored: dim, slow orbits, reduced opacity */
            .consciousness-orb.mood-bored .orb-essence {
                opacity: 0.55 !important;
                filter: brightness(0.7)
                        drop-shadow(0 0 10px rgba(167, 139, 250, 0.3)) !important;
                animation: navOrbBreathe 7s ease-in-out infinite !important;
            }
            .consciousness-orb.mood-bored::before,
            .consciousness-orb.mood-bored::after {
                opacity: 0.4;
                animation-duration: 6s !important;
            }

            /* Lonely: very dim, near-sleeping */
            .consciousness-orb.mood-lonely .orb-essence {
                opacity: 0.35 !important;
                filter: grayscale(0.2) brightness(0.55)
                        drop-shadow(0 0 10px rgba(167, 139, 250, 0.2)) !important;
                animation: navOrbBreathe 8s ease-in-out infinite !important;
            }
            .consciousness-orb.mood-lonely::before,
            .consciousness-orb.mood-lonely::after {
                opacity: 0.25;
                animation-duration: 8s !important;
            }

            /* Confused: amber flicker (HITL pending) */
            .consciousness-orb.mood-confused .orb-essence {
                filter: drop-shadow(0 0 14px rgba(245, 158, 11, 0.6))
                        drop-shadow(0 0 25px rgba(245, 158, 11, 0.3))
                        hue-rotate(-40deg) saturate(1.3) !important;
                animation: amberFlicker 1.5s ease-in-out infinite !important;
            }
            .consciousness-orb.mood-confused::before,
            .consciousness-orb.mood-confused::after {
                border-top-color: rgba(245, 158, 11, 0.6) !important;
            }

            /* Frustrated: red tinge, erratic shake */
            .consciousness-orb.mood-frustrated .orb-essence {
                filter: drop-shadow(0 0 14px rgba(239, 68, 68, 0.6))
                        drop-shadow(0 0 25px rgba(239, 68, 68, 0.3))
                        hue-rotate(-80deg) saturate(1.5) !important;
                animation: orbShake 0.6s ease-in-out infinite !important;
            }
            .consciousness-orb.mood-frustrated::before,
            .consciousness-orb.mood-frustrated::after {
                border-top-color: rgba(239, 68, 68, 0.6) !important;
                animation-duration: 1.2s !important;
            }

            .consciousness-status {
                margin-top: 4px;
            }
            .consciousness-status .status-text {
                font-size: 0.65rem !important;
                letter-spacing: 0.15em;
            }
            .consciousness-controls { margin-top: 8px; gap: 8px; }
            .toggle-track { width: 44px; height: 24px; border-radius: 12px; }
            .toggle-thumb { width: 18px; height: 18px; }
            .autonomy-toggle input:checked + .toggle-track .toggle-thumb { left: 22px; }
        }

        /* ===== ORB TABBED PANEL ===== */
        .orb-tabbed-panel {
            width: 100%;
            flex: 1;
            min-height: 0;
            display: flex;
            flex-direction: column;
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.06);
            border-radius: 16px;
            overflow: hidden;
        }

        .orb-tabs {
            display: flex;
            border-bottom: 1px solid rgba(255, 255, 255, 0.06);
            flex-shrink: 0;
        }

        .orb-tab {
            flex: 1;
            padding: 10px 4px;
            background: none;
            border: none;
            color: var(--text-muted);
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.72rem;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
            transition: all 0.2s ease;
            border-bottom: 2px solid transparent;
            white-space: nowrap;
        }

        .orb-tab:hover {
            color: var(--text-secondary);
            background: transparent;
        }

        .orb-tab.active {
            color: var(--accent-light);
            border-bottom-color: var(--accent);
            background: transparent;
        }

        .orb-tab svg {
            flex-shrink: 0;
        }

        .orb-tab-icon {
            font-size: 0.7rem;
            flex-shrink: 0;
        }

        .orb-tab-badge {
            font-family: 'Space Mono', monospace;
            font-size: 0.55rem;
            font-weight: 700;
            padding: 1px 5px;
            border-radius: 6px;
            background: rgba(139, 92, 246, 0.2);
            color: var(--accent-light);
            min-width: 14px;
            text-align: center;
        }

        .orb-tab-badge.green {
            background: rgba(34, 197, 94, 0.2);
            color: #4ade80;
        }

        .orb-tab-content {
            flex: 1;
            min-height: 0;
            overflow: hidden;
            position: relative;
        }

        .orb-tab-pane {
            display: none;
            flex-direction: column;
            height: 100%;
            overflow-y: auto;
        }

        .orb-tab-pane.active {
            display: flex;
        }

        .orb-tab-pane::-webkit-scrollbar { width: 3px; }
        .orb-tab-pane::-webkit-scrollbar-track { background: transparent; }
        .orb-tab-pane::-webkit-scrollbar-thumb { background: rgba(139, 92, 246, 0.3); border-radius: 2px; }

        /* ===== VERTICAL MONITOR LAYOUT (1400px+ height) ===== */
        .orb-pane-header {
            display: none;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.7rem;
            font-weight: 700;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 1px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.04);
            background: rgba(139, 92, 246, 0.03);
            flex-shrink: 0;
        }
        .orb-pane-header svg { opacity: 0.5; }

        @media (min-height: 1400px) and (min-width: 1024px) {
            .orb-tabs { display: none !important; }
            .orb-tab-content {
                display: flex !important;
                flex-direction: column;
                gap: 2px;
                overflow-y: auto;
            }
            .orb-tab-pane {
                display: flex !important;
                flex-direction: column;
                height: auto;
                overflow-y: auto;
                border-bottom: 1px solid rgba(255, 255, 255, 0.04);
                flex-shrink: 0;
            }
            #orb-pane-info { max-height: 280px; }
            #orb-pane-command { flex: 1 1 auto; min-height: 200px; flex-shrink: 1 !important; }
            #orb-pane-completed { max-height: 200px; }
            #orb-pane-browser { max-height: 400px; }
            .mind-col-orb {
                width: clamp(420px, 35vw, 600px) !important;
            }
            .orb-pane-header { display: flex !important; }
            .orb-tabbed-panel .agents-status-panel {
                flex-shrink: 0;
                margin-top: auto;
            }
        }

        /* ===== CEREBRO PROGRESS BAR ===== */
        .cerebro-progress-bar {
            display: none;
            flex-direction: column;
            padding: 8px 14px;
            background: rgba(139, 92, 246, 0.06);
            border-bottom: 1px solid rgba(139, 92, 246, 0.15);
            flex-shrink: 0;
        }
        .cerebro-progress-bar.active { display: flex; }
        .progress-bar-track {
            flex: 1;
            height: 4px;
            background: rgba(255, 255, 255, 0.06);
            border-radius: 2px;
            overflow: hidden;
        }
        .progress-bar-inner {
            height: 100%;
            width: 20%;
            background: linear-gradient(90deg, #8b5cf6, #a78bfa);
            border-radius: 2px;
            transition: width 0.5s ease;
            animation: progressPulse 2s ease-in-out infinite;
        }
        @keyframes progressPulse {
            0%, 100% { opacity: 0.7; }
            50% { opacity: 1; }
        }
        .progress-info {
            display: flex;
            flex-direction: column;
            gap: 1px;
            min-width: 0;
            flex: 2;
        }
        .progress-status {
            font-family: 'Space Mono', monospace;
            font-size: 0.68rem;
            color: rgba(255, 255, 255, 0.7);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .progress-elapsed {
            font-family: 'Space Mono', monospace;
            font-size: 0.6rem;
            color: rgba(255, 255, 255, 0.3);
        }
        .progress-bar-header {
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
            width: 100%;
        }
        .progress-expand-icon {
            font-size: 0.6rem;
            color: rgba(255, 255, 255, 0.4);
            transition: transform 0.2s ease;
            flex-shrink: 0;
            user-select: none;
        }
        .progress-expand-icon.expanded {
            transform: rotate(90deg);
        }
        .progress-live-output {
            display: none;
            max-height: 300px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 0 0 8px 8px;
            padding: 8px 12px;
            margin-top: 4px;
            scrollbar-width: thin;
            scrollbar-color: rgba(139, 92, 246, 0.3) transparent;
        }
        .progress-live-output.visible { display: block; }
        .progress-live-output-inner {
            font-family: 'Space Mono', monospace;
            font-size: 0.65rem;
            color: rgba(255, 255, 255, 0.6);
            line-height: 1.5;
        }
        .progress-live-output-inner p {
            margin: 2px 0;
            padding: 2px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.04);
        }
        .progress-live-output-inner p.tool-line {
            color: rgba(139, 92, 246, 0.7);
            font-style: italic;
        }

        /* ===== SUMMARY MESSAGE STYLING ===== */
        .mind-chat-msg.cerebro.summary-msg {
            border-left: 3px solid rgba(34, 197, 94, 0.6);
            background: rgba(34, 197, 94, 0.04);
            position: relative;
            padding-top: 22px;
        }
        .mind-chat-msg.cerebro.summary-msg::before {
            content: 'Summary';
            position: absolute;
            top: 4px;
            left: 10px;
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.58rem;
            font-weight: 700;
            color: rgba(34, 197, 94, 0.7);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* ===== TAMAGOTCHI HEALTH PANEL ===== */
        .tamagotchi-panel {
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding: 14px 16px;
        }
        .tama-bar-group { display: flex; flex-direction: column; gap: 4px; }
        .tama-bar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .tama-bar-label {
            font-size: 0.7rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--text-secondary, rgba(255,255,255,0.6));
        }
        .tama-bar-value {
            font-size: 0.65rem;
            color: var(--text-muted, rgba(255,255,255,0.4));
            font-weight: 500;
        }
        .tama-bar {
            height: 8px;
            background: rgba(255, 255, 255, 0.06);
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }
        .tama-bar-fill {
            height: 100%;
            border-radius: 4px;
            transition: width 0.8s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
        }

        /* Mood fills */
        .mood-fill.excited { background: linear-gradient(90deg, #22c55e, #4ade80); box-shadow: 0 0 8px rgba(74, 222, 128, 0.5); }
        .mood-fill.happy { background: linear-gradient(90deg, #7c3aed, #a78bfa); box-shadow: 0 0 8px rgba(167, 139, 250, 0.5); }
        .mood-fill.content { background: linear-gradient(90deg, #6366f1, #818cf8); box-shadow: 0 0 6px rgba(129, 140, 248, 0.4); }
        .mood-fill.bored { background: linear-gradient(90deg, #4b5563, #6b7280); }
        .mood-fill.lonely { background: linear-gradient(90deg, #374151, #4b5563); }
        .mood-fill.confused { background: linear-gradient(90deg, #d97706, #f59e0b); box-shadow: 0 0 8px rgba(245, 158, 11, 0.5); }
        .mood-fill.frustrated { background: linear-gradient(90deg, #dc2626, #ef4444); box-shadow: 0 0 8px rgba(239, 68, 68, 0.5); }

        /* Energy fill */
        .energy-fill { background: linear-gradient(90deg, #0ea5e9, #38bdf8); box-shadow: 0 0 6px rgba(56, 189, 248, 0.4); }

        /* Memory fill */
        .memory-fill { background: linear-gradient(90deg, #10b981, #34d399); box-shadow: 0 0 6px rgba(52, 211, 153, 0.4); }
        .memory-fill.degraded { background: linear-gradient(90deg, #f59e0b, #fbbf24); box-shadow: 0 0 6px rgba(251, 191, 36, 0.4); }
        .memory-fill.offline { background: linear-gradient(90deg, #ef4444, #f87171); box-shadow: 0 0 6px rgba(248, 113, 113, 0.4); }

        /* XP fill */
        .xp-fill { background: linear-gradient(90deg, #8b5cf6, #c084fc); box-shadow: 0 0 6px rgba(192, 132, 252, 0.4); }

        /* Indicators */
        .tama-indicators {
            display: flex;
            align-items: center;
            gap: 16px;
            padding-top: 4px;
            border-top: 1px solid rgba(255,255,255,0.04);
        }
        .tama-indicator {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .tama-indicator-label {
            font-size: 0.6rem;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--text-muted, rgba(255,255,255,0.4));
            font-weight: 600;
        }
        .tama-phase-dot {
            width: 7px; height: 7px;
            border-radius: 50%;
            background: var(--text-muted, rgba(255,255,255,0.3));
            flex-shrink: 0;
        }
        .tama-phase-dot.running { background: #a78bfa; box-shadow: 0 0 6px rgba(167,139,250,0.6); }
        .tama-phase-dot.observing { background: #22d3ee; box-shadow: 0 0 6px rgba(34,211,238,0.6); }
        .tama-phase-dot.acting { background: #f59e0b; box-shadow: 0 0 6px rgba(245,158,11,0.6); }
        .tama-phase-dot.dormant { background: rgba(255,255,255,0.2); }
        .tama-phase-label {
            font-size: 0.7rem;
            font-weight: 600;
            color: var(--text-secondary, rgba(255,255,255,0.6));
            text-transform: capitalize;
        }
        .tama-pips { display: flex; gap: 4px; align-items: center; }
        .tama-pip {
            width: 12px; height: 12px;
            border-radius: 3px;
            background: rgba(255,255,255,0.08);
            border: 1px solid rgba(255,255,255,0.1);
            transition: all 0.25s ease;
            cursor: pointer;
        }
        .tama-pip:hover {
            background: rgba(139, 92, 246, 0.3);
            border-color: rgba(139, 92, 246, 0.5);
            transform: scale(1.15);
        }
        .tama-pip.filled {
            background: rgba(139, 92, 246, 0.6);
            border-color: rgba(139, 92, 246, 0.4);
            box-shadow: 0 0 5px rgba(139, 92, 246, 0.4);
        }
        .tama-pip.filled:hover {
            background: rgba(139, 92, 246, 0.8);
        }

        /* Mini stat cards */
        .tama-stats-row {
            display: flex;
            gap: 8px;
            padding-top: 4px;
        }
        .tama-stat-card {
            flex: 1;
            background: rgba(255,255,255,0.04);
            border: 1px solid rgba(255,255,255,0.06);
            border-radius: 8px;
            padding: 8px 6px;
            text-align: center;
        }
        .tama-stat-num {
            font-size: 1.1rem;
            font-weight: 700;
            color: var(--text-primary, #fff);
            line-height: 1.2;
        }
        .tama-stat-label {
            font-size: 0.55rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-muted, rgba(255,255,255,0.4));
            font-weight: 600;
        }

        /* Directive cards in Command tab */
        .directive-card {
            display: flex;
            align-items: flex-start;
            gap: 10px;
            padding: 10px 12px;
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(255,255,255,0.06);
            border-radius: 10px;
            margin: 0 12px 6px;
            transition: background 0.2s ease;
        }
        .directive-card:hover { background: rgba(255,255,255,0.05); }
        .directive-status-badge {
            display: inline-flex;
            align-items: center;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.6rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.06em;
            flex-shrink: 0;
            margin-top: 2px;
        }
        .directive-status-badge.active {
            background: rgba(139, 92, 246, 0.2);
            color: #a78bfa;
            border: 1px solid rgba(139, 92, 246, 0.3);
        }
        .directive-status-badge.pending {
            background: rgba(255,255,255,0.06);
            color: var(--text-muted, rgba(255,255,255,0.4));
            border: 1px solid rgba(255,255,255,0.08);
        }
        .directive-card-text {
            flex: 1;
            font-size: 0.8rem;
            color: var(--text-primary, #fff);
            line-height: 1.4;
        }
        .directive-card-btn {
            width: 28px; height: 28px;
            border-radius: 8px;
            background: rgba(74, 222, 128, 0.15);
            border: 1px solid rgba(74, 222, 128, 0.25);
            color: #4ade80;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            transition: all 0.2s ease;
        }
        .directive-card-btn:hover {
            background: rgba(74, 222, 128, 0.3);
            transform: scale(1.08);
        }

        /* Command tab  input at bottom */
        .orb-command-input.command-input-bottom {
            border-bottom: none;
            border-top: 1px solid rgba(255, 255, 255, 0.04);
            margin-top: auto;
        }

        /* Command tab */
        .orb-command-input {
            display: flex;
            flex-direction: column;
            gap: 6px;
            padding: 12px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.04);
            flex-shrink: 0;
        }

        .orb-auto-awake {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .orb-auto-awake input[type="checkbox"] {
            appearance: none;
            -webkit-appearance: none;
            width: 15px;
            height: 15px;
            border: 1.5px solid rgba(139, 92, 246, 0.6);
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.06);
            cursor: pointer;
            position: relative;
            flex-shrink: 0;
            transition: all 0.2s ease;
        }

        .orb-auto-awake input[type="checkbox"]:hover {
            border-color: var(--accent);
            background: rgba(139, 92, 246, 0.15);
        }

        .orb-auto-awake input[type="checkbox"]:checked {
            background: rgba(139, 92, 246, 0.4);
            border-color: var(--accent);
        }

        .orb-auto-awake input[type="checkbox"]:checked::after {
            content: '\2713';
            position: absolute;
            top: -1px;
            left: 2px;
            font-size: 11px;
            color: #c4b5fd;
            font-weight: bold;
        }

        .orb-auto-awake label {
            font-size: 11.5px;
            color: rgba(255, 255, 255, 0.5);
            cursor: pointer;
            user-select: none;
        }

        .orb-command-input textarea {
            flex: 1;
            background: rgba(255, 255, 255, 0.06);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 12px;
            padding: 10px 14px;
            color: var(--text-primary);
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.85rem;
            font-weight: 500;
            outline: none;
            resize: none;
            min-height: 42px;
            max-height: 80px;
            transition: border-color 0.2s ease;
        }

        .orb-command-input textarea:focus {
            border-color: var(--accent);
            background: rgba(139, 92, 246, 0.08);
        }

        .orb-command-input textarea::placeholder {
            color: var(--text-muted);
        }

        .orb-command-send {
            width: 38px;
            height: 38px;
            border-radius: 10px;
            background: rgba(139, 92, 246, 0.2);
            border: 1px solid rgba(139, 92, 246, 0.3);
            color: var(--accent-light);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            align-self: flex-end;
            transition: all 0.2s ease;
        }

        .orb-command-send:hover {
            background: rgba(139, 92, 246, 0.4);
            transform: scale(1.05);
        }

        .orb-command-directives {
            flex: 1;
            overflow-y: auto;
            padding: 10px 12px;
        }

        .orb-command-empty, .orb-pane-empty {
            text-align: center;
            color: var(--text-muted);
            font-size: 0.78rem;
            padding: 24px 16px;
            opacity: 0.6;
        }

        .orb-pane-list {
            padding: 8px 12px;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        /* Directive tag in command panel */
        .orb-directive-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: rgba(139, 92, 246, 0.08);
            border: 1px solid rgba(139, 92, 246, 0.15);
            border-radius: 10px;
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.8rem;
            color: var(--text-secondary);
            transition: all 0.2s ease;
        }

        .orb-directive-item:hover {
            border-color: rgba(139, 92, 246, 0.3);
            background: rgba(139, 92, 246, 0.12);
        }

        .orb-directive-text {
            flex: 1;
            min-width: 0;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .orb-directive-complete {
            background: none;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            padding: 2px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            transition: color 0.2s ease;
        }

        .orb-directive-complete:hover {
            color: var(--green);
        }

        /* Focus/Completed/Skills list items in orb panel */
        .orb-list-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 10px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.8rem;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .orb-list-item:hover {
            background: rgba(139, 92, 246, 0.08);
            border-color: rgba(139, 92, 246, 0.2);
        }

        .orb-list-item .item-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .orb-list-item .item-dot.active { background: var(--accent); box-shadow: 0 0 6px var(--accent); }
        .orb-list-item .item-dot.done { background: var(--green); }
        .orb-list-item .item-dot.skill { background: var(--energy-blue); }

        .orb-list-item .item-text {
            flex: 1;
            min-width: 0;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .orb-list-item .item-meta {
            font-size: 0.65rem;
            color: var(--text-muted);
            flex-shrink: 0;
        }

        /* Agents panel inside tabbed panel */
        .orb-tabbed-panel .agents-status-panel {
            display: block;
            position: relative;
            bottom: auto;
            left: auto;
            transform: none;
            z-index: auto;
            width: 100%;
            max-width: none;
            min-width: 0;
            border-radius: 0;
            border: none;
            border-top: 1px solid rgba(255, 255, 255, 0.06);
            background: rgba(8, 8, 14, 0.6);
            box-shadow: none;
            flex-shrink: 0;
        }

        /* ===== SLIDE-OUT PANELS ===== */
        .slide-panel-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 200;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.35s ease;
        }

        .slide-panel-backdrop.visible {
            opacity: 1;
            pointer-events: all;
        }

        .slide-panel {
            position: fixed;
            top: 0;
            bottom: 0;
            width: 360px;
            background: rgba(8, 8, 14, 0.97);
            border: 1px solid rgba(139, 92, 246, 0.12);
            backdrop-filter: blur(24px);
            -webkit-backdrop-filter: blur(24px);
            z-index: 210;
            display: flex;
            flex-direction: column;
            transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            overflow: hidden;
        }

        .slide-panel.left {
            left: 0;
            transform: translateX(-100%);
            border-left: none;
            border-radius: 0 16px 16px 0;
        }

        .slide-panel.right {
            right: 0;
            transform: translateX(100%);
            border-right: none;
            border-radius: 16px 0 0 16px;
        }

        .slide-panel.open {
            transform: translateX(0);
        }

        .slide-panel-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 20px 20px 16px;
            border-bottom: 1px solid rgba(139, 92, 246, 0.1);
            flex-shrink: 0;
        }

        .slide-panel-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text-primary);
            letter-spacing: 0.05em;
        }

        .slide-panel-close {
            width: 32px;
            height: 32px;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.08);
            color: var(--text-muted);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            font-size: 1.1rem;
        }

        .slide-panel-close:hover {
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-primary);
        }

        .slide-panel-body {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
        }

        .slide-panel-body::-webkit-scrollbar { width: 3px; }
        .slide-panel-body::-webkit-scrollbar-track { background: transparent; }
        .slide-panel-body::-webkit-scrollbar-thumb {
            background: rgba(139, 92, 246, 0.3);
            border-radius: 2px;
        }

        /* Edge indicators - subtle glow lines to hint at panels */
        .edge-indicator {
            position: fixed;
            top: 50%;
            transform: translateY(-50%);
            width: 3px;
            height: 120px;
            border-radius: 3px;
            z-index: 100;
            cursor: pointer;
            transition: all 0.3s ease;
            opacity: 0.3;
        }

        /* Edge indicators only show in autonomy view */
        .view:not(.active) .edge-indicator,
        .view:not(.active) .slide-panel,
        .view:not(.active) .slide-panel-backdrop {
            display: none;
        }

        .edge-indicator.left {
            left: 0;
            background: linear-gradient(180deg, transparent, rgba(59, 130, 246, 0.5), rgba(139, 92, 246, 0.5), transparent);
        }

        .edge-indicator.right {
            right: 0;
            background: linear-gradient(180deg, transparent, rgba(236, 72, 153, 0.5), rgba(139, 92, 246, 0.5), transparent);
        }

        .edge-indicator:hover {
            opacity: 1;
            width: 5px;
            box-shadow: 0 0 15px currentColor;
        }

        /* ===== DETAIL DROPDOWN (for status strip items) ===== */
        .strip-detail-dropdown {
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%) translateY(8px);
            width: 340px;
            max-height: 300px;
            background: rgba(12, 12, 20, 0.95);
            border: 1px solid rgba(139, 92, 246, 0.2);
            border-radius: 16px;
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            z-index: 50;
            overflow-y: auto;
            opacity: 0;
            pointer-events: none;
            transition: all 0.25s ease;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }

        .strip-detail-dropdown.visible {
            opacity: 1;
            pointer-events: all;
            transform: translateX(-50%) translateY(4px);
        }

        .strip-detail-dropdown::-webkit-scrollbar { width: 3px; }
        .strip-detail-dropdown::-webkit-scrollbar-track { background: transparent; }
        .strip-detail-dropdown::-webkit-scrollbar-thumb {
            background: rgba(139, 92, 246, 0.3);
            border-radius: 2px;
        }

        /* Status strip wrapper needs relative positioning for dropdown */
        .mind-status-strip {
            position: relative;
        }

        .strip-item {
            position: relative;
        }

        /* ===== RESPONSIVE: Slide panels & status cards ===== */
        @media (max-width: 768px) {
            .slide-panel {
                width: 100%;
                border-radius: 0;
            }

            .mind-status-bar {
                padding: 12px 16px 4px;
            }

            .status-card {
                min-width: 100px;
                padding: 8px 12px;
            }

            .status-card-value {
                font-size: 0.85rem;
            }

            .mind-chat-messages {
                max-height: 220px;
            }
        }

        @media (max-width: 480px) {
            .status-card {
                min-width: 45%;
                flex: 1 1 45%;
            }
        }

        /* ===== THE PRESENCE - Central Consciousness Chamber ===== */
        .consciousness-chamber {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            min-height: auto;
            padding: 20px 20px 10px;
            z-index: 1;
            width: 100%;
            max-width: 800px;
        }

        /* Deep space ambient glow */
        .consciousness-chamber::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 800px;
            height: 800px;
            transform: translate(-50%, -50%);
            background: radial-gradient(circle,
                rgba(139, 92, 246, 0.08) 0%,
                rgba(88, 28, 135, 0.05) 30%,
                transparent 70%);
            animation: ambientBreath 6s ease-in-out infinite;
            pointer-events: none;
        }

        @keyframes ambientBreath {
            0%, 100% { opacity: 0.5; transform: translate(-50%, -50%) scale(1); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1.15); }
        }

        /* Orbital rings around the consciousness */
        .orbital-system {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 600px;
            height: 600px;
            pointer-events: none;
        }

        .orbit {
            position: absolute;
            top: 50%;
            left: 50%;
            border-radius: 50%;
            border: 1px solid transparent;
        }

        .orbit-1 {
            width: 420px;
            height: 420px;
            margin: -210px 0 0 -210px;
            border-color: rgba(139, 92, 246, 0.1);
            animation: orbitSpin 20s linear infinite;
        }

        .orbit-2 {
            width: 510px;
            height: 510px;
            margin: -255px 0 0 -255px;
            border-color: rgba(99, 102, 241, 0.08);
            animation: orbitSpin 30s linear infinite reverse;
        }

        .orbit-3 {
            width: 600px;
            height: 600px;
            margin: -300px 0 0 -300px;
            border-color: rgba(139, 92, 246, 0.05);
            animation: orbitSpin 40s linear infinite;
        }

        @keyframes orbitSpin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        /* Small energy nodes on orbits */
        .orbit-node {
            position: absolute;
            width: 4px;
            height: 4px;
            background: var(--accent);
            border-radius: 50%;
            box-shadow: 0 0 10px var(--accent), 0 0 20px rgba(139, 92, 246, 0.5);
        }

        .orbit-1 .orbit-node { top: 0; left: 50%; margin-left: -2px; }
        .orbit-2 .orbit-node { top: 50%; right: 0; margin-top: -2px; }
        .orbit-3 .orbit-node { bottom: 0; left: 50%; margin-left: -2px; }

        /* ===== THE CONSCIOUSNESS ORB - The Living Mind ===== */
        .consciousness-orb {
            position: relative;
            width: 360px;
            height: 360px;
            cursor: pointer;
            transition: transform 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
            z-index: 2;
        }

        .consciousness-orb:hover {
            transform: scale(1.05);
        }

        /* Core essence - the mind itself (logo image) */
        .orb-essence.orb-logo-img {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 255px;
            height: 255px;
            border-radius: 50%;
            object-fit: cover;
            filter: drop-shadow(0 0 80px rgba(139, 92, 246, 0.7))
                    drop-shadow(0 0 160px rgba(124, 58, 237, 0.4));
            animation: essenceBreath 4s ease-in-out infinite;
            transition: filter 0.6s ease, transform 0.6s ease, opacity 0.6s ease;
        }

        @keyframes essenceBreath {
            0%, 100% {
                transform: translate(-50%, -50%) scale(1);
                filter: drop-shadow(0 0 80px rgba(139, 92, 246, 0.7))
                        drop-shadow(0 0 160px rgba(124, 58, 237, 0.4));
            }
            50% {
                transform: translate(-50%, -50%) scale(1.03);
                filter: drop-shadow(0 0 100px rgba(139, 92, 246, 0.8))
                        drop-shadow(0 0 200px rgba(124, 58, 237, 0.5));
            }
        }

        /* Outer aura layers */
        .orb-aura {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border-radius: 50%;
            pointer-events: none;
        }

        .orb-aura-1 {
            width: 300px;
            height: 300px;
            background: radial-gradient(circle, rgba(139, 92, 246, 0.25) 0%, transparent 70%);
            animation: auraExpand 3s ease-in-out infinite;
        }

        .orb-aura-2 {
            width: 390px;
            height: 390px;
            background: radial-gradient(circle, rgba(124, 58, 237, 0.15) 0%, transparent 60%);
            animation: auraExpand 3s ease-in-out infinite 0.5s;
        }

        .orb-aura-3 {
            width: 480px;
            height: 480px;
            background: radial-gradient(circle, rgba(88, 28, 135, 0.08) 0%, transparent 50%);
            animation: auraExpand 3s ease-in-out infinite 1s;
        }

        @keyframes auraExpand {
            0%, 100% { opacity: 0.4; transform: translate(-50%, -50%) scale(1); }
            50% { opacity: 0.8; transform: translate(-50%, -50%) scale(1.08); }
        }

        /* Floating energy particles around orb */
        .orb-particles {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 450px;
            height: 450px;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        .energy-particle {
            position: absolute;
            width: 3px;
            height: 3px;
            background: #a78bfa;
            border-radius: 50%;
            box-shadow: 0 0 6px #a78bfa;
            opacity: 0;
        }

        .consciousness-orb.active .energy-particle {
            animation: particleFloat 4s ease-in-out infinite;
        }

        .energy-particle:nth-child(1) { top: 10%; left: 50%; animation-delay: 0s; }
        .energy-particle:nth-child(2) { top: 25%; left: 85%; animation-delay: 0.5s; }
        .energy-particle:nth-child(3) { top: 50%; left: 95%; animation-delay: 1s; }
        .energy-particle:nth-child(4) { top: 75%; left: 85%; animation-delay: 1.5s; }
        .energy-particle:nth-child(5) { top: 90%; left: 50%; animation-delay: 2s; }
        .energy-particle:nth-child(6) { top: 75%; left: 15%; animation-delay: 2.5s; }
        .energy-particle:nth-child(7) { top: 50%; left: 5%; animation-delay: 3s; }
        .energy-particle:nth-child(8) { top: 25%; left: 15%; animation-delay: 3.5s; }

        @keyframes particleFloat {
            0%, 100% { opacity: 0; transform: scale(0.5) translateY(0); }
            50% { opacity: 1; transform: scale(1) translateY(-10px); }
        }

        /* ===== CONSCIOUSNESS STATES - The Mind's Moods ===== */

        /* DORMANT - Sleeping, waiting to awaken */
        .consciousness-orb.dormant .orb-essence {
            opacity: 0.3;
            filter: grayscale(0.5) brightness(0.5)
                    drop-shadow(0 0 30px rgba(100, 100, 120, 0.2));
            animation: dormantPulse 6s ease-in-out infinite;
        }
        .consciousness-orb.dormant .orb-aura { opacity: 0.1; }

        @keyframes dormantPulse {
            0%, 100% { transform: translate(-50%, -50%) scale(0.98); opacity: 0.25; }
            50% { transform: translate(-50%, -50%) scale(1); opacity: 0.35; }
        }

        /* AWAKENING - Coming to life */
        .consciousness-orb.awakening .orb-essence {
            animation: awakening 2s ease-out forwards;
        }

        @keyframes awakening {
            0% { opacity: 0.3; filter: grayscale(0.5) brightness(0.5); transform: translate(-50%, -50%) scale(0.9); }
            50% { opacity: 0.7; filter: grayscale(0.2) brightness(0.8); }
            100% { opacity: 1; filter: drop-shadow(0 0 80px rgba(139, 92, 246, 0.7)) drop-shadow(0 0 160px rgba(124, 58, 237, 0.4)); transform: translate(-50%, -50%) scale(1); }
        }

        /* THINKING - Deep purple, intense glow */
        .consciousness-orb.thinking .orb-essence {
            filter: drop-shadow(0 0 100px rgba(139, 92, 246, 0.9))
                    drop-shadow(0 0 200px rgba(124, 58, 237, 0.6))
                    brightness(1.15) saturate(1.3);
            animation: thinkingPulse 2s ease-in-out infinite;
        }

        @keyframes thinkingPulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.06); }
        }

        /* OBSERVING - Cool cyan, absorbing information */
        .consciousness-orb.observing .orb-essence {
            filter: drop-shadow(0 0 100px rgba(59, 130, 246, 0.8))
                    drop-shadow(0 0 180px rgba(37, 99, 235, 0.5))
                    hue-rotate(120deg) brightness(1.1);
            animation: observingPulse 2.5s ease-in-out infinite;
        }

        @keyframes observingPulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.04); }
        }

        /* DECIDING - Warm amber, weighing choices */
        .consciousness-orb.deciding .orb-essence {
            filter: drop-shadow(0 0 100px rgba(245, 158, 11, 0.8))
                    drop-shadow(0 0 180px rgba(217, 119, 6, 0.5))
                    hue-rotate(-40deg) saturate(1.3);
            animation: decidingPulse 1.5s ease-in-out infinite;
        }

        @keyframes decidingPulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1) rotate(0deg); }
            25% { transform: translate(-50%, -50%) scale(1.05) rotate(1deg); }
            75% { transform: translate(-50%, -50%) scale(1.05) rotate(-1deg); }
        }

        /* ACTING - Vibrant orange, taking action */
        .consciousness-orb.acting .orb-essence {
            filter: drop-shadow(0 0 120px rgba(249, 115, 22, 0.9))
                    drop-shadow(0 0 220px rgba(234, 88, 12, 0.6))
                    hue-rotate(-50deg) saturate(1.6);
            animation: actingBurst 0.6s ease-out infinite;
        }

        @keyframes actingBurst {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.1); }
        }

        /* REFLECTING - Serene green/teal, contemplating results */
        .consciousness-orb.reflecting .orb-essence {
            filter: drop-shadow(0 0 80px rgba(16, 185, 129, 0.7))
                    drop-shadow(0 0 160px rgba(5, 150, 105, 0.4))
                    hue-rotate(80deg) brightness(1.1);
            animation: reflectingCalm 4s ease-in-out infinite;
        }

        @keyframes reflectingCalm {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.02); }
        }

        /* ===== CONSCIOUSNESS STATUS - Minimal, Elegant ===== */
        .consciousness-status {
            margin-top: 20px;
            text-align: center;
            z-index: 2;
        }

        .status-text {
            font-family: 'Orbitron', sans-serif;
            font-size: 1rem;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5em;
            color: var(--text-muted);
            opacity: 0.8;
            transition: all 0.5s ease;
        }

        .consciousness-orb.active ~ .consciousness-status .status-text {
            color: var(--accent-light);
            opacity: 1;
            text-shadow: 0 0 20px rgba(139, 92, 246, 0.5);
        }

        /* ===== CONSCIOUSNESS CONTROLS FLEX ROW ===== */
        .consciousness-controls {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin-top: 16px;
        }

        /* ===== APPLE-STYLE AUTONOMY TOGGLE ===== */
        .autonomy-toggle {
            display: inline-flex;
            align-items: center;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
        }
        .autonomy-toggle input {
            position: absolute;
            opacity: 0;
            width: 0;
            height: 0;
        }
        .toggle-track {
            position: relative;
            width: 52px;
            height: 28px;
            background: rgba(60, 60, 80, 0.6);
            border-radius: 14px;
            border: 1px solid rgba(100, 100, 130, 0.3);
            transition: all 0.35s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .toggle-thumb {
            position: absolute;
            top: 2px;
            left: 2px;
            width: 22px;
            height: 22px;
            background: rgba(180, 180, 200, 0.9);
            border-radius: 50%;
            transition: all 0.35s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
        }
        .autonomy-toggle input:checked + .toggle-track {
            background: rgba(139, 92, 246, 0.5);
            border-color: rgba(139, 92, 246, 0.6);
            box-shadow: 0 0 16px rgba(139, 92, 246, 0.3), 0 0 4px rgba(139, 92, 246, 0.2);
        }
        .autonomy-toggle input:checked + .toggle-track .toggle-thumb {
            left: 26px;
            background: #c4b5fd;
            box-shadow: 0 0 8px rgba(196, 181, 253, 0.6), 0 1px 3px rgba(0, 0, 0, 0.3);
        }
        .autonomy-toggle:hover .toggle-track {
            border-color: rgba(139, 92, 246, 0.5);
        }
        .autonomy-toggle:hover .toggle-thumb {
            transform: scale(1.06);
        }

        /* ===== HEARTBEAT CONFIG BUTTON (near orb) ===== */
        .heartbeat-config-btn {
            background: transparent;
            border: 1px solid rgba(239, 68, 68, 0.25);
            border-radius: 50%;
            width: 32px;
            height: 32px;
            color: rgba(239, 68, 68, 0.6);
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }
        .heartbeat-config-btn:hover {
            color: #ef4444;
            border-color: rgba(239, 68, 68, 0.6);
            box-shadow: 0 0 12px rgba(239, 68, 68, 0.3);
            transform: scale(1.1);
        }
        .heartbeat-config-btn.has-findings {
            animation: heartPulse 2s ease-in-out infinite;
        }
        @keyframes heartPulse {
            0%, 100% { color: rgba(239, 68, 68, 0.6); }
            50% { color: #ef4444; text-shadow: 0 0 8px rgba(239, 68, 68, 0.5); }
        }

        /* ===== HEARTBEAT SETTINGS MODAL ===== */
        .modal-heartbeat {
            max-width: 640px;
            max-height: 90vh;
            display: flex;
            flex-direction: column;
        }
        .modal-heartbeat .modal-body {
            flex: 1;
            overflow-y: auto;
            padding: 16px 20px;
            display: flex;
            flex-direction: column;
            gap: 16px;
        }
        .hb-section {
            background: rgba(0, 0, 0, 0.15);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 14px 16px;
        }
        .hb-section-title {
            font-size: 0.65rem;
            font-weight: 700;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            color: rgba(239, 68, 68, 0.7);
            margin-bottom: 12px;
        }
        .hb-interval-row {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 14px;
            padding-bottom: 14px;
            border-bottom: 1px solid rgba(255,255,255,0.06);
        }
        .hb-interval-row label {
            font-size: 0.78rem;
            color: var(--text-secondary);
            white-space: nowrap;
        }
        .hb-interval-row input[type="range"] {
            flex: 1;
            accent-color: #ef4444;
            height: 4px;
        }
        .hb-interval-value {
            font-size: 0.78rem;
            color: var(--text-primary);
            font-weight: 600;
            min-width: 36px;
            text-align: right;
            font-family: 'Space Mono', monospace;
        }
        .hb-monitor-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }
        .hb-monitor-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 6px 10px;
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.2);
            transition: background 0.2s ease;
        }
        .hb-monitor-item:hover { background: rgba(0, 0, 0, 0.3); }
        .hb-monitor-item span {
            font-size: 0.75rem;
            color: var(--text-secondary);
        }
        .hb-toggle {
            position: relative;
            width: 36px;
            height: 20px;
            flex-shrink: 0;
        }
        .hb-toggle input {
            position: absolute;
            opacity: 0;
            width: 0;
            height: 0;
        }
        .hb-toggle-track {
            position: absolute;
            inset: 0;
            background: rgba(60, 60, 80, 0.6);
            border-radius: 10px;
            border: 1px solid rgba(100, 100, 130, 0.3);
            transition: all 0.25s ease;
            cursor: pointer;
        }
        .hb-toggle-thumb {
            position: absolute;
            top: 2px;
            left: 2px;
            width: 14px;
            height: 14px;
            background: rgba(180, 180, 200, 0.9);
            border-radius: 50%;
            transition: all 0.25s ease;
            pointer-events: none;
        }
        .hb-toggle input:checked + .hb-toggle-track {
            background: rgba(239, 68, 68, 0.45);
            border-color: rgba(239, 68, 68, 0.6);
            box-shadow: 0 0 10px rgba(239, 68, 68, 0.2);
        }
        .hb-toggle input:checked + .hb-toggle-track .hb-toggle-thumb {
            left: 18px;
            background: #fca5a5;
        }
        .hb-list {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        .hb-list-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 5px 8px;
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.15);
            font-size: 0.78rem;
            color: var(--text-primary);
            transition: background 0.15s ease;
        }
        .hb-list-item:hover { background: rgba(0, 0, 0, 0.25); }
        .hb-list-item .hb-item-text { flex: 1; }
        .hb-list-item .hb-item-delete {
            opacity: 0;
            background: none;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            font-size: 1rem;
            padding: 0 4px;
            transition: opacity 0.15s ease, color 0.15s ease;
        }
        .hb-list-item:hover .hb-item-delete { opacity: 1; }
        .hb-list-item .hb-item-delete:hover { color: #ef4444; }
        .hb-task-checkbox {
            accent-color: #ef4444;
            width: 14px;
            height: 14px;
            cursor: pointer;
            flex-shrink: 0;
        }
        .hb-task-checkbox:checked + .hb-item-text {
            text-decoration: line-through;
            opacity: 0.5;
        }
        .hb-add-row {
            display: flex;
            gap: 6px;
            margin-top: 6px;
        }
        .hb-add-input {
            flex: 1;
            background: rgba(0, 0, 0, 0.25);
            border: 1px solid rgba(255,255,255,0.08);
            border-radius: 6px;
            padding: 6px 10px;
            font-size: 0.75rem;
            color: var(--text-primary);
            outline: none;
            font-family: inherit;
        }
        .hb-add-input::placeholder { color: var(--text-muted); }
        .hb-add-input:focus { border-color: rgba(239, 68, 68, 0.4); }
        .hb-add-btn {
            background: rgba(239, 68, 68, 0.15);
            border: 1px solid rgba(239, 68, 68, 0.3);
            border-radius: 6px;
            color: rgba(239, 68, 68, 0.8);
            cursor: pointer;
            padding: 4px 10px;
            font-size: 0.75rem;
            font-weight: 600;
            transition: all 0.2s ease;
        }
        .hb-add-btn:hover {
            background: rgba(239, 68, 68, 0.25);
            color: #ef4444;
        }
        /* Goal section styles */
        .hb-goal-item {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            padding: 10px 12px;
            margin-bottom: 6px;
        }
        .hb-goal-header {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .hb-goal-header .hb-task-checkbox {
            accent-color: #22c55e;
        }
        .hb-goal-desc {
            flex: 1;
            font-size: 0.78rem;
            color: var(--text-primary);
            min-width: 0;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .hb-goal-mode {
            font-size: 0.55rem;
            font-weight: 700;
            padding: 2px 8px;
            border-radius: 6px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            flex-shrink: 0;
        }
        .hb-goal-mode.monitor { background: rgba(59,130,246,0.15); color: #3b82f6; }
        .hb-goal-mode.think { background: rgba(234,179,8,0.15); color: #eab308; }
        .hb-goal-mode.act { background: rgba(239,68,68,0.15); color: #ef4444; }
        .hb-goal-meta {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 6px;
            padding-left: 22px;
        }
        .hb-goal-progress-bar {
            flex: 1;
            height: 4px;
            background: rgba(255,255,255,0.08);
            border-radius: 2px;
            overflow: hidden;
        }
        .hb-goal-progress-fill {
            height: 100%;
            border-radius: 2px;
            background: #22c55e;
            transition: width 0.3s ease;
        }
        .hb-goal-pct {
            font-size: 0.65rem;
            color: var(--text-secondary);
            font-family: 'Space Mono', monospace;
            min-width: 32px;
            text-align: right;
        }
        .hb-goal-deadline {
            font-size: 0.6rem;
            color: var(--text-muted);
            white-space: nowrap;
        }
        .hb-goal-add-form {
            display: flex;
            flex-direction: column;
            gap: 6px;
            margin-top: 8px;
        }
        .hb-goal-add-row {
            display: flex;
            gap: 6px;
        }
        .hb-goal-mode-select {
            background: rgba(0, 0, 0, 0.25);
            border: 1px solid rgba(255,255,255,0.08);
            border-radius: 6px;
            padding: 6px 8px;
            font-size: 0.72rem;
            color: var(--text-primary);
            outline: none;
            font-family: inherit;
            cursor: pointer;
        }
        .hb-goal-mode-select:focus { border-color: rgba(239, 68, 68, 0.4); }
        .hb-goal-date-input {
            background: rgba(0, 0, 0, 0.25);
            border: 1px solid rgba(255,255,255,0.08);
            border-radius: 6px;
            padding: 6px 8px;
            font-size: 0.72rem;
            color: var(--text-primary);
            outline: none;
            font-family: inherit;
            color-scheme: dark;
        }
        .hb-goal-date-input:focus { border-color: rgba(239, 68, 68, 0.4); }
        .hb-goal-item .hb-item-delete {
            opacity: 0;
            background: none;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            font-size: 1rem;
            padding: 0 4px;
            transition: opacity 0.15s ease, color 0.15s ease;
            flex-shrink: 0;
        }
        .hb-goal-item:hover .hb-item-delete { opacity: 1; }
        .hb-goal-item .hb-item-delete:hover { color: #ef4444; }
        .hb-dormant-textarea {
            width: 100%;
            min-height: 80px;
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255,255,255,0.08);
            border-radius: 8px;
            padding: 10px 12px;
            font-size: 0.78rem;
            color: var(--text-primary);
            font-family: inherit;
            line-height: 1.5;
            resize: vertical;
            outline: none;
        }
        .hb-dormant-textarea:focus { border-color: rgba(239, 68, 68, 0.4); }
        .hb-dormant-textarea::placeholder { color: var(--text-muted); }
        .hb-raw-toggle {
            display: flex;
            align-items: center;
            gap: 6px;
            background: none;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            font-size: 0.72rem;
            padding: 4px 0;
            transition: color 0.2s ease;
        }
        .hb-raw-toggle:hover { color: var(--text-secondary); }
        .hb-raw-toggle .hb-raw-arrow {
            transition: transform 0.2s ease;
            font-size: 0.6rem;
        }
        .hb-raw-toggle.expanded .hb-raw-arrow { transform: rotate(90deg); }
        .hb-raw-editor-wrap {
            display: none;
            margin-top: 8px;
        }
        .hb-raw-editor-wrap.visible { display: block; }
        .hb-raw-editor {
            width: 100%;
            min-height: 200px;
            background: var(--bg-elevated);
            color: var(--text-primary);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 12px;
            font-family: 'Space Mono', 'Fira Code', monospace;
            font-size: 0.78rem;
            line-height: 1.5;
            resize: vertical;
            outline: none;
            tab-size: 4;
        }
        .hb-raw-editor::placeholder { color: var(--text-muted); }
        .hb-status-bar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 20px;
            background: rgba(0, 0, 0, 0.3);
            border-top: 1px solid var(--border);
            font-size: 0.7rem;
            color: var(--text-muted);
            font-family: 'Space Mono', monospace;
        }
        .hb-status-bar .hb-status-text { flex: 1; }
        .hb-dirty-indicator {
            color: #f59e0b;
            opacity: 0;
            transition: opacity 0.2s ease;
            margin-left: 8px;
        }
        .hb-dirty-indicator.visible { opacity: 1; }

        /* ===== CEREBRO'S VOICE - Communication Stream ===== */
        .voice-stream {
            position: relative;
            max-width: 700px;
            width: 100%;
            margin: 0 auto;
            padding: 0 20px 12px;
            z-index: 1;
            flex-shrink: 0;
        }

        /* Current thought - what Cerebro is saying NOW */
        .current-voice {
            background: linear-gradient(135deg,
                rgba(139, 92, 246, 0.08) 0%,
                rgba(88, 28, 135, 0.04) 50%,
                rgba(30, 58, 138, 0.06) 100%);
            border: 1px solid rgba(139, 92, 246, 0.2);
            border-radius: 24px;
            padding: 28px 32px;
            margin-bottom: 24px;
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            position: relative;
            overflow: hidden;
        }

        .current-voice::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, rgba(139, 92, 246, 0.5), transparent);
        }

        .voice-label {
            font-family: 'Space Mono', monospace;
            font-size: 0.7rem;
            color: var(--accent);
            text-transform: uppercase;
            letter-spacing: 0.2em;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .voice-speak-btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 26px;
            height: 26px;
            border-radius: 50%;
            background: rgba(139, 92, 246, 0.15);
            border: 1px solid rgba(139, 92, 246, 0.3);
            color: var(--accent);
            cursor: pointer;
            transition: all 0.2s ease;
            margin-left: auto;
        }

        .voice-speak-btn:hover {
            background: rgba(139, 92, 246, 0.3);
            transform: scale(1.1);
        }

        .voice-speak-btn.speaking {
            background: var(--accent);
            color: white;
            animation: speak-pulse 1s ease-in-out infinite;
        }

        .voice-indicator {
            width: 6px;
            height: 6px;
            background: var(--accent);
            border-radius: 50%;
            animation: voicePulse 1.5s ease-in-out infinite;
            box-shadow: 0 0 10px var(--accent);
        }

        @keyframes voicePulse {
            0%, 100% { opacity: 0.5; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.2); }
        }

        .voice-content {
            font-family: 'Rajdhani', sans-serif;
            font-size: 1.25rem;
            font-weight: 400;
            line-height: 1.7;
            color: var(--text-primary);
            letter-spacing: 0.02em;
            transition: opacity 0.15s ease;
        }

        /* Typing effect cursor */
        .voice-content.typing::after {
            content: '';
            color: var(--accent);
            animation: cursorBlink 1s step-end infinite;
            margin-left: 2px;
        }

        @keyframes cursorBlink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }

        /* Message history - past communications */
        .message-history {
            display: flex;
            flex-direction: column;
            gap: 16px;
            max-height: 300px;
            overflow-y: auto;
            padding-right: 8px;
            margin-bottom: 24px;
        }

        .message-history::-webkit-scrollbar { width: 3px; }
        .message-history::-webkit-scrollbar-track { background: transparent; }
        .message-history::-webkit-scrollbar-thumb { background: rgba(139, 92, 246, 0.3); border-radius: 3px; }

        .voice-message {
            padding: 16px 20px;
            background: rgba(255, 255, 255, 0.02);
            border-left: 2px solid rgba(139, 92, 246, 0.3);
            border-radius: 0 12px 12px 0;
            animation: messageSlide 0.4s ease-out;
            transition: all 0.3s ease;
        }

        .voice-message:hover {
            background: rgba(139, 92, 246, 0.05);
            border-left-color: var(--accent);
        }

        @keyframes messageSlide {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .voice-message.insight {
            border-left-color: rgba(34, 197, 94, 0.5);
            background: rgba(34, 197, 94, 0.03);
        }

        .voice-message.insight:hover {
            border-left-color: #22c55e;
        }

        .message-text {
            font-family: 'Rajdhani', sans-serif;
            font-size: 1rem;
            color: var(--text-secondary);
            line-height: 1.6;
            margin-bottom: 8px;
        }

        .message-meta {
            font-family: 'Space Mono', monospace;
            font-size: 0.7rem;
            color: var(--text-muted);
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .message-type {
            padding: 2px 8px;
            background: rgba(139, 92, 246, 0.15);
            border-radius: 6px;
            color: var(--accent-light);
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .voice-message.insight .message-type {
            background: rgba(34, 197, 94, 0.15);
            color: #22c55e;
        }

        /* ===== DIRECTIVE INPUT - Whisper to Cerebro ===== */
        .directive-whisper {
            max-width: 700px;
            width: 100%;
            margin: 0 auto;
            padding: 0 20px 30px 20px;
            position: relative;
            z-index: 1;
        }

        .whisper-container {
            position: relative;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(139, 92, 246, 0.15);
            border-radius: 16px;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .whisper-container:focus-within {
            border-color: rgba(139, 92, 246, 0.4);
            box-shadow: 0 0 30px rgba(139, 92, 246, 0.1), inset 0 0 20px rgba(139, 92, 246, 0.02);
        }

        .whisper-input {
            width: 100%;
            background: transparent;
            border: none;
            padding: 18px 60px 18px 24px;
            color: var(--text-primary);
            font-family: 'Rajdhani', sans-serif;
            font-size: 1.05rem;
            font-weight: 500;
            letter-spacing: 0.02em;
            outline: none;
            /* Auto-expand textarea styles */
            min-height: 56px;
            max-height: 200px;
            resize: none;
            overflow-y: auto;
            line-height: 1.5;
        }

        .whisper-input::placeholder {
            color: var(--text-muted);
            font-style: italic;
            opacity: 0.6;
        }

        .whisper-send {
            position: absolute;
            right: 8px;
            bottom: 8px;
            width: 40px;
            height: 40px;
            background: rgba(139, 92, 246, 0.2);
            border: 1px solid rgba(139, 92, 246, 0.3);
            border-radius: 12px;
            color: var(--accent-light);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .whisper-send:hover {
            background: rgba(139, 92, 246, 0.4);
            transform: scale(1.05);
        }

        .whisper-send svg {
            width: 18px;
            height: 18px;
            fill: none;
            stroke: currentColor;
            stroke-width: 2;
        }

        /* Active directives - subtle display */
        .active-directives {
            margin-top: 16px;
            margin-bottom: 20px; /* Extra space before nav */
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            justify-content: center;
        }

        .directive-tag {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 14px;
            background: rgba(139, 92, 246, 0.1);
            border: 1px solid rgba(139, 92, 246, 0.2);
            border-radius: 20px;
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.85rem;
            color: var(--text-secondary);
            transition: all 0.3s ease;
            animation: tagAppear 0.3s ease-out;
        }

        @keyframes tagAppear {
            from { opacity: 0; transform: scale(0.9); }
            to { opacity: 1; transform: scale(1); }
        }

        .directive-tag:hover {
            background: rgba(139, 92, 246, 0.15);
            border-color: rgba(139, 92, 246, 0.4);
        }

        .directive-tag .status-dot {
            width: 6px;
            height: 6px;
            background: var(--accent);
            border-radius: 50%;
            animation: directivePulseDot 2s ease-in-out infinite;
        }

        @keyframes directivePulseDot {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; box-shadow: 0 0 8px var(--accent); }
        }

        .directive-tag .remove {
            width: 16px;
            height: 16px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: var(--text-muted);
            transition: all 0.2s ease;
        }

        .directive-tag .remove:hover {
            background: rgba(239, 68, 68, 0.3);
            color: #ef4444;
        }

        /* ===== MINIMAL CONTROLS - Under Orb ===== */
        /* consciousness-controls layout is defined in the main section above */

        .control-btn {
            width: 48px;
            height: 48px;
            background: rgba(20, 20, 30, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 14px;
            color: var(--text-muted);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }

        .control-btn:hover {
            background: rgba(30, 30, 45, 0.95);
            border-color: rgba(139, 92, 246, 0.3);
            color: var(--text-primary);
            transform: translateX(-4px);
        }

        .control-btn.emergency {
            border-color: rgba(239, 68, 68, 0.3);
        }

        .control-btn.emergency:hover {
            background: rgba(239, 68, 68, 0.2);
            border-color: rgba(239, 68, 68, 0.6);
            color: #ef4444;
        }

        .control-btn svg {
            width: 20px;
            height: 20px;
            fill: none;
            stroke: currentColor;
            stroke-width: 1.5;
        }

        /* Expandable technical panel */
        .tech-panel {
            position: fixed;
            bottom: 80px;
            left: 0;
            right: 0;
            background: rgba(10, 10, 15, 0.95);
            border-top: 1px solid rgba(139, 92, 246, 0.2);
            padding: 0;
            max-height: 0;
            overflow: hidden;
            transition: all 0.4s ease;
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            z-index: 50;
        }

        .tech-panel.expanded {
            max-height: 300px;
            padding: 20px 24px;
        }

        .tech-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }

        .tech-panel-title {
            font-family: 'Space Mono', monospace;
            font-size: 0.75rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.15em;
        }

        .tech-stats {
            display: flex;
            gap: 24px;
        }

        .tech-stat {
            text-align: center;
        }

        .tech-stat-value {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.5rem;
            color: var(--accent-light);
        }

        .tech-stat-label {
            font-family: 'Space Mono', monospace;
            font-size: 0.65rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        /* Autonomy level slider - minimal style */
        .level-control {
            margin-top: 16px;
            padding-top: 16px;
            border-top: 1px solid rgba(255, 255, 255, 0.05);
        }

        .level-slider-container {
            position: relative;
        }

        .level-marks {
            display: flex;
            justify-content: space-between;
            padding: 0 2px;
            margin-bottom: 8px;
        }

        .level-mark {
            font-family: 'Space Mono', monospace;
            font-size: 0.6rem;
            color: var(--text-muted);
            opacity: 0.5;
            transition: all 0.3s ease;
        }

        .level-mark.active {
            opacity: 1;
            color: var(--accent);
        }

        .level-slider {
            width: 100%;
            height: 4px;
            -webkit-appearance: none;
            appearance: none;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            outline: none;
        }

        .level-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: var(--accent);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 15px rgba(139, 92, 246, 0.5);
            transition: all 0.2s ease;
        }

        .level-slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 0 25px rgba(139, 92, 246, 0.7);
        }

        /* ===== FLOATING SIDEBARS - LIVE ACTIVITY & QUESTIONS ===== */

        /* Shared sidebar styles */
        /* Old floating sidebars - now hidden, replaced by slide-out panels */
        .floating-sidebar {
            display: none;
        }

        .floating-sidebar.collapsed {
            display: none;
        }

        .floating-sidebar.collapsed .sidebar-content,
        .floating-sidebar.collapsed .sidebar-header-title,
        .floating-sidebar.collapsed .sidebar-header-count {
            opacity: 0;
            visibility: hidden;
        }

        /* Left sidebar - Activity Logs (legacy - hidden) */
        .sidebar-activity {
            display: none;
        }

        /* Right sidebar - Questions (legacy - hidden) */
        .sidebar-questions {
            display: none;
        }

        /* Sidebar header */
        .sidebar-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px;
            border-bottom: 1px solid rgba(139, 92, 246, 0.1);
            flex-shrink: 0;
        }

        .sidebar-header-left {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .sidebar-toggle {
            width: 28px;
            height: 28px;
            background: rgba(139, 92, 246, 0.15);
            border: 1px solid rgba(139, 92, 246, 0.2);
            border-radius: 8px;
            color: var(--accent-light);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            flex-shrink: 0;
        }

        .sidebar-toggle:hover {
            background: rgba(139, 92, 246, 0.25);
            transform: scale(1.1);
        }

        .sidebar-toggle svg {
            width: 14px;
            height: 14px;
            fill: none;
            stroke: currentColor;
            stroke-width: 2;
            transition: transform 0.3s ease;
        }

        .sidebar-activity .sidebar-toggle svg {
            transform: rotate(0deg);
        }

        .sidebar-activity.collapsed .sidebar-toggle svg {
            transform: rotate(180deg);
        }

        .sidebar-questions .sidebar-toggle svg {
            transform: rotate(180deg);
        }

        .sidebar-questions.collapsed .sidebar-toggle svg {
            transform: rotate(0deg);
        }

        .sidebar-header-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.7rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            color: var(--text-secondary);
            transition: opacity 0.3s ease;
        }

        .sidebar-header-count {
            font-family: 'Space Mono', monospace;
            font-size: 0.65rem;
            padding: 3px 8px;
            background: rgba(139, 92, 246, 0.2);
            border-radius: 10px;
            color: var(--accent-light);
            transition: opacity 0.3s ease;
        }

        /* Sidebar content area */
        .sidebar-content {
            flex: 1;
            overflow-y: auto;
            padding: 12px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            transition: opacity 0.3s ease;
        }

        .sidebar-content::-webkit-scrollbar { width: 3px; }
        .sidebar-content::-webkit-scrollbar-track { background: transparent; }
        .sidebar-content::-webkit-scrollbar-thumb {
            background: rgba(139, 92, 246, 0.3);
            border-radius: 3px;
        }

        /* Activity log container: tighter spacing for terminal lines */
        #activity-log-container, #slide-activity-log {
            gap: 1px !important;
            padding: 6px 8px !important;
        }
        /* Floating clear button inside activity section */
        .activity-section-wrapper {
            position: relative;
        }
        .activity-clear-float {
            position: absolute;
            top: 4px;
            right: 6px;
            z-index: 10;
            background: rgba(15, 15, 25, 0.7);
            border: 1px solid rgba(139, 92, 246, 0.15);
            border-radius: 4px;
            padding: 3px 5px;
            cursor: pointer;
            color: rgba(255,255,255,0.3);
            display: flex;
            align-items: center;
            transition: all 0.2s ease;
            backdrop-filter: blur(8px);
        }
        .activity-clear-float:hover {
            color: #ef4444;
            background: rgba(239, 68, 68, 0.1);
            border-color: rgba(239, 68, 68, 0.3);
        }

        /* Activity Log  Cycle-Based View */
        .cycle-row {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 10px;
            font-family: 'JetBrains Mono', 'Fira Code', 'Cascadia Code', monospace;
            font-size: 0.75rem;
            cursor: pointer;
            border-radius: 6px;
            border: 1px solid rgba(139, 92, 246, 0.1);
            transition: all 0.15s ease;
            animation: logSlideIn 0.2s ease-out;
            margin-bottom: 4px;
        }
        .cycle-row:hover { background: rgba(139, 92, 246, 0.08); border-color: rgba(139, 92, 246, 0.25); }
        .cycle-row.running { border-color: rgba(139, 92, 246, 0.4); animation: cyclePulse 2s ease-in-out infinite; }
        .cycle-number { color: var(--accent, #8b5cf6); font-weight: 600; min-width: 56px; flex-shrink: 0; }
        .cycle-time { color: var(--text-muted, rgba(255,255,255,0.35)); min-width: 80px; flex-shrink: 0; font-variant-numeric: tabular-nums; }
        .cycle-steps { color: rgba(255,255,255,0.5); white-space: nowrap; }
        .cycle-decision { color: var(--text-secondary, rgba(255,255,255,0.6)); overflow: hidden; text-overflow: ellipsis; white-space: nowrap; min-width: 0; flex: 1; }
        .cycle-status { margin-left: auto; flex-shrink: 0; }
        .cycle-status.completed { color: #22c55e; }
        .cycle-status.running { color: #f59e0b; }
        .cycle-status.error { color: #ef4444; }
        @keyframes cyclePulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(139, 92, 246, 0); }
            50% { box-shadow: 0 0 12px 2px rgba(139, 92, 246, 0.15); }
        }

        /* Cycle detail modal */
        .cycle-modal-overlay { position:fixed;inset:0;background:rgba(0,0,0,0.7);z-index:10000;display:flex;align-items:center;justify-content:center;backdrop-filter:blur(4px);animation:fadeIn 0.15s ease; }
        .cycle-modal { background:var(--card-bg, #1a1a2e);border:1px solid rgba(139,92,246,0.3);border-radius:16px;padding:24px;max-width:640px;width:92%;max-height:85vh;overflow-y:auto;animation:scaleIn 0.2s ease; }
        .cycle-modal-header { display:flex;align-items:center;justify-content:space-between;margin-bottom:16px; }
        .cycle-modal-title { font-size:1rem;font-weight:700;color:var(--text-primary, #fff); }
        .cycle-modal-meta { font-size:0.72rem;color:var(--text-muted, rgba(255,255,255,0.4));margin-bottom:12px; }
        .cycle-modal-close { background:none;border:none;color:var(--text-muted);font-size:1.4rem;cursor:pointer;padding:4px 8px;border-radius:4px; }
        .cycle-modal-close:hover { background:rgba(255,255,255,0.1);color:#fff; }

        /* Tree view */
        .cycle-tree-phase { padding: 4px 0; }
        .cycle-tree-phase-header { display:flex;align-items:center;gap:8px;cursor:pointer;padding:6px 8px;border-radius:6px;transition:background 0.1s; }
        .cycle-tree-phase-header:hover { background:rgba(255,255,255,0.05); }
        .cycle-tree-chevron { transition:transform 0.2s; font-size:0.65rem; color:var(--text-muted, rgba(255,255,255,0.4)); min-width:12px; }
        .cycle-tree-chevron.open { transform:rotate(90deg); }
        .cycle-tree-phase-badge { font-size:0.68rem; font-weight:700; text-transform:uppercase; padding:2px 6px; border-radius:4px; letter-spacing:0.03em; }
        .cycle-tree-phase-badge.observe { background:rgba(59,130,246,0.15); color:#60a5fa; }
        .cycle-tree-phase-badge.orient  { background:rgba(245,158,11,0.15); color:#fbbf24; }
        .cycle-tree-phase-badge.decide  { background:rgba(168,85,247,0.15); color:#c084fc; }
        .cycle-tree-phase-badge.act     { background:rgba(16,185,129,0.15); color:#34d399; }
        .cycle-tree-phase-badge.reflect { background:rgba(236,72,153,0.15); color:#f472b6; }
        .cycle-tree-phase-time { color:var(--text-muted, rgba(255,255,255,0.35));font-size:0.68rem;font-variant-numeric:tabular-nums; }
        .cycle-tree-phase-summary { color:var(--text-secondary, rgba(255,255,255,0.6));font-size:0.75rem;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;min-width:0;flex:1; }

        /* Nested content (expandable) */
        .cycle-tree-details { padding:8px 8px 8px 28px;font-size:0.75rem;color:var(--text-secondary, rgba(255,255,255,0.65)); display:none; }
        .cycle-tree-details.open { display:block; }
        .cycle-tree-detail-label { font-size:0.68rem;color:var(--text-muted, rgba(255,255,255,0.4));margin-top:8px;margin-bottom:2px; }
        .cycle-tree-detail-content { white-space:pre-wrap;line-height:1.5; }
        .cycle-tree-confidence { display:inline-flex;align-items:center;gap:4px;margin-top:4px; }
        .cycle-tree-confidence-bar { width:60px;height:4px;background:rgba(255,255,255,0.1);border-radius:2px;overflow:hidden; }
        .cycle-tree-confidence-fill { height:100%;border-radius:2px; }

        /* Browser steps nested under ACT */
        .cycle-tree-browser-steps { padding:4px 0 0 20px;border-left:2px solid rgba(16,185,129,0.2);margin-left:12px; }
        .cycle-tree-browser-step { display:flex;gap:6px;padding:3px 0 3px 8px;font-size:0.72rem;color:rgba(255,255,255,0.6); }
        .cycle-tree-browser-step-num { color:var(--accent, #8b5cf6);min-width:18px;font-weight:600; }
        .cycle-tree-browser-step-action { color:#34d399; }
        .cycle-tree-browser-step-detail { color:rgba(255,255,255,0.45);overflow:hidden;text-overflow:ellipsis;white-space:nowrap; }
        /* Alive pulse dot */
        .alive-pulse {
            display: inline-block;
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: #8b5cf6;
            margin-left: 6px;
            vertical-align: middle;
            animation: alivePulse 3s ease-in-out infinite;
        }
        .alive-pulse.hidden { display: none; }
        @keyframes alivePulse {
            0%, 100% { opacity: 0.2; }
            50% { opacity: 1; }
        }

        /* ===== LEFT SIDEBAR SPLIT LAYOUT ===== */
        .sidebar-split-left {
            display: flex;
            flex-direction: column;
            flex: 1;
            overflow: hidden;
        }

        .sidebar-section-activity {
            flex: 1;
            min-height: 0;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .sidebar-section-activity .sidebar-content {
            flex: 1;
            overflow-y: auto;
        }

        .sidebar-section-controls {
            flex-shrink: 0;
            background: linear-gradient(180deg, rgba(139, 92, 246, 0.05), rgba(8, 8, 12, 0.98));
            border-top: 1px solid rgba(139, 92, 246, 0.2);
            padding: 16px;
        }

        .controls-section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .controls-section-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.65rem;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            color: var(--text-muted);
        }

        .controls-current-level {
            font-family: 'Space Mono', monospace;
            font-size: 1.2rem;
            font-weight: 700;
            background: linear-gradient(135deg, #a78bfa, #7c3aed);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        /* Controls Stats Row */
        .controls-stats {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
        }

        .controls-stat {
            flex: 1;
            background: rgba(20, 15, 35, 0.6);
            border-radius: 8px;
            padding: 8px 6px;
            text-align: center;
            border: 1px solid rgba(139, 92, 246, 0.1);
        }

        .controls-stat-value {
            font-family: 'Space Mono', monospace;
            font-size: 1rem;
            font-weight: 700;
            color: var(--accent-light);
        }

        .controls-stat-label {
            font-size: 0.55rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-muted);
            margin-top: 2px;
        }

        /* Compact Level Slider */
        .controls-level-slider {
            margin-bottom: 12px;
        }

        .level-marks-compact {
            display: flex;
            justify-content: space-between;
            padding: 0 2px;
            margin-bottom: 6px;
        }

        .level-mark-compact {
            font-family: 'Space Mono', monospace;
            font-size: 0.65rem;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            background: rgba(30, 30, 50, 0.5);
            color: var(--text-muted);
            transition: all 0.3s ease;
        }

        .level-mark-compact.active {
            background: linear-gradient(135deg, #a78bfa, #7c3aed);
            color: white;
            box-shadow: 0 0 12px rgba(139, 92, 246, 0.5);
        }

        .level-slider-compact {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: linear-gradient(90deg, rgba(30, 30, 50, 0.8), rgba(50, 50, 80, 0.8));
            -webkit-appearance: none;
            appearance: none;
            cursor: pointer;
            border: 1px solid rgba(139, 92, 246, 0.2);
        }

        .level-slider-compact::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: linear-gradient(135deg, #a78bfa, #7c3aed);
            cursor: pointer;
            box-shadow: 0 0 12px rgba(139, 92, 246, 0.6);
            border: 2px solid rgba(255,255,255,0.2);
        }

        .level-slider-compact::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: linear-gradient(135deg, #a78bfa, #7c3aed);
            cursor: pointer;
            border: 2px solid rgba(255,255,255,0.2);
        }

        .level-labels-compact {
            display: flex;
            justify-content: space-between;
            margin-top: 4px;
            font-size: 0.55rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        /* Full Autonomy Toggle Compact */
        .controls-full-autonomy {
            background: rgba(30, 25, 45, 0.5);
            border-radius: 8px;
            padding: 10px;
            border: 1px solid rgba(139, 92, 246, 0.15);
        }

        .controls-full-autonomy.enabled {
            border-color: rgba(239, 68, 68, 0.4);
            background: rgba(239, 68, 68, 0.08);
        }

        .full-autonomy-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .full-autonomy-info {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .full-autonomy-label {
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .full-autonomy-desc {
            font-size: 0.6rem;
            color: var(--text-muted);
        }

        .toggle-switch-compact {
            position: relative;
            display: inline-block;
            width: 38px;
            height: 20px;
        }

        .toggle-switch-compact input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider-compact {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(30, 30, 50, 0.8);
            border: 1px solid var(--border);
            transition: all 0.3s ease;
            border-radius: 20px;
        }

        .toggle-slider-compact:before {
            position: absolute;
            content: "";
            height: 14px;
            width: 14px;
            left: 2px;
            bottom: 2px;
            background-color: var(--text-muted);
            transition: all 0.3s ease;
            border-radius: 50%;
        }

        .toggle-switch-compact input:checked + .toggle-slider-compact {
            background-color: var(--red);
            border-color: var(--red);
        }

        .toggle-switch-compact input:checked + .toggle-slider-compact:before {
            transform: translateX(18px);
            background-color: white;
        }

        /* ===== EMERGENCY STOP BUTTON (In Sidebar) ===== */
        .sidebar-emergency-stop {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid rgba(255, 255, 255, 0.06);
        }

        .sidebar-emergency-stop .emergency-stop-btn {
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: center;
            gap: 8px;
            width: 100%;
            padding: 10px 16px;
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.1), rgba(220, 38, 38, 0.05));
            border: 1px solid rgba(239, 68, 68, 0.3);
            border-radius: 10px;
            color: rgba(239, 68, 68, 0.8);
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: 'Orbitron', sans-serif;
        }

        .sidebar-emergency-stop .emergency-stop-btn:hover {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            color: white;
            border-color: #ef4444;
            box-shadow: 0 0 20px rgba(239, 68, 68, 0.4);
            transform: scale(1.02);
        }

        .sidebar-emergency-stop .emergency-stop-btn:active {
            transform: scale(0.98);
        }

        .sidebar-emergency-stop .emergency-stop-icon {
            width: 16px;
            height: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .sidebar-emergency-stop .emergency-stop-icon svg {
            width: 100%;
            height: 100%;
            fill: currentColor;
            stroke: none;
        }

        .sidebar-emergency-stop .emergency-stop-label {
            font-size: 0.7rem;
            font-weight: 600;
            letter-spacing: 0.15em;
        }

        /* ===== AGENTS STATUS PANEL ===== */
        .agents-status-panel {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            background: rgba(15, 10, 30, 0.95);
            border: 1px solid var(--border);
            border-radius: 12px;
            min-width: 200px;
            max-width: 400px;
            backdrop-filter: blur(20px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
            display: block;
        }

        .agents-status-panel.has-agents {
            border-color: var(--primary);
            box-shadow: 0 8px 32px rgba(139, 92, 246, 0.3);
        }

        .agents-status-panel.expanded {
            max-height: 300px;
        }

        .agents-status-header {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 14px;
            cursor: pointer;
            transition: background 0.2s ease;
            border-radius: 12px;
        }

        .agents-status-header:hover {
            background: rgba(139, 92, 246, 0.1);
        }

        .agents-status-icon {
            color: var(--primary);
            display: flex;
            align-items: center;
        }

        .agents-status-icon svg {
            animation: pulse-slow 2s ease-in-out infinite;
        }

        @keyframes pulse-slow {
            0%, 100% { opacity: 0.7; }
            50% { opacity: 1; }
        }

        .agents-status-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.7rem;
            font-weight: 600;
            letter-spacing: 0.1em;
            color: var(--text-secondary);
            text-transform: uppercase;
        }

        .agents-status-count {
            background: var(--primary);
            color: white;
            font-size: 0.7rem;
            font-weight: 700;
            padding: 2px 8px;
            border-radius: 10px;
            min-width: 20px;
            text-align: center;
        }

        .agents-status-count.zero {
            background: var(--text-muted);
            opacity: 0.5;
        }

        .agents-status-expand {
            margin-left: auto;
            color: var(--text-muted);
            transition: transform 0.3s ease;
        }

        .agents-status-panel.expanded .agents-status-expand {
            transform: rotate(180deg);
        }

        .agents-status-body {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
            border-top: 1px solid transparent;
        }

        .agents-status-panel.expanded .agents-status-body {
            max-height: 200px;
            overflow-y: auto;
            border-top-color: var(--border);
        }

        .agents-status-empty {
            padding: 16px;
            text-align: center;
            color: var(--text-muted);
            font-size: 0.8rem;
        }

        .agents-status-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 14px;
            border-bottom: 1px solid var(--border);
            transition: background 0.2s ease;
            cursor: pointer;
        }

        .agents-status-item:last-child {
            border-bottom: none;
        }

        .agents-status-item:hover {
            background: rgba(139, 92, 246, 0.1);
        }

        .agent-status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .agent-status-dot.running {
            background: var(--green);
            box-shadow: 0 0 8px var(--green);
            animation: pulse 1.5s ease-in-out infinite;
        }

        .agent-status-dot.queued {
            background: var(--yellow);
        }

        .agent-status-dot.completed {
            background: var(--blue);
        }

        .agent-status-dot.failed {
            background: var(--red);
        }

        .agent-status-info {
            flex: 1;
            min-width: 0;
        }

        .agent-status-name {
            font-family: 'Space Mono', monospace;
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .agent-status-task {
            font-size: 0.7rem;
            color: var(--text-muted);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .agent-status-type {
            font-size: 0.6rem;
            padding: 2px 6px;
            border-radius: 4px;
            background: rgba(139, 92, 246, 0.2);
            color: var(--primary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        /* Hide collapsed sidebar controls content */
        .floating-sidebar.collapsed .sidebar-split-left {
            opacity: 0;
            visibility: hidden;
        }

        @keyframes logSlideIn {
            from { opacity: 0; transform: translateX(-20px); }
            to { opacity: 1; transform: translateX(0); }
        }

        .activity-log-phase {
            font-family: 'Space Mono', monospace;
            font-size: 0.6rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-muted);
            margin-bottom: 4px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .activity-log-phase .phase-dot {
            width: 5px;
            height: 5px;
            border-radius: 50%;
            background: currentColor;
        }

        .activity-log-item.phase-observe .phase-dot { background: #3b82f6; }
        .activity-log-item.phase-orient .phase-dot { background: #8b5cf6; }
        .activity-log-item.phase-decide .phase-dot { background: #fbbf24; }
        .activity-log-item.phase-act .phase-dot { background: #f97316; }
        .activity-log-item.phase-reflect .phase-dot { background: #10b981; }
        .activity-log-item.phase-idle .phase-dot { background: #6b7280; }

        /* Important activities (ACT, DECIDE) get visual emphasis */
        .activity-log-item.important {
            background: rgba(249, 115, 22, 0.1);
            border-left-width: 3px;
            padding-left: 10px;
        }

        .activity-log-item.important .activity-log-content {
            color: var(--text-primary);
            font-weight: 500;
        }

        /* IDLE items are dimmed */
        .activity-log-item.phase-idle {
            opacity: 0.6;
        }

        .activity-log-item.phase-idle .activity-log-content {
            font-style: italic;
        }

        /* Phase icon replaces dot */
        .phase-icon {
            font-size: 0.9rem;
            margin-right: 4px;
        }

        .activity-log-content {
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.85rem;
            line-height: 1.4;
            color: var(--text-secondary);
        }

        .activity-log-time {
            font-family: 'Space Mono', monospace;
            font-size: 0.55rem;
            color: var(--text-muted);
            margin-top: 6px;
        }

        /* Question Items */
        .question-item {
            padding: 14px;
            background: linear-gradient(135deg, rgba(236, 72, 153, 0.08), rgba(139, 92, 246, 0.05));
            border: 1px solid rgba(236, 72, 153, 0.2);
            border-radius: 12px;
            animation: questionFadeIn 0.4s ease-out;
            transition: all 0.3s ease;
        }

        .question-item:hover {
            background: linear-gradient(135deg, rgba(236, 72, 153, 0.15), rgba(139, 92, 246, 0.1));
            border-color: rgba(236, 72, 153, 0.4);
            transform: translateX(-4px);
        }

        @keyframes questionFadeIn {
            from { opacity: 0; transform: translateX(20px); }
            to { opacity: 1; transform: translateX(0); }
        }

        .question-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .question-icon {
            font-size: 0.9rem;
        }

        .question-tag {
            font-family: 'Space Mono', monospace;
            font-size: 0.55rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            padding: 2px 8px;
            background: rgba(236, 72, 153, 0.2);
            border-radius: 8px;
            color: #ec4899;
        }

        .question-text {
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.95rem;
            line-height: 1.5;
            color: var(--text-primary);
            margin-bottom: 12px;
        }

        .question-context {
            font-size: 0.75rem;
            color: var(--text-muted);
            font-style: italic;
            margin-bottom: 12px;
            padding-left: 10px;
            border-left: 2px solid rgba(236, 72, 153, 0.3);
        }

        .question-actions {
            display: flex;
            gap: 8px;
        }

        .question-btn {
            flex: 1;
            padding: 8px 12px;
            border-radius: 8px;
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.8rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 1px solid transparent;
        }

        .question-btn.answer {
            background: rgba(236, 72, 153, 0.2);
            border-color: rgba(236, 72, 153, 0.3);
            color: #ec4899;
        }

        .question-btn.answer:hover {
            background: rgba(236, 72, 153, 0.3);
            transform: translateY(-1px);
        }

        .question-btn.dismiss {
            background: rgba(255, 255, 255, 0.05);
            color: var(--text-muted);
        }

        .question-btn.dismiss:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        /* Question input overlay */
        .question-input-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .question-input-overlay.active {
            display: flex;
        }

        .question-input-card {
            width: 90%;
            max-width: 500px;
            background: rgba(15, 15, 25, 0.98);
            border: 1px solid rgba(236, 72, 153, 0.3);
            border-radius: 20px;
            padding: 30px;
            animation: questionCardPop 0.3s ease-out;
        }

        @keyframes questionCardPop {
            from { opacity: 0; transform: scale(0.9); }
            to { opacity: 1; transform: scale(1); }
        }

        .question-input-header {
            text-align: center;
            margin-bottom: 20px;
        }

        .question-input-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: #ec4899;
            margin-bottom: 8px;
        }

        .question-input-question {
            font-family: 'Rajdhani', sans-serif;
            font-size: 1.1rem;
            color: var(--text-primary);
            line-height: 1.5;
        }

        .question-input-field {
            width: 100%;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(236, 72, 153, 0.2);
            border-radius: 12px;
            padding: 16px;
            color: var(--text-primary);
            font-family: 'Rajdhani', sans-serif;
            font-size: 1rem;
            min-height: 100px;
            resize: vertical;
            margin-bottom: 16px;
        }

        .question-input-field:focus {
            outline: none;
            border-color: rgba(236, 72, 153, 0.5);
            box-shadow: 0 0 20px rgba(236, 72, 153, 0.1);
        }

        .question-input-actions {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
        }

        .question-input-btn {
            padding: 12px 24px;
            border-radius: 10px;
            font-family: 'Rajdhani', sans-serif;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 1px solid transparent;
        }

        .question-input-btn.submit {
            background: linear-gradient(135deg, #ec4899, #8b5cf6);
            color: white;
        }

        .question-input-btn.submit:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(236, 72, 153, 0.3);
        }

        .question-input-btn.cancel {
            background: rgba(255, 255, 255, 0.05);
            color: var(--text-muted);
        }

        .question-input-btn.cancel:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        /* Empty state for sidebars */
        .sidebar-empty {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 40px 20px;
            text-align: center;
            color: var(--text-muted);
        }

        .sidebar-empty-icon {
            font-size: 2rem;
            margin-bottom: 12px;
            opacity: 0.5;
        }

        .sidebar-empty-text {
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.9rem;
            line-height: 1.5;
        }

        /* Split Sidebar Layout - Questions + Current Focus */
        .sidebar-split {
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        .sidebar-section {
            display: flex;
            flex-direction: column;
            min-height: 0;
        }

        .sidebar-section.section-questions {
            flex: 1;
            border-bottom: 1px solid rgba(139, 92, 246, 0.15);
        }

        /* Chat Section Styles - 50% of sidebar */
        .sidebar-section.section-chat {
            flex: 0 0 50%;
            display: flex;
            flex-direction: column;
            border-bottom: 1px solid rgba(139, 92, 246, 0.15);
            min-height: 150px;
            max-height: 50%;
        }

        .cerebro-questions-badge {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 4px 10px;
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.2) 0%, rgba(249, 115, 22, 0.2) 100%);
            border: 1px solid rgba(239, 68, 68, 0.4);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
            animation: badge-pulse 2s ease-in-out infinite;
        }

        .cerebro-questions-badge:hover {
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.3) 0%, rgba(249, 115, 22, 0.3) 100%);
            transform: scale(1.02);
        }

        @keyframes badge-pulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.4); }
            50% { box-shadow: 0 0 8px 2px rgba(239, 68, 68, 0.3); }
        }

        .badge-icon { font-size: 0.7rem; }
        .badge-text {
            font-size: 0.6rem;
            font-weight: 500;
            color: #f87171;
        }
        .badge-count {
            font-family: 'Space Mono', monospace;
            font-size: 0.6rem;
            padding: 1px 5px;
            background: rgba(239, 68, 68, 0.3);
            border-radius: 6px;
            color: #fca5a5;
        }

        .cerebro-chat-area {
            flex: 1;
            overflow-y: auto;
            padding: 12px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .cerebro-chat-area::-webkit-scrollbar { width: 3px; }
        .cerebro-chat-area::-webkit-scrollbar-track { background: transparent; }
        .cerebro-chat-area::-webkit-scrollbar-thumb {
            background: rgba(139, 92, 246, 0.3);
            border-radius: 2px;
        }

        .chat-welcome {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 30px 20px;
            opacity: 0.6;
            text-align: center;
        }
        .chat-welcome-icon { font-size: 2rem; margin-bottom: 8px; }
        .chat-welcome-text { font-size: 0.85rem; font-weight: 500; color: var(--text-secondary); }
        .chat-welcome-hint { font-size: 0.7rem; color: var(--text-muted); margin-top: 4px; }

        .chat-message {
            max-width: 85%;
            padding: 10px 14px;
            border-radius: 16px;
            font-size: 0.8rem;
            line-height: 1.5;
            animation: msg-fade-in 0.2s ease;
        }

        @keyframes msg-fade-in {
            from { opacity: 0; transform: translateY(8px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .chat-message.user {
            align-self: flex-end;
            background: linear-gradient(135deg, var(--accent) 0%, var(--accent-dark) 100%);
            color: white;
            border-bottom-right-radius: 4px;
        }

        .chat-message.cerebro {
            align-self: flex-start;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: var(--text-primary);
            border-bottom-left-radius: 4px;
            position: relative;
        }

        .chat-message-content {
            margin-bottom: 4px;
        }

        /* Message content wrapper for proper layout */
        .message .message-content-wrapper {
            flex: 1;
        }

        /* Assistant messages need flex layout for speaker button */
        .message.assistant {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            position: relative;
        }

        .chat-speak-btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 26px;
            height: 26px;
            border-radius: 50%;
            background: rgba(139, 92, 246, 0.15);
            border: 1px solid rgba(139, 92, 246, 0.25);
            color: var(--accent-light);
            cursor: pointer;
            transition: all 0.2s ease;
            margin-top: 8px;
            opacity: 0.7;
            flex-shrink: 0;
        }

        .chat-speak-btn:hover {
            background: rgba(139, 92, 246, 0.4);
            transform: scale(1.1);
            opacity: 1;
        }

        .chat-speak-btn.speaking {
            background: var(--accent);
            color: white;
            opacity: 1;
            animation: speak-pulse 1s ease-in-out infinite;
        }

        .chat-speak-btn svg {
            width: 14px;
            height: 14px;
        }


        /* TTS loading state */
        .chat-speak-btn.loading,
        .voice-speak-btn.loading {
            opacity: 1;
            pointer-events: none;
            position: relative;
        }
        .chat-speak-btn.loading svg,
        .voice-speak-btn.loading svg {
            opacity: 0;
        }
        .chat-speak-btn.loading::after,
        .voice-speak-btn.loading::after {
            content: '';
            position: absolute;
            width: 14px;
            height: 14px;
            border: 2px solid rgba(139, 92, 246, 0.3);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin-loader 0.6s linear infinite;
        }
        @keyframes spin-loader {
            to { transform: rotate(360deg); }
        }
        @keyframes speak-pulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(139, 92, 246, 0.4); }
            50% { box-shadow: 0 0 0 6px rgba(139, 92, 246, 0); }
        }
        /* TTS loading animation on orb */
        #nav-orb-container.loading-tts .nav-orb-img {
            animation: orb-loading 1s ease-in-out infinite;
        }
        @keyframes orb-loading {
            0%, 100% { opacity: 0.7; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.05); }
        }

        .model-badge {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 0.65rem;
            color: var(--text-muted);
            margin-top: 6px;
            padding-top: 4px;
            border-top: 1px solid var(--border);
            opacity: 0.7;
        }

        .model-badge .model-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .chat-message.typing {
            background: rgba(139, 92, 246, 0.1);
            border: 1px solid rgba(139, 92, 246, 0.2);
        }

        .typing-indicator {
            display: flex;
            gap: 4px;
            padding: 4px 0;
        }
        .typing-indicator span {
            width: 6px;
            height: 6px;
            background: var(--accent);
            border-radius: 50%;
            animation: typing-bounce 1.4s ease-in-out infinite;
        }
        .typing-indicator span:nth-child(2) { animation-delay: 0.2s; }
        .typing-indicator span:nth-child(3) { animation-delay: 0.4s; }

        @keyframes typing-bounce {
            0%, 60%, 100% { transform: translateY(0); }
            30% { transform: translateY(-6px); }
        }

        .cerebro-chat-input {
            display: flex;
            gap: 8px;
            padding: 10px 12px;
            border-top: 1px solid rgba(255, 255, 255, 0.05);
            background: rgba(0, 0, 0, 0.2);
        }

        .cerebro-chat-input input {
            flex: 1;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 10px 16px;
            color: var(--text-primary);
            font-size: 0.8rem;
            outline: none;
            transition: all 0.2s ease;
        }

        .cerebro-chat-input input:focus {
            border-color: var(--accent);
            background: rgba(139, 92, 246, 0.1);
        }

        .cerebro-chat-input input::placeholder {
            color: var(--text-muted);
        }

        .chat-send-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--accent) 0%, var(--accent-dark) 100%);
            border: none;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .chat-send-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(139, 92, 246, 0.4);
        }

        /* Questions Wizard Modal */
        .questions-wizard-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(8px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            animation: wizard-fade-in 0.3s ease;
        }

        .questions-wizard-overlay.active {
            display: flex;
        }

        @keyframes wizard-fade-in {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .questions-wizard {
            width: 90%;
            max-width: 500px;
            max-height: 80vh;
            background: linear-gradient(180deg, rgba(30, 20, 50, 0.98) 0%, rgba(15, 10, 30, 0.98) 100%);
            border: 1px solid rgba(139, 92, 246, 0.3);
            border-radius: 20px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            animation: wizard-slide-up 0.3s ease;
        }

        @keyframes wizard-slide-up {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .wizard-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px 20px;
            border-bottom: 1px solid rgba(139, 92, 246, 0.2);
        }

        .wizard-header-left {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .wizard-icon { font-size: 1.3rem; }
        .wizard-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .wizard-close {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: var(--text-muted);
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .wizard-close:hover {
            background: rgba(239, 68, 68, 0.2);
            color: #ef4444;
        }

        .wizard-progress {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 20px;
            background: rgba(0, 0, 0, 0.2);
        }

        .wizard-progress-bar {
            flex: 1;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            overflow: hidden;
            position: relative;
        }

        .wizard-progress-bar::after {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            height: 100%;
            width: var(--progress, 33%);
            background: linear-gradient(90deg, var(--accent) 0%, #a78bfa 100%);
            border-radius: 2px;
            transition: width 0.3s ease;
        }

        .wizard-progress-text {
            font-family: 'Space Mono', monospace;
            font-size: 0.7rem;
            color: var(--text-muted);
            white-space: nowrap;
        }

        .wizard-content {
            flex: 1;
            overflow-y: auto;
            padding: 24px 20px;
        }

        .wizard-question-tag {
            display: inline-block;
            padding: 4px 10px;
            background: rgba(139, 92, 246, 0.2);
            border-radius: 12px;
            font-size: 0.65rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--accent-light);
            margin-bottom: 12px;
        }

        .wizard-question-text {
            font-size: 0.95rem;
            line-height: 1.7;
            color: var(--text-primary);
            margin-bottom: 20px;
        }

        .wizard-answer-input {
            width: 100%;
            min-height: 100px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 14px;
            color: var(--text-primary);
            font-size: 0.85rem;
            resize: vertical;
            outline: none;
            transition: all 0.2s ease;
        }

        .wizard-answer-input:focus {
            border-color: var(--accent);
            background: rgba(139, 92, 246, 0.1);
        }

        .wizard-actions {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px 20px;
            border-top: 1px solid rgba(139, 92, 246, 0.2);
            background: rgba(0, 0, 0, 0.2);
        }

        .wizard-actions-right {
            display: flex;
            gap: 10px;
        }

        .wizard-btn {
            padding: 10px 20px;
            border-radius: 10px;
            font-size: 0.8rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            border: none;
        }

        .wizard-btn.skip {
            background: transparent;
            color: var(--text-muted);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .wizard-btn.skip:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .wizard-btn.prev {
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-secondary);
        }
        .wizard-btn.prev:hover {
            background: rgba(255, 255, 255, 0.15);
        }
        .wizard-btn.prev:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .wizard-btn.next {
            background: linear-gradient(135deg, var(--accent) 0%, var(--accent-dark) 100%);
            color: white;
        }
        .wizard-btn.next:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(139, 92, 246, 0.4);
        }

        /* Unified Tabbed Section - 50% of sidebar (after Chat takes 50%) */
        .sidebar-section.section-unified-tabs {
            flex: 1 1 50%;
            min-height: 0;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .sidebar-section.section-unified-tabs .tab-content {
            flex: 1;
            overflow-y: auto;
        }

        .section-header {
            padding: 12px 16px 8px 16px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 1px solid rgba(255, 255, 255, 0.03);
        }

        .section-header-left {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .section-header-icon {
            font-size: 0.9rem;
            opacity: 0.7;
        }

        .section-header-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.6rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            color: var(--text-muted);
        }

        .section-header-count {
            font-family: 'Space Mono', monospace;
            font-size: 0.6rem;
            padding: 2px 6px;
            background: rgba(139, 92, 246, 0.15);
            border-radius: 8px;
            color: var(--accent-light);
        }

        /* Unified 3-Tab Layout for Focus/Completed/Skills */
        .section-tabs, .section-tabs-3 {
            display: flex;
            padding: 0 !important;
            border-bottom: none !important;
        }

        .section-tab {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
            padding: 8px 4px;
            cursor: pointer;
            border-bottom: 2px solid transparent;
            transition: all 0.2s ease;
            opacity: 0.5;
        }

        .section-tab:hover {
            opacity: 0.8;
            background: rgba(255, 255, 255, 0.02);
        }

        .section-tab.active {
            opacity: 1;
            border-bottom-color: var(--accent);
            background: rgba(139, 92, 246, 0.05);
        }

        .section-tab-icon {
            font-size: 0.75rem;
        }

        .section-tab-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.5rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-muted);
        }

        .section-tab.active .section-tab-title {
            color: var(--text-primary);
        }

        .section-tab-count {
            font-family: 'Space Mono', monospace;
            font-size: 0.5rem;
            padding: 1px 4px;
            background: rgba(139, 92, 246, 0.15);
            border-radius: 4px;
            color: var(--accent-light);
        }

        .section-content.hidden, .tab-content.hidden {
            display: none !important;
        }

        .section-content {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .section-content::-webkit-scrollbar { width: 2px; }
        .section-content::-webkit-scrollbar-track { background: transparent; }
        .section-content::-webkit-scrollbar-thumb {
            background: rgba(139, 92, 246, 0.2);
            border-radius: 2px;
        }

        /* Completed Section - 50/50 split with Focus section */
        .section-completed {
            flex: 1 1 0;
            min-height: 0;
            border-top: 1px solid rgba(16, 185, 129, 0.15);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .section-completed .section-content {
            flex: 1;
            overflow-y: auto;
            padding-right: 4px;
        }

        .section-completed .section-content::-webkit-scrollbar {
            width: 4px;
        }

        .section-completed .section-content::-webkit-scrollbar-track {
            background: transparent;
        }

        .section-completed .section-content::-webkit-scrollbar-thumb {
            background: rgba(16, 185, 129, 0.3);
            border-radius: 2px;
        }

        .section-completed .section-content::-webkit-scrollbar-thumb:hover {
            background: rgba(16, 185, 129, 0.5);
        }

        .section-completed .section-header {
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .section-completed .section-header:hover {
            background: rgba(16, 185, 129, 0.1);
        }

        .section-header-right {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .section-collapse-icon {
            font-size: 0.6rem;
            color: var(--text-muted);
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .section-collapsed .section-collapse-icon {
            transform: rotate(-90deg);
        }

        .section-collapsible {
            transition: max-height 0.3s ease, opacity 0.2s ease;
            overflow: hidden;
        }

        .section-collapsed .section-collapsible {
            max-height: 0 !important;
            opacity: 0;
            padding: 0 10px;
        }

        .section-completed .section-header-count {
            background: rgba(16, 185, 129, 0.15);
            color: #10b981;
        }

        /* ===== SKILLS SECTION - Learned Browser Automations ===== */
        .section-skills {
            margin-top: 8px;
            border-top: 1px solid rgba(139, 92, 246, 0.1);
            padding-top: 8px;
        }

        .section-skills .section-header {
            cursor: pointer;
            transition: background 0.2s ease;
            border-radius: 8px;
        }

        .section-skills .section-header:hover {
            background: rgba(139, 92, 246, 0.1);
        }

        .section-skills .section-header-count {
            background: rgba(139, 92, 246, 0.15);
            color: var(--accent);
        }

        .skills-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
            max-height: 200px;
            overflow-y: auto;
        }

        .skills-list::-webkit-scrollbar { width: 4px; }
        .skills-list::-webkit-scrollbar-track { background: transparent; }
        .skills-list::-webkit-scrollbar-thumb {
            background: rgba(139, 92, 246, 0.3);
            border-radius: 2px;
        }

        .skills-empty {
            text-align: center;
            padding: 16px 8px;
            color: var(--text-muted);
            font-size: 0.8rem;
        }

        .skill-card {
            background: rgba(139, 92, 246, 0.08);
            border: 1px solid rgba(139, 92, 246, 0.15);
            border-radius: 8px;
            padding: 10px 12px;
            transition: all 0.2s ease;
        }

        .skill-card:hover {
            background: rgba(139, 92, 246, 0.12);
            border-color: rgba(139, 92, 246, 0.25);
        }

        .skill-card.skill-new {
            animation: skillSlideIn 0.3s ease;
        }

        .skill-card.skill-active {
            border-color: var(--accent);
            box-shadow: 0 0 12px rgba(139, 92, 246, 0.3);
        }

        @keyframes skillSlideIn {
            from {
                opacity: 0;
                transform: translateX(-20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .skill-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 4px;
        }

        .skill-name {
            font-weight: 600;
            font-size: 0.85rem;
            color: var(--text-primary);
        }

        .skill-status {
            font-size: 0.65rem;
            padding: 2px 6px;
            border-radius: 4px;
            text-transform: uppercase;
        }

        .skill-status.verified {
            background: rgba(34, 197, 94, 0.2);
            color: #22c55e;
        }

        .skill-status.unverified {
            background: rgba(234, 179, 8, 0.2);
            color: #eab308;
        }

        .skill-status.failed {
            background: rgba(239, 68, 68, 0.2);
            color: #ef4444;
        }

        .skill-description {
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-bottom: 6px;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        .skill-meta {
            font-size: 0.7rem;
            color: var(--text-muted);
            display: flex;
            gap: 6px;
            margin-bottom: 8px;
        }

        .skill-actions {
            display: flex;
            gap: 6px;
        }

        .skill-btn {
            padding: 4px 10px;
            border-radius: 4px;
            border: none;
            cursor: pointer;
            font-size: 0.7rem;
            transition: all 0.2s ease;
        }

        .skill-btn.primary {
            background: var(--accent);
            color: white;
        }

        .skill-btn.primary:hover {
            background: var(--accent-light);
        }

        .skill-btn.secondary {
            background: transparent;
            border: 1px solid rgba(139, 92, 246, 0.3);
            color: var(--accent-light);
        }

        .skill-btn.secondary:hover {
            background: rgba(139, 92, 246, 0.1);
        }

        .skill-btn.danger {
            background: transparent;
            border: 1px solid rgba(239, 68, 68, 0.3);
            color: #ef4444;
        }

        .skill-btn.danger:hover {
            background: rgba(239, 68, 68, 0.1);
        }

        /* Skill Output Modal */
        .skill-output-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 10000;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .skill-output-modal.visible {
            opacity: 1;
        }

        .skill-output-backdrop {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(4px);
        }

        .skill-output-content {
            position: relative;
            background: var(--bg-card, #12121a);
            border: 1px solid var(--border);
            border-radius: 16px;
            max-width: 700px;
            width: 90%;
            max-height: 85vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            animation: modalSlideUp 0.3s ease;
        }

        @keyframes modalSlideUp {
            from { transform: translateY(20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .skill-output-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            background: var(--bg-secondary, #0f0f18);
            border-bottom: 1px solid var(--border);
            border-radius: 16px 16px 0 0;
        }

        .skill-output-title {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.75rem;
            font-weight: 600;
            letter-spacing: 0.05em;
            color: var(--text-muted);
            text-transform: uppercase;
        }

        .skill-output-icon {
            font-size: 1rem;
        }

        .skill-output-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            color: var(--text-muted);
            cursor: pointer;
            padding: 0;
            line-height: 1;
            transition: color 0.15s ease;
        }

        .skill-output-close:hover {
            color: var(--text-primary);
        }

        .skill-output-body {
            padding: 0;
            overflow-y: auto;
            flex: 1;
            min-height: 150px;
            max-height: 500px;
        }

        .skill-output-body .agent-output-rendered {
            border: none;
            border-radius: 0;
            background: transparent;
            padding: 20px;
        }

        .skill-output-actions {
            display: flex;
            gap: 12px;
            padding: 14px 20px;
            border-top: 1px solid var(--border);
            justify-content: flex-end;
            background: var(--bg-secondary, #0f0f18);
            border-radius: 0 0 16px 16px;
        }

        .skill-output-btn {
            padding: 8px 16px;
            border-radius: 8px;
            border: 1px solid rgba(139, 92, 246, 0.3);
            background: transparent;
            color: var(--text-primary);
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.2s ease;
        }

        .skill-output-btn:hover {
            background: rgba(139, 92, 246, 0.1);
        }

        .skill-output-btn.primary {
            background: var(--accent);
            border-color: var(--accent);
            color: white;
        }

        .skill-output-btn.primary:hover {
            background: var(--accent-light);
        }

        /* ==================== SIMULATION CARD ==================== */
        .simulation-card {
            background: var(--glass-bg);
            backdrop-filter: blur(var(--glass-blur));
            -webkit-backdrop-filter: blur(var(--glass-blur));
            border: 1px solid var(--glass-border);
            border-radius: 16px;
            padding: 20px;
            margin: 4px 0;
            box-shadow: var(--shadow-md), 0 0 30px var(--glow-subtle);
            transition: all 0.3s ease;
            animation: simCardIn 0.4s ease;
        }

        .simulation-card:hover {
            border-color: var(--glass-border-hover);
            box-shadow: var(--shadow-lg), 0 0 40px var(--glow-medium);
        }

        @keyframes simCardIn {
            from { opacity: 0; transform: translateY(12px) scale(0.98); }
            to { opacity: 1; transform: translateY(0) scale(1); }
        }

        .sim-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 14px;
            padding-bottom: 12px;
            border-bottom: 1px solid var(--border);
        }

        .sim-header svg {
            color: var(--accent-light);
            flex-shrink: 0;
        }

        .sim-header-title {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
            letter-spacing: 0.02em;
        }

        .sim-query {
            font-size: 12px;
            color: var(--text-secondary);
            margin-bottom: 16px;
            padding: 8px 12px;
            background: rgba(139, 92, 246, 0.06);
            border-radius: 8px;
            border-left: 3px solid var(--accent);
            line-height: 1.5;
        }

        .sim-stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-bottom: 16px;
        }

        .sim-stat-cell {
            background: var(--bg-elevated);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 12px;
            transition: border-color 0.2s ease;
        }

        .sim-stat-cell:hover {
            border-color: var(--border-light);
        }

        .sim-stat-label {
            font-size: 10px;
            font-weight: 500;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.08em;
            margin-bottom: 6px;
        }

        .sim-stat-value {
            font-size: 18px;
            font-weight: 700;
            font-family: 'SF Mono', 'Fira Code', 'Cascadia Code', monospace;
            color: var(--text-primary);
            line-height: 1.2;
        }

        .sim-stat-value.accent {
            color: var(--accent-light);
        }

        .sim-risk-badge {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            padding: 3px 10px;
            border-radius: 20px;
            font-size: 11px;
            font-weight: 700;
            letter-spacing: 0.06em;
        }

        .sim-risk-badge.risk-low {
            background: rgba(63, 185, 80, 0.12);
            color: #3fb950;
            border: 1px solid rgba(63, 185, 80, 0.25);
        }

        .sim-risk-badge.risk-medium {
            background: rgba(210, 153, 34, 0.12);
            color: #d29922;
            border: 1px solid rgba(210, 153, 34, 0.25);
        }

        .sim-risk-badge.risk-high {
            background: rgba(240, 136, 62, 0.12);
            color: #f0883e;
            border: 1px solid rgba(240, 136, 62, 0.25);
        }

        .sim-risk-badge.risk-extreme {
            background: rgba(248, 81, 73, 0.12);
            color: #f85149;
            border: 1px solid rgba(248, 81, 73, 0.25);
        }

        .risk-low { color: #3fb950; }
        .risk-medium { color: #d29922; }
        .risk-high { color: #f0883e; }
        .risk-extreme { color: #f85149; }

        .sim-sparkline {
            margin-bottom: 14px;
            padding: 10px;
            background: var(--bg-elevated);
            border: 1px solid var(--border);
            border-radius: 10px;
        }

        .sim-sparkline svg {
            width: 100%;
            height: 50px;
            display: block;
        }

        .sim-sparkline-label {
            font-size: 10px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.06em;
            margin-bottom: 6px;
        }

        .sim-analysis {
            margin-bottom: 14px;
            padding: 12px;
            background: rgba(139, 92, 246, 0.04);
            border: 1px solid var(--border);
            border-radius: 10px;
        }

        .sim-analysis-title {
            font-size: 11px;
            font-weight: 600;
            color: var(--accent-light);
            text-transform: uppercase;
            letter-spacing: 0.06em;
            margin-bottom: 8px;
        }

        .sim-analysis-summary {
            font-size: 12px;
            color: var(--text-secondary);
            line-height: 1.6;
        }

        .sim-findings {
            list-style: none;
            padding: 0;
            margin: 8px 0 0 0;
        }

        .sim-findings li {
            font-size: 12px;
            color: var(--text-secondary);
            padding: 4px 0 4px 16px;
            position: relative;
            line-height: 1.5;
        }

        .sim-findings li::before {
            content: '';
            position: absolute;
            left: 0;
            top: 11px;
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: var(--accent);
        }

        .sim-actions {
            display: flex;
            gap: 8px;
            padding-top: 12px;
            border-top: 1px solid var(--border);
        }

        .sim-btn {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 7px 14px;
            border-radius: 8px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 1px solid var(--border);
            background: var(--bg-elevated);
            color: var(--text-secondary);
        }

        .sim-btn:hover {
            background: var(--bg-hover);
            color: var(--text-primary);
            border-color: var(--border-light);
        }

        .sim-btn.primary {
            background: var(--accent);
            border-color: var(--accent);
            color: white;
        }

        .sim-btn.primary:hover {
            background: var(--accent-light);
            box-shadow: 0 0 16px var(--glow-subtle);
        }

        /* Personality toggle */
        .personality-btn.active { background:var(--accent)!important;color:#fff!important;border-color:var(--accent)!important; }
        /* Sim clarification modal */
        .sim-clarify-overlay { position:fixed;inset:0;background:rgba(0,0,0,0.7);z-index:10000;display:flex;align-items:center;justify-content:center;animation:fadeIn 0.3s ease;backdrop-filter:blur(4px); }
        .sim-clarify-modal { background:#1a1a2e;border:1px solid rgba(139,92,246,0.3);border-radius:16px;padding:28px;max-width:480px;width:90%;box-shadow:0 20px 60px rgba(139,92,246,0.15); }
        .sim-clarify-header { display:flex;align-items:center;gap:10px;margin-bottom:16px;font-size:1.1rem;font-weight:600;color:#e2e8f0; }
        .sim-clarify-context { background:rgba(139,92,246,0.08);color:#a78bfa;font-size:0.85rem;padding:10px 14px;border-radius:10px;margin-bottom:18px; }
        .sim-clarify-field { margin-bottom:14px; }
        .sim-clarify-field label { display:block;color:#a1a1aa;font-size:0.8rem;margin-bottom:5px; }
        .sim-clarify-field input,.sim-clarify-field select { width:100%;padding:9px 12px;border-radius:8px;border:1px solid rgba(255,255,255,0.1);background:rgba(255,255,255,0.04);color:#e2e8f0;font-size:0.9rem;box-sizing:border-box; }
        .sim-clarify-field select { cursor:pointer; }
        .sim-clarify-field input:focus,.sim-clarify-field select:focus { outline:none;border-color:var(--accent); }
        .sim-clarify-submit { width:100%;padding:11px;border:none;border-radius:10px;cursor:pointer;background:var(--accent-gradient);color:#fff;font-weight:600;font-size:0.95rem;transition:opacity 0.2s; }
        .sim-clarify-submit:hover { opacity:0.9; }
        /* Sim follow-up suggestions */
        .sim-followups { display:flex;flex-wrap:wrap;gap:8px;margin-top:10px;padding-top:10px;border-top:1px solid rgba(255,255,255,0.06); }
        .sim-followup-pill { padding:6px 14px;border-radius:20px;border:1px solid rgba(139,92,246,0.4);background:rgba(139,92,246,0.06);color:#a78bfa;font-size:0.8rem;cursor:pointer;transition:all 0.2s; }
        .sim-followup-pill:hover { background:rgba(139,92,246,0.15);border-color:var(--accent);color:#e2e8f0; }
        .sim-followup-input-wrap { display:flex;gap:6px;width:100%;margin-top:6px; }
        .sim-followup-input { flex:1;padding:7px 12px;border-radius:20px;border:1px solid rgba(255,255,255,0.1);background:rgba(255,255,255,0.04);color:#e2e8f0;font-size:0.8rem; }
        .sim-followup-input:focus { outline:none;border-color:var(--accent); }
        .sim-followup-send { padding:7px 14px;border-radius:20px;border:none;background:var(--accent);color:#fff;font-size:0.8rem;cursor:pointer; }

        /* Completed Task Items */
        .completed-item {
            background: rgba(16, 185, 129, 0.08);
            border: 1px solid rgba(16, 185, 129, 0.15);
            border-radius: 8px;
            padding: 10px 12px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .completed-item:hover {
            background: rgba(16, 185, 129, 0.15);
            transform: translateX(4px);
        }

        .completed-item-header {
            display: flex;
            align-items: flex-start;
            gap: 8px;
            margin-bottom: 6px;
        }

        .completed-item-icon {
            font-size: 0.8rem;
            flex-shrink: 0;
        }

        .completed-item-text {
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.75rem;
            font-weight: 500;
            color: var(--text-secondary);
            line-height: 1.3;
            flex: 1;
        }

        .completed-item-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-family: 'Space Mono', monospace;
            font-size: 0.6rem;
            color: var(--text-muted);
        }

        .completed-item-time {
            opacity: 0.7;
        }

        .completed-item-type {
            padding: 2px 6px;
            background: rgba(16, 185, 129, 0.2);
            border-radius: 4px;
            color: #10b981;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        /* Final Answer Banner for Completed Tasks */
        .final-answer-banner {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px 16px;
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.2) 0%, rgba(16, 185, 129, 0.1) 100%);
            border: 1px solid rgba(16, 185, 129, 0.3);
            border-radius: 10px;
            margin-bottom: 16px;
        }

        .final-answer-icon {
            font-size: 1.5rem;
        }

        .final-answer-label {
            font-family: 'Rajdhani', sans-serif;
            font-size: 1.1rem;
            font-weight: 600;
            color: #10b981;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .final-answer-content {
            background: rgba(16, 185, 129, 0.05);
            border: 1px solid rgba(16, 185, 129, 0.15);
            border-radius: 10px;
            padding: 16px 20px;
        }

        .final-answer-content h3 {
            font-family: 'Rajdhani', sans-serif;
            font-size: 1rem;
            margin-bottom: 12px;
        }

        .findings-meta-dot.completed {
            background: #10b981;
            box-shadow: 0 0 8px rgba(16, 185, 129, 0.6);
        }

        /* Ask Cerebro Input */
        .ask-cerebro-input {
            display: flex;
            gap: 6px;
            padding: 8px 10px;
            border-bottom: 1px solid rgba(139, 92, 246, 0.1);
        }

        .ask-cerebro-input input {
            flex: 1;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(139, 92, 246, 0.2);
            border-radius: 8px;
            padding: 8px 12px;
            color: var(--text-primary);
            font-size: 0.8rem;
            outline: none;
            transition: all 0.2s ease;
        }

        .ask-cerebro-input input:focus {
            border-color: rgba(139, 92, 246, 0.5);
            box-shadow: 0 0 10px rgba(139, 92, 246, 0.1);
        }

        .ask-cerebro-input input::placeholder {
            color: var(--text-muted);
            opacity: 0.6;
        }

        .ask-cerebro-btn {
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.3), rgba(139, 92, 246, 0.2));
            border: 1px solid rgba(139, 92, 246, 0.3);
            border-radius: 8px;
            color: var(--accent-light);
            width: 36px;
            height: 36px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
        }

        .ask-cerebro-btn:hover {
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.5), rgba(139, 92, 246, 0.3));
            transform: scale(1.05);
        }

        .ask-cerebro-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Cerebro Chat Interface - Conversational Style */
        .chat-container {
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding: 4px;
            max-height: 350px;
            overflow-y: auto;
        }

        .chat-message {
            max-width: 90%;
            padding: 10px 14px;
            border-radius: 16px;
            font-size: 0.85rem;
            line-height: 1.45;
            animation: messageSlide 0.3s ease-out;
            position: relative;
        }

        @keyframes messageSlide {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .chat-message.user {
            align-self: flex-end;
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.3), rgba(139, 92, 246, 0.15));
            border: 1px solid rgba(139, 92, 246, 0.3);
            color: var(--text-primary);
            border-bottom-right-radius: 4px;
        }

        .chat-message.cerebro {
            align-self: flex-start;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.08), rgba(255, 255, 255, 0.03));
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: var(--text-primary);
            border-bottom-left-radius: 4px;
        }

        .chat-message.cerebro::before {
            content: '';
            position: absolute;
            top: -8px;
            left: -8px;
            font-size: 0.7rem;
            background: var(--bg-secondary);
            border-radius: 50%;
            padding: 2px;
        }

        .chat-message.loading {
            opacity: 0.7;
        }

        .chat-message.loading::after {
            content: '';
            display: inline-block;
            width: 4px;
            height: 4px;
            background: var(--accent);
            border-radius: 50%;
            margin-left: 6px;
            animation: typingDot 1s ease-in-out infinite;
        }

        @keyframes typingDot {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }

        .chat-timestamp {
            font-size: 0.6rem;
            color: var(--text-muted);
            margin-top: 4px;
            text-align: right;
        }

        .chat-message.cerebro .chat-timestamp {
            text-align: left;
        }

        /* Clear chat button */
        .chat-clear-btn {
            font-size: 0.65rem;
            color: var(--text-muted);
            background: none;
            border: none;
            cursor: pointer;
            padding: 2px 6px;
            opacity: 0.6;
            transition: opacity 0.2s;
        }

        .chat-clear-btn:hover {
            opacity: 1;
            color: var(--error);
        }

        /* Empty chat state */
        .chat-empty {
            text-align: center;
            padding: 20px;
            color: var(--text-muted);
            font-size: 0.8rem;
        }

        .chat-empty-icon {
            font-size: 1.5rem;
            margin-bottom: 8px;
            opacity: 0.5;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Current Focus Items - Goals/Directives being worked on */
        .focus-item {
            padding: 10px 12px;
            background: rgba(16, 185, 129, 0.05);
            border-radius: 10px;
            border-left: 2px solid rgba(16, 185, 129, 0.4);
            animation: focusFadeIn 0.4s ease-out;
        }

        .focus-item.active {
            background: rgba(16, 185, 129, 0.1);
            border-left-color: rgba(16, 185, 129, 0.8);
            box-shadow: 0 0 15px rgba(16, 185, 129, 0.05);
        }

        .focus-item.pending {
            border-left-color: rgba(251, 191, 36, 0.5);
            background: rgba(251, 191, 36, 0.05);
        }

        @keyframes focusFadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .focus-item-status {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-bottom: 6px;
        }

        .focus-status-indicator {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: #10b981;
            animation: statusPulse 2s infinite;
        }

        .focus-item.active .focus-status-indicator {
            background: #10b981;
        }

        .focus-item.pending .focus-status-indicator {
            background: #fbbf24;
            animation: none;
        }

        @keyframes statusPulse {
            0%, 100% { opacity: 1; box-shadow: 0 0 0 0 rgba(16, 185, 129, 0.4); }
            50% { opacity: 0.7; box-shadow: 0 0 0 4px rgba(16, 185, 129, 0); }
        }

        .focus-status-label {
            font-family: 'Space Mono', monospace;
            font-size: 0.55rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: #10b981;
        }

        .focus-item.pending .focus-status-label {
            color: #fbbf24;
        }

        .focus-item-text {
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.85rem;
            color: var(--text-primary);
            line-height: 1.4;
        }

        .focus-item-progress {
            margin-top: 8px;
            height: 3px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            overflow: hidden;
        }

        .focus-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #10b981, #34d399);
            border-radius: 2px;
            transition: width 0.5s ease;
        }

        .section-empty {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px 12px;
            text-align: center;
            color: var(--text-muted);
            opacity: 0.6;
        }

        .section-empty-icon {
            font-size: 1.2rem;
            margin-bottom: 6px;
        }

        .section-empty-text {
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.75rem;
            line-height: 1.4;
        }

        /* Enhanced Focus Items - Clickable with Controls */
        .focus-item {
            cursor: pointer;
            position: relative;
        }

        .focus-item:hover {
            background: rgba(16, 185, 129, 0.15);
            transform: translateX(4px);
        }

        .focus-item-controls {
            display: flex;
            gap: 6px;
            margin-top: 8px;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .focus-item:hover .focus-item-controls {
            opacity: 1;
        }

        .focus-control-btn {
            padding: 4px 10px;
            font-size: 0.65rem;
            font-family: 'Rajdhani', sans-serif;
            font-weight: 500;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.3);
            color: var(--text-muted);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .focus-control-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-primary);
        }

        .focus-control-btn.pause {
            border-color: rgba(251, 191, 36, 0.3);
        }

        .focus-control-btn.pause:hover {
            background: rgba(251, 191, 36, 0.2);
            color: #fbbf24;
        }

        .focus-control-btn.view {
            border-color: rgba(59, 130, 246, 0.3);
        }

        .focus-control-btn.view:hover {
            background: rgba(59, 130, 246, 0.2);
            color: #3b82f6;
        }

        .focus-item.paused {
            opacity: 0.5;
            border-left-color: rgba(107, 114, 128, 0.4);
        }

        .focus-item.paused .focus-status-indicator {
            background: #6b7280;
            animation: none;
        }

        .focus-item.paused .focus-status-label {
            color: #6b7280;
        }

        /* Task vs Goal type styling */
        .focus-type-badge {
            font-size: 0.75rem;
            margin-right: 4px;
        }

        .focus-item.goal-type {
            border-left-color: rgba(251, 191, 36, 0.6);
            background: rgba(251, 191, 36, 0.05);
        }

        .focus-item.goal-type .focus-status-indicator {
            background: #fbbf24;
        }

        .focus-item.task-type {
            border-left-color: rgba(16, 185, 129, 0.6);
        }

        .focus-progress-bar.goal-bar {
            background: linear-gradient(90deg, rgba(251, 191, 36, 0.8), rgba(251, 191, 36, 0.4));
        }

        .focus-progress-bar.task-bar {
            background: linear-gradient(90deg, rgba(16, 185, 129, 0.8), rgba(16, 185, 129, 0.4));
        }

        /* Research Findings Popup */
        .findings-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .findings-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .findings-modal {
            width: 90%;
            max-width: 800px;
            max-height: 85vh;
            background: linear-gradient(135deg, rgba(15, 15, 20, 0.98), rgba(20, 20, 30, 0.98));
            border: 1px solid rgba(139, 92, 246, 0.2);
            border-radius: 24px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            transform: scale(0.9) translateY(20px);
            transition: transform 0.3s ease;
        }

        .findings-overlay.active .findings-modal {
            transform: scale(1) translateY(0);
        }

        .findings-header {
            padding: 24px 28px 20px;
            border-bottom: 1px solid rgba(139, 92, 246, 0.15);
            display: flex;
            align-items: flex-start;
            justify-content: space-between;
            gap: 20px;
        }

        .findings-header-content {
            flex: 1;
        }

        .findings-directive {
            font-family: 'Rajdhani', sans-serif;
            font-size: 1.3rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 8px;
        }

        .findings-meta {
            display: flex;
            gap: 16px;
            flex-wrap: wrap;
        }

        .findings-meta-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-family: 'Space Mono', monospace;
            font-size: 0.7rem;
            color: var(--text-muted);
        }

        .findings-meta-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
        }

        .findings-meta-dot.active { background: #10b981; }
        .findings-meta-dot.paused { background: #fbbf24; }
        .findings-meta-dot.complete { background: #3b82f6; }

        .findings-close {
            width: 36px;
            height: 36px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            background: transparent;
            color: var(--text-muted);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            flex-shrink: 0;
        }

        .findings-close:hover {
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-primary);
        }

        .findings-tabs {
            display: flex;
            padding: 0 28px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            gap: 4px;
        }

        .findings-tab {
            padding: 14px 20px;
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.9rem;
            font-weight: 500;
            color: var(--text-muted);
            background: transparent;
            border: none;
            cursor: pointer;
            position: relative;
            transition: color 0.2s ease;
        }

        .findings-tab:hover {
            color: var(--text-secondary);
        }

        .findings-tab.active {
            color: var(--accent-light);
        }

        .findings-tab.active::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: var(--accent);
        }

        .findings-tab-count {
            margin-left: 6px;
            padding: 2px 6px;
            background: rgba(139, 92, 246, 0.2);
            border-radius: 8px;
            font-size: 0.7rem;
        }

        .findings-tab.summary-tab {
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.15), rgba(139, 92, 246, 0.05));
            border-radius: 8px 8px 0 0;
            color: var(--accent-light);
        }

        .findings-tab.summary-tab.active {
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.25), rgba(139, 92, 246, 0.1));
        }

        /* Summary Report Styling */
        .summary-content {
            display: none;
        }

        .summary-content.active {
            display: block;
        }

        .summary-loading {
            text-align: center;
            padding: 40px;
            color: var(--text-muted);
        }

        .summary-loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(139, 92, 246, 0.2);
            border-top-color: var(--accent);
            border-radius: 50%;
            margin: 0 auto 16px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .summary-report {
            line-height: 1.6;
        }

        .summary-report h2 {
            font-family: 'Rajdhani', sans-serif;
            font-size: 1.3rem;
            color: var(--accent-light);
            margin: 24px 0 12px 0;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(139, 92, 246, 0.2);
        }

        .summary-report h2:first-child {
            margin-top: 0;
        }

        .summary-report h3 {
            font-family: 'Rajdhani', sans-serif;
            font-size: 1.1rem;
            color: var(--text-primary);
            margin: 16px 0 8px 0;
        }

        .summary-report p {
            color: var(--text-secondary);
            margin-bottom: 12px;
        }

        .summary-report ul, .summary-report ol {
            margin: 12px 0;
            padding-left: 24px;
        }

        .summary-report li {
            color: var(--text-secondary);
            margin-bottom: 8px;
        }

        .summary-report strong {
            color: var(--text-primary);
        }

        .summary-report code {
            background: rgba(139, 92, 246, 0.15);
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.9em;
        }

        .summary-actions {
            margin-top: 24px;
            padding-top: 16px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            gap: 12px;
        }

        .summary-action-btn {
            padding: 10px 20px;
            border-radius: 8px;
            font-family: 'Rajdhani', sans-serif;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            border: none;
        }

        .summary-action-btn.primary {
            background: linear-gradient(135deg, var(--accent), var(--accent-dark));
            color: white;
        }

        .summary-action-btn.secondary {
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-secondary);
        }

        .summary-action-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(139, 92, 246, 0.3);
        }

        .summary-refresh-btn {
            position: absolute;
            top: 16px;
            right: 16px;
            padding: 6px 12px;
            font-size: 0.8rem;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: var(--text-muted);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .summary-refresh-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-secondary);
        }

        .findings-content {
            flex: 1;
            overflow-y: auto;
            padding: 20px 28px;
        }

        .findings-content::-webkit-scrollbar { width: 4px; }
        .findings-content::-webkit-scrollbar-track { background: transparent; }
        .findings-content::-webkit-scrollbar-thumb {
            background: rgba(139, 92, 246, 0.3);
            border-radius: 4px;
        }

        .findings-section {
            display: none;
        }

        .findings-section.active {
            display: block;
        }

        .finding-item {
            padding: 16px 20px;
            background: rgba(255, 255, 255, 0.02);
            border-radius: 12px;
            margin-bottom: 12px;
            border-left: 3px solid rgba(139, 92, 246, 0.4);
            transition: all 0.2s ease;
        }

        .finding-item:hover {
            background: rgba(139, 92, 246, 0.05);
        }

        .finding-item.observation { border-left-color: #3b82f6; }
        .finding-item.learning { border-left-color: #10b981; }
        .finding-item.prediction { border-left-color: #f97316; }
        .finding-item.insight { border-left-color: #ec4899; }

        .finding-type {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            font-family: 'Space Mono', monospace;
            font-size: 0.65rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-muted);
            margin-bottom: 8px;
        }

        .finding-type-dot {
            width: 5px;
            height: 5px;
            border-radius: 50%;
        }

        .finding-item.observation .finding-type-dot { background: #3b82f6; }
        .finding-item.learning .finding-type-dot { background: #10b981; }
        .finding-item.prediction .finding-type-dot { background: #f97316; }
        .finding-item.insight .finding-type-dot { background: #ec4899; }

        .finding-text {
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.95rem;
            color: var(--text-primary);
            line-height: 1.5;
        }

        .finding-time {
            font-family: 'Space Mono', monospace;
            font-size: 0.65rem;
            color: var(--text-muted);
            margin-top: 8px;
        }

        .findings-empty {
            text-align: center;
            padding: 40px 20px;
            color: var(--text-muted);
        }

        .findings-empty-icon {
            font-size: 2.5rem;
            margin-bottom: 12px;
            opacity: 0.5;
        }

        .findings-empty-text {
            font-family: 'Rajdhani', sans-serif;
            font-size: 1rem;
        }

        .findings-footer {
            padding: 16px 28px;
            border-top: 1px solid rgba(255, 255, 255, 0.05);
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 12px;
        }

        .findings-status {
            display: flex;
            align-items: center;
            gap: 8px;
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.85rem;
            color: var(--text-muted);
        }

        .saturation-bar {
            width: 100px;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            overflow: hidden;
        }

        .saturation-fill {
            height: 100%;
            background: linear-gradient(90deg, #10b981, #fbbf24, #ef4444);
            border-radius: 3px;
            transition: width 0.5s ease;
        }

        .findings-actions {
            display: flex;
            gap: 10px;
        }

        .findings-btn {
            padding: 10px 20px;
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.9rem;
            font-weight: 600;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 1px solid transparent;
        }

        .findings-btn.primary {
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.3), rgba(88, 28, 135, 0.3));
            border-color: rgba(139, 92, 246, 0.4);
            color: var(--accent-light);
        }

        .findings-btn.primary:hover {
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.5), rgba(88, 28, 135, 0.5));
            transform: translateY(-1px);
        }

        .findings-btn.secondary {
            background: rgba(255, 255, 255, 0.05);
            color: var(--text-secondary);
        }

        .findings-btn.secondary:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .findings-btn.danger {
            border-color: rgba(239, 68, 68, 0.3);
            color: #ef4444;
        }

        .findings-btn.danger:hover {
            background: rgba(239, 68, 68, 0.2);
        }

        /* ===== CONSCIOUSNESS INTERFACE - RESPONSIVE ===== */

        /* Sidebars are now slide-out panels - always hidden by default */
        @media (max-width: 768px) {
            .consciousness-chamber {
                min-height: auto;
                padding: 16px 16px 8px;
            }

            .consciousness-orb {
                width: 270px;
                height: 270px;
            }

            .orb-essence.orb-logo-img {
                width: 195px;
                height: 195px;
            }

            .orbital-system {
                width: 480px;
                height: 480px;
            }

            .orbit-1 { width: 360px; height: 360px; margin: -180px 0 0 -180px; }
            .orbit-2 { width: 420px; height: 420px; margin: -210px 0 0 -210px; }
            .orbit-3 { width: 480px; height: 480px; margin: -240px 0 0 -240px; }

            .voice-stream {
                padding: 0 16px 20px;
            }

            .current-voice {
                padding: 20px;
                border-radius: 16px;
            }

            .voice-content {
                font-size: 1.1rem;
            }

            .directive-whisper {
                padding: 0 16px 30px 16px;
            }

            .whisper-input {
                font-size: 1rem;
                padding: 16px 50px 16px 16px;
            }

            .control-btn {
                width: 44px;
                height: 44px;
            }

            .tech-panel.expanded {
                padding: 16px;
            }

            .tech-stats {
                gap: 16px;
            }

            .tech-stat-value {
                font-size: 1.2rem;
            }

            .level-marks {
                font-size: 0.55rem;
            }
        }

        @media (max-width: 480px) {
            .consciousness-chamber {
                min-height: auto;
            }

            .consciousness-orb {
                width: 225px;
                height: 225px;
            }

            .orb-essence.orb-logo-img {
                width: 158px;
                height: 158px;
            }

            .status-text {
                font-size: 0.8rem;
            }

            .consciousness-controls { margin-top: 12px; gap: 8px; }

            .voice-content {
                font-size: 1rem;
            }

            .message-history {
                max-height: 200px;
            }

            .directive-tag {
                font-size: 0.8rem;
                padding: 6px 10px;
            }
        }

        /* Current Focus Section - Dramatic Card */
        .current-focus-section {
            margin: 0;
            padding: 0 20px 20px;
            z-index: 1;
            position: relative;
        }

        .focus-card {
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.2), rgba(59, 130, 246, 0.1), rgba(0,0,0,0.3));
            border: 1px solid rgba(139, 92, 246, 0.4);
            border-radius: 20px;
            padding: 24px;
            backdrop-filter: blur(10px);
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3), inset 0 1px 0 rgba(255,255,255,0.05);
        }

        .focus-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 12px;
        }

        .focus-icon {
            font-size: 1.5rem;
        }

        .focus-title {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .focus-content {
            font-size: 1.1rem;
            line-height: 1.5;
            color: var(--text-primary);
            margin-bottom: 12px;
        }

        .focus-reasoning {
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 12px;
        }

        .reasoning-header {
            font-size: 0.8rem;
            color: var(--text-muted);
            margin-bottom: 6px;
        }

        .reasoning-content {
            font-size: 0.9rem;
            color: var(--text-secondary);
            line-height: 1.4;
            font-style: italic;
        }

        .focus-safety {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .safety-badge {
            font-size: 0.75rem;
            padding: 4px 10px;
            border-radius: 12px;
            font-weight: 500;
        }

        .safety-badge.safe {
            background: rgba(34, 197, 94, 0.2);
            color: #22c55e;
            border: 1px solid rgba(34, 197, 94, 0.3);
        }

        .safety-badge.action-planned {
            background: rgba(251, 191, 36, 0.2);
            color: #fbbf24;
            border: 1px solid rgba(251, 191, 36, 0.3);
        }

        .safety-badge.needs-approval {
            background: rgba(239, 68, 68, 0.2);
            color: #ef4444;
            border: 1px solid rgba(239, 68, 68, 0.3);
        }

        /* Autonomy Grid - Enhanced */
        .autonomy-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            padding: 20px;
            z-index: 1;
            position: relative;
        }

        @media (max-width: 768px) {
            .autonomy-grid {
                grid-template-columns: 1fr;
            }
        }

        /* Thought Stream - ALIVE Neural Feed */
        .thought-stream-section {
            background: linear-gradient(180deg, rgba(20, 15, 35, 0.9), rgba(10, 10, 20, 0.95));
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-radius: 20px;
            border: 1px solid rgba(139, 92, 246, 0.2);
            padding: 20px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.4), inset 0 1px 0 rgba(255,255,255,0.03);
            position: relative;
            overflow: hidden;
        }

        /* Subtle animated border */
        .thought-stream-section::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, transparent, var(--accent), transparent);
            animation: borderScan 3s ease-in-out infinite;
        }

        @keyframes borderScan {
            0%, 100% { transform: translateX(-100%); opacity: 0; }
            50% { transform: translateX(100%); opacity: 1; }
        }

        .thought-stream-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 1px solid rgba(139, 92, 246, 0.15);
        }

        .thought-stream-title {
            font-size: 1rem;
            font-weight: 700;
            color: var(--text-primary);
            text-transform: uppercase;
            letter-spacing: 0.1em;
            display: flex;
            align-items: center;
        }

        .thought-stream {
            max-height: 350px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 12px;
            padding-right: 8px;
        }

        /* Custom scrollbar for thought stream */
        .thought-stream::-webkit-scrollbar {
            width: 4px;
        }
        .thought-stream::-webkit-scrollbar-track {
            background: rgba(0,0,0,0.2);
            border-radius: 2px;
        }
        .thought-stream::-webkit-scrollbar-thumb {
            background: var(--accent);
            border-radius: 2px;
        }

        .thought-item {
            background: linear-gradient(135deg, rgba(30, 25, 50, 0.8), rgba(20, 15, 35, 0.9));
            border-radius: 14px;
            padding: 14px 16px;
            border: 1px solid rgba(139, 92, 246, 0.15);
            transition: all 0.3s ease;
            position: relative;
        }

        .thought-item:hover {
            border-color: rgba(139, 92, 246, 0.4);
            transform: translateX(4px);
            box-shadow: 0 4px 20px rgba(139, 92, 246, 0.15);
        }

        .thought-item.new {
            animation: thoughtSlideIn 0.5s cubic-bezier(0.16, 1, 0.3, 1);
            border-color: var(--accent);
            box-shadow: 0 0 30px rgba(139, 92, 246, 0.3), inset 0 0 20px rgba(139, 92, 246, 0.05);
        }

        @keyframes thoughtSlideIn {
            from {
                opacity: 0;
                transform: translateY(-20px) scale(0.95);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        /* Session Markers - Visual dividers between sessions */
        .session-marker {
            padding: 16px 12px;
            margin: 8px 0;
            text-align: center;
            position: relative;
        }

        .session-marker-line {
            position: absolute;
            top: 50%;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, rgba(139, 92, 246, 0.4), transparent);
        }

        .session-marker-content {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            background: var(--bg-secondary);
            padding: 6px 14px;
            border-radius: 20px;
            position: relative;
            z-index: 1;
            border: 1px solid rgba(139, 92, 246, 0.3);
        }

        .session-marker-icon {
            font-size: 1rem;
        }

        .session-marker-text {
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-muted);
        }

        .session-marker-level, .session-marker-cycles {
            font-size: 0.65rem;
            padding: 2px 8px;
            border-radius: 10px;
            background: rgba(139, 92, 246, 0.2);
            color: var(--accent);
        }

        .session-marker-time {
            font-size: 0.65rem;
            color: var(--text-muted);
            margin-top: 6px;
            font-family: 'SF Mono', 'Fira Code', monospace;
        }

        .session-start .session-marker-line {
            background: linear-gradient(90deg, transparent, rgba(16, 185, 129, 0.5), transparent);
        }

        .session-start .session-marker-content {
            border-color: rgba(16, 185, 129, 0.3);
        }

        .session-end .session-marker-line {
            background: linear-gradient(90deg, transparent, rgba(245, 158, 11, 0.4), transparent);
        }

        .session-end .session-marker-content {
            border-color: rgba(245, 158, 11, 0.3);
        }

        .thought-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .thought-phase {
            font-size: 0.7rem;
            font-weight: 700;
            text-transform: uppercase;
            padding: 4px 10px;
            border-radius: 10px;
            letter-spacing: 0.05em;
        }

        .thought-phase.observe { background: rgba(59, 130, 246, 0.25); color: #60a5fa; border: 1px solid rgba(59, 130, 246, 0.3); }
        .thought-phase.orient { background: rgba(139, 92, 246, 0.25); color: #a78bfa; border: 1px solid rgba(139, 92, 246, 0.3); }
        .thought-phase.decide { background: rgba(245, 158, 11, 0.25); color: #fbbf24; border: 1px solid rgba(245, 158, 11, 0.3); }
        .thought-phase.act { background: rgba(249, 115, 22, 0.25); color: #fb923c; border: 1px solid rgba(249, 115, 22, 0.3); }
        .thought-phase.reflect { background: rgba(16, 185, 129, 0.25); color: #34d399; border: 1px solid rgba(16, 185, 129, 0.3); }
        .thought-phase.idle { background: rgba(113, 113, 122, 0.2); color: var(--text-muted); border: 1px solid rgba(113, 113, 122, 0.2); }

        .thought-time {
            font-size: 0.7rem;
            color: var(--text-muted);
            font-family: 'SF Mono', 'Fira Code', monospace;
        }

        .thought-content {
            font-size: 0.9rem;
            color: var(--text-primary);
            line-height: 1.5;
        }

        .thought-confidence {
            margin-top: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .thought-confidence-bar {
            flex: 1;
            height: 4px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 2px;
            overflow: hidden;
        }

        .thought-confidence-fill {
            height: 100%;
            border-radius: 2px;
            transition: width 0.5s ease;
        }

        .thought-confidence-value {
            font-size: 0.7rem;
            color: var(--text-muted);
            font-family: 'SF Mono', 'Fira Code', monospace;
        }

        /* Directives Section - Give the AI missions */
        .directives-section {
            background: linear-gradient(180deg, rgba(20, 25, 35, 0.9), rgba(10, 15, 20, 0.95));
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-radius: 20px;
            border: 1px solid rgba(59, 130, 246, 0.25);
            padding: 20px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.4), inset 0 1px 0 rgba(255,255,255,0.03);
            grid-column: 1 / -1;
            position: relative;
            overflow: hidden;
        }

        .directives-section::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, transparent, #3b82f6, transparent);
            animation: directivePulse 4s ease-in-out infinite;
        }

        @keyframes directivePulse {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }

        .directives-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }

        .directives-title {
            font-size: 1rem;
            font-weight: 700;
            color: var(--text-primary);
            text-transform: uppercase;
            letter-spacing: 0.1em;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .directives-title-icon {
            font-size: 1.2rem;
        }

        .directives-input-container {
            display: flex;
            gap: 12px;
            margin-bottom: 16px;
        }

        .directive-input {
            flex: 1;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(59, 130, 246, 0.3);
            border-radius: 12px;
            padding: 14px 18px;
            color: var(--text-primary);
            font-size: 0.95rem;
            transition: all 0.3s ease;
            outline: none;
        }

        .directive-input::placeholder {
            color: var(--text-muted);
            font-style: italic;
        }

        .directive-input:focus {
            border-color: #3b82f6;
            box-shadow: 0 0 20px rgba(59, 130, 246, 0.2);
        }

        .directive-submit-btn {
            background: linear-gradient(135deg, #3b82f6, #2563eb);
            border: none;
            border-radius: 12px;
            padding: 14px 24px;
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
            white-space: nowrap;
        }

        .directive-submit-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(59, 130, 246, 0.4);
        }

        .directive-submit-btn:active {
            transform: translateY(0);
        }

        .directives-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-height: 200px;
            overflow-y: auto;
        }

        .directive-item {
            background: linear-gradient(135deg, rgba(30, 35, 50, 0.8), rgba(20, 25, 35, 0.9));
            border-radius: 14px;
            padding: 14px 16px;
            border: 1px solid rgba(59, 130, 246, 0.2);
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 12px;
            transition: all 0.3s ease;
            animation: directiveSlideIn 0.3s ease-out;
        }

        @keyframes directiveSlideIn {
            from {
                opacity: 0;
                transform: translateX(-20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .directive-item:hover {
            border-color: rgba(59, 130, 246, 0.4);
            box-shadow: 0 4px 20px rgba(59, 130, 246, 0.15);
        }

        .directive-content {
            flex: 1;
        }

        .directive-text {
            color: var(--text-primary);
            font-size: 0.95rem;
            line-height: 1.5;
            margin-bottom: 6px;
        }

        .directive-meta {
            display: flex;
            gap: 12px;
            font-size: 0.75rem;
            color: var(--text-muted);
        }

        .directive-status {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .directive-status.active {
            color: #22c55e;
        }

        .directive-status.pending {
            color: #f59e0b;
        }

        .directive-actions {
            display: flex;
            gap: 6px;
        }

        .directive-action-btn {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 6px 10px;
            color: var(--text-muted);
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.75rem;
        }

        .directive-action-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-primary);
        }

        .directive-action-btn.delete:hover {
            background: rgba(239, 68, 68, 0.2);
            border-color: rgba(239, 68, 68, 0.4);
            color: #ef4444;
        }

        .directives-empty {
            text-align: center;
            padding: 30px;
            color: var(--text-muted);
        }

        .directives-empty-icon {
            font-size: 2rem;
            opacity: 0.3;
            margin-bottom: 8px;
        }

        /* ============================================
           INSIGHTS SECTION - What Cerebro Found
           ============================================ */
        .insights-section {
            background: linear-gradient(180deg, rgba(16, 35, 20, 0.95), rgba(10, 25, 15, 0.98));
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-radius: 20px;
            border: 1px solid rgba(34, 197, 94, 0.3);
            padding: 20px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.4), inset 0 1px 0 rgba(255,255,255,0.03);
            grid-column: 1 / -1;
            position: relative;
            overflow: hidden;
        }

        .insights-section::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, transparent, #22c55e, #10b981, transparent);
            animation: insightGlow 3s ease-in-out infinite;
        }

        @keyframes insightGlow {
            0%, 100% { opacity: 0.4; }
            50% { opacity: 1; }
        }

        .insights-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }

        .insights-title {
            font-size: 1.1rem;
            font-weight: 700;
            color: #22c55e;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .insights-title-icon {
            font-size: 1.3rem;
            animation: bulbPulse 2s ease-in-out infinite;
        }

        @keyframes bulbPulse {
            0%, 100% { transform: scale(1); filter: brightness(1); }
            50% { transform: scale(1.1); filter: brightness(1.3); }
        }

        .insights-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
            max-height: 300px;
            overflow-y: auto;
        }

        .insight-card {
            background: linear-gradient(135deg, rgba(34, 197, 94, 0.1), rgba(16, 185, 129, 0.05));
            border-radius: 16px;
            padding: 18px 20px;
            border: 1px solid rgba(34, 197, 94, 0.2);
            animation: insightSlideIn 0.4s ease-out;
            transition: all 0.3s ease;
        }

        @keyframes insightSlideIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .insight-card:hover {
            border-color: rgba(34, 197, 94, 0.4);
            box-shadow: 0 8px 30px rgba(34, 197, 94, 0.15);
            transform: translateY(-2px);
        }

        .insight-card-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 10px;
        }

        .insight-card-title {
            font-size: 1rem;
            font-weight: 600;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .insight-card-badge {
            font-size: 0.7rem;
            padding: 3px 8px;
            border-radius: 10px;
            background: rgba(34, 197, 94, 0.2);
            color: #22c55e;
            font-weight: 600;
        }

        .insight-card-content {
            color: var(--text-secondary);
            font-size: 0.9rem;
            line-height: 1.6;
            margin-bottom: 12px;
        }

        .insight-card-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.75rem;
            color: var(--text-muted);
        }

        .insight-confidence {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .insight-confidence-bar {
            width: 60px;
            height: 4px;
            background: rgba(255,255,255,0.1);
            border-radius: 2px;
            overflow: hidden;
        }

        .insight-confidence-fill {
            height: 100%;
            background: linear-gradient(90deg, #22c55e, #10b981);
            border-radius: 2px;
            transition: width 0.3s ease;
        }

        .insight-dismiss {
            background: none;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 0.8rem;
        }

        .insight-dismiss:hover {
            background: rgba(255,255,255,0.1);
            color: var(--text-primary);
        }

        .insights-empty {
            text-align: center;
            padding: 40px 20px;
            color: var(--text-muted);
        }

        .insights-empty-icon {
            font-size: 2.5rem;
            opacity: 0.3;
            margin-bottom: 12px;
        }

        .insights-empty-text {
            font-size: 0.9rem;
            margin-bottom: 4px;
        }

        .insights-empty-hint {
            font-size: 0.75rem;
            color: var(--text-muted);
            opacity: 0.7;
        }

        /* Activity Section - Enhanced */
        .activity-section {
            background: linear-gradient(180deg, rgba(20, 15, 35, 0.9), rgba(10, 10, 20, 0.95));
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-radius: 20px;
            border: 1px solid rgba(139, 92, 246, 0.2);
            padding: 20px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.4), inset 0 1px 0 rgba(255,255,255,0.03);
        }

        .activity-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .activity-title {
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .activity-feed {
            max-height: 200px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 16px;
        }

        .activity-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px;
            background: var(--bg-card);
            border-radius: 8px;
            font-size: 0.8rem;
        }

        .activity-icon {
            width: 24px;
            height: 24px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.9rem;
        }

        .activity-icon.success { background: rgba(34, 197, 94, 0.2); }
        .activity-icon.pending { background: rgba(234, 179, 8, 0.2); }
        .activity-icon.error { background: rgba(239, 68, 68, 0.2); }

        /* Pending Approvals */
        .pending-approvals {
            border-top: 1px solid var(--border);
            padding-top: 12px;
        }

        .pending-title {
            font-size: 0.8rem;
            font-weight: 600;
            color: var(--yellow);
            margin-bottom: 10px;
        }

        .approval-card {
            background: var(--bg-card);
            border-radius: 10px;
            padding: 12px;
            border: 1px solid var(--yellow);
            margin-bottom: 8px;
        }

        .approval-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .approval-action {
            font-weight: 600;
            color: var(--text-primary);
        }

        .approval-risk {
            font-size: 0.7rem;
            font-weight: 600;
            text-transform: uppercase;
            padding: 2px 8px;
            border-radius: 8px;
        }

        .approval-risk.high { background: rgba(239, 68, 68, 0.2); color: var(--red); }
        .approval-risk.medium { background: rgba(234, 179, 8, 0.2); color: var(--yellow); }

        .approval-description {
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin-bottom: 10px;
        }

        .approval-buttons {
            display: flex;
            gap: 8px;
        }

        .approval-btn {
            flex: 1;
            padding: 8px;
            border-radius: 8px;
            border: none;
            font-size: 0.8rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .approval-btn.approve {
            background: var(--green);
            color: white;
        }

        .approval-btn.reject {
            background: var(--bg-elevated);
            border: 1px solid var(--border);
            color: var(--text-secondary);
        }

        /* Controls Section - Command Center */
        .autonomy-controls {
            background: linear-gradient(180deg, rgba(20, 15, 35, 0.95), rgba(10, 10, 20, 0.98));
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-radius: 20px;
            border: 1px solid rgba(139, 92, 246, 0.2);
            padding: 24px;
            grid-column: span 2;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.4), inset 0 1px 0 rgba(255,255,255,0.03);
        }

        @media (max-width: 768px) {
            .autonomy-controls {
                grid-column: span 1;
            }
        }

        .controls-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 16px;
            border-bottom: 1px solid rgba(139, 92, 246, 0.15);
        }

        .controls-title {
            font-size: 1rem;
            font-weight: 700;
            color: var(--text-primary);
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        /* Autonomy Level Slider - Enhanced */
        .autonomy-level-control {
            margin-bottom: 24px;
        }

        .autonomy-level-labels {
            display: flex;
            justify-content: space-between;
            margin-bottom: 12px;
        }

        .level-label {
            font-size: 0.75rem;
            color: var(--text-muted);
            text-align: center;
            width: 70px;
            padding: 6px 4px;
            border-radius: 8px;
            transition: all 0.3s ease;
        }

        .level-label.active {
            color: var(--accent);
            font-weight: 700;
            background: rgba(139, 92, 246, 0.15);
            box-shadow: 0 0 20px rgba(139, 92, 246, 0.2);
        }

        .autonomy-slider {
            width: 100%;
            height: 10px;
            border-radius: 5px;
            background: linear-gradient(90deg, rgba(30, 30, 50, 0.8), rgba(50, 50, 80, 0.8));
            -webkit-appearance: none;
            appearance: none;
            cursor: pointer;
            border: 1px solid rgba(139, 92, 246, 0.2);
        }

        .autonomy-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: linear-gradient(135deg, #a78bfa, #7c3aed);
            cursor: pointer;
            box-shadow: 0 0 20px rgba(139, 92, 246, 0.6), 0 2px 10px rgba(0,0,0,0.3);
            border: 2px solid rgba(255,255,255,0.2);
            transition: all 0.2s ease;
        }

        .autonomy-slider::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            box-shadow: 0 0 30px rgba(139, 92, 246, 0.8), 0 2px 15px rgba(0,0,0,0.4);
        }

        .autonomy-slider::-moz-range-thumb {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: linear-gradient(135deg, #a78bfa, #7c3aed);
            cursor: pointer;
            border: 2px solid rgba(255,255,255,0.2);
            box-shadow: 0 0 20px rgba(139, 92, 246, 0.6), 0 2px 10px rgba(0,0,0,0.3);
        }

        /* Stats Row - Dramatic Counters */
        .autonomy-stats {
            display: flex;
            gap: 16px;
            margin-bottom: 24px;
        }

        .autonomy-stat {
            flex: 1;
            background: linear-gradient(135deg, rgba(30, 25, 50, 0.8), rgba(20, 15, 35, 0.9));
            border-radius: 16px;
            padding: 16px;
            text-align: center;
            border: 1px solid rgba(139, 92, 246, 0.15);
            position: relative;
            overflow: hidden;
        }

        .autonomy-stat::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, transparent, var(--accent), transparent);
            opacity: 0.5;
        }

        .autonomy-stat-value {
            font-size: 2rem;
            font-weight: 800;
            background: linear-gradient(135deg, #c4b5fd, #8b5cf6);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-family: 'SF Mono', 'Fira Code', monospace;
        }

        .autonomy-stat-label {
            font-size: 0.7rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-top: 4px;
        }

        /* Kill Switch - DRAMATIC */
        .kill-switch-container {
            text-align: center;
            margin-top: 8px;
        }

        .kill-switch-btn {
            padding: 18px 50px;
            border-radius: 16px;
            border: 2px solid #ef4444;
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.1), rgba(220, 38, 38, 0.05));
            color: #ef4444;
            font-size: 1.1rem;
            font-weight: 800;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .kill-switch-btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: radial-gradient(circle, rgba(239, 68, 68, 0.4), transparent);
            transform: translate(-50%, -50%);
            transition: all 0.5s ease;
            border-radius: 50%;
        }

        .kill-switch-btn:hover {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            color: white;
            box-shadow: 0 0 40px rgba(239, 68, 68, 0.5), 0 0 80px rgba(239, 68, 68, 0.2);
            transform: translateY(-2px);
        }

        .kill-switch-btn:hover::before {
            width: 300px;
            height: 300px;
        }

        .kill-switch-btn:active {
            transform: translateY(0) scale(0.98);
        }

        /* Full Autonomy Toggle */
        .full-autonomy-toggle {
            background: var(--bg-elevated);
            border-radius: 12px;
            padding: 14px 16px;
            margin-bottom: 16px;
            border: 1px solid var(--border);
        }

        .full-autonomy-toggle.enabled {
            border-color: var(--red);
            background: rgba(239, 68, 68, 0.1);
        }

        .full-autonomy-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .full-autonomy-info {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .full-autonomy-label {
            font-weight: 600;
            font-size: 0.9rem;
            color: var(--text-primary);
        }

        .full-autonomy-desc {
            font-size: 0.7rem;
            color: var(--text-muted);
        }

        .full-autonomy-warning {
            margin-top: 10px;
            padding: 8px 12px;
            background: rgba(239, 68, 68, 0.15);
            border-radius: 8px;
            font-size: 0.75rem;
            color: var(--red);
        }

        /* Toggle Switch */
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 26px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--bg-secondary);
            border: 1px solid var(--border);
            transition: all 0.3s ease;
            border-radius: 26px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 2px;
            bottom: 2px;
            background-color: var(--text-muted);
            transition: all 0.3s ease;
            border-radius: 50%;
        }

        .toggle-switch input:checked + .toggle-slider {
            background-color: var(--red);
            border-color: var(--red);
        }

        .toggle-switch input:checked + .toggle-slider:before {
            transform: translateX(24px);
            background-color: white;
        }

        .toggle-switch input:focus + .toggle-slider {
            box-shadow: 0 0 4px var(--accent);
        }

        /* Debug Feed - Live LLM/API Visibility */
        .debug-feed-section {
            margin-top: 24px;
            background: var(--bg-card);
            border-radius: 16px;
            border: 1px solid var(--border);
            overflow: hidden;
        }

        .debug-feed-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            background: var(--bg-elevated);
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .debug-feed-header:hover {
            background: var(--bg-hover);
        }

        .debug-feed-title {
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .debug-feed-icon {
            font-size: 1.1rem;
        }

        .debug-feed-subtitle {
            font-size: 0.75rem;
            color: var(--text-muted);
            font-weight: 400;
        }

        .debug-feed-controls {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .debug-feed-count {
            font-size: 0.75rem;
            color: var(--accent);
            background: rgba(139, 92, 246, 0.1);
            padding: 4px 8px;
            border-radius: 6px;
        }

        .debug-clear-btn {
            font-size: 0.7rem;
            padding: 4px 8px;
            background: transparent;
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-muted);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .debug-clear-btn:hover {
            background: var(--red);
            border-color: var(--red);
            color: white;
        }

        .debug-expand-icon {
            font-size: 0.8rem;
            color: var(--text-muted);
            transition: transform 0.3s ease;
        }

        .debug-feed-section.collapsed .debug-expand-icon {
            transform: rotate(-90deg);
        }

        .debug-feed-content {
            max-height: 400px;
            overflow-y: auto;
            padding: 12px;
            font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
            font-size: 0.75rem;
            transition: max-height 0.3s ease;
        }

        .debug-feed-section.collapsed .debug-feed-content {
            max-height: 0;
            padding: 0 12px;
            overflow: hidden;
        }

        .debug-feed-empty {
            text-align: center;
            padding: 30px;
            color: var(--text-muted);
            font-size: 0.8rem;
        }

        .debug-event {
            padding: 8px 10px;
            margin-bottom: 6px;
            border-radius: 8px;
            border-left: 3px solid;
            background: var(--bg-secondary);
        }

        .debug-event.llm_prompt {
            border-left-color: var(--cyan);
        }

        .debug-event.llm_response {
            border-left-color: var(--green);
        }

        .debug-event.api_call {
            border-left-color: var(--blue);
        }

        .debug-event.api_response {
            border-left-color: #3b82f6;
        }

        .debug-event.api_error {
            border-left-color: var(--red);
        }

        .debug-event.action_execute {
            border-left-color: var(--yellow);
        }

        .debug-event.action_result {
            border-left-color: var(--accent);
        }

        .debug-event-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 4px;
        }

        .debug-event-type {
            font-weight: 600;
            text-transform: uppercase;
            font-size: 0.65rem;
            letter-spacing: 0.5px;
        }

        .debug-event.llm_prompt .debug-event-type { color: var(--cyan); }
        .debug-event.llm_response .debug-event-type { color: var(--green); }
        .debug-event.api_call .debug-event-type { color: var(--blue); }
        .debug-event.api_response .debug-event-type { color: #3b82f6; }
        .debug-event.api_error .debug-event-type { color: var(--red); }
        .debug-event.action_execute .debug-event-type { color: var(--yellow); }
        .debug-event.action_result .debug-event-type { color: var(--accent); }

        .debug-event-time {
            font-size: 0.6rem;
            color: var(--text-muted);
        }

        .debug-event-phase {
            display: inline-block;
            font-size: 0.6rem;
            padding: 2px 5px;
            border-radius: 4px;
            background: rgba(139, 92, 246, 0.15);
            color: var(--accent-light);
            margin-right: 6px;
        }

        .debug-event-content {
            color: var(--text-secondary);
            line-height: 1.4;
            word-break: break-word;
        }

        .debug-event-content .model {
            color: var(--accent);
        }

        .debug-event-content .tokens {
            color: var(--green);
        }

        .debug-event-content .duration {
            color: var(--yellow);
        }

        .debug-event-content pre {
            margin: 6px 0 0 0;
            padding: 8px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            white-space: pre-wrap;
            overflow-x: auto;
            max-height: 120px;
            overflow-y: auto;
            color: var(--text-muted);
            font-size: 0.7rem;
        }

        .debug-event-content .thinking {
            margin-top: 6px;
            padding: 6px 8px;
            background: rgba(34, 211, 238, 0.1);
            border-radius: 6px;
            border-left: 2px solid var(--cyan);
            font-style: italic;
            color: var(--cyan);
            max-height: 80px;
            overflow-y: auto;
        }

        .debug-feed-content::-webkit-scrollbar {
            width: 6px;
        }

        .debug-feed-content::-webkit-scrollbar-track {
            background: var(--bg-secondary);
        }

        .debug-feed-content::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 3px;
        }

        /* Prediction Warning Modal */
        .prediction-modal {
            background: var(--bg-card);
            border-radius: 20px;
            padding: 24px;
            max-width: 440px;
            width: 90%;
            border: 1px solid var(--border);
            box-shadow: var(--shadow-lg);
        }

        .prediction-modal .modal-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 16px;
        }

        .prediction-modal .modal-icon {
            font-size: 2rem;
        }

        .prediction-modal h3 {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .prediction-warnings {
            margin-bottom: 16px;
        }

        .warning-item {
            display: flex;
            align-items: flex-start;
            gap: 10px;
            padding: 12px;
            background: rgba(234, 179, 8, 0.1);
            border-radius: 10px;
            margin-bottom: 8px;
            border-left: 3px solid var(--yellow);
        }

        .warning-item .confidence {
            font-size: 0.75rem;
            font-weight: 700;
            color: var(--yellow);
            padding: 2px 6px;
            background: rgba(234, 179, 8, 0.2);
            border-radius: 6px;
            flex-shrink: 0;
        }

        .warning-item .text {
            font-size: 0.9rem;
            color: var(--text-primary);
            line-height: 1.4;
        }

        .prediction-alternatives h4 {
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-bottom: 8px;
        }

        .prediction-alternatives ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .prediction-alternatives li {
            padding: 8px 12px;
            background: var(--bg-elevated);
            border-radius: 8px;
            margin-bottom: 6px;
            font-size: 0.85rem;
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .prediction-alternatives li:hover {
            background: var(--accent);
            color: white;
        }

        .modal-actions {
            display: flex;
            gap: 12px;
            margin-top: 20px;
        }

        .modal-actions .btn-secondary {
            flex: 1;
            padding: 12px;
            border-radius: 12px;
            border: 1px solid var(--border);
            background: transparent;
            color: var(--text-secondary);
            cursor: pointer;
            font-weight: 500;
        }

        .modal-actions .btn-primary {
            flex: 1;
            padding: 12px;
            border-radius: 12px;
            border: none;
            background: var(--accent);
            color: white;
            cursor: pointer;
            font-weight: 500;
        }

        .modal-actions .btn-secondary:hover {
            background: var(--bg-elevated);
        }

        .modal-actions .btn-primary:hover {
            background: var(--accent-dark);
        }

        /* Chat Warnings Banner */
        .chat-warnings {
            padding: 12px 16px;
            background: rgba(234, 179, 8, 0.1);
            border: 1px solid rgba(234, 179, 8, 0.3);
            border-radius: 12px;
            margin-bottom: 16px;
            display: none;
        }

        .chat-warnings.visible {
            display: block;
        }

        .chat-warning-content {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .chat-warning-icon {
            font-size: 1.2rem;
        }

        .chat-warning-text {
            flex: 1;
            font-size: 0.85rem;
            color: var(--yellow);
        }

        .chat-warning-dismiss {
            padding: 6px 12px;
            border-radius: 8px;
            border: 1px solid var(--yellow);
            background: transparent;
            color: var(--yellow);
            cursor: pointer;
            font-size: 0.75rem;
        }

        /* Proactive Status Indicator */
        .proactive-indicator {
            display: none;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: var(--glass-bg);
            backdrop-filter: blur(var(--glass-blur));
            border-radius: 20px;
            border: 1px solid var(--glass-border);
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        .proactive-indicator.visible {
            display: flex;
        }

        .pulse-dot {
            width: 8px;
            height: 8px;
            background: var(--accent);
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(1.2); }
        }

        /* ==================== AUTOMATION VIEW - REDESIGNED ==================== */
        .automation-view {
            padding: 20px;
            gap: 20px;
            overflow-y: auto;
        }

        .automation-view .view-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .automation-view .view-title {
            font-size: 1.5rem;
            font-weight: 700;
        }

        /* Two-column layout container for desktop */
        .automation-layout {
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
        }

        @media (min-width: 900px) {
            .automation-layout {
                grid-template-columns: 1fr 320px;
                align-items: start;
            }
        }

        @media (min-width: 1200px) {
            .automation-layout {
                grid-template-columns: 1fr 360px;
            }
        }

        /* Primary column - Automations (left on desktop) */
        .automation-primary {
            display: flex;
            flex-direction: column;
            gap: 20px;
            order: 2;
        }

        @media (min-width: 900px) {
            .automation-primary {
                order: 1;
            }
        }

        /* Secondary column - Calendar (right on desktop) */
        .automation-secondary {
            order: 1;
        }

        @media (min-width: 900px) {
            .automation-secondary {
                order: 2;
                position: sticky;
                top: 20px;
            }
        }

        /* Calendar - Compact Glassmorphism Style */
        .automation-calendar-section {
            background: var(--glass-bg);
            backdrop-filter: blur(var(--glass-blur));
            -webkit-backdrop-filter: blur(var(--glass-blur));
            border-radius: 20px;
            padding: 16px;
            border: 1px solid var(--glass-border);
            box-shadow: var(--shadow-lg);
        }

        .calendar-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
        }

        .calendar-header h2 {
            font-size: 1rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .calendar-header button {
            background: var(--bg-elevated);
            border: 1px solid var(--border);
            color: var(--text-secondary);
            width: 32px;
            height: 32px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s var(--ease-out-expo);
        }

        .calendar-header button:hover {
            background: var(--bg-hover);
            color: var(--accent-light);
            border-color: var(--glass-border-hover);
        }

        .calendar-weekdays {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 2px;
            margin-bottom: 6px;
            text-align: center;
        }

        .calendar-weekdays span {
            font-size: 0.7rem;
            color: var(--text-muted);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .calendar-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 3px;
        }

        /* Compact calendar cells - max 44px */
        .calendar-day {
            aspect-ratio: 1;
            min-width: 32px;
            min-height: 32px;
            max-width: 44px;
            max-height: 44px;
            background: var(--bg-elevated);
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 4px;
            cursor: pointer;
            position: relative;
            transition: all 0.2s var(--ease-out-expo);
            border: 1px solid var(--border);
        }

        .calendar-day:hover {
            background: var(--bg-hover);
            transform: scale(1.05);
            box-shadow: 0 0 15px var(--glow-subtle);
            border-color: var(--glass-border);
        }

        .calendar-day.today {
            background: var(--accent);
            color: white;
            box-shadow: 0 0 20px var(--glow-medium);
            border-color: var(--accent);
        }

        .calendar-day.today .day-number {
            color: white;
        }

        .calendar-day.other-month {
            opacity: 0.3;
        }

        .day-number {
            font-size: 11px;
            font-weight: 500;
            color: var(--text-secondary);
        }

        .day-events {
            display: flex;
            gap: 2px;
            flex-wrap: wrap;
            justify-content: center;
            margin-top: 1px;
        }

        .event-dot {
            width: 4px;
            height: 4px;
            border-radius: 50%;
        }

        .event-dot.researcher { background: var(--blue); }
        .event-dot.coder { background: var(--green); }
        .event-dot.worker { background: var(--accent); }
        .event-dot.analyst { background: var(--purple); }

        /* Section Cards - Glassmorphism */
        .automation-section {
            background: var(--glass-bg);
            backdrop-filter: blur(var(--glass-blur));
            -webkit-backdrop-filter: blur(var(--glass-blur));
            border-radius: 20px;
            padding: 20px;
            border: 1px solid var(--glass-border);
            box-shadow: var(--shadow-lg);
        }

        .automation-section-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 16px;
        }

        .automation-section-title {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 1px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .automation-section-title::before {
            content: '';
            width: 8px;
            height: 8px;
            background: var(--accent);
            border-radius: 50%;
            box-shadow: 0 0 8px var(--glow-medium);
        }

        .clear-activity-btn {
            background: transparent;
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 6px 8px;
            cursor: pointer;
            color: var(--text-muted);
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .clear-activity-btn:hover {
            border-color: var(--red);
            color: var(--red);
            background: rgba(239, 68, 68, 0.1);
        }

        /* Activity sidebar clear button */
        .sidebar-header-right {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .activity-clear-btn {
            background: transparent;
            border: none;
            padding: 4px;
            cursor: pointer;
            color: var(--text-muted);
            opacity: 0.6;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
        }

        .activity-clear-btn:hover {
            color: var(--red);
            opacity: 1;
            background: rgba(239, 68, 68, 0.1);
        }

        .automation-section-count {
            background: var(--bg-elevated);
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.75rem;
            color: var(--text-muted);
        }

        /* Schedule Cards - Enhanced */
        .schedules-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .schedule-card {
            background: var(--bg-card);
            border-radius: 16px;
            padding: 16px;
            display: flex;
            align-items: center;
            gap: 12px;
            border: 1px solid var(--border);
            transition: all 0.2s var(--ease-out-expo);
        }

        .schedule-card:hover {
            border-color: var(--glass-border-hover);
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3), 0 0 20px var(--glow-subtle);
        }

        .schedule-toggle {
            flex-shrink: 0;
        }

        .schedule-info {
            flex: 1;
            min-width: 0;
        }

        .schedule-name {
            font-weight: 600;
            font-size: 0.95rem;
            margin-bottom: 4px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            color: var(--text-primary);
        }

        .schedule-timing {
            font-size: 0.8rem;
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
        }

        .schedule-badge {
            font-size: 0.65rem;
            padding: 3px 8px;
            border-radius: 6px;
            background: var(--bg-elevated);
            color: var(--text-muted);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .schedule-badge.recurring {
            background: var(--accent-gradient);
            color: white;
        }

        .schedule-actions {
            display: flex;
            gap: 6px;
            flex-shrink: 0;
        }

        .schedule-actions button {
            background: var(--bg-elevated);
            border: 1px solid var(--border);
            color: var(--text-secondary);
            width: 36px;
            height: 36px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s var(--ease-out-expo);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .schedule-actions button:hover {
            background: var(--bg-hover);
            color: var(--text-primary);
        }

        .schedule-actions button.run-btn:hover {
            background: var(--green);
            color: white;
            border-color: var(--green);
        }

        .schedule-actions button.delete-btn:hover {
            background: var(--red);
            color: white;
            border-color: var(--red);
        }

        .schedule-toggle {
            margin-right: 12px;
        }

        /* Day Selector */
        .day-selector {
            display: flex;
            gap: 6px;
        }

        .day-btn {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border: 1px solid var(--border);
            background: var(--bg-elevated);
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 0.8rem;
            font-weight: 500;
            transition: all 0.2s ease;
        }

        .day-btn:hover {
            background: var(--bg-hover);
        }

        .day-btn.active {
            background: var(--accent);
            border-color: var(--accent);
            color: white;
        }

        /* Timeout Selector */
        .timeout-selector { display: flex; gap: 8px; }
        .timeout-btn {
            flex: 1; padding: 8px 12px; border-radius: 8px;
            background: rgba(139, 92, 246, 0.1); border: 1px solid rgba(139, 92, 246, 0.2);
            color: var(--text-secondary); cursor: pointer; font-size: 0.85rem; transition: all 0.2s;
        }
        .timeout-btn:hover { border-color: var(--accent); }
        .timeout-btn.active { background: var(--accent); color: white; border-color: var(--accent); }

        /* Schedule Type Toggle */
        .schedule-type-toggle {
            display: flex;
            background: var(--bg-elevated);
            border-radius: 8px;
            padding: 4px;
            border: 1px solid var(--border);
        }

        .toggle-btn {
            flex: 1;
            padding: 10px;
            border: none;
            background: transparent;
            color: var(--text-secondary);
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            transition: all 0.2s ease;
        }

        .toggle-btn.active {
            background: var(--accent);
            color: white;
        }

        /* Toggle Row */
        .toggle-row {
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
        }

        .toggle-row input[type="checkbox"] {
            width: 20px;
            height: 20px;
            accent-color: var(--accent);
        }

        /* Execution History - Enhanced */
        .execution-history {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .execution-item {
            background: var(--bg-card);
            border-radius: 12px;
            padding: 14px;
            display: flex;
            align-items: center;
            gap: 12px;
            border: 1px solid var(--border);
            transition: all 0.2s var(--ease-out-expo);
        }

        .execution-item:hover {
            border-color: var(--glass-border);
            background: var(--bg-elevated);
        }

        .execution-item.clickable {
            cursor: pointer;
        }

        .execution-item.clickable:hover {
            border-color: var(--accent);
            transform: translateX(4px);
        }

        .execution-arrow {
            margin-left: auto;
            color: var(--text-muted);
            opacity: 0;
            transition: all 0.2s ease;
        }

        .execution-item.clickable:hover .execution-arrow {
            opacity: 1;
            color: var(--accent);
        }

        .execution-status.running {
            background: rgba(234, 179, 8, 0.15);
            color: var(--yellow);
            animation: pulse 1.5s ease-in-out infinite;
        }

        .execution-time {
            font-size: 0.7rem;
            color: var(--text-muted);
            min-width: 50px;
            font-weight: 500;
        }

        .execution-status {
            width: 28px;
            height: 28px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            flex-shrink: 0;
        }

        .execution-status.success {
            background: rgba(34, 197, 94, 0.15);
            color: var(--green);
        }

        .execution-status.failed {
            background: rgba(239, 68, 68, 0.15);
            color: var(--red);
        }

        .execution-status.running {
            background: rgba(139, 92, 246, 0.15);
            color: var(--accent);
        }

        .execution-info {
            flex: 1;
            min-width: 0;
        }

        .execution-name {
            font-size: 0.85rem;
            font-weight: 500;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            color: var(--text-primary);
        }

        .execution-type {
            font-size: 0.7rem;
            color: var(--text-secondary);
        }

        /* Recurring options */
        .recurring-options, .weekly-options {
            transition: all 0.3s ease;
        }

        .recurring-options.hidden, .weekly-options.hidden {
            display: none;
        }

        /* Form row */
        .form-row {
            display: flex;
            gap: 12px;
        }

        .form-half {
            flex: 1;
        }

        /* Empty state - Enhanced */
        .empty-state {
            text-align: center;
            padding: 32px 20px;
            color: var(--text-muted);
        }

        .empty-state-icon {
            width: 56px;
            height: 56px;
            margin: 0 auto 16px;
            background: var(--bg-elevated);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid var(--border);
        }

        .empty-state-icon svg {
            width: 28px;
            height: 28px;
            stroke: var(--text-muted);
            stroke-width: 1.5;
            fill: none;
        }

        .empty-state-text {
            font-size: 0.85rem;
            line-height: 1.5;
            max-width: 200px;
            margin: 0 auto;
        }

        /* Quick Stats Row for Automation */
        .automation-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
            margin-bottom: 20px;
        }

        @media (min-width: 900px) {
            .automation-stats {
                grid-template-columns: repeat(3, 1fr);
            }
        }

        .automation-stat-card {
            background: var(--bg-card);
            border-radius: 14px;
            padding: 16px;
            text-align: center;
            border: 1px solid var(--border);
            transition: all 0.2s var(--ease-out-expo);
        }

        .automation-stat-card:hover {
            border-color: var(--glass-border);
            transform: translateY(-2px);
        }

        .automation-stat-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 4px;
        }

        .automation-stat-label {
            font-size: 0.7rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* ==================== HITL POPUP - CENTER MODAL ==================== */
        
        /* ==================== SECURITY ALERT POPUP ==================== */
        .security-alert-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 9800;
            display: none;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(6px);
            -webkit-backdrop-filter: blur(6px);
        }
        .security-alert-overlay.visible {
            display: flex;
        }

        .security-alert-popup {
            width: min(520px, 92vw);
            background: rgba(20, 10, 10, 0.97);
            backdrop-filter: blur(20px);
            border: 2px solid rgba(239, 68, 68, 0.6);
            border-radius: 16px;
            padding: 0;
            box-shadow:
                0 20px 60px rgba(0, 0, 0, 0.8),
                0 0 80px rgba(239, 68, 68, 0.3),
                0 0 120px rgba(239, 68, 68, 0.15);
            animation: securityAlertIn 0.4s cubic-bezier(0.16, 1, 0.3, 1);
            overflow: hidden;
        }

        .security-alert-popup.dismissing {
            animation: securityAlertOut 0.3s ease-in forwards;
        }

        @keyframes securityAlertIn {
            from { opacity: 0; transform: scale(0.8) translateY(-20px); }
            to { opacity: 1; transform: scale(1) translateY(0); }
        }
        @keyframes securityAlertOut {
            from { opacity: 1; transform: scale(1); }
            to { opacity: 0; transform: scale(0.85); }
        }

        .security-alert-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px 20px 12px;
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.15), rgba(239, 68, 68, 0.05));
            border-bottom: 1px solid rgba(239, 68, 68, 0.3);
        }

        .security-alert-header-left {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .security-alert-icon {
            width: 40px;
            height: 40px;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.4rem;
            background: rgba(239, 68, 68, 0.25);
            animation: securityPulse 1.5s ease-in-out infinite;
        }

        @keyframes securityPulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.5); }
            50% { box-shadow: 0 0 0 12px rgba(239, 68, 68, 0); }
        }

        .security-alert-label {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            color: var(--red);
        }

        .security-alert-severity {
            font-family: 'Space Mono', monospace;
            font-size: 0.6rem;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            padding: 4px 10px;
            border-radius: 8px;
            font-weight: 700;
            background: rgba(239, 68, 68, 0.25);
            color: var(--red);
            border: 1px solid rgba(239, 68, 68, 0.4);
            animation: severityBlink 2s ease-in-out infinite;
        }

        @keyframes severityBlink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        .security-alert-close {
            background: none;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            font-size: 1.3rem;
            padding: 4px;
            line-height: 1;
            transition: color 0.2s;
        }
        .security-alert-close:hover { color: var(--red); }

        .security-alert-body {
            padding: 20px;
        }

        .security-alert-title {
            font-family: 'Rajdhani', sans-serif;
            font-size: 1.15rem;
            font-weight: 600;
            color: #fff;
            margin-bottom: 16px;
        }

        .security-alert-device {
            background: rgba(239, 68, 68, 0.08);
            border: 1px solid rgba(239, 68, 68, 0.2);
            border-radius: 10px;
            padding: 14px;
            margin-bottom: 12px;
            font-family: 'Space Mono', monospace;
            font-size: 0.8rem;
            line-height: 1.8;
            color: var(--text-secondary);
        }

        .security-alert-device strong {
            color: var(--red);
            font-weight: 600;
        }

        .security-alert-timestamp {
            font-size: 0.7rem;
            color: var(--text-muted);
            margin-top: 8px;
        }

        .security-alert-actions {
            display: flex;
            gap: 10px;
            padding: 14px 20px 18px;
            border-top: 1px solid rgba(239, 68, 68, 0.15);
        }

        .security-alert-btn {
            flex: 1;
            padding: 10px 16px;
            border-radius: 10px;
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.85rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            border: none;
        }

        .security-alert-btn.dismiss {
            background: rgba(255, 255, 255, 0.06);
            color: var(--text-secondary);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .security-alert-btn.dismiss:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .security-alert-btn.investigate {
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.3), rgba(239, 68, 68, 0.15));
            color: #fff;
            border: 1px solid rgba(239, 68, 68, 0.4);
        }
        .security-alert-btn.investigate:hover {
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.45), rgba(239, 68, 68, 0.25));
            box-shadow: 0 4px 20px rgba(239, 68, 68, 0.3);
        }
        .security-alert-btn.register {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.3), rgba(59, 130, 246, 0.15));
            color: #fff;
            border: 1px solid rgba(59, 130, 246, 0.4);
        }
        .security-alert-btn.register:hover {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.45), rgba(59, 130, 246, 0.25));
            box-shadow: 0 4px 20px rgba(59, 130, 246, 0.3);
        }

        /* Register device inline form */
        .security-register-form {
            display: flex;
            gap: 8px;
            margin-top: 12px;
            animation: fadeInUp 0.2s ease;
        }
        .security-register-form input {
            flex: 1;
            padding: 8px 12px;
            border-radius: 8px;
            border: 1px solid rgba(59, 130, 246, 0.4);
            background: rgba(0, 0, 0, 0.3);
            color: #fff;
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.85rem;
            outline: none;
        }
        .security-register-form input::placeholder {
            color: rgba(255, 255, 255, 0.35);
        }
        .security-register-form input:focus {
            border-color: rgba(59, 130, 246, 0.7);
            box-shadow: 0 0 12px rgba(59, 130, 246, 0.2);
        }
        .security-register-form button {
            padding: 8px 16px;
            border-radius: 8px;
            border: none;
            background: rgba(59, 130, 246, 0.4);
            color: #fff;
            font-family: 'Rajdhani', sans-serif;
            font-weight: 600;
            font-size: 0.8rem;
            cursor: pointer;
            white-space: nowrap;
        }
        .security-register-form button:hover {
            background: rgba(59, 130, 246, 0.6);
        }
        @keyframes fadeInUp {
            from { opacity: 0; transform: translateY(8px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Network device joined  inline chat message */
        .network-join-message {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 14px;
            margin: 6px 0;
            border-radius: 10px;
            background: rgba(239, 68, 68, 0.08);
            border-left: 3px solid rgba(239, 68, 68, 0.5);
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.82rem;
            color: rgba(239, 68, 68, 0.85);
            animation: fadeInUp 0.3s ease;
        }
        .network-join-message .join-icon {
            font-size: 1rem;
            flex-shrink: 0;
        }
        .network-join-message .join-name {
            font-weight: 700;
            color: rgba(239, 68, 68, 0.95);
        }
        .network-join-message .join-ip {
            color: rgba(255, 255, 255, 0.4);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
        }
        .network-join-message .join-time {
            margin-left: auto;
            color: rgba(255, 255, 255, 0.25);
            font-size: 0.72rem;
            flex-shrink: 0;
        }

        .hitl-popup-container {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 9500;
            display: none;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(4px);
            -webkit-backdrop-filter: blur(4px);
        }
        .hitl-popup-container.visible {
            display: flex;
        }

        .hitl-popup {
            width: min(480px, 90vw);
            background: rgba(18, 18, 30, 0.95);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(139, 92, 246, 0.4);
            border-radius: 16px;
            padding: 0;
            box-shadow:
                0 20px 60px rgba(0, 0, 0, 0.7),
                0 0 60px rgba(139, 92, 246, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.05);
            animation: hitlScaleIn 0.35s var(--ease-out-expo);
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .hitl-popup:hover {
            border-color: rgba(139, 92, 246, 0.6);
            box-shadow:
                0 24px 70px rgba(0, 0, 0, 0.8),
                0 0 80px rgba(139, 92, 246, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.08);
        }

        .hitl-popup.dismissing {
            animation: hitlScaleOut 0.25s ease-in forwards;
        }

        @keyframes hitlScaleIn {
            from {
                opacity: 0;
                transform: scale(0.85);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        @keyframes hitlScaleOut {
            from {
                opacity: 1;
                transform: scale(1);
            }
            to {
                opacity: 0;
                transform: scale(0.85);
            }
        }

        .hitl-popup-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 14px 16px 10px;
            border-bottom: 1px solid rgba(139, 92, 246, 0.15);
        }

        .hitl-popup-header-left {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .hitl-popup-icon {
            width: 32px;
            height: 32px;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.1rem;
            background: rgba(139, 92, 246, 0.2);
            animation: hitlPulse 2s ease-in-out infinite;
        }

        @keyframes hitlPulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(139, 92, 246, 0.4); }
            50% { box-shadow: 0 0 0 8px rgba(139, 92, 246, 0); }
        }

        .hitl-popup-label {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.6rem;
            text-transform: uppercase;
            letter-spacing: 0.12em;
            color: var(--accent-light);
        }

        .hitl-popup-urgency {
            font-family: 'Space Mono', monospace;
            font-size: 0.55rem;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            padding: 3px 8px;
            border-radius: 8px;
            font-weight: 600;
        }

        .hitl-popup-urgency.high {
            background: rgba(239, 68, 68, 0.2);
            color: var(--red);
            border: 1px solid rgba(239, 68, 68, 0.3);
        }

        .hitl-popup-urgency.medium {
            background: rgba(234, 179, 8, 0.2);
            color: var(--yellow);
            border: 1px solid rgba(234, 179, 8, 0.3);
        }

        .hitl-popup-urgency.low {
            background: rgba(34, 197, 94, 0.2);
            color: var(--green);
            border: 1px solid rgba(34, 197, 94, 0.3);
        }

        .hitl-popup-close {
            background: none;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            font-size: 1.2rem;
            padding: 4px;
            line-height: 1;
            transition: color 0.2s;
        }

        .hitl-popup-close:hover {
            color: var(--text-primary);
        }

        .hitl-popup-body {
            padding: 14px 16px;
        }

        .hitl-popup-question {
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.95rem;
            line-height: 1.5;
            color: var(--text-primary);
            margin-bottom: 12px;
        }

        .hitl-popup-context {
            font-size: 0.75rem;
            color: var(--text-muted);
            font-style: italic;
            margin-bottom: 12px;
            padding-left: 10px;
            border-left: 2px solid rgba(139, 92, 246, 0.3);
            line-height: 1.4;
        }

        /* Browser preview thumbnail */
        .hitl-browser-preview {
            margin-bottom: 12px;
            border-radius: 10px;
            overflow: hidden;
            border: 1px solid rgba(139, 92, 246, 0.2);
            position: relative;
            cursor: pointer;
            transition: border-color 0.2s;
        }

        .hitl-browser-preview:hover {
            border-color: rgba(139, 92, 246, 0.5);
        }

        .hitl-browser-preview img {
            width: 100%;
            height: 120px;
            object-fit: cover;
            display: block;
            background: var(--bg-card);
        }

        .hitl-browser-preview-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 6px 10px;
            background: linear-gradient(transparent, rgba(0,0,0,0.8));
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .hitl-browser-preview-label {
            font-size: 0.65rem;
            color: rgba(255,255,255,0.7);
            font-family: 'Space Mono', monospace;
        }

        .hitl-view-browser-btn {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            background: rgba(139, 92, 246, 0.2);
            border: 1px solid rgba(139, 92, 246, 0.3);
            border-radius: 8px;
            color: var(--accent-light);
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.8rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            text-decoration: none;
        }

        .hitl-view-browser-btn:hover {
            background: rgba(139, 92, 246, 0.35);
            border-color: rgba(139, 92, 246, 0.5);
            transform: translateY(-1px);
        }

        .hitl-view-browser-btn svg {
            width: 14px;
            height: 14px;
        }

        /* Answer input area */
        .hitl-popup-answer {
            padding: 0 16px 14px;
        }

        .hitl-answer-input {
            width: 100%;
            padding: 10px 12px;
            background: rgba(10, 10, 20, 0.6);
            border: 1px solid rgba(139, 92, 246, 0.2);
            border-radius: 10px;
            color: var(--text-primary);
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.9rem;
            resize: none;
            outline: none;
            transition: border-color 0.2s;
            box-sizing: border-box;
        }

        .hitl-answer-input:focus {
            border-color: rgba(139, 92, 246, 0.5);
        }

        .hitl-answer-input::placeholder {
            color: var(--text-muted);
        }

        .hitl-popup-actions {
            display: flex;
            gap: 8px;
            padding: 0 16px 14px;
        }

        .hitl-action-btn {
            flex: 1;
            padding: 9px 14px;
            border-radius: 10px;
            border: none;
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.85rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }

        .hitl-action-btn.submit {
            background: var(--accent-gradient);
            color: white;
        }

        .hitl-action-btn.submit:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 16px rgba(139, 92, 246, 0.3);
        }

        .hitl-action-btn.approve {
            background: rgba(34, 197, 94, 0.9);
            color: white;
        }

        .hitl-action-btn.approve:hover {
            background: rgba(34, 197, 94, 1);
            transform: translateY(-1px);
        }

        .hitl-action-btn.reject {
            background: rgba(30, 30, 45, 0.8);
            border: 1px solid rgba(239, 68, 68, 0.3);
            color: var(--text-secondary);
        }

        .hitl-action-btn.reject:hover {
            border-color: rgba(239, 68, 68, 0.6);
            background: rgba(239, 68, 68, 0.1);
        }

        /* Timer bar removed - no auto-dismiss */
        .hitl-popup-timer { display: none; }
        .hitl-popup-timer-bar { display: none; }

        /* Sidebar pulsing indicator for unanswered questions */
        .sidebar-questions.has-pending-hitl .sidebar-header-title::after {
            content: '';
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--red);
            margin-left: 8px;
            animation: hitlPulse 2s ease-in-out infinite;
        }

        /* ==================== BROWSER CONTROL (TAB PANE) ==================== */
        .browser-status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--text-muted);
            transition: all 0.3s ease;
        }

        .browser-status-dot.running {
            background: var(--accent);
            box-shadow: 0 0 8px var(--glow-medium);
        }

        .browser-status-dot.paused {
            background: var(--yellow);
            box-shadow: 0 0 8px rgba(234, 179, 8, 0.5);
            animation: hitlPulse 2s ease-in-out infinite;
        }

        .browser-status-dot.stopped {
            background: var(--text-muted);
        }

        .browser-status-text {
            font-family: 'Space Mono', monospace;
            font-size: 0.6rem;
            color: var(--text-muted);
        }

        .browser-status-text.running { color: var(--green); }
        .browser-status-text.paused { color: var(--yellow); }

        /* Old .browser-launch-btn, .browser-url-bar, .browser-url-text removed  replaced by tab pane styles */

        .browser-tab-list {
            max-height: 100px;
            overflow-y: auto;
            margin: 8px 0;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .browser-tab-list::-webkit-scrollbar { width: 3px; }
        .browser-tab-list::-webkit-scrollbar-track { background: transparent; }
        .browser-tab-list::-webkit-scrollbar-thumb {
            background: var(--glass-border);
            border-radius: 3px;
        }

        .browser-tab-item {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 5px 8px;
            background: rgba(10, 10, 20, 0.4);
            border: 1px solid var(--border);
            border-radius: 6px;
            font-size: 0.65rem;
            color: var(--text-secondary);
            cursor: default;
            transition: background 0.15s ease;
        }

        .browser-tab-item:hover {
            background: var(--bg-hover);
        }

        .browser-tab-item.active-tab {
            border-color: rgba(139, 92, 246, 0.3);
            color: var(--text-primary);
        }

        .browser-tab-favicon {
            width: 12px;
            height: 12px;
            border-radius: 2px;
            flex-shrink: 0;
        }

        .browser-tab-title {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            flex: 1;
        }

        /* Old .browser-preview removed  replaced by .browser-tab-screenshot */

        .browser-control-toggle {
            width: 100%;
            padding: 8px;
            border-radius: 8px;
            border: 1px solid var(--glass-border);
            background: rgba(139, 92, 246, 0.1);
            color: var(--accent-light);
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.8rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            margin-top: 6px;
        }

        .browser-control-toggle:hover {
            background: rgba(139, 92, 246, 0.2);
            border-color: var(--accent);
            transform: translateY(-1px);
        }

        .browser-control-toggle.give-back {
            background: rgba(234, 179, 8, 0.1);
            border-color: rgba(234, 179, 8, 0.3);
            color: var(--yellow);
        }

        .browser-control-toggle.give-back:hover {
            background: rgba(234, 179, 8, 0.2);
            border-color: var(--yellow);
        }

        .browser-control-toggle svg {
            width: 14px;
            height: 14px;
        }

        /* "Cerebro needs you" action banner */
        .browser-action-banner {
            display: none;
            margin-top: 8px;
            padding: 10px 12px;
            background: linear-gradient(135deg, rgba(234, 179, 8, 0.15), rgba(239, 68, 68, 0.1));
            border: 1px solid rgba(234, 179, 8, 0.4);
            border-radius: 10px;
            animation: actionBannerPulse 2s ease-in-out infinite;
        }

        .browser-action-banner.visible {
            display: block;
        }

        @keyframes actionBannerPulse {
            0%, 100% {
                box-shadow: 0 0 10px rgba(234, 179, 8, 0.2);
                border-color: rgba(234, 179, 8, 0.4);
            }
            50% {
                box-shadow: 0 0 25px rgba(234, 179, 8, 0.4);
                border-color: rgba(234, 179, 8, 0.7);
            }
        }

        .browser-action-banner-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.6rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--yellow);
            margin-bottom: 4px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .browser-action-banner-desc {
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.8rem;
            color: var(--text-primary);
            line-height: 1.4;
            margin-bottom: 8px;
        }

        .browser-action-done-btn {
            width: 100%;
            padding: 8px;
            border-radius: 8px;
            border: none;
            background: var(--accent-gradient);
            color: white;
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.85rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .browser-action-done-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 16px rgba(139, 92, 246, 0.3);
        }

        /* Old .browser-panel-body removed  tab pane handles visibility */

        /* ==================== BROWSER TAB PANE STYLES ==================== */
        #orb-pane-browser { padding: 0; overflow: hidden; }

        .browser-tab-status-bar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 12px;
            border-bottom: 1px solid var(--border);
            flex-shrink: 0;
        }
        .browser-tab-status-bar .status-left {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .browser-tab-status-bar .browser-status-text {
            font-size: 0.65rem;
        }

        .browser-tab-launch-btn {
            padding: 4px 12px;
            border-radius: 6px;
            border: 1px solid var(--glass-border);
            background: var(--bg-elevated);
            color: var(--text-primary);
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.75rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .browser-tab-launch-btn:hover {
            border-color: var(--accent);
            background: rgba(139, 92, 246, 0.1);
        }
        .browser-tab-launch-btn.stop {
            border-color: rgba(239, 68, 68, 0.3);
            color: var(--red);
        }
        .browser-tab-launch-btn.stop:hover {
            border-color: var(--red);
            background: rgba(239, 68, 68, 0.1);
        }
        .browser-tab-launch-btn svg { width: 12px; height: 12px; }

        .browser-tab-stopped {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 12px;
            padding: 32px 16px;
            text-align: center;
        }
        .browser-tab-stopped .stopped-icon {
            width: 40px;
            height: 40px;
            color: var(--text-muted);
            opacity: 0.5;
        }
        .browser-tab-stopped .stopped-text {
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.8rem;
            color: var(--text-muted);
        }
        .browser-tab-stopped .stopped-launch-btn {
            padding: 10px 24px;
            border-radius: 10px;
            border: 1px solid var(--glass-border);
            background: var(--bg-elevated);
            color: var(--text-primary);
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .browser-tab-stopped .stopped-launch-btn:hover {
            border-color: var(--accent);
            background: rgba(139, 92, 246, 0.1);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(139, 92, 246, 0.2);
        }

        .browser-tab-running {
            display: flex;
            flex-direction: column;
            flex: 1;
            min-height: 0;
            overflow: hidden;
        }

        .browser-tab-screenshot {
            position: relative;
            border-bottom: 1px solid var(--border);
            cursor: pointer;
            flex: 1 1 auto;
            min-height: 120px;
            overflow: hidden;
            display: flex;
            align-items: stretch;
            justify-content: center;
            background: var(--bg-card);
        }
        .browser-tab-screenshot img {
            width: 100%;
            height: 100%;
            object-fit: fill;
            display: block;
        }
        .browser-tab-screenshot .screenshot-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 4px 8px;
            background: linear-gradient(transparent, rgba(0,0,0,0.7));
            font-size: 0.55rem;
            color: rgba(255,255,255,0.5);
            font-family: 'Space Mono', monospace;
            opacity: 0;
            transition: opacity 0.2s;
        }
        .browser-tab-screenshot:hover .screenshot-overlay { opacity: 1; }

        .browser-tab-url {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 10px;
            border-bottom: 1px solid var(--border);
            flex-shrink: 0;
        }
        .browser-tab-url svg {
            width: 12px;
            height: 12px;
            flex-shrink: 0;
            color: var(--text-muted);
        }
        .browser-url-input {
            flex: 1;
            background: transparent;
            border: none;
            outline: none;
            font-family: 'Space Mono', monospace;
            font-size: 0.6rem;
            color: var(--text-secondary);
        }
        .browser-url-input::placeholder { color: var(--text-muted); }

        .browser-tab-strip {
            max-height: 60px;
            overflow-y: auto;
            padding: 4px 8px;
            display: flex;
            flex-direction: column;
            gap: 3px;
            border-bottom: 1px solid var(--border);
            flex-shrink: 0;
        }
        .browser-tab-strip:empty { display: none; }
        .browser-tab-strip::-webkit-scrollbar { width: 3px; }
        .browser-tab-strip::-webkit-scrollbar-thumb {
            background: var(--glass-border);
            border-radius: 3px;
        }

        .browser-tab-controls {
            padding: 6px 10px;
            border-bottom: 1px solid var(--border);
            flex-shrink: 0;
        }

        .browser-tab-step-log-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 6px 10px;
            border-bottom: 1px solid var(--border);
            flex-shrink: 0;
        }
        .browser-tab-step-log-header .log-label {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.55rem;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--text-muted);
        }
        .browser-tab-step-log-header .log-count {
            font-family: 'Space Mono', monospace;
            font-size: 0.55rem;
            color: var(--accent-light);
            background: rgba(139, 92, 246, 0.15);
            padding: 1px 6px;
            border-radius: 8px;
        }

        .browser-tab-step-log {
            max-height: 100px;
            overflow-y: auto;
            padding: 4px 0;
            flex-shrink: 0;
        }
        .browser-tab-step-log::-webkit-scrollbar { width: 3px; }
        .browser-tab-step-log::-webkit-scrollbar-thumb {
            background: var(--glass-border);
            border-radius: 3px;
        }

        .browser-step-entry {
            display: flex;
            gap: 8px;
            padding: 5px 10px;
            border-left: 2px solid rgba(99, 102, 241, 0.3);
            margin-left: 10px;
            transition: background 0.15s;
        }
        .browser-step-entry:hover { background: var(--bg-hover); }
        .browser-step-entry .step-num {
            font-family: 'Space Mono', monospace;
            font-size: 0.55rem;
            color: var(--accent-light);
            flex-shrink: 0;
            min-width: 24px;
        }
        .browser-step-entry .step-body {
            flex: 1;
            min-width: 0;
        }
        .browser-step-entry .step-action {
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.72rem;
            font-weight: 600;
            color: var(--text-primary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .browser-step-entry .step-reasoning {
            font-size: 0.6rem;
            color: var(--text-muted);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .browser-step-entry .step-thumb {
            width: 36px;
            height: 24px;
            border-radius: 3px;
            object-fit: cover;
            flex-shrink: 0;
            border: 1px solid var(--border);
        }

        .orb-browser-status-dot {
            display: inline-block;
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: var(--text-muted);
        }
        .orb-browser-status-dot.running {
            background: var(--accent);
            box-shadow: 0 0 6px var(--glow-medium);
        }
        .orb-browser-status-dot.paused {
            background: var(--yellow);
            box-shadow: 0 0 6px rgba(234, 179, 8, 0.5);
        }
        .orb-browser-status-dot.stopped { background: var(--text-muted); }

        @media (max-width: 768px) {
            .browser-tab-screenshot { min-height: 40px; }
            .browser-tab-step-log { max-height: 80px; }
        }

        /* ==================== OODA PHASE TRANSITIONS (Enhanced) ==================== */
        .ooda-phase-indicator {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 12px;
            border-radius: 20px;
            font-family: 'Space Mono', monospace;
            font-size: 0.65rem;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            font-weight: 600;
            animation: phaseGlow 0.5s ease;
        }

        @keyframes phaseGlow {
            from { opacity: 0; transform: scale(0.9); }
            to { opacity: 1; transform: scale(1); }
        }

        .ooda-phase-indicator.observe {
            background: rgba(59, 130, 246, 0.15);
            color: #3b82f6;
            border: 1px solid rgba(59, 130, 246, 0.3);
        }

        .ooda-phase-indicator.orient {
            background: rgba(139, 92, 246, 0.15);
            color: #a78bfa;
            border: 1px solid rgba(139, 92, 246, 0.3);
        }

        .ooda-phase-indicator.decide {
            background: rgba(245, 158, 11, 0.15);
            color: #f59e0b;
            border: 1px solid rgba(245, 158, 11, 0.3);
        }

        .ooda-phase-indicator.act {
            background: rgba(239, 68, 68, 0.15);
            color: #ef4444;
            border: 1px solid rgba(239, 68, 68, 0.3);
        }

        /* Activity log phase grouping */
        .activity-phase-group {
            margin-bottom: 8px;
            border-radius: 12px;
            overflow: hidden;
            border: 1px solid rgba(139, 92, 246, 0.1);
        }

        .activity-phase-header {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: rgba(18, 18, 30, 0.6);
            cursor: pointer;
            transition: background 0.2s;
        }

        .activity-phase-header:hover {
            background: rgba(18, 18, 30, 0.8);
        }

        .activity-phase-icon {
            font-size: 0.9rem;
        }

        .activity-phase-name {
            font-family: 'Space Mono', monospace;
            font-size: 0.6rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            font-weight: 600;
        }

        .activity-phase-summary {
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin-left: auto;
            max-width: 200px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .activity-phase-details {
            padding: 6px 12px 10px;
            font-size: 0.75rem;
            color: var(--text-muted);
            line-height: 1.5;
            display: none;
        }

        .activity-phase-group.expanded .activity-phase-details {
            display: block;
        }

        @media (max-width: 768px) {
            
        /* ==================== SECURITY ALERT POPUP ==================== */
        .security-alert-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 9800;
            display: none;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(6px);
            -webkit-backdrop-filter: blur(6px);
        }
        .security-alert-overlay.visible {
            display: flex;
        }

        .security-alert-popup {
            width: min(520px, 92vw);
            background: rgba(20, 10, 10, 0.97);
            backdrop-filter: blur(20px);
            border: 2px solid rgba(239, 68, 68, 0.6);
            border-radius: 16px;
            padding: 0;
            box-shadow:
                0 20px 60px rgba(0, 0, 0, 0.8),
                0 0 80px rgba(239, 68, 68, 0.3),
                0 0 120px rgba(239, 68, 68, 0.15);
            animation: securityAlertIn 0.4s cubic-bezier(0.16, 1, 0.3, 1);
            overflow: hidden;
        }

        .security-alert-popup.dismissing {
            animation: securityAlertOut 0.3s ease-in forwards;
        }

        @keyframes securityAlertIn {
            from { opacity: 0; transform: scale(0.8) translateY(-20px); }
            to { opacity: 1; transform: scale(1) translateY(0); }
        }
        @keyframes securityAlertOut {
            from { opacity: 1; transform: scale(1); }
            to { opacity: 0; transform: scale(0.85); }
        }

        .security-alert-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px 20px 12px;
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.15), rgba(239, 68, 68, 0.05));
            border-bottom: 1px solid rgba(239, 68, 68, 0.3);
        }

        .security-alert-header-left {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .security-alert-icon {
            width: 40px;
            height: 40px;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.4rem;
            background: rgba(239, 68, 68, 0.25);
            animation: securityPulse 1.5s ease-in-out infinite;
        }

        @keyframes securityPulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.5); }
            50% { box-shadow: 0 0 0 12px rgba(239, 68, 68, 0); }
        }

        .security-alert-label {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            color: var(--red);
        }

        .security-alert-severity {
            font-family: 'Space Mono', monospace;
            font-size: 0.6rem;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            padding: 4px 10px;
            border-radius: 8px;
            font-weight: 700;
            background: rgba(239, 68, 68, 0.25);
            color: var(--red);
            border: 1px solid rgba(239, 68, 68, 0.4);
            animation: severityBlink 2s ease-in-out infinite;
        }

        @keyframes severityBlink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        .security-alert-close {
            background: none;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            font-size: 1.3rem;
            padding: 4px;
            line-height: 1;
            transition: color 0.2s;
        }
        .security-alert-close:hover { color: var(--red); }

        .security-alert-body {
            padding: 20px;
        }

        .security-alert-title {
            font-family: 'Rajdhani', sans-serif;
            font-size: 1.15rem;
            font-weight: 600;
            color: #fff;
            margin-bottom: 16px;
        }

        .security-alert-device {
            background: rgba(239, 68, 68, 0.08);
            border: 1px solid rgba(239, 68, 68, 0.2);
            border-radius: 10px;
            padding: 14px;
            margin-bottom: 12px;
            font-family: 'Space Mono', monospace;
            font-size: 0.8rem;
            line-height: 1.8;
            color: var(--text-secondary);
        }

        .security-alert-device strong {
            color: var(--red);
            font-weight: 600;
        }

        .security-alert-timestamp {
            font-size: 0.7rem;
            color: var(--text-muted);
            margin-top: 8px;
        }

        .security-alert-actions {
            display: flex;
            gap: 10px;
            padding: 14px 20px 18px;
            border-top: 1px solid rgba(239, 68, 68, 0.15);
        }

        .security-alert-btn {
            flex: 1;
            padding: 10px 16px;
            border-radius: 10px;
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.85rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            border: none;
        }

        .security-alert-btn.dismiss {
            background: rgba(255, 255, 255, 0.06);
            color: var(--text-secondary);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .security-alert-btn.dismiss:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .security-alert-btn.investigate {
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.3), rgba(239, 68, 68, 0.15));
            color: #fff;
            border: 1px solid rgba(239, 68, 68, 0.4);
        }
        .security-alert-btn.investigate:hover {
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.45), rgba(239, 68, 68, 0.25));
            box-shadow: 0 4px 20px rgba(239, 68, 68, 0.3);
        }
        .security-alert-btn.register {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.3), rgba(59, 130, 246, 0.15));
            color: #fff;
            border: 1px solid rgba(59, 130, 246, 0.4);
        }
        .security-alert-btn.register:hover {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.45), rgba(59, 130, 246, 0.25));
            box-shadow: 0 4px 20px rgba(59, 130, 246, 0.3);
        }

        .hitl-popup-container {
                padding: 10px;
            }
            .hitl-popup {
                width: 100%;
            }
        }

        /*  Stored Item Detail Popup  */
        .stored-item-detail-overlay {
            position: fixed; inset: 0; z-index: 9700;
            background: rgba(0,0,0,0.6);
            backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);
            display: flex; align-items: center; justify-content: center;
            animation: fadeIn 0.2s ease;
        }
        .stored-item-detail-popup {
            width: 92vw; max-width: 520px; max-height: 80vh;
            background: var(--glass-bg, rgba(20,20,35,0.95));
            border: 1px solid rgba(255,255,255,0.08);
            border-radius: 16px;
            overflow: hidden; display: flex; flex-direction: column;
            animation: hitlScaleIn 0.25s ease;
            box-shadow: 0 24px 80px rgba(0,0,0,0.5);
        }
        .stored-item-detail-popup.type-alert {
            border-color: rgba(239,68,68,0.3);
            box-shadow: 0 24px 80px rgba(0,0,0,0.5), 0 0 40px rgba(239,68,68,0.08);
        }
        .stored-item-detail-popup.type-finding {
            border-color: rgba(59,130,246,0.3);
            box-shadow: 0 24px 80px rgba(0,0,0,0.5), 0 0 40px rgba(59,130,246,0.08);
        }
        .stored-item-detail-popup.type-agent_result {
            border-color: rgba(34,197,94,0.3);
            box-shadow: 0 24px 80px rgba(0,0,0,0.5), 0 0 40px rgba(34,197,94,0.08);
        }

        .stored-item-detail-header {
            padding: 16px 20px;
            display: flex; align-items: center; gap: 12px;
            position: relative;
        }
        .stored-item-detail-header.type-alert {
            background: linear-gradient(135deg, rgba(239,68,68,0.15), rgba(239,68,68,0.05));
            border-bottom: 1px solid rgba(239,68,68,0.15);
        }
        .stored-item-detail-header.type-finding {
            background: linear-gradient(135deg, rgba(59,130,246,0.15), rgba(59,130,246,0.05));
            border-bottom: 1px solid rgba(59,130,246,0.15);
        }
        .stored-item-detail-header.type-agent_result {
            background: linear-gradient(135deg, rgba(34,197,94,0.15), rgba(34,197,94,0.05));
            border-bottom: 1px solid rgba(34,197,94,0.15);
        }
        .stored-item-detail-icon {
            width: 36px; height: 36px; border-radius: 10px;
            display: flex; align-items: center; justify-content: center;
            font-size: 1.1rem; flex-shrink: 0;
        }
        .stored-item-detail-icon.type-alert {
            background: rgba(239,68,68,0.2); color: #ef4444;
        }
        .stored-item-detail-icon.type-finding {
            background: rgba(59,130,246,0.2); color: #3b82f6;
        }
        .stored-item-detail-icon.type-agent_result {
            background: rgba(34,197,94,0.2); color: #22c55e;
        }
        .stored-item-detail-icon.type-goal_progress {
            background: rgba(234,179,8,0.2); color: #eab308;
        }
        .stored-item-detail-icon.type-goal_complete {
            background: rgba(34,197,94,0.2); color: #22c55e;
        }
        .stored-item-detail-icon.type-quick_task {
            background: rgba(20,184,166,0.2); color: #14b8a6;
        }
        .stored-item-detail-header-text { flex: 1; min-width: 0; }
        .stored-item-detail-type-label {
            font-size: 0.65rem; font-weight: 700;
            text-transform: uppercase; letter-spacing: 0.5px;
            margin-bottom: 2px;
        }
        .stored-item-detail-type-label.type-alert { color: #ef4444; }
        .stored-item-detail-type-label.type-finding { color: #3b82f6; }
        .stored-item-detail-type-label.type-agent_result { color: #22c55e; }
        .stored-item-detail-type-label.type-goal_progress { color: #eab308; }
        .stored-item-detail-type-label.type-goal_complete { color: #22c55e; }
        .stored-item-detail-type-label.type-quick_task { color: #14b8a6; }
        .stored-item-detail-title {
            font-size: 1rem; font-weight: 600; color: var(--text-primary, #fff);
            white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
        }
        .stored-item-detail-close {
            position: absolute; top: 12px; right: 12px;
            width: 28px; height: 28px; border-radius: 8px;
            background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.08);
            color: var(--text-secondary, #aaa); cursor: pointer;
            display: flex; align-items: center; justify-content: center;
            font-size: 1rem; transition: background 0.15s;
        }
        .stored-item-detail-close:hover {
            background: rgba(255,255,255,0.12); color: #fff;
        }

        .stored-item-detail-body {
            flex: 1; overflow-y: auto; padding: 20px;
        }
        .stored-item-detail-fields {
            display: grid; grid-template-columns: auto 1fr;
            gap: 8px 16px; align-items: baseline;
        }
        .stored-item-detail-field-label {
            font-size: 0.75rem; font-weight: 600; color: var(--text-secondary, #aaa);
            text-transform: uppercase; letter-spacing: 0.3px;
        }
        .stored-item-detail-field-value {
            font-size: 0.88rem; color: var(--text-primary, #fff);
            font-family: 'JetBrains Mono', monospace; word-break: break-all;
        }
        .stored-item-detail-markdown {
            font-size: 0.88rem; color: var(--text-primary, #fff);
            line-height: 1.6;
        }
        .stored-item-detail-markdown p { margin: 0 0 8px 0; }
        .stored-item-detail-markdown strong { color: #fff; }
        .stored-item-detail-markdown code {
            background: rgba(255,255,255,0.06); padding: 1px 5px;
            border-radius: 4px; font-size: 0.82rem;
        }
        .stored-item-detail-timestamp {
            margin-top: 16px; padding-top: 12px;
            border-top: 1px solid rgba(255,255,255,0.06);
            font-size: 0.72rem; color: var(--text-tertiary, #666);
        }
        .stored-item-detail-meta {
            margin-top: 12px; padding: 10px 12px;
            background: rgba(255,255,255,0.03); border-radius: 8px;
            font-size: 0.75rem; color: var(--text-secondary, #aaa);
        }
        .stored-item-detail-meta-row {
            display: flex; justify-content: space-between; padding: 2px 0;
        }

        .stored-item-detail-actions {
            padding: 12px 20px; display: flex; gap: 10px; justify-content: flex-end;
            border-top: 1px solid rgba(255,255,255,0.06);
            background: rgba(0,0,0,0.15);
        }
        .stored-item-detail-btn {
            padding: 8px 18px; border-radius: 8px; font-size: 0.82rem;
            font-weight: 600; cursor: pointer; border: none;
            transition: all 0.15s;
        }
        .stored-item-detail-btn.delete {
            background: rgba(239,68,68,0.12); color: #ef4444;
            border: 1px solid rgba(239,68,68,0.2);
        }
        .stored-item-detail-btn.delete:hover {
            background: rgba(239,68,68,0.25);
        }
        .stored-item-detail-btn.investigate {
            color: #fff;
        }
        .stored-item-detail-btn.investigate.type-alert {
            background: linear-gradient(135deg, rgba(239,68,68,0.3), rgba(239,68,68,0.15));
            border: 1px solid rgba(239,68,68,0.4);
        }
        .stored-item-detail-btn.investigate.type-alert:hover {
            background: linear-gradient(135deg, rgba(239,68,68,0.45), rgba(239,68,68,0.25));
            box-shadow: 0 4px 20px rgba(239,68,68,0.2);
        }
        .stored-item-detail-btn.investigate.type-finding {
            background: linear-gradient(135deg, rgba(59,130,246,0.3), rgba(59,130,246,0.15));
            border: 1px solid rgba(59,130,246,0.4);
        }
        .stored-item-detail-btn.investigate.type-finding:hover {
            background: linear-gradient(135deg, rgba(59,130,246,0.45), rgba(59,130,246,0.25));
            box-shadow: 0 4px 20px rgba(59,130,246,0.2);
        }
        .stored-item-detail-btn.investigate.type-agent_result {
            background: linear-gradient(135deg, rgba(34,197,94,0.3), rgba(34,197,94,0.15));
            border: 1px solid rgba(34,197,94,0.4);
        }
        .stored-item-detail-btn.investigate.type-agent_result:hover {
            background: linear-gradient(135deg, rgba(34,197,94,0.45), rgba(34,197,94,0.25));
            box-shadow: 0 4px 20px rgba(34,197,94,0.2);
        }
        .stored-item-detail-popup.closing {
            animation: hitlScaleOut 0.2s ease forwards;
        }
        .stored-item-detail-overlay.closing {
            animation: fadeIn 0.2s ease reverse forwards;
        }


        /* ================================================================
           Voice Screenshot - Toast + Fullscreen Overlay
           ================================================================ */
        .voice-screenshot-toast {
            position: fixed;
            bottom: 24px;
            right: 24px;
            width: 320px;
            background: var(--glass-bg);
            backdrop-filter: blur(var(--glass-blur));
            -webkit-backdrop-filter: blur(var(--glass-blur));
            border: 1px solid var(--glass-border);
            border-radius: 16px;
            padding: 14px;
            z-index: 9998;
            box-shadow: var(--shadow-lg), 0 0 30px var(--accent-glow);
            animation: vsToastIn 0.4s var(--ease-out-back);
            cursor: pointer;
            transition: transform 0.2s ease, opacity 0.3s ease;
        }
        .voice-screenshot-toast:hover {
            transform: translateY(-2px);
            border-color: var(--glass-border-hover);
        }
        .voice-screenshot-toast.dismissing {
            opacity: 0;
            transform: translateY(10px);
        }
        .voice-screenshot-toast .vs-toast-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 10px;
        }
        .voice-screenshot-toast .vs-toast-label {
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--accent-light);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        .voice-screenshot-toast .vs-toast-title {
            font-size: 0.8rem;
            color: var(--text-secondary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            flex: 1;
        }
        .voice-screenshot-toast .vs-toast-close {
            width: 22px;
            height: 22px;
            border-radius: 50%;
            background: var(--bg-elevated);
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            flex-shrink: 0;
        }
        .voice-screenshot-toast .vs-toast-thumb {
            width: 100%;
            border-radius: 10px;
            max-height: 180px;
            object-fit: cover;
            border: 1px solid var(--border);
        }

        @keyframes vsToastIn {
            from { opacity: 0; transform: translateX(40px) scale(0.95); }
            to { opacity: 1; transform: translateX(0) scale(1); }
        }

        .voice-screenshot-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10002;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
            padding: 20px;
        }
        .voice-screenshot-overlay.active {
            opacity: 1;
            visibility: visible;
        }
        .voice-screenshot-overlay img {
            max-width: 95vw;
            max-height: 85vh;
            object-fit: contain;
            border-radius: 12px;
            box-shadow: 0 0 60px rgba(139, 92, 246, 0.3);
        }
        .voice-screenshot-overlay .vs-overlay-bar {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--glass-bg);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            padding: 10px 20px;
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 0.85rem;
            color: var(--text-secondary);
        }
        .voice-screenshot-overlay .vs-overlay-bar .vs-window-title {
            color: var(--text-primary);
            font-weight: 500;
        }
        .voice-screenshot-overlay .vs-overlay-close {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: var(--glass-bg);
            border: 1px solid var(--glass-border);
            color: var(--text-primary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.3rem;
            transition: background 0.2s;
        }
        .voice-screenshot-overlay .vs-overlay-close:hover {
            background: var(--bg-hover);
        }


    </style>
</head>
<body>
    <!-- Ambient particle background -->
    <div id="particles-bg"></div>

    <div class="app" id="app">
        <!-- Login View -->
        <div class="login-view" id="login-view">
            <div class="login-card">
                <div class="login-logo">C</div>
                <div class="login-title">Cerebro</div>
                <div class="login-subtitle">Your AI, Everywhere</div>
                <input type="password" class="login-input" id="password-input" placeholder="Enter password" autocomplete="current-password">
                <button class="login-btn" onclick="login()">Sign In</button>
                <div class="login-error" id="login-error">Invalid password</div>
            </div>
        </div>

        <!-- Cinematic Onboarding -->
        <div class="login-view hidden" id="onboarding-view">
            <div class="cin-onboard">
                <div class="cin-backdrop"></div>
                <div class="cin-dissolve" id="cin-dissolve"></div>
                <div class="cin-orb-wrap" id="cin-orb">
                    <img src="/static/cerebro-orb.png" alt="Cerebro" class="cin-orb-img" draggable="false">
                    <div class="cin-ring cin-ring-1"></div>
                    <div class="cin-ring cin-ring-2"></div>
                    <div class="cin-ring cin-ring-3"></div>
                </div>
                <div id="cin-conversation"></div>
                <div class="cin-input-bar" id="cin-input-bar">
                    <div class="cin-input-content" id="cin-input-content"></div>
                </div>
                <div class="cin-error" id="cin-error"></div>
            </div>
        </div>

        <!-- Main App -->
        <div id="main-app" class="hidden">
            <!-- Header -->
            <header class="header">
                <div class="logo">
                    <div class="nav-orb-container" id="nav-orb-container" title="Click to start/stop voice conversation">
                        <div class="nav-orb-ring"></div>
                        <div class="nav-orb-ring"></div>
                        <img src="/static/cerebro-logo-128.png" alt="Cerebro" class="nav-orb-img">
                    </div>
                    <span class="logo-text">Cerebro</span>
                </div>
                <div class="header-status">
                    <div class="header-agents-pill" id="header-agents-pill">idle</div>
                    <div class="notification-bell" id="notification-bell" onclick="toggleNotificationPanel()">
                        <svg class="bell-icon-svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"/><path d="M13.73 21a2 2 0 0 1-3.46 0"/></svg>
                        <span class="notification-badge hidden" id="notification-badge">0</span>
                    </div>
                    <div class="sync-badge" id="sync-badge" title="Connected devices">
                        <div class="sync-dot"></div>
                        <span id="device-count">1</span>
                    </div>
                    <div class="status-badge" id="header-status-badge" title="Online" style="display:none">
                        <div class="status-dot" id="status-dot"></div>
                    </div>
                </div>

                <!-- Notification Panel Dropdown -->
                <div class="notification-panel hidden" id="notification-panel">
                    <div class="notification-panel-header">
                        <span>Notifications</span>
                        <button class="mark-all-read-btn" onclick="markAllNotificationsRead()">Mark all read</button>
                    </div>
                    <div class="notification-list" id="notification-list">
                        <div class="no-notifications">No notifications</div>
                    </div>
                </div>
            </header>

            <!-- Main Content -->
            <main class="main-content">
                <!-- Home View -->
                <div class="view home-view active" id="view-home">

                    <!-- Section 1: Compact Hero Bar -->
                    <div class="hero-bar" id="cerebro-presence">
                        <div class="hero-bar-main">
                            <div class="hero-orb-mini">
                                <div class="core-ring"></div>
                                <div class="core-ring"></div>
                                <img src="/static/cerebro-logo-128.png" alt="Cerebro" class="hero-orb-img">
                            </div>
                            <div class="hero-info">
                                <div class="hero-greeting" id="presence-greeting">Hey there</div>
                                <div class="hero-status">
                                    <div class="status-indicator" id="cerebro-status-indicator"></div>
                                    <span id="cerebro-status-text">Awake and ready</span>
                                    <div class="mood-indicator" id="mood-indicator" style="margin-left:8px">
                                        <span class="mood-dot" id="mood-emoji"></span>
                                        <span id="mood-text">Focused</span>
                                    </div>
                                </div>
                            </div>
                            <div class="hero-datetime" id="hero-datetime"></div>
                        </div>
                        <div class="hero-pills">
                            <div class="stat-pill" onclick="openHomeDetail('stat', {name:'Observations', value: this.querySelector('.stat-pill-value').textContent, icon:'\u{1F9E0}', context:'Facts, entities, and insights extracted from conversations.'})">
                                <span class="stat-pill-value" id="memory-count">0</span>
                                <span class="stat-pill-label">Observations</span>
                            </div>
                            <div class="stat-pill" onclick="openHomeDetail('stat', {name:'Learnings', value: this.querySelector('.stat-pill-value').textContent, icon:'\u{1F4DA}', context:'Solutions, patterns, and insights recorded from sessions.'})">
                                <span class="stat-pill-value" id="home-learnings-count">0</span>
                                <span class="stat-pill-label">Learnings</span>
                            </div>
                            <div class="stat-pill" onclick="openHomeDetail('stat', {name:'Patterns', value: this.querySelector('.stat-pill-value').textContent, icon:'\u{1F50D}', context:'Promoted patterns from 3+ recurring learnings.'})">
                                <span class="stat-pill-value" id="home-patterns-count">0</span>
                                <span class="stat-pill-label">Patterns</span>
                            </div>
                            <div class="stat-pill" onclick="openHomeDetail('stat', {name:'Active Agents', value: this.querySelector('.stat-pill-value').textContent, icon:'\u{1F916}', context:'Currently running autonomous agents.'})">
                                <span class="stat-pill-value" id="active-agents-count">0</span>
                                <span class="stat-pill-label">Agents</span>
                            </div>
                            <div class="stat-pill" onclick="openHomeDetail('stat', {name:'Goals', value: this.querySelector('.stat-pill-value').textContent, icon:'\u{1F3AF}', context:'Active goals being tracked and pursued.'})">
                                <span class="stat-pill-value" id="home-goals-count">0</span>
                                <span class="stat-pill-label">Goals</span>
                            </div>
                            <div class="stat-pill" onclick="openHomeDetail('stat', {name:'System Health', value: this.querySelector('.stat-pill-value').textContent, icon:'\u2764\uFE0F', context:'Overall knowledge base health score.'})">
                                <span class="stat-pill-value" id="system-health">100%</span>
                                <span class="stat-pill-label">Health</span>
                            </div>
                        </div>
                    </div>

                    <!-- Section 2: Smart Next Actions (always visible) -->
                    <div class="home-section" id="home-section-actions">
                        <div class="section-title">Next Actions</div>
                        <div class="smart-actions-scroll" id="smart-actions-container">
                            <div class="loading-container"><div class="spinner"></div></div>
                        </div>
                    </div>

                    <!-- Section 3: Live Activity (collapsible, default expanded) -->
                    <div class="home-section" id="home-section-activity">
                        <div class="section-collapse-header" onclick="toggleSection('activity')">
                            <div class="section-collapse-left">
                                <span class="section-title" style="margin-bottom:0">Live Activity</span>
                                <span class="section-count-badge" id="activity-count-badge">3</span>
                            </div>
                            <span class="section-chevron" id="activity-chevron">&#9660;</span>
                        </div>
                        <div class="home-section-body" id="activity-section-body">
                            <div class="live-activity-grid" id="live-activity-grid">
                                <div class="live-card" onclick="openHomeDetail('activity', {type:'agents', title:'Running Agents'})">
                                    <div class="live-card-header">
                                        <span class="live-card-icon">&#x1F916;</span>
                                        <span class="live-card-title">Running Agents</span>
                                    </div>
                                    <div class="live-card-body" id="live-agents-body">
                                        <div class="live-empty">No agents running</div>
                                    </div>
                                </div>
                                <div class="live-card" onclick="openHomeDetail('activity', {type:'health', title:'Memory Health'})">
                                    <div class="live-card-header">
                                        <span class="live-card-icon">&#x1F9E0;</span>
                                        <span class="live-card-title">Memory Health</span>
                                    </div>
                                    <div class="live-card-body" id="memory-health-grid">
                                        <div class="status-grid">
                                            <div class="status-item"><span class="status-dot unknown"></span><span class="status-name">Loading...</span></div>
                                        </div>
                                    </div>
                                </div>
                                <div class="live-card">
                                    <div class="live-card-header">
                                        <span class="live-card-icon">&#x1F4BB;</span>
                                        <span class="live-card-title">Active Devices</span>
                                        <button class="live-card-add-btn" onclick="event.stopPropagation(); refreshAllDevices()" title="Refresh all devices" id="refresh-devices-btn" style="font-size:0.85rem;">&#x21bb;</button>
                                        <button class="live-card-add-btn" onclick="event.stopPropagation(); openAddDeviceModal()" title="Add device">+</button>
                                    </div>
                                    <div class="live-card-body" id="live-devices-body">
                                        <div class="live-empty">No devices</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Section 4: Goals & Progress (collapsible, default expanded) -->
                    <div class="home-section" id="home-goals-section">
                        <div class="section-collapse-header" onclick="toggleSection('goals')">
                            <div class="section-collapse-left">
                                <span class="section-title" style="margin-bottom:0">Goals</span>
                                <span class="section-count-badge" id="goals-count-badge">0</span>
                            </div>
                            <span class="section-chevron" id="goals-chevron">&#9660;</span>
                        </div>
                        <div class="home-section-body" id="goals-section-body">
                            <div class="home-goals-list" id="home-goals-list">
                                <div class="live-empty">Loading goals...</div>
                            </div>
                        </div>
                    </div>

                    <!-- Section 5: Project Tracker (collapsible, default collapsed) -->
                    <div class="home-section collapsed" id="home-section-projects">
                        <div class="section-collapse-header" onclick="toggleSection('projects')">
                            <div class="section-collapse-left">
                                <span class="section-title" style="margin-bottom:0">Projects</span>
                                <span class="section-count-badge" id="projects-count-badge">0</span>
                            </div>
                            <span class="section-chevron" id="projects-chevron">&#9660;</span>
                        </div>
                        <div class="home-section-body" id="projects-section-body">
                            <div class="project-tracker-scroll" id="project-tracker-container">
                                <div class="loading-container"><div class="spinner"></div></div>
                            </div>
                        </div>
                    </div>

                    <!-- Section 6: Memory Intelligence (collapsible, default collapsed) -->
                    <div class="home-section collapsed" id="home-section-memory">
                        <div class="section-collapse-header" onclick="toggleSection('memory')">
                            <div class="section-collapse-left">
                                <span class="section-title" style="margin-bottom:0">Memory Intelligence</span>
                                <span class="section-count-badge" id="memory-section-count-badge">6</span>
                            </div>
                            <span class="section-chevron" id="memory-chevron">&#9660;</span>
                        </div>
                        <div class="home-section-body" id="memory-section-body">
                            <div class="mem-intel-grid" id="mem-intel-grid">
                                <div class="mem-tile green" onclick="openHomeDetail('stat', {name:'Total Observations', value: document.getElementById('intel-total-memories').textContent, icon:'&#x1F9E0;', context:'Facts, entities, and insights extracted from conversations and knowledge base entries.'})">
                                    <div class="mem-tile-value" id="intel-total-memories">--</div>
                                    <div class="mem-tile-label">Total Observations</div>
                                </div>
                                <div class="mem-tile purple" onclick="openHomeDetail('stat', {name:'This Week', value: document.getElementById('intel-recent-learnings').textContent, icon:'&#x1F4DA;', context:'New learnings recorded in the past 7 days from conversations and discoveries.'})">
                                    <div class="mem-tile-value" id="intel-recent-learnings">--</div>
                                    <div class="mem-tile-label">This Week</div>
                                </div>
                                <div class="mem-tile purple" onclick="openHomeDetail('stat', {name:'Patterns', value: document.getElementById('intel-patterns').textContent, icon:'&#x1F50D;', context:'Promoted patterns that graduated from 3+ recurring learnings.'})">
                                    <div class="mem-tile-value" id="intel-patterns">--</div>
                                    <div class="mem-tile-label">Patterns</div>
                                </div>
                                <div class="mem-tile amber" onclick="openHomeDetail('stat', {name:'Contradictions', value: document.getElementById('intel-contradictions').textContent, icon:'&#x26A0;&#xFE0F;', context:'Pending contradictions in the knowledge base that need resolution.'})">
                                    <div class="mem-tile-value" id="intel-contradictions">--</div>
                                    <div class="mem-tile-label">Contradictions</div>
                                </div>
                                <div class="mem-tile green" onclick="openHomeDetail('stat', {name:'Knowledge Health', value: document.getElementById('intel-health').textContent, icon:'&#x2764;&#xFE0F;', context:'Overall health score based on freshness, consistency, and coverage of the knowledge base.'})">
                                    <div class="mem-tile-value" id="intel-health">--</div>
                                    <div class="mem-tile-label">Knowledge Health</div>
                                </div>
                                <div class="mem-tile purple" onclick="openHomeDetail('stat', {name:'FAISS Index', value: document.getElementById('intel-faiss').textContent, icon:'&#x1F4BE;', context:'Size of the FAISS vector search index used for semantic memory retrieval.'})">
                                    <div class="mem-tile-value" id="intel-faiss">--</div>
                                    <div class="mem-tile-label">FAISS Index</div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Section 7: Recent Agents -->
                    <div class="home-section" id="recent-agents-section" style="display:none">
                        <div class="section-title">Recent Agents</div>
                        <div class="recent-agents-list" id="recent-agents-list"></div>
                    </div>

                    <!-- Hidden elements for compatibility -->
                    <span id="uptime-display" style="display:none">Online</span>
                </div>

                <!-- Chat View -->
                <div class="view chat-view" id="view-chat">
                    <div class="split-left-panel" id="split-left-panel">
                        <div class="split-left-tabs">
                            <button class="split-tab active" data-tab="notepad" onclick="switchSplitTab('notepad')">Notepad</button>
                            <button class="split-tab" data-tab="compose" onclick="switchSplitTab('compose')">Compose</button>
                        </div>
                        <div class="split-tab-content" id="split-tab-notepad">
                            <textarea class="split-notepad" id="split-notepad" placeholder="Jot down ideas, notes, code snippets..."></textarea>
                        </div>
                        <div class="split-tab-content" id="split-tab-compose" style="display:none">
                            <textarea class="split-compose" id="split-compose" placeholder="Draft a longer message to Cerebro..." onkeydown="handleComposeKeyDown(event)"></textarea>
                        </div>
                    </div>
                    <div class="messages-container" id="messages">
                        <div class="message assistant" data-text="Hey! I'm Cerebro, your AI command center. I can spawn agents, search your memory, run automations, or help with anything else. What do you need?">
                            <div class="msg-header">
                                <span class="msg-sender">Cerebro</span>
                                <span class="msg-meta">
                                    <span class="msg-model"></span>
                                    <span class="msg-time">Welcome</span>
                                </span>
                            </div>
                            <div class="message-content-wrapper">Hey! I'm Cerebro, your AI command center. I can spawn agents, search your memory, run automations, or help with anything else. What do you need?</div>
                        </div>
                    </div>
                    <div class="chat-input-area">
                        <div class="quick-action-pills"></div>
                        <div id="chat-image-preview" class="image-upload-preview"></div>
                        <div class="chat-input-wrapper">
                            <div class="input-model-selector">
                                <button class="input-model-btn" id="input-model-btn" onclick="toggleInputModelDropdown()">
                                    <span class="model-dot" id="input-model-dot"></span>
                                    <span id="input-model-label">Sonnet 4.5</span>
                                    <svg class="chevron-icon" width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="6 9 12 15 18 9"/></svg>
                                </button>
                                <div class="input-model-dropdown" id="input-model-dropdown">
                                    <button class="model-option" data-model="claude-opus-4-6" onclick="selectModel('claude-opus-4-6')">
                                        <span class="model-dot opus"></span>
                                        <div class="model-info"><div class="model-name">Claude Opus 4.6</div><div class="model-desc">Most capable</div></div>
                                        <svg class="model-check" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><polyline points="20 6 9 17 4 12"/></svg>
                                    </button>
                                    <button class="model-option" data-model="claude-sonnet-4-6" onclick="selectModel('claude-sonnet-4-6')">
                                        <span class="model-dot sonnet46"></span>
                                        <div class="model-info"><div class="model-name">Claude Sonnet 4.6</div><div class="model-desc">Fast & intelligent</div></div>
                                        <svg class="model-check" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><polyline points="20 6 9 17 4 12"/></svg>
                                    </button>
                                    <button class="model-option" data-model="claude-sonnet-4-5-20250929" onclick="selectModel('claude-sonnet-4-5-20250929')">
                                        <span class="model-dot sonnet"></span>
                                        <div class="model-info"><div class="model-name">Claude Sonnet 4.5</div><div class="model-desc">Balanced</div></div>
                                        <svg class="model-check" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><polyline points="20 6 9 17 4 12"/></svg>
                                    </button>
                                    <button class="model-option" data-model="claude-haiku-4-5-20251001" onclick="selectModel('claude-haiku-4-5-20251001')">
                                        <span class="model-dot haiku"></span>
                                        <div class="model-info"><div class="model-name">Claude Haiku 4.5</div><div class="model-desc">Fastest</div></div>
                                        <svg class="model-check" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><polyline points="20 6 9 17 4 12"/></svg>
                                    </button>
                                </div>
                            </div>
                            <div class="chat-offload-selector" id="chat-offload-selector" style="display:none;">
                                <button class="chat-offload-btn" id="chat-offload-btn" onclick="toggleChatOffloadDropdown()" title="Route chat to device">
                                    <span class="offload-icon">&#x1F4BB;</span>
                                    <span id="chat-offload-label">Local</span>
                                    <svg class="chevron-icon" width="8" height="8" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="6 9 12 15 18 9"/></svg>
                                </button>
                                <div class="chat-offload-dropdown" id="chat-offload-dropdown">
                                    <button class="offload-option selected" data-device-id="" onclick="selectChatOffloadDevice('')">
                                        <span class="offload-opt-icon">&#x1F4BB;</span>
                                        <div class="offload-opt-info"><div class="offload-opt-name">Local</div><div class="offload-opt-detail">Process on this machine</div></div>
                                        <svg class="offload-check" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><polyline points="20 6 9 17 4 12"/></svg>
                                    </button>
                                </div>
                            </div>
                            <button class="attach-btn" onclick="triggerFileAttach()" title="Attach file">
                                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48"/></svg>
                            </button>
                            <textarea class="chat-input" id="chat-input" placeholder="Message Cerebro..." rows="1" onkeydown="handleKeyDown(event)"></textarea>
                            <div class="input-actions">
                                <button class="layout-toggle-btn" id="layout-toggle-btn" onclick="toggleChatLayout()" title="Toggle split view">
                                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                        <rect x="3" y="3" width="18" height="18" rx="2"/>
                                        <line x1="9" y1="3" x2="9" y2="21"/>
                                    </svg>
                                </button>
                                <button class="browser-toggle-btn" id="chat-browser-btn" onclick="toggleChatBrowser()" title="Launch/Stop Browser">
                                    <span class="chat-browser-dot" id="chat-browser-dot"></span>
                                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><line x1="2" y1="12" x2="22" y2="12"/><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"/></svg>
                                </button>
                                <button class="save-memory-btn" id="split-save-btn" onclick="saveNotepadToMemory()" title="Save notepad to memory" style="display:none">
                                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/>
                                        <polyline points="17 21 17 13 7 13 7 21"/>
                                        <polyline points="7 3 7 8 15 8"/>
                                    </svg>
                                </button>
                                <button class="send-btn" onclick="sendMessage()" id="send-btn">
                                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                                        <path d="M22 2L11 13"/>
                                        <path d="M22 2L15 22L11 13L2 9L22 2Z"/>
                                    </svg>
                                </button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Quick Actions View -->
                <div class="view quick-view" id="view-quick">
                    <div class="action-section">
                        <div class="section-title">System Control</div>
                        <div class="action-grid">
                            <div class="action-btn" onclick="runQuickAction('start chrome')">
                                <div class="action-btn-icon"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><line x1="2" y1="12" x2="22" y2="12"/><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"/></svg></div>
                                <div class="action-btn-label">Chrome</div>
                            </div>
                            <div class="action-btn" onclick="runQuickAction('code')">
                                <div class="action-btn-icon"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="16 18 22 12 16 6"/><polyline points="8 6 2 12 8 18"/></svg></div>
                                <div class="action-btn-label">VS Code</div>
                            </div>
                            <div class="action-btn" onclick="runQuickAction('start wt')">
                                <div class="action-btn-icon"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="4 17 10 11 4 5"/><line x1="12" y1="19" x2="20" y2="19"/></svg></div>
                                <div class="action-btn-label">Terminal</div>
                            </div>
                            <div class="action-btn" onclick="runQuickAction('start chrome https://youtube.com')">
                                <div class="action-btn-icon"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="5 3 19 12 5 21 5 3"/></svg></div>
                                <div class="action-btn-label">YouTube</div>
                            </div>
                            <div class="action-btn" onclick="runQuickAction(CEREBRO_DATA_DIR ? 'explorer ' + CEREBRO_DATA_DIR : 'echo No data dir configured')">
                                <div class="action-btn-icon"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/></svg></div>
                                <div class="action-btn-label">Files</div>
                            </div>
                            <div class="action-btn" onclick="runQuickAction('start chrome https://github.com')">
                                <div class="action-btn-icon"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"/></svg></div>
                                <div class="action-btn-label">GitHub</div>
                            </div>
                            <div class="action-btn" onclick="runQuickAction('start chrome https://claude.ai')">
                                <div class="action-btn-icon"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><path d="M8 12h8"/><path d="M12 8v8"/></svg></div>
                                <div class="action-btn-label">Claude</div>
                            </div>
                            <div class="action-btn" onclick="runQuickAction('start chrome https://chat.openai.com')">
                                <div class="action-btn-icon"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><circle cx="12" cy="12" r="4"/></svg></div>
                                <div class="action-btn-label">ChatGPT</div>
                            </div>
                        </div>
                    </div>

                    <div class="action-section">
                        <div class="section-title">Dev Tools</div>
                        <div class="action-row">
                            <div class="action-wide" onclick="startChat('Run git status in my current project and show me any uncommitted changes')">
                                <span class="action-wide-icon"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="18" cy="18" r="3"/><circle cx="6" cy="6" r="3"/><path d="M6 21V9a9 9 0 0 0 9 9"/></svg></span>
                                <span class="action-wide-label">Git Status</span>
                            </div>
                            <div class="action-wide" onclick="startChat('Check the health of all my services and servers')">
                                <span class="action-wide-icon"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z"/></svg></span>
                                <span class="action-wide-label">Health Check</span>
                            </div>
                        </div>
                        <div class="action-row" style="margin-top: 12px;">
                            <div class="action-wide" onclick="startChat('Show me my recent AI Memory learnings from the past week')">
                                <span class="action-wide-icon"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><path d="M12 16v-4"/><path d="M12 8h.01"/></svg></span>
                                <span class="action-wide-label">Recent Learnings</span>
                            </div>
                            <div class="action-wide" onclick="startChat('What projects do I have and what is their current status?')">
                                <span class="action-wide-icon"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"/><rect x="8" y="2" width="8" height="4" rx="1" ry="1"/></svg></span>
                                <span class="action-wide-label">All Projects</span>
                            </div>
                        </div>
                    </div>

                    <div class="action-section">
                        <div class="section-title">AI Memory</div>
                        <div class="action-row">
                            <div class="action-wide" onclick="startChat('Save this conversation to AI Memory')">
                                <span class="action-wide-icon"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><polyline points="17 21 17 13 7 13 7 21"/><polyline points="7 3 7 8 15 8"/></svg></span>
                                <span class="action-wide-label">Save Session</span>
                            </div>
                            <div class="action-wide" onclick="startChat('Run a memory health check and show me stats')">
                                <span class="action-wide-icon"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="20" x2="18" y2="10"/><line x1="12" y1="20" x2="12" y2="4"/><line x1="6" y1="20" x2="6" y2="14"/></svg></span>
                                <span class="action-wide-label">Memory Stats</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Agents View -->
                <div class="view agents-view" id="view-agents">
                    <div class="agents-header">
                        <div class="agents-view-mode">
                            <button class="view-mode-btn active" data-view="grid" onclick="switchAgentsViewMode('grid')" title="Grid view">
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="7" height="7"/><rect x="14" y="3" width="7" height="7"/><rect x="3" y="14" width="7" height="7"/><rect x="14" y="14" width="7" height="7"/></svg>
                                Grid
                            </button>
                            <button class="view-mode-btn" data-view="project" onclick="switchAgentsViewMode('project')" title="Project view">
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/></svg>
                                Groups
                            </button>
                            <button class="view-mode-btn" data-view="list" onclick="switchAgentsViewMode('list')" title="List view">
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="8" y1="6" x2="21" y2="6"/><line x1="8" y1="12" x2="21" y2="12"/><line x1="8" y1="18" x2="21" y2="18"/><line x1="3" y1="6" x2="3.01" y2="6"/><line x1="3" y1="12" x2="3.01" y2="12"/><line x1="3" y1="18" x2="3.01" y2="18"/></svg>
                                List
                            </button>
                        </div>
                        <div class="agents-tab-control">
                            <button class="agents-tab active" data-tab="all" onclick="switchAgentsTab('all')">All Agents</button>
                            <button class="agents-tab" data-tab="user" onclick="switchAgentsTab('user')">My Agents</button>
                            <button class="agents-tab" data-tab="cerebro" onclick="switchAgentsTab('cerebro')">Cerebro's Agents</button>
                        </div>
                        <div class="agents-toolbar">
                            <input type="text" class="agents-search" id="agents-search-input" placeholder="Search agents..." oninput="filterAgents()">
                            <div class="agents-sort-toggle" id="agents-sort-toggle">
                                <button class="sort-arrow-btn active" id="sort-btn-desc" onclick="setAgentSortDir('desc')" title="Newest first">&darr;</button>
                                <div class="sort-divider"></div>
                                <button class="sort-arrow-btn" id="sort-btn-asc" onclick="setAgentSortDir('asc')" title="Oldest first">&uarr;</button>
                            </div>
                        </div>
                        <div class="agents-header-row">
                            <div class="agents-count" id="agents-count">0 running</div>
                            <div style="flex:1"></div>
                            <button class="btn-spawn-compact" onclick="showSpawnAgentDialog()">+ Spawn</button>
                            <button class="btn btn-secondary btn-select-header" id="agent-select-toggle-btn" onclick="toggleAgentSelectMode()">
                                Select
                            </button>
                            <button class="btn btn-secondary btn-select-header" onclick="openGroupEditor()">
                                Edit Groups
                            </button>
                        </div>
                        <!-- Agent Control Bar  stop individual or all -->
                        <div class="agent-control-bar" id="agent-control-bar">
                            <span class="control-label">Running:</span>
                            <div class="running-agent-chips" id="running-agent-chips"></div>
                            <button class="stop-all-btn" onclick="gracefulStopAllAgents()">Stop All</button>
                        </div>
                    </div>

                    <div id="agents-container">
                        <div class="no-agents">
                            <div class="no-agents-icon"><svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><circle cx="12" cy="8" r="5"/><path d="M3 21v-2a7 7 0 0 1 7-7h4a7 7 0 0 1 7 7v2"/></svg></div>
                            <div>No agents running</div>
                            <div style="font-size: 0.85rem; margin-top: 8px; color: var(--text-muted);">
                                Spawn agents from suggestions or chat
                            </div>
                        </div>
                    </div>


                    <!-- Selection action bar (shown when agents are selected) -->
                    <div class="selection-action-bar" id="selection-action-bar" style="display: none;">
                        <span class="selection-count" id="selection-count">0 selected</span>
                        <button class="btn btn-primary" onclick="showMergeSpawnModal()">Merge &amp; Spawn</button>
                        <button class="btn btn-secondary" onclick="showBulkAssignGroupModal()">Move to Group</button>
                        <button class="btn btn-secondary" onclick="deleteSelectedAgents()" style="color: #ff6b6b;">&#128465; Delete</button>
                        <button class="btn btn-secondary" onclick="clearAgentSelection()">Clear</button>
                    </div>

                    <!-- Archived Agents Section -->
                    <div class="archive-section" id="archive-section">
                        <div class="archive-toggle" onclick="toggleArchiveSection()">
                            <span class="archive-toggle-icon" id="archive-toggle-icon"></span>
                            <span>Archived Agents</span>
                            <span class="archived-count" id="archived-count">(0)</span>
                        </div>
                        <div class="archived-agents-container hidden" id="archived-agents-container">
                            <!-- Archived agents rendered here -->
                        </div>
                    </div>
                </div>

                <!-- Autonomy View - Consciousness Interface -->
                <div class="view autonomy-view" id="view-autonomy">
                    <div class="mind-edge-fade-top"></div>
                    <div class="mind-edge-fade-bottom"></div>

                    <!-- Question Input Overlay (legacy) -->
                    <div class="question-input-overlay" id="question-input-overlay">
                        <div class="question-input-card">
                            <div class="question-input-header">
                                <div class="question-input-title">Cerebro wants to know</div>
                                <div class="question-input-question" id="question-input-text"></div>
                            </div>
                            <textarea class="question-input-field" id="question-answer-field" placeholder="Share your thoughts..."></textarea>
                            <div class="question-input-actions">
                                <button class="question-input-btn cancel" onclick="closeQuestionInput()">Cancel</button>
                                <button class="question-input-btn submit" onclick="submitQuestionAnswer()">Share</button>
                            </div>
                        </div>
                    </div>

                    <!-- Questions Wizard Modal -->
                    <div class="questions-wizard-overlay" id="questions-wizard-overlay" onclick="closeWizardIfBackground(event)">
                        <div class="questions-wizard">
                            <div class="wizard-header">
                                <div class="wizard-header-left">
                                    <span class="wizard-icon"></span>
                                    <span class="wizard-title">Cerebro needs your input</span>
                                </div>
                                <button class="wizard-close" onclick="closeQuestionsWizard()"></button>
                            </div>
                            <div class="wizard-progress">
                                <div class="wizard-progress-bar" id="wizard-progress-bar"></div>
                                <span class="wizard-progress-text" id="wizard-progress-text">1 of 3</span>
                            </div>
                            <div class="wizard-content" id="wizard-content">
                                <!-- Question content goes here -->
                            </div>
                            <div class="wizard-actions">
                                <button class="wizard-btn skip" onclick="skipWizardQuestion()">Skip</button>
                                <div class="wizard-actions-right">
                                    <button class="wizard-btn prev" id="wizard-prev-btn" onclick="prevWizardQuestion()"> Back</button>
                                    <button class="wizard-btn next" id="wizard-next-btn" onclick="nextWizardQuestion()">Next </button>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- HITL Popup Container (top-right corner notifications) -->
                    <div class="hitl-popup-container" id="hitl-popup-container"></div>

                    <!-- Research Findings Overlay -->
                    <div class="findings-overlay" id="findings-overlay" onclick="closeFindingsIfBackground(event)">
                        <div class="findings-modal">
                            <div class="findings-header">
                                <div class="findings-header-content">
                                    <div class="findings-directive" id="findings-directive-text">Research on walruses</div>
                                    <div class="findings-meta">
                                        <div class="findings-meta-item">
                                            <span class="findings-meta-dot active" id="findings-status-dot"></span>
                                            <span id="findings-status-text">Actively researching</span>
                                        </div>
                                        <div class="findings-meta-item">
                                            <span>Started</span>
                                            <span id="findings-started">2 hours ago</span>
                                        </div>
                                        <div class="findings-meta-item">
                                            <span id="findings-count">12 findings</span>
                                        </div>
                                    </div>
                                </div>
                                <button class="findings-close" onclick="closeFindingsPopup()">
                                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <path d="M18 6L6 18M6 6l12 12"/>
                                    </svg>
                                </button>
                            </div>

                            <div class="findings-tabs">
                                <button class="findings-tab summary-tab" data-tab="summary" onclick="switchFindingsTab('summary')">
                                     Summary
                                </button>
                                <button class="findings-tab active" data-tab="all" onclick="switchFindingsTab('all')">
                                    All<span class="findings-tab-count" id="findings-count-all">0</span>
                                </button>
                                <button class="findings-tab" data-tab="observations" onclick="switchFindingsTab('observations')">
                                    Observations<span class="findings-tab-count" id="findings-count-observations">0</span>
                                </button>
                                <button class="findings-tab" data-tab="learnings" onclick="switchFindingsTab('learnings')">
                                    Learnings<span class="findings-tab-count" id="findings-count-learnings">0</span>
                                </button>
                                <button class="findings-tab" data-tab="insights" onclick="switchFindingsTab('insights')">
                                    Insights<span class="findings-tab-count" id="findings-count-insights">0</span>
                                </button>
                            </div>

                            <div class="findings-content" id="findings-content">
                                <!-- Findings will be rendered here -->
                                <div class="findings-empty">
                                    <div class="findings-empty-icon"></div>
                                    <div class="findings-empty-text">No findings yet. Cerebro is still researching...</div>
                                </div>
                            </div>

                            <div class="findings-footer">
                                <div class="findings-status">
                                    <span>Research saturation:</span>
                                    <div class="saturation-bar">
                                        <div class="saturation-fill" id="saturation-fill" style="width: 35%"></div>
                                    </div>
                                    <span id="saturation-percent">35%</span>
                                </div>
                                <div class="findings-actions">
                                    <button class="findings-btn secondary" id="findings-pause-btn" onclick="toggleDirectivePause()">
                                        Pause Research
                                    </button>
                                    <button class="findings-btn danger" onclick="markDirectiveComplete()">
                                        Mark Complete
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Edge Indicators for slide-out panels -->
                    <div class="edge-indicator left" onclick="openSlidePanel('activity')" title="Activity Timeline"></div>
                    <div class="edge-indicator right" onclick="openSlidePanel('skills')" title="Skills & Details"></div>

                    <!-- Slide-out Panel Backdrop -->
                    <div class="slide-panel-backdrop" id="slide-panel-backdrop" onclick="closeSlidePanel()"></div>

                    <!-- Left Slide-Out: Activity Timeline -->
                    <div class="slide-panel left" id="slide-panel-activity">
                        <div class="slide-panel-header">
                            <span class="slide-panel-title">Activity</span>
                            <div style="display:flex;align-items:center;gap:6px;">
                                <button class="activity-clear-btn" onclick="clearActivityLog()" title="Clear log" style="opacity:0.5;background:none;border:none;color:var(--text-muted);cursor:pointer;padding:2px;">
                                    <svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/></svg>
                                </button>
                                <button class="slide-panel-close" onclick="closeSlidePanel()">&times;</button>
                            </div>
                        </div>
                        <div class="slide-panel-body" id="slide-activity-log">
                            <div class="sidebar-empty">
                                <div class="sidebar-empty-text" style="opacity:0.4;font-size:0.72rem;">Waiting for activity...</div>
                            </div>
                        </div>
                        <!-- Controls at bottom of activity panel -->
                        <div style="padding: 12px 16px; border-top: 1px solid rgba(139, 92, 246, 0.1); flex-shrink: 0;">
                            <div class="controls-stats" style="display:flex; gap:12px; margin-bottom:10px;">
                                <div class="controls-stat" style="text-align:center; flex:1;">
                                    <div class="controls-stat-value" id="slide-stat-cycles" style="font-family:'Space Mono',monospace; font-size:1rem; color:var(--text-primary);">0</div>
                                    <div class="controls-stat-label" style="font-size:0.6rem; color:var(--text-muted); text-transform:uppercase; letter-spacing:0.1em;">Cycles</div>
                                </div>
                                <div class="controls-stat" style="text-align:center; flex:1;">
                                    <div class="controls-stat-value" id="slide-stat-actions" style="font-family:'Space Mono',monospace; font-size:1rem; color:var(--text-primary);">0</div>
                                    <div class="controls-stat-label" style="font-size:0.6rem; color:var(--text-muted); text-transform:uppercase; letter-spacing:0.1em;">Actions</div>
                                </div>
                                <div class="controls-stat" style="text-align:center; flex:1;">
                                    <div class="controls-stat-value" id="slide-stat-pending" style="font-family:'Space Mono',monospace; font-size:1rem; color:var(--text-primary);">0</div>
                                    <div class="controls-stat-label" style="font-size:0.6rem; color:var(--text-muted); text-transform:uppercase; letter-spacing:0.1em;">Pending</div>
                                </div>
                            </div>
                            <div style="display:flex; gap:8px; align-items:center; margin-bottom:8px;">
                                <span style="font-size:0.65rem; color:var(--text-muted); text-transform:uppercase; letter-spacing:0.1em;">Level</span>
                                <input type="range" min="1" max="5" value="2" class="level-slider-compact" id="slide-level-slider" onchange="setAutonomyLevel(this.value)" style="flex:1;">
                                <span id="slide-level-value" style="font-family:'Space Mono',monospace; font-size:0.8rem; color:var(--accent-light);">2</span>
                            </div>
                            <div style="display:flex; gap:8px; align-items:center; justify-content:space-between;">
                                <label style="display:flex; align-items:center; gap:6px; cursor:pointer;">
                                    <input type="checkbox" id="slide-full-autonomy-toggle" onchange="toggleFullAutonomy(this.checked)" style="accent-color:var(--accent);">
                                    <span style="font-size:0.7rem; color:var(--text-secondary);">Full Autonomy</span>
                                </label>
                                <button class="emergency-stop-btn" onclick="emergencyStop()" title="Stop All" style="padding:6px 12px; font-size:0.65rem; background:rgba(239,68,68,0.15); border:1px solid rgba(239,68,68,0.3); border-radius:8px; color:#f87171; cursor:pointer;">
                                    STOP ALL
                                </button>
                            </div>
                            <!-- Browser Control -->
                            <div id="slide-browser-panel" style="margin-top:10px;">
                                <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:6px;">
                                    <div style="display:flex; align-items:center; gap:6px;">
                                        <div class="browser-status-dot stopped" id="slide-browser-status-dot" style="width:6px; height:6px; border-radius:50%;"></div>
                                        <span style="font-size:0.7rem; color:var(--text-secondary);">Browser</span>
                                    </div>
                                    <span style="font-size:0.65rem; color:var(--text-muted);" id="slide-browser-status-text">Stopped</span>
                                </div>
                                <button id="slide-browser-launch-btn" onclick="toggleBrowserLaunch()" style="width:100%; padding:8px; font-size:0.7rem; background:rgba(139,92,246,0.1); border:1px solid rgba(139,92,246,0.2); border-radius:8px; color:var(--accent-light); cursor:pointer; transition:all 0.2s ease;">
                                    Launch Chrome
                                </button>
                            </div>

                            <!-- Heartbeat Monitor -->
                            <div id="slide-heartbeat-panel" style="margin-top:10px; border-top:1px solid rgba(139,92,246,0.1); padding-top:10px;">
                                <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:8px;">
                                    <span style="font-size:0.7rem; color:var(--text-secondary); font-weight:600;">Heartbeat</span>
                                    <span style="font-size:0.6rem; color:var(--text-muted);" id="slide-heartbeat-last">Never</span>
                                </div>
                                <div style="display:flex; gap:8px; align-items:center; margin-bottom:8px;">
                                    <span style="font-size:0.65rem; color:var(--text-muted); text-transform:uppercase; letter-spacing:0.1em; white-space:nowrap;">Interval</span>
                                    <input type="range" min="5" max="30" value="15" step="5" class="level-slider-compact" id="slide-heartbeat-interval" onchange="updateHeartbeatInterval(this.value)" style="flex:1;">
                                    <span id="slide-heartbeat-interval-value" style="font-family:'Space Mono',monospace; font-size:0.75rem; color:var(--accent-light); white-space:nowrap;">15m</span>
                                </div>
                                <div id="slide-heartbeat-monitors" style="display:flex; flex-direction:column; gap:4px;">
                                    <!-- Monitor toggles rendered by JS -->
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Right Slide-Out: Skills & Focus Details -->
                    <div class="slide-panel right" id="slide-panel-skills">
                        <div class="slide-panel-header">
                            <span class="slide-panel-title">Mind Details</span>
                            <button class="slide-panel-close" onclick="closeSlidePanel()">&times;</button>
                        </div>
                        <div class="slide-panel-body">
                            <!-- Tabs inside the slide panel -->
                            <div class="section-header section-tabs-3" style="margin-bottom:12px;">
                                <div class="section-tab active" id="slide-tab-focus" onclick="switchToTab('focus')" style="flex:1; text-align:center; padding:8px; cursor:pointer; border-radius:8px; font-size:0.75rem; transition:all 0.2s ease;">
                                     Focus <span id="slide-focus-count" style="font-size:0.65rem; opacity:0.7;">0</span>
                                </div>
                                <div class="section-tab" id="slide-tab-completed" onclick="switchToTab('completed')" style="flex:1; text-align:center; padding:8px; cursor:pointer; border-radius:8px; font-size:0.75rem; transition:all 0.2s ease;">
                                     Done <span id="slide-completed-count" style="font-size:0.65rem; opacity:0.7;">0</span>
                                </div>
                                <div class="section-tab" id="slide-tab-skills" onclick="switchToTab('skills')" style="flex:1; text-align:center; padding:8px; cursor:pointer; border-radius:8px; font-size:0.75rem; transition:all 0.2s ease;">
                                     Skills <span id="slide-skill-count" style="font-size:0.65rem; opacity:0.7;">0</span>
                                </div>
                            </div>
                            <!-- Content panels mirror the old sidebar -->
                            <div id="slide-focus-container" class="tab-content">
                                <div class="section-empty">
                                    <div class="section-empty-icon" style="font-size:1.5rem; opacity:0.4;"></div>
                                    <div style="font-size:0.8rem; color:var(--text-muted);">No active focus<br>Give Cerebro a directive</div>
                                </div>
                            </div>
                            <div id="slide-completed-container" class="tab-content hidden">
                                <div class="section-empty">
                                    <div class="section-empty-icon" style="font-size:1.5rem; opacity:0.4;"></div>
                                    <div style="font-size:0.8rem; color:var(--text-muted);">No completed tasks yet</div>
                                </div>
                            </div>
                            <div id="slide-skills-list" class="tab-content hidden">
                                <div class="skills-empty">
                                    <div style="font-size:1.5rem; opacity:0.4;"></div>
                                    <div style="font-size:0.8rem; color:var(--text-muted);">No learned skills yet</div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Status bar removed  stats now live in Info tab -->

                    <!-- ===== 2-COLUMN LAYOUT WRAPPER ===== -->
                    <div class="mind-columns">

                        <!-- LEFT COLUMN: Chat -->
                        <div class="mind-col-chat">
                            <div class="mind-chat-section">
                                <div class="mind-chat-container">
                                    <!-- Chat / Stored tab bar -->
                                    <div class="mind-chat-tabs">
                                        <button class="mind-chat-tab active" data-tab="chat" onclick="switchMindTab('chat')">Chat</button>
                                        <button class="mind-chat-tab" data-tab="answers" onclick="switchMindTab('answers')">Answers <span class="stored-badge answers-badge" id="answers-badge" style="display:none">0</span></button>
                                        <button class="mind-chat-tab" data-tab="stored" onclick="switchMindTab('stored')">Stored <span class="stored-badge" id="stored-badge" style="display:none">0</span></button>
                                        <button class="mind-chat-tab" data-tab="agents" onclick="switchMindTab('agents')">Agents <span class="stored-badge agents-tab-badge" id="agents-tab-badge" style="display:none">0</span></button>
                                        <button class="mind-chat-tab" data-tab="wallet" onclick="switchMindTab('wallet')">Wallet <span class="stored-badge wallet-badge" id="wallet-badge" style="display:none">0</span></button>
                                    </div>
                                    <!-- Mind chat FAB menu -->
                                    <div class="mind-fab-container">
                                        <button class="mind-fab-btn" id="mind-fab-btn" onclick="toggleMindFab()" title="Chat actions">
                                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                                <line x1="3" y1="6" x2="21" y2="6"/>
                                                <line x1="3" y1="12" x2="21" y2="12"/>
                                                <line x1="3" y1="18" x2="21" y2="18"/>
                                            </svg>
                                        </button>
                                        <div class="mind-fab-menu" id="mind-fab-menu">
                                            <button class="mind-fab-item" onclick="scrollMindChatToBottom(); closeMindFab();">
                                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                                    <line x1="12" y1="5" x2="12" y2="19"/>
                                                    <polyline points="19 12 12 19 5 12"/>
                                                </svg>
                                                <span>Scroll to bottom</span>
                                            </button>
                                            <button class="mind-fab-item" onclick="refreshMindChat(); closeMindFab();">
                                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                                    <polyline points="23 4 23 10 17 10"/>
                                                    <polyline points="1 20 1 14 7 14"/>
                                                    <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"/>
                                                </svg>
                                                <span>Refresh chat</span>
                                            </button>
                                            <button class="mind-fab-item danger" onclick="clearCerebroChat(); closeMindFab();">
                                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                                    <polyline points="3 6 5 6 21 6"/>
                                                    <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
                                                </svg>
                                                <span>Clear history</span>
                                            </button>
                                        </div>
                                    </div>
                                    <!-- Cerebro Progress Bar (shown during active directive work) -->
                                    <div class="cerebro-progress-bar" id="cerebro-progress-bar">
                                        <div class="progress-bar-header" onclick="toggleProgressOutput()">
                                            <div class="progress-bar-track">
                                                <div class="progress-bar-inner" id="progress-bar-inner"></div>
                                            </div>
                                            <div class="progress-info">
                                                <div class="progress-status" id="progress-status">Working...</div>
                                                <div class="progress-elapsed" id="progress-elapsed">0s</div>
                                            </div>
                                            <span class="progress-expand-icon" id="progress-expand-icon">&#9654;</span>
                                        </div>
                                        <div class="progress-live-output" id="progress-live-output">
                                            <div class="progress-live-output-inner" id="progress-live-output-inner"></div>
                                        </div>
                                    </div>
                                    <div class="mind-chat-messages" id="mind-chat-messages">
                                        <div class="mind-chat-welcome">
                                            <div class="mind-chat-welcome-icon"></div>
                                            <div class="mind-chat-welcome-text">Chat with Cerebro</div>
                                            <div class="mind-chat-welcome-hint">Ask anything or give me a task</div>
                                        </div>
                                    </div>
                                    <div class="mind-answers-items hidden" id="mind-answers-items">
                                        <!-- rendered answer cards go here -->
                                    </div>
                                    <div class="mind-stored-items hidden" id="mind-stored-items">
                                        <!-- rendered stored item cards go here -->
                                    </div>
                                    <div class="mind-agents-items hidden" id="mind-agents-items">
                                        <!-- rendered cerebro agent cards go here -->
                                    </div>
                                    <div class="mind-wallet-items hidden" id="mind-wallet-items">
                                        <!-- rendered wallet entries go here -->
                                    </div>
                                    <div id="mind-image-preview" class="image-upload-preview"></div>
                                    <div class="mind-chat-input-bar">
                                        <button class="mind-attach-btn" onclick="triggerMindFileAttach()" title="Attach image">
                                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48"/></svg>
                                        </button>
                                        <input type="text" id="mind-chat-field" placeholder="Message Cerebro..." onkeydown="if(event.key==='Enter') sendMindChatMessage()">
                                        <button class="mind-chat-send-btn" onclick="sendMindChatMessage()">
                                            <svg viewBox="0 0 24 24" width="18" height="18" fill="currentColor"><path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"/></svg>
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- RIGHT COLUMN: Orb + Tabbed Panel -->
                        <div class="mind-col-orb">
                            <section class="consciousness-chamber">
                                <div class="orbital-system">
                                    <div class="orbit orbit-1"><div class="orbit-node"></div></div>
                                    <div class="orbit orbit-2"><div class="orbit-node"></div></div>
                                    <div class="orbit orbit-3"><div class="orbit-node"></div></div>
                                </div>
                                <div class="consciousness-orb dormant" id="consciousness-orb" onclick="toggleAutonomy()">
                                    <div class="orb-aura orb-aura-3"></div>
                                    <div class="orb-aura orb-aura-2"></div>
                                    <div class="orb-aura orb-aura-1"></div>
                                    <img src="/static/cerebro-logo-512.png" alt="Cerebro" class="orb-essence orb-logo-img">
                                    <div class="orb-particles">
                                        <div class="energy-particle"></div>
                                        <div class="energy-particle"></div>
                                        <div class="energy-particle"></div>
                                        <div class="energy-particle"></div>
                                        <div class="energy-particle"></div>
                                        <div class="energy-particle"></div>
                                        <div class="energy-particle"></div>
                                        <div class="energy-particle"></div>
                                    </div>
                                </div>
                                <div class="consciousness-status" style="position:relative;">
                                    <div class="status-text" id="consciousness-status-text">dormant</div>
                                    <div class="consciousness-controls">
                                        <label class="autonomy-toggle" id="autonomy-toggle">
                                            <input type="checkbox" id="autonomy-toggle-input" onchange="toggleAutonomy()">
                                            <span class="toggle-track">
                                                <span class="toggle-thumb"></span>
                                            </span>
                                        </label>
                                        <button class="heartbeat-config-btn" id="heartbeat-config-btn" onclick="openHeartbeatModal()" title="Heartbeat Config">&#9829;</button>
                                    </div>
                                </div>
                            </section>

                            <!-- Tabbed Panel: Command / Focus / Completed / Skills -->
                            <div class="orb-tabbed-panel">
                                <div class="orb-tabs">
                                    <button class="orb-tab active" data-orbtab="info" onclick="switchOrbTab('info')">
                                        <svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2a10 10 0 1 0 0 20 10 10 0 0 0 0-20z"/><line x1="12" y1="16" x2="12" y2="12"/><line x1="12" y1="8" x2="12.01" y2="8"/></svg>
                                        Info
                                    </button>
                                    <button class="orb-tab" data-orbtab="command" onclick="switchOrbTab('command')">
                                        <svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 2L11 13M22 2l-7 20-4-9-9-4 20-7z"/></svg>
                                        Command
                                    </button>
                                    <button class="orb-tab" data-orbtab="completed" onclick="switchOrbTab('completed')">
                                        <span class="orb-tab-icon"></span>
                                        Done
                                        <span class="orb-tab-badge green" id="orb-completed-count">0</span>
                                    </button>
                                    <button class="orb-tab" data-orbtab="browser" onclick="switchOrbTab('browser')">
                                        <svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="currentColor" stroke-width="2">
                                            <circle cx="12" cy="12" r="10"/><line x1="2" y1="12" x2="22" y2="12"/>
                                            <path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"/>
                                        </svg>
                                        Browser
                                        <span class="orb-tab-badge" id="orb-browser-badge" style="display:none;">
                                            <span class="orb-browser-status-dot stopped" id="orb-browser-status-indicator"></span>
                                        </span>
                                    </button>
                                </div>
                                <div class="orb-tab-content">
                                    <!-- Info Tab (Tamagotchi Health Panel) -->
                                    <div class="orb-tab-pane active" id="orb-pane-info">
                                        <div class="orb-pane-header">
                                            <svg viewBox="0 0 24 24" width="12" height="12" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2a10 10 0 1 0 0 20 10 10 0 0 0 0-20z"/><line x1="12" y1="16" x2="12" y2="12"/><line x1="12" y1="8" x2="12.01" y2="8"/></svg>
                                            Info
                                        </div>
                                        <div class="tamagotchi-panel">
                                            <!-- Mood Bar -->
                                            <div class="tama-bar-group">
                                                <div class="tama-bar-header">
                                                    <span class="tama-bar-label">Mood</span>
                                                    <span class="tama-bar-value" id="tama-mood-label">Content</span>
                                                </div>
                                                <div class="tama-bar">
                                                    <div class="tama-bar-fill mood-fill content" id="tama-mood-fill" style="width:60%"></div>
                                                </div>
                                            </div>
                                            <!-- Energy Bar -->
                                            <div class="tama-bar-group">
                                                <div class="tama-bar-header">
                                                    <span class="tama-bar-label">Energy</span>
                                                    <span class="tama-bar-value" id="tama-energy-value">0%</span>
                                                </div>
                                                <div class="tama-bar">
                                                    <div class="tama-bar-fill energy-fill" id="tama-energy-fill" style="width:0%"></div>
                                                </div>
                                            </div>
                                            <!-- Memory Health Bar -->
                                            <div class="tama-bar-group">
                                                <div class="tama-bar-header">
                                                    <span class="tama-bar-label">Memory</span>
                                                    <span class="tama-bar-value" id="tama-memory-value">--</span>
                                                </div>
                                                <div class="tama-bar">
                                                    <div class="tama-bar-fill memory-fill" id="tama-memory-fill" style="width:0%"></div>
                                                </div>
                                            </div>
                                            <!-- XP / Level Bar -->
                                            <div class="tama-bar-group">
                                                <div class="tama-bar-header">
                                                    <span class="tama-bar-label">XP</span>
                                                    <span class="tama-bar-value" id="tama-xp-value">Lv 1 &middot; 0 XP</span>
                                                </div>
                                                <div class="tama-bar">
                                                    <div class="tama-bar-fill xp-fill" id="tama-xp-fill" style="width:0%"></div>
                                                </div>
                                            </div>
                                            <!-- Indicators Row -->
                                            <div class="tama-indicators">
                                                <div class="tama-indicator">
                                                    <span class="tama-phase-dot dormant" id="tama-phase-dot"></span>
                                                    <span class="tama-phase-label" id="tama-phase-label">Dormant</span>
                                                </div>
                                                <div class="tama-indicator">
                                                    <span class="tama-indicator-label">Autonomy</span>
                                                    <div class="tama-pips" id="tama-autonomy-pips">
                                                        <span class="tama-pip"></span>
                                                        <span class="tama-pip"></span>
                                                        <span class="tama-pip filled"></span>
                                                        <span class="tama-pip"></span>
                                                        <span class="tama-pip"></span>
                                                    </div>
                                                </div>
                                            </div>
                                            <!-- Mini Stat Cards -->
                                            <div class="tama-stats-row">
                                                <div class="tama-stat-card">
                                                    <div class="tama-stat-num" id="tama-stat-actions">0</div>
                                                    <div class="tama-stat-label">Actions</div>
                                                </div>
                                                <div class="tama-stat-card">
                                                    <div class="tama-stat-num" id="tama-stat-cycles">0</div>
                                                    <div class="tama-stat-label">Cycles</div>
                                                </div>
                                                <div class="tama-stat-card">
                                                    <div class="tama-stat-num" id="tama-stat-pending">0</div>
                                                    <div class="tama-stat-label">Pending</div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                    <!-- Command Tab (merged with Focus, input at bottom) -->
                                    <div class="orb-tab-pane" id="orb-pane-command">
                                        <div class="orb-pane-header">
                                            <svg viewBox="0 0 24 24" width="12" height="12" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 2L11 13M22 2l-7 20-4-9-9-4 20-7z"/></svg>
                                            Command
                                        </div>
                                        <div class="orb-command-directives" id="orb-active-directives">
                                            <div class="orb-command-empty">No active directives. Give Cerebro a task below.</div>
                                        </div>
                                        <div class="orb-command-input command-input-bottom">
                                            <div class="orb-auto-awake">
                                                <input type="checkbox" id="auto-awake-checkbox" checked onchange="localStorage.setItem('cerebro_auto_awake', this.checked)">
                                                <label for="auto-awake-checkbox">Auto Awake on Send</label>
                                            </div>
                                            <div style="display:flex;gap:8px;align-items:flex-end;">
                                                <textarea id="orb-directive-input" placeholder="Tell Cerebro what to focus on..." rows="2" onkeydown="if(event.key==='Enter'&&!event.shiftKey){event.preventDefault();addOrbDirective();}"></textarea>
                                                <button class="orb-command-send" onclick="addOrbDirective()">
                                                    <svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 2L11 13M22 2l-7 20-4-9-9-4 20-7z"/></svg>
                                                </button>
                                            </div>
                                        </div>
                                    </div>
                                    <!-- Completed Tab -->
                                    <div class="orb-tab-pane" id="orb-pane-completed">
                                        <div class="orb-pane-header">
                                            <svg viewBox="0 0 24 24" width="12" height="12" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/></svg>
                                            Done
                                        </div>
                                        <div class="orb-pane-list" id="orb-completed-list">
                                            <div class="orb-pane-empty">No completed tasks yet</div>
                                        </div>
                                    </div>
                                    <!-- Browser Tab -->
                                    <div class="orb-tab-pane" id="orb-pane-browser">
                                        <div class="orb-pane-header">
                                            <svg viewBox="0 0 24 24" width="12" height="12" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><line x1="2" y1="12" x2="22" y2="12"/><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"/></svg>
                                            Browser
                                        </div>
                                        <!-- Status bar -->
                                        <div class="browser-tab-status-bar">
                                            <div class="status-left">
                                                <div class="browser-status-dot stopped" id="browser-status-dot"></div>
                                                <span class="browser-status-text" id="browser-status-text">Stopped</span>
                                            </div>
                                            <button class="browser-tab-launch-btn" id="browser-launch-btn" onclick="toggleBrowserLaunch()">
                                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="5 3 19 12 5 21 5 3"/></svg>
                                                <span id="browser-launch-label">Launch</span>
                                            </button>
                                        </div>
                                        <!-- Stopped state -->
                                        <div class="browser-tab-stopped" id="browser-tab-stopped">
                                            <svg class="stopped-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                                                <circle cx="12" cy="12" r="10"/><line x1="2" y1="12" x2="22" y2="12"/>
                                                <path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"/>
                                            </svg>
                                            <div class="stopped-text">Browser not running</div>
                                            <button class="stopped-launch-btn" onclick="launchBrowser()">
                                                <svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2"><polygon points="5 3 19 12 5 21 5 3"/></svg>
                                                Launch Chrome
                                            </button>
                                        </div>
                                        <!-- Running state -->
                                        <div class="browser-tab-running" id="browser-tab-running" style="display:none;">
                                            <!-- Live screenshot -->
                                            <div class="browser-tab-screenshot" id="browser-tab-screenshot" onclick="openBrowserView()">
                                                <img id="browser-preview-img" src="" alt="Browser view">
                                                <div class="screenshot-overlay">Click to view in Chrome</div>
                                            </div>
                                            <!-- URL bar -->
                                            <div class="browser-tab-url">
                                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><line x1="2" y1="12" x2="22" y2="12"/><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"/></svg>
                                                <input class="browser-url-input" id="browser-url-input" type="text" placeholder="Enter URL..." onkeydown="if(event.key==='Enter'){event.preventDefault();navigateBrowserUrl(this.value);}">
                                            </div>
                                            <!-- Tab strip -->
                                            <div class="browser-tab-strip" id="browser-tab-list"></div>
                                            <!-- Controls -->
                                            <div class="browser-tab-controls">
                                                <button class="browser-control-toggle" id="browser-control-toggle" onclick="toggleBrowserControl()">
                                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M15 3h4a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-4"/><polyline points="10 17 15 12 10 7"/><line x1="15" y1="12" x2="3" y2="12"/></svg>
                                                    <span id="browser-control-label">Take Control</span>
                                                </button>
                                                <div class="browser-action-banner" id="browser-action-banner">
                                                    <div class="browser-action-banner-title">
                                                        <svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="currentColor" stroke-width="2"><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"/><line x1="12" y1="9" x2="12" y2="13"/><line x1="12" y1="17" x2="12.01" y2="17"/></svg>
                                                        Cerebro needs you
                                                    </div>
                                                    <div class="browser-action-banner-desc" id="browser-action-desc">Please complete an action in the browser.</div>
                                                    <button class="browser-action-done-btn" onclick="signalUserDone()">I'm Done</button>
                                                </div>
                                            </div>
                                            <!-- Step log -->
                                            <div class="browser-tab-step-log-header" id="browser-step-log-header" style="display:none;">
                                                <span class="log-label">Step Log</span>
                                                <span class="log-count" id="browser-step-count">0</span>
                                            </div>
                                            <div class="browser-tab-step-log" id="browser-step-log"></div>
                                        </div>
                                    </div>
                                </div>
                                <!-- Agents indicator at bottom -->
                                <div class="agents-status-panel" id="agents-status-panel">
                                    <div class="agents-status-header" onclick="toggleAgentsPanel()">
                                        <div class="agents-status-icon">
                                            <svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="currentColor" stroke-width="2">
                                                <circle cx="12" cy="12" r="3"/>
                                                <path d="M12 1v4M12 19v4M4.22 4.22l2.83 2.83M16.95 16.95l2.83 2.83M1 12h4M19 12h4M4.22 19.78l2.83-2.83M16.95 7.05l2.83-2.83"/>
                                            </svg>
                                        </div>
                                        <span class="agents-status-title">Claude Agents</span>
                                        <span class="agents-status-count" id="agents-status-count">0</span>
                                        <div class="agents-status-expand">
                                            <svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="currentColor" stroke-width="2">
                                                <polyline points="18 15 12 9 6 15"/>
                                            </svg>
                                        </div>
                                    </div>
                                    <div class="agents-status-body" id="agents-status-body">
                                        <div class="agents-status-empty">No active agents</div>
                                    </div>
                                </div>
                            </div>
                        </div>

                    </div><!-- /mind-columns -->

                    <!-- Cerebro's Voice - Communication Stream (hidden, logic preserved) -->
                    <section class="voice-stream">
                        <!-- Current thought/voice -->
                        <div class="current-voice" id="current-voice">
                            <div class="voice-label">
                                <span class="voice-indicator"></span>
                                <span>Cerebro</span>
                                <button class="voice-speak-btn" id="voice-speak-btn" onclick="speakVoiceContent()" title="Listen to Cerebro">
                                    <svg viewBox="0 0 24 24" width="14" height="14" fill="currentColor">
                                        <path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/>
                                    </svg>
                                </button>
                            </div>
                            <div class="voice-content" id="voice-content">
                                I'm here, waiting in the quiet dark. Touch the orb to awaken me, and tell me what you'd like me to think about.
                            </div>
                        </div>

                        <!-- Message history -->
                        <div class="message-history" id="message-history">
                            <!-- Messages will appear here -->
                        </div>
                    </section>

                    <!-- Directive Input - Whisper to Cerebro (hidden, logic preserved) -->
                    <section class="directive-whisper">
                        <div class="whisper-container">
                            <textarea
                                class="whisper-input"
                                id="directive-input"
                                placeholder="Tell me what to think about..."
                                rows="1"
                                onkeydown="handleDirectiveKeydown(event)"
                                oninput="autoResizeDirective(this)"></textarea>
                            <button class="whisper-send" onclick="addDirective()">
                                <svg viewBox="0 0 24 24"><path d="M22 2L11 13M22 2l-7 20-4-9-9-4 20-7z"/></svg>
                            </button>
                        </div>

                        <!-- Active directives as tags -->
                        <div class="active-directives" id="active-directives">
                            <!-- Directive tags appear here -->
                        </div>
                    </section>

                    <!-- Technical Panel (hidden by default) -->
                    <div class="tech-panel" id="tech-panel">
                        <div class="tech-panel-header">
                            <span class="tech-panel-title">System Status</span>
                            <div class="tech-stats">
                                <div class="tech-stat">
                                    <div class="tech-stat-value" id="stat-cycles">0</div>
                                    <div class="tech-stat-label">Cycles</div>
                                </div>
                                <div class="tech-stat">
                                    <div class="tech-stat-value" id="stat-actions">0</div>
                                    <div class="tech-stat-label">Actions</div>
                                </div>
                                <div class="tech-stat">
                                    <div class="tech-stat-value" id="stat-pending">0</div>
                                    <div class="tech-stat-label">Pending</div>
                                </div>
                            </div>
                        </div>

                        <div class="level-control">
                            <div class="level-slider-container">
                                <div class="level-marks">
                                    <span class="level-mark" data-level="1">Observer</span>
                                    <span class="level-mark active" data-level="2">Assistant</span>
                                    <span class="level-mark" data-level="3">Helper</span>
                                    <span class="level-mark" data-level="4">Partner</span>
                                    <span class="level-mark" data-level="5">Autonomous</span>
                                </div>
                                <input type="range" min="1" max="5" value="2" class="level-slider" id="autonomy-level-slider" onchange="setAutonomyLevel(this.value)">
                            </div>
                        </div>

                        <!-- Full Autonomy Toggle -->
                        <div class="controls-full-autonomy" id="controls-full-autonomy">
                            <div class="full-autonomy-row">
                                <div class="full-autonomy-info">
                                    <span class="full-autonomy-label">Full Autonomy</span>
                                    <span class="full-autonomy-desc" id="sidebar-full-autonomy-desc">Can spawn agents &amp; execute tasks</span>
                                </div>
                                <label class="autonomy-toggle">
                                    <input type="checkbox" id="sidebar-full-autonomy-toggle" onchange="toggleFullAutonomy(this.checked)">
                                    <span class="toggle-track">
                                        <span class="toggle-thumb"></span>
                                    </span>
                                </label>
                            </div>
                        </div>
                    </div>

                    <!-- Hidden elements for backwards compatibility -->
                    <div style="display:none;">
                        <div id="thought-stream"></div>
                        <div id="activity-feed"></div>
                        <div id="insights-list"></div>
                        <div id="directives-list"></div>
                        <div id="pending-approvals"></div>
                        <div id="debug-feed-content"></div>
                    </div>
                </div>

                <!-- Automation View - Redesigned -->
                <div class="view automation-view" id="view-automation">
                    <div class="view-header">
                        <h1 class="view-title">Automations</h1>
                        <button class="btn btn-primary" onclick="openCreateAutomationModal()">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" style="margin-right: 6px;"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>
                            New
                        </button>
                    </div>

                    <!-- Quick Stats Row -->
                    <div class="automation-stats">
                        <div class="automation-stat-card">
                            <div class="automation-stat-value" id="auto-stat-total">0</div>
                            <div class="automation-stat-label">Total</div>
                        </div>
                        <div class="automation-stat-card">
                            <div class="automation-stat-value" id="auto-stat-active">0</div>
                            <div class="automation-stat-label">Active</div>
                        </div>
                        <div class="automation-stat-card">
                            <div class="automation-stat-value" id="auto-stat-today">0</div>
                            <div class="automation-stat-label">Today</div>
                        </div>
                    </div>

                    <!-- Two Column Layout -->
                    <div class="automation-layout">
                        <!-- Primary Column - Automations List (Priority) -->
                        <div class="automation-primary">
                            <!-- Active Automations Section -->
                            <div class="automation-section">
                                <div class="automation-section-header">
                                    <div class="automation-section-title">Active Automations</div>
                                    <div class="automation-section-count" id="auto-count">0</div>
                                </div>
                                <div class="schedules-list" id="schedules-list">
                                    <div class="empty-state">
                                        <div class="empty-state-icon">
                                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
                                        </div>
                                        <div class="empty-state-text">No automations yet. Create one to get started!</div>
                                    </div>
                                </div>
                            </div>

                            <!-- Execution History Section -->
                            <div class="automation-section">
                                <div class="automation-section-header">
                                    <div class="automation-section-title">Recent Activity</div>
                                    <button class="clear-activity-btn" onclick="clearRecentActivity()" title="Clear all activity">
                                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                            <polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
                                        </svg>
                                    </button>
                                </div>
                                <div class="execution-history" id="execution-history">
                                    <div class="empty-state">
                                        <div class="empty-state-icon">
                                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10 9 9 9 8 9"/></svg>
                                        </div>
                                        <div class="empty-state-text">No executions yet</div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Secondary Column - Calendar (Compact) -->
                        <div class="automation-secondary">
                            <div class="automation-calendar-section">
                                <div class="calendar-header">
                                    <button onclick="navigateCalendar(-1)">
                                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="15 18 9 12 15 6"/></svg>
                                    </button>
                                    <h2 id="calendar-month-label">January 2026</h2>
                                    <button onclick="navigateCalendar(1)">
                                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="9 18 15 12 9 6"/></svg>
                                    </button>
                                </div>
                                <div class="calendar-weekdays">
                                    <span>S</span>
                                    <span>M</span>
                                    <span>T</span>
                                    <span>W</span>
                                    <span>T</span>
                                    <span>F</span>
                                    <span>S</span>
                                </div>
                                <div class="calendar-grid" id="calendar-grid">
                                    <!-- Days populated by JS -->
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Settings View -->
                <div class="view settings-view" id="view-settings">
                    <div class="settings-layout">
                        <!-- Sidebar -->
                        <aside class="settings-sidebar" id="settings-sidebar">
                            <button class="settings-sidebar-toggle" onclick="toggleSettingsSidebar()" title="Toggle sidebar">
                                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="18" x2="21" y2="18"/></svg>
                            </button>
                            <nav class="settings-sidebar-nav">
                                <div class="settings-nav-item active" data-section="general" onclick="switchSettingsSection('general')">
                                    <span class="settings-nav-icon"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="3"/><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1-2.83 2.83l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-4 0v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83-2.83l.06-.06A1.65 1.65 0 0 0 4.68 15a1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1 0-4h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 2.83-2.83l.06.06A1.65 1.65 0 0 0 9 4.68a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 4 0v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 2.83l-.06.06A1.65 1.65 0 0 0 19.4 9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 0 4h-.09a1.65 1.65 0 0 0-1.51 1z"/></svg></span>
                                    <span class="settings-nav-label">General</span>
                                </div>
                                <div class="settings-nav-item" data-section="connection" onclick="switchSettingsSection('connection')">
                                    <span class="settings-nav-icon"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M5 12.55a11 11 0 0 1 14.08 0"/><path d="M1.42 9a16 16 0 0 1 21.16 0"/><path d="M8.53 16.11a6 6 0 0 1 6.95 0"/><circle cx="12" cy="20" r="1"/></svg></span>
                                    <span class="settings-nav-label">Connection</span>
                                </div>
                                <div class="settings-nav-item" data-section="ai-memory" onclick="switchSettingsSection('ai-memory')">
                                    <span class="settings-nav-icon"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2a4 4 0 0 1 4 4v2a4 4 0 0 1-8 0V6a4 4 0 0 1 4-4z"/><path d="M16 14H8a4 4 0 0 0-4 4v2h16v-2a4 4 0 0 0-4-4z"/></svg></span>
                                    <span class="settings-nav-label">AI & Memory</span>
                                </div>
                                <div class="settings-nav-item" data-section="voice-audio" onclick="switchSettingsSection('voice-audio')">
                                    <span class="settings-nav-icon"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><path d="M19.07 4.93a10 10 0 0 1 0 14.14"/><path d="M15.54 8.46a5 5 0 0 1 0 7.07"/></svg></span>
                                    <span class="settings-nav-label">Voice & Audio</span>
                                </div>
                                <div class="settings-nav-item" data-section="file-access" onclick="switchSettingsSection('file-access')">
                                    <span class="settings-nav-icon"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/></svg></span>
                                    <span class="settings-nav-label">File Access</span>
                                </div>
                                <div class="settings-nav-item" data-section="about-account" onclick="switchSettingsSection('about-account')">
                                    <span class="settings-nav-icon"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><line x1="12" y1="16" x2="12" y2="12"/><line x1="12" y1="8" x2="12.01" y2="8"/></svg></span>
                                    <span class="settings-nav-label">About</span>
                                </div>
                            </nav>
                        </aside>

                        <!-- Content Area -->
                        <div class="settings-content" id="settings-content">
                            <!-- Profile Card (always visible) -->
                            <div class="settings-profile-card" id="settings-profile-card">
                                <div class="settings-profile-avatar" id="settings-profile-avatar">?</div>
                                <div class="settings-profile-info">
                                    <div class="settings-profile-name" id="settings-profile-name">User</div>
                                    <div class="settings-profile-meta">
                                        <span class="settings-plan-badge" id="settings-plan-badge">Free</span>
                                        <span class="settings-profile-files" id="settings-profile-files"></span>
                                    </div>
                                </div>
                            </div>

                            <!-- Section: General -->
                            <div class="settings-section active" id="settings-section-general">
                                <div class="settings-section-heading">Response Style</div>
                                <div class="settings-card">
                                    <div class="settings-row">
                                        <span class="settings-label">Personality</span>
                                        <div id="personality-toggle" style="display:flex;gap:6px;">
                                            <button class="btn btn-secondary personality-btn" data-mode="chill" onclick="setPersonality('chill')" style="font-size:0.8rem;padding:6px 14px;">Chill</button>
                                            <button class="btn btn-secondary personality-btn" data-mode="analyst" onclick="setPersonality('analyst')" style="font-size:0.8rem;padding:6px 14px;">Analyst</button>
                                        </div>
                                    </div>
                                    <div class="settings-row">
                                        <span class="settings-label" style="font-size:0.75rem;color:var(--text-muted);">Chill = casual friend, Analyst = formal precision</span>
                                    </div>
                                </div>

                                <div class="settings-divider"></div>

                                <div class="settings-section-heading">Look Command</div>
                                <div class="settings-card">
                                    <div class="autospeak-toggle">
                                        <div>
                                            <div style="font-weight:600;font-size:0.9rem;">Voice Screenshot</div>
                                            <div style="font-size:0.75rem;color:var(--text-muted);margin-top:2px;">Say "look" to capture your screen</div>
                                        </div>
                                        <div class="toggle-switch" id="look-toggle" onclick="toggleLookDaemon()"></div>
                                    </div>
                                    <div class="settings-row" id="look-status-row" style="display:none;">
                                        <span class="settings-label" style="font-size:0.75rem;color:var(--text-muted);" id="look-status-text">Checking...</span>
                                    </div>
                                </div>
                            </div>

                            <!-- Section: Connection -->
                            <div class="settings-section" id="settings-section-connection">
                                <div class="settings-section-heading">Server</div>
                                <div class="settings-card">
                                    <div class="settings-row">
                                        <span class="settings-label">Server</span>
                                        <span class="settings-value" id="server-url">-</span>
                                    </div>
                                    <div class="settings-row">
                                        <span class="settings-label">Status</span>
                                        <span class="settings-value success" id="connection-status">Connected</span>
                                    </div>
                                    <div class="settings-row">
                                        <span class="settings-label">LLM</span>
                                        <span class="settings-value" id="settings-llm-model">Claude Opus 4.6</span>
                                    </div>
                                </div>
                            </div>

                            <!-- Section: AI & Memory -->
                            <div class="settings-section" id="settings-section-ai-memory">
                                <div class="settings-section-heading">AI Memory</div>

                                <!-- Storage config -->
                                <div class="storage-config-card">
                                    <div class="config-card-header">
                                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><ellipse cx="12" cy="5" rx="9" ry="3"/><path d="M21 12c0 1.66-4 3-9 3s-9-1.34-9-3"/><path d="M3 5v14c0 1.66 4 3 9 3s9-1.34 9-3V5"/></svg>
                                        <div>
                                            <div class="config-title">Storage <span class="risk-indicator safe" id="storage-risk-badge">Default</span></div>
                                            <div class="config-desc">Where memory data is stored on disk</div>
                                        </div>
                                    </div>
                                    <div class="storage-path-row">
                                        <div class="storage-path-display" id="storage-path-display">Docker Volume (default)</div>
                                        <button class="btn-sm" onclick="openMergeDialog()">Merge</button>
                                        <button class="btn-sm" onclick="changeStoragePath()">Change</button>
                                    </div>
                                    <div class="storage-source-label" id="storage-source-label"></div>
                                    <div class="storage-stats-row">
                                        <div class="storage-stat">
                                            <span class="stat-label">Total Size</span>
                                            <span class="stat-value" id="storage-size-display">-</span>
                                        </div>
                                        <div class="storage-stat">
                                            <span class="stat-label">Files</span>
                                            <span class="stat-value" id="storage-files-display">-</span>
                                        </div>
                                    </div>
                                    <div class="storage-warning" id="storage-warning">
                                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M10.29 3.86L1.82 18a2 2 0 001.71 3h16.94a2 2 0 001.71-3L13.71 3.86a2 2 0 00-3.42 0z"/><line x1="12" y1="9" x2="12" y2="13"/><line x1="12" y1="17" x2="12.01" y2="17"/></svg>
                                        <span>Changing storage requires a container restart. Make sure the destination is always accessible.</span>
                                    </div>
                                    <div class="storage-warning error" id="storage-health-warning">
                                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><line x1="12" y1="8" x2="12" y2="12"/><line x1="12" y1="16" x2="12.01" y2="16"/></svg>
                                        <span id="storage-health-warning-text">Docker storage mount issue detected. Your data may not be persisting to the NAS.</span>
                                    </div>
                                </div>

                                <!-- Offload config -->
                                <div class="offload-config-card">
                                    <div class="config-card-header">
                                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="2" y="2" width="20" height="8" rx="2" ry="2"/><rect x="2" y="14" width="20" height="8" rx="2" ry="2"/><line x1="6" y1="6" x2="6.01" y2="6"/><line x1="6" y1="18" x2="6.01" y2="18"/></svg>
                                        <div>
                                            <div class="config-title">Offload <span class="risk-indicator safe" id="offload-risk-badge">Off</span></div>
                                            <div class="config-desc">Run agents on a remote device via SSH + Claude CLI</div>
                                        </div>
                                    </div>
                                    <div id="offload-current-device" style="display:none;" class="offload-current">
                                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="2" y="3" width="20" height="14" rx="2" ry="2"/><line x1="8" y1="21" x2="16" y2="21"/><line x1="12" y1="17" x2="12" y2="21"/></svg>
                                        <span class="device-name" id="offload-current-name">-</span>
                                        <button class="btn-disable" onclick="disableOffload()">Disable</button>
                                    </div>
                                    <div style="display:flex; align-items:center; gap:8px; margin-bottom:8px;">
                                        <span style="font-size:0.75rem; color:var(--text-secondary);">Eligible Devices</span>
                                        <button class="btn-sm" onclick="refreshDevicesForOffload()" id="offload-refresh-btn" style="font-size:0.7rem; padding:2px 8px;">Refresh</button>
                                    </div>
                                    <div class="offload-device-list" id="offload-device-list">
                                        <div class="offload-empty">Loading eligible devices...</div>
                                    </div>
                                </div>
                            </div>

                            <!-- Section: Voice & Audio -->
                            <div class="settings-section" id="settings-section-voice-audio">
                                <div class="settings-section-heading">Voice</div>

                                <!-- Voice Engine Status -->
                                <div class="voice-settings-card" id="kokoro-engine-card">
                                    <div style="display:flex;align-items:center;justify-content:space-between;gap:12px;">
                                        <div style="display:flex;align-items:center;gap:10px;">
                                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" y1="19" x2="12" y2="23"/><line x1="8" y1="23" x2="16" y2="23"/></svg>
                                            <div>
                                                <div style="font-weight:600;font-size:0.9rem;">Voice Engine</div>
                                                <div style="font-size:0.75rem;color:var(--text-muted);margin-top:2px;" id="kokoro-engine-desc">Checking status...</div>
                                            </div>
                                        </div>
                                        <div id="kokoro-engine-status">
                                            <span class="risk-indicator" id="kokoro-status-badge" style="font-size:0.7rem;">Checking</span>
                                        </div>
                                    </div>
                                    <div id="kokoro-install-area" style="display:none;margin-top:12px;">
                                        <div style="font-size:0.75rem;color:var(--text-muted);margin-bottom:8px;">
                                            Kokoro TTS gives Cerebro a natural human voice. Download is ~2 GB.
                                        </div>
                                        <button class="btn-sm" id="kokoro-install-btn" onclick="installKokoroTts()" style="width:100%;padding:8px;font-size:0.85rem;">
                                            Download & Install Voice Engine
                                        </button>
                                    </div>
                                    <div id="kokoro-progress-area" style="display:none;margin-top:12px;">
                                        <div style="display:flex;align-items:center;gap:8px;margin-bottom:6px;">
                                            <div class="spinner-sm"></div>
                                            <span style="font-size:0.8rem;color:var(--text-secondary);" id="kokoro-progress-text">Downloading...</span>
                                        </div>
                                        <div style="width:100%;height:4px;background:rgba(255,255,255,0.08);border-radius:2px;overflow:hidden;">
                                            <div id="kokoro-progress-bar" style="height:100%;background:var(--accent-primary);border-radius:2px;width:0%;transition:width 0.3s;"></div>
                                        </div>
                                    </div>
                                </div>

                                <div class="voice-settings-card">
                                    <div id="voice-options-list">
                                        <div class="voice-option selected" data-voice="af_heart" onclick="selectVoice('af_heart')">
                                            <div class="voice-option-radio"></div>
                                            <div class="voice-option-info">
                                                <div class="voice-option-name">Heart</div>
                                                <div class="voice-option-desc">Confident & Sharp</div>
                                            </div>
                                            <button class="voice-preview-btn" onclick="event.stopPropagation(); previewVoice('af_heart', this)" title="Preview">
                                                <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor"><polygon points="5 3 19 12 5 21 5 3"/></svg>
                                            </button>
                                        </div>
                                        <div class="voice-option" data-voice="af_bella" onclick="selectVoice('af_bella')">
                                            <div class="voice-option-radio"></div>
                                            <div class="voice-option-info">
                                                <div class="voice-option-name">Bella</div>
                                                <div class="voice-option-desc">Warm & Smooth</div>
                                            </div>
                                            <button class="voice-preview-btn" onclick="event.stopPropagation(); previewVoice('af_bella', this)" title="Preview">
                                                <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor"><polygon points="5 3 19 12 5 21 5 3"/></svg>
                                            </button>
                                        </div>
                                        <div class="voice-option" data-voice="af_sarah" onclick="selectVoice('af_sarah')">
                                            <div class="voice-option-radio"></div>
                                            <div class="voice-option-info">
                                                <div class="voice-option-name">Sarah</div>
                                                <div class="voice-option-desc">Balanced & Clear</div>
                                            </div>
                                            <button class="voice-preview-btn" onclick="event.stopPropagation(); previewVoice('af_sarah', this)" title="Preview">
                                                <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor"><polygon points="5 3 19 12 5 21 5 3"/></svg>
                                            </button>
                                        </div>
                                        <div class="voice-option" data-voice="af_sky" onclick="selectVoice('af_sky')">
                                            <div class="voice-option-radio"></div>
                                            <div class="voice-option-info">
                                                <div class="voice-option-name">Sky</div>
                                                <div class="voice-option-desc">Bright & Energetic</div>
                                            </div>
                                            <button class="voice-preview-btn" onclick="event.stopPropagation(); previewVoice('af_sky', this)" title="Preview">
                                                <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor"><polygon points="5 3 19 12 5 21 5 3"/></svg>
                                            </button>
                                        </div>
                                    </div>
                                </div>

                                <div class="voice-settings-card">
                                    <div class="settings-row">
                                        <span class="settings-label">Speed</span>
                                    </div>
                                    <div class="speed-slider-container">
                                        <span style="font-size:0.75rem;color:var(--text-muted);">0.5x</span>
                                        <input type="range" class="speed-slider" id="voice-speed-slider" min="0.5" max="2.0" step="0.1" value="1.0" oninput="updateVoiceSpeed(this.value)">
                                        <span style="font-size:0.75rem;color:var(--text-muted);">2.0x</span>
                                        <span class="speed-value" id="voice-speed-display">1.0x</span>
                                    </div>
                                </div>

                                <div class="settings-divider"></div>

                                <div class="settings-section-heading">Audio Devices</div>
                                <div class="settings-card">
                                    <div class="settings-row">
                                        <span class="settings-label">Microphone</span>
                                        <select id="mic-select" class="settings-select" onchange="selectMicrophone(this.value)">
                                            <option value="">Default Microphone</option>
                                        </select>
                                    </div>
                                    <div class="settings-row">
                                        <span class="settings-label">Speaker</span>
                                        <select id="speaker-select" class="settings-select" onchange="selectSpeaker(this.value)">
                                            <option value="">Default Speaker</option>
                                        </select>
                                    </div>
                                    <div class="settings-row">
                                        <span class="settings-label">Voice Status</span>
                                        <span class="settings-value" id="voice-status">Not initialized</span>
                                    </div>
                                </div>

                                <div class="settings-divider"></div>

                                <div class="voice-settings-card">
                                    <div class="autospeak-toggle">
                                        <div>
                                            <div style="font-weight:600;font-size:0.9rem;">Auto-Speak</div>
                                            <div style="font-size:0.75rem;color:var(--text-muted);margin-top:2px;">Narrations auto-play when Cerebro finishes thinking</div>
                                        </div>
                                        <div class="toggle-switch" id="autospeak-toggle" onclick="toggleAutoSpeak()"></div>
                                    </div>
                                </div>

                                <div style="display:flex;gap:8px;margin-top:12px;">
                                    <button class="btn btn-secondary" style="flex:1;" onclick="testMicrophone()">Test Mic</button>
                                    <button class="btn btn-secondary" style="flex:1;" onclick="testSpeaker()">Test Speaker</button>
                                    <button class="btn btn-secondary" style="flex:1;" onclick="testCurrentVoice()">
                                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="margin-right:4px;vertical-align:middle;">
                                            <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/>
                                            <path d="M19.07 4.93a10 10 0 0 1 0 14.14"/>
                                        </svg>
                                        Test Voice
                                    </button>
                                </div>
                            </div>

                            <!-- Section: File Access -->
                            <div class="settings-section" id="settings-section-file-access">
                                <div class="settings-section-heading" style="display:flex;align-items:center;">File Access<span class="risk-indicator safe" id="file-access-risk">Safe</span></div>
                                <div id="file-access-section">
                                    <!-- Explanation card -->
                                    <div class="settings-card" style="margin-bottom:12px;">
                                        <div style="padding:16px 20px;display:flex;gap:14px;align-items:flex-start;">
                                            <div style="width:36px;height:36px;border-radius:10px;background:rgba(139,92,246,0.1);display:flex;align-items:center;justify-content:center;flex-shrink:0;margin-top:2px;">
                                                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="var(--accent)" stroke-width="2"><rect x="3" y="3" width="7" height="7"/><rect x="14" y="3" width="7" height="7"/><rect x="3" y="14" width="7" height="7"/><rect x="14" y="14" width="7" height="7"/></svg>
                                            </div>
                                            <div>
                                                <div style="font-weight:600;font-size:0.9rem;margin-bottom:4px;">Share folders with your agents</div>
                                                <div style="font-size:0.78rem;color:var(--text-muted);line-height:1.5;">Cerebro agents run in an isolated container and can't see your files by default. Enable folders below to let agents read (or write) files on your computer. Changes require a container restart.</div>
                                            </div>
                                        </div>
                                    </div>

                                    <div class="file-access-warning" id="file-access-warning">
                                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"/><line x1="12" y1="9" x2="12" y2="13"/><line x1="12" y1="17" x2="12.01" y2="17"/></svg>
                                        Write access is enabled on one or more folders. Agents can modify and delete files in those directories.
                                    </div>

                                    <!-- Quick presets -->
                                    <div style="font-size:0.78rem;color:var(--text-muted);margin-bottom:6px;padding-left:2px;">Quick Presets</div>
                                    <div class="settings-card" id="file-access-presets-card">
                                        <div id="file-access-presets-list">
                                            <!-- Populated by JS -->
                                        </div>
                                    </div>

                                    <!-- Custom folders -->
                                    <div style="font-size:0.78rem;color:var(--text-muted);margin-bottom:6px;margin-top:14px;padding-left:2px;">Custom Folders</div>
                                    <div class="settings-card">
                                        <div id="custom-mounts-list">
                                            <!-- Populated by JS -->
                                        </div>
                                        <div style="padding:12px 20px;">
                                            <button class="btn btn-secondary btn-block" onclick="addCustomMount()" style="font-size:0.8rem;padding:10px 16px;">
                                                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>
                                                Add Folder
                                            </button>
                                        </div>
                                    </div>
                                </div>
                                <div class="file-access-not-available" id="file-access-not-available" style="display:none;">
                                    <div style="margin-bottom:8px;">
                                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="var(--text-muted)" stroke-width="1.5"><rect x="2" y="3" width="20" height="14" rx="2"/><line x1="8" y1="21" x2="16" y2="21"/><line x1="12" y1="17" x2="12" y2="21"/></svg>
                                    </div>
                                    File access settings are only available in the Cerebro desktop app.
                                </div>
                            </div>

                            <!-- Section: About & Account -->
                            <div class="settings-section" id="settings-section-about-account">
                                <div class="settings-section-heading">About</div>
                                <div class="settings-card">
                                    <div class="settings-row">
                                        <span class="settings-label">Version</span>
                                        <span class="settings-value" id="app-version">--</span>
                                    </div>
                                    <div class="settings-row">
                                        <span class="settings-label">Cost</span>
                                        <span class="settings-value success" id="settings-cost-display">Included (Claude Code subscription)</span>
                                    </div>
                                </div>

                                <button class="btn btn-secondary btn-block" id="settings-check-update-btn" style="margin-top: 16px;" onclick="manualCheckForUpdates()">
                                    Check for Updates
                                </button>
                                <div style="margin-top: 12px; padding: 12px 14px; background: rgba(139,92,246,0.08); border: 1px solid rgba(139,92,246,0.15); border-radius: 10px; font-size: 0.78rem; color: var(--text-muted); line-height: 1.5;">
                                    <span style="color: var(--accent-light); font-weight: 600;">Update tip:</span>
                                    If "Restart &amp; Update" doesn't work, fully quit Cerebro (File &rarr; Quit, or right-click the system tray icon &rarr; Quit), then reopen it from your desktop shortcut or Start menu. The update installs automatically on quit. Simply closing the window keeps Cerebro running in the background.
                                </div>

                                <div class="settings-divider"></div>

                                <div class="settings-section-heading">Session</div>
                                <div class="settings-card">
                                    <div class="settings-row">
                                        <span class="settings-label">User</span>
                                        <span class="settings-value" id="username-display"></span>
                                    </div>
                                    <div class="settings-row">
                                        <span class="settings-label">Session ID</span>
                                        <span class="settings-value" id="session-id">-</span>
                                    </div>
                                </div>

                                <button class="btn btn-danger btn-block" style="margin-top: 24px;" onclick="logout()">
                                    Sign Out
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </main>

            <!-- File Access Restart Bar -->
            <div class="file-access-restart-bar" id="file-access-restart-bar" style="display:none;">
                <span class="restart-msg">File access changes require a container restart to take effect.</span>
                <button class="btn btn-primary" id="file-access-restart-btn" onclick="applyFileAccessRestart()">Restart Now</button>
            </div>

            <!-- Update Available Banner -->
            <div class="update-available-bar" id="update-available-bar" style="display:none;">
                <span class="update-msg" id="update-msg-text">A new version of Cerebro is available.</span>
                <button class="btn btn-primary" id="update-apply-btn" onclick="applyAppUpdate()">Restart &amp; Update</button>
                <button class="update-dismiss-btn" onclick="dismissUpdateBanner()" title="Dismiss">&times;</button>
            </div>

            <!-- Scroll to bottom button (for chat view) -->
            <!-- Floating Chat Actions Menu (hamburger) -->
            <div class="chat-fab-container" id="chat-fab-container">
                <button class="chat-fab-btn" id="chat-fab-btn" onclick="toggleChatFab()" title="Chat actions">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="3" y1="6" x2="21" y2="6"/>
                        <line x1="3" y1="12" x2="21" y2="12"/>
                        <line x1="3" y1="18" x2="21" y2="18"/>
                    </svg>
                </button>
                <div class="chat-fab-menu" id="chat-fab-menu">
                    <button class="chat-fab-item" onclick="scrollMessagesToBottom(); closeChatFab();">
                        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <line x1="12" y1="5" x2="12" y2="19"/>
                            <polyline points="19 12 12 19 5 12"/>
                        </svg>
                        <span>Scroll to bottom</span>
                    </button>
                    <button class="chat-fab-item" onclick="refreshChat(); closeChatFab();">
                        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <polyline points="23 4 23 10 17 10"/>
                            <polyline points="1 20 1 14 7 14"/>
                            <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"/>
                        </svg>
                        <span>Refresh chat</span>
                    </button>
                    <button class="chat-fab-item" onclick="openGuideModal(); closeChatFab();">
                        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <circle cx="12" cy="12" r="10"/>
                            <line x1="12" y1="16" x2="12" y2="12"/>
                            <line x1="12" y1="8" x2="12.01" y2="8"/>
                        </svg>
                        <span>Guide</span>
                    </button>
                    <button class="chat-fab-item danger" onclick="clearChatHistory(); closeChatFab();">
                        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <polyline points="3 6 5 6 21 6"/>
                            <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
                        </svg>
                        <span>Clear history</span>
                    </button>
                </div>
            </div>


            <!-- Bottom Navigation -->
            <nav class="bottom-nav">
                <div class="nav-item active" data-view="home" onclick="switchView('home')">
                    <span class="nav-icon"><svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/><polyline points="9 22 9 12 15 12 15 22"/></svg></span>
                    <span class="nav-label">Home</span>
                </div>
                <div class="nav-item" data-view="chat" onclick="switchView('chat')">
                    <span class="nav-icon"><svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/></svg></span>
                    <span class="nav-label">Chat</span>
                </div>
                <div class="nav-item" data-view="agents" onclick="switchView('agents')">
                    <span class="nav-icon"><svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="8" r="5"/><path d="M3 21v-2a7 7 0 0 1 7-7h4a7 7 0 0 1 7 7v2"/></svg></span>
                    <span class="nav-label">Agents</span>
                </div>
                <div class="nav-item" data-view="autonomy" onclick="switchView('autonomy')">
                    <span class="nav-icon"><svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><path d="M12 6v6l4 2"/><circle cx="12" cy="12" r="3" fill="currentColor"/></svg></span>
                    <span class="nav-label">Mind</span>
                </div>
                <div class="nav-item" data-view="automation" onclick="switchView('automation')">
                    <span class="nav-icon"><svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg></span>
                    <span class="nav-label">Auto</span>
                </div>
                <div class="nav-item" data-view="settings" onclick="switchView('settings')">
                    <span class="nav-icon"><svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="3"/><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"/></svg></span>
                    <span class="nav-label">Settings</span>
                </div>
            </nav>
        </div>


        <!-- Heartbeat Settings Modal -->
        <div class="modal-overlay" id="heartbeat-modal" onclick="if(event.target===this) closeHeartbeatModal()">
            <div class="modal modal-heartbeat">
                <div class="modal-header">
                    <span class="modal-title"><span style="color:#ef4444;">&#9829;</span> Heartbeat Settings</span>
                    <button class="modal-close" onclick="closeHeartbeatModal()">&times;</button>
                </div>
                <div class="modal-body" id="hb-modal-body">
                    <!-- Monitors Section -->
                    <div class="hb-section">
                        <div class="hb-section-title">Monitors</div>
                        <div class="hb-interval-row">
                            <label>Interval</label>
                            <input type="range" id="hb-interval-slider" min="5" max="60" step="1" value="15" oninput="document.getElementById('hb-interval-display').textContent=this.value+'m'">
                            <span class="hb-interval-value" id="hb-interval-display">15m</span>
                        </div>
                        <div class="hb-monitor-grid" id="hb-monitor-grid"></div>
                    </div>
                    <!-- Long-Term Goals Section -->
                    <div class="hb-section">
                        <div class="hb-section-title">Long-Term Goals</div>
                        <div id="hb-goals-list"></div>
                        <div class="hb-goal-add-form">
                            <div class="hb-goal-add-row">
                                <input class="hb-add-input" id="hb-goal-input" placeholder="Add goal..." onkeydown="if(event.key==='Enter'){event.preventDefault();_addHbGoal();}">
                                <select class="hb-goal-mode-select" id="hb-goal-mode-select">
                                    <option value="monitor">Monitor</option>
                                    <option value="think">Think</option>
                                    <option value="act">Act</option>
                                </select>
                                <button class="hb-add-btn" onclick="_addHbGoal()">+</button>
                            </div>
                            <div class="hb-goal-add-row">
                                <input class="hb-goal-date-input" id="hb-goal-deadline" type="date" placeholder="Deadline (optional)">
                            </div>
                        </div>
                    </div>
                    <!-- Quick Tasks Section -->
                    <div class="hb-section">
                        <div class="hb-section-title">Quick Tasks</div>
                        <div class="hb-list" id="hb-tasks-list"></div>
                        <div class="hb-add-row">
                            <input class="hb-add-input" id="hb-task-input" placeholder="Add quick task..." onkeydown="if(event.key==='Enter'){event.preventDefault();_addHbIdleTask();}">
                            <button class="hb-add-btn" onclick="_addHbIdleTask()">+</button>
                        </div>
                    </div>
                    <!-- Dormant Instructions Section -->
                    <div class="hb-section">
                        <div class="hb-section-title">Dormant Instructions</div>
                        <textarea class="hb-dormant-textarea" id="hb-dormant-textarea" placeholder="Freeform instructions for idle behavior..." spellcheck="false"></textarea>
                    </div>
                    <!-- Raw Editor (collapsed) -->
                    <div>
                        <button class="hb-raw-toggle" id="hb-raw-toggle-btn" onclick="toggleRawEditor()">
                            <span class="hb-raw-arrow">&#9654;</span> Raw Editor
                        </button>
                        <div class="hb-raw-editor-wrap" id="hb-raw-wrap">
                            <textarea class="hb-raw-editor" id="hb-raw-textarea" spellcheck="false" placeholder="heartbeat.md content..."></textarea>
                        </div>
                    </div>
                </div>
                <div class="hb-status-bar">
                    <span class="hb-status-text" id="hb-status-text">Loading...</span>
                    <span class="hb-dirty-indicator" id="hb-dirty-indicator">&#9679; unsaved</span>
                </div>
                <div class="modal-footer">
                    <button class="btn btn-secondary" onclick="closeHeartbeatModal()">Cancel</button>
                    <button class="btn btn-primary" id="hb-save-btn" onclick="saveHeartbeatSettings()">Save</button>
                </div>
            </div>
        </div>

        <!-- Unified Agent Split Panel -->
        <div class="agent-panel-overlay" id="agent-panel" onclick="if(event.target===this)closeAgentPanel()">
            <div class="agent-panel" onclick="event.stopPropagation()">
                <div class="agent-panel-header">
                    <span class="agent-title" id="panel-title">Spawn New Agent</span>
                    <span class="agent-status-badge" id="panel-status-badge" style="display:none;">RUNNING</span>
                    <button class="modal-close-btn" onclick="closeAgentPanel()" title="Close">&times;</button>
                </div>

                <!-- Agent lineage breadcrumb -->
                <div class="agent-chain-nav" id="panel-chain-nav" style="display: none;"></div>

                <div class="agent-panel-body">
                    <!-- ===== LEFT PANEL ===== -->
                    <div class="agent-panel-left">
                        <!-- Left: Create mode (builder form) -->
                        <div class="panel-mode active" id="panel-left-create">
                            <div class="spawn-mode-toggle">
                                <button class="mode-btn active" data-mode="single" onclick="setSpawnMode('single')">
                                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/><circle cx="12" cy="7" r="4"/></svg> Single Agent
                                </button>
                                <button class="mode-btn" data-mode="workflow" onclick="setSpawnMode('workflow')">
                                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M23 21v-2a4 4 0 0 0-3-3.87"/><path d="M16 3.13a4 4 0 0 1 0 7.75"/></svg> Multi-Agent
                                </button>
                                <button class="mode-btn" data-mode="specops" onclick="setSpawnMode('specops')">
                                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2L2 7l10 5 10-5-10-5z"/><path d="M2 17l10 5 10-5"/><path d="M2 12l10 5 10-5"/></svg> Special Ops
                                </button>
                            </div>

                            <!-- Single Agent Form -->
                            <div id="panel-single-agent-form">
                                <div class="form-group">
                                    <label class="form-label">Agent Role <span class="required">*</span></label>
                                    <div class="role-selector" id="panel-role-selector">
                                        <div class="role-option selected" data-role="worker" onclick="selectRole(this)">
                                            <div class="role-icon"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/></svg></div>
                                            <div class="role-name">Worker</div>
                                            <div class="role-desc">Execute tasks efficiently</div>
                                        </div>
                                        <div class="role-option" data-role="researcher" onclick="selectRole(this)">
                                            <div class="role-icon"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/></svg></div>
                                            <div class="role-name">Researcher</div>
                                            <div class="role-desc">Deep investigation</div>
                                        </div>
                                        <div class="role-option" data-role="coder" onclick="selectRole(this)">
                                            <div class="role-icon"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="16 18 22 12 16 6"/><polyline points="8 6 2 12 8 18"/></svg></div>
                                            <div class="role-name">Coder</div>
                                            <div class="role-desc">Write & modify code</div>
                                        </div>
                                        <div class="role-option" data-role="analyst" onclick="selectRole(this)">
                                            <div class="role-icon"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="20" x2="18" y2="10"/><line x1="12" y1="20" x2="12" y2="4"/><line x1="6" y1="20" x2="6" y2="14"/></svg></div>
                                            <div class="role-name">Analyst</div>
                                            <div class="role-desc">Data & strategic insights</div>
                                        </div>
                                    </div>
                                </div>

                                <div class="form-group">
                                    <label class="form-label">Task Description <span class="required">*</span></label>
                                    <textarea class="form-input form-textarea" id="agent-task-input" placeholder="What should this agent accomplish? Be specific about the goal."></textarea>
                                </div>

                                <div class="advanced-toggle" onclick="toggleAdvancedOptions()">
                                    <span id="advanced-arrow">&#9654;</span> Advanced Options
                                </div>

                                <div id="advanced-options" class="advanced-options hidden">
                                    <div class="form-group">
                                        <label class="form-label">Context / Background</label>
                                        <textarea class="form-input form-textarea-small" id="agent-context-input" placeholder="Any background information the agent should know..."></textarea>
                                    </div>
                                    <div class="form-row">
                                        <div class="form-group form-half">
                                            <label class="form-label">Expected Output</label>
                                            <select class="form-input" id="agent-output-format">
                                                <option value="">Any format</option>
                                                <option value="summary">Brief Summary</option>
                                                <option value="detailed">Detailed Report</option>
                                                <option value="code">Code Only</option>
                                                <option value="list">Bullet Points</option>
                                                <option value="json">JSON Data</option>
                                            </select>
                                        </div>
                                        <div class="form-group form-half">
                                            <label class="form-label">Priority</label>
                                            <select class="form-input" id="agent-priority">
                                                <option value="normal">Normal</option>
                                                <option value="low">Low</option>
                                                <option value="high">High</option>
                                                <option value="critical">Critical</option>
                                            </select>
                                        </div>
                                    </div>
                                    <div class="form-row">
                                        <div class="form-group form-half">
                                            <label class="form-label">Model</label>
                                            <select class="form-input" id="agent-model-select">
                                                <option value="sonnet" selected>Sonnet 4.6 (Fast)</option>
                                                <option value="opus">Opus 4.6 (Powerful)</option>
                                                <option value="haiku">Haiku 4.5 (Fastest)</option>
                                            </select>
                                        </div>
                                    </div>
                                    <div class="form-group">
                                        <label class="form-label">Resources (file paths or URLs)</label>
                                        <input type="text" class="form-input" id="agent-resources-input" placeholder="Z:\path\to\file.py, https://example.com/docs">
                                    </div>
                                    <div class="form-group">
                                        <label class="form-label">Timeout</label>
                                        <div class="timeout-selector" id="agent-timeout-selector">
                                            <button type="button" class="timeout-btn" data-timeout="1800" onclick="selectAgentTimeout(this)">30 min</button>
                                            <button type="button" class="timeout-btn active" data-timeout="3600" onclick="selectAgentTimeout(this)">1 hour</button>
                                            <button type="button" class="timeout-btn" data-timeout="14400" onclick="selectAgentTimeout(this)">4 hours</button>
                                            <button type="button" class="timeout-btn" data-timeout="0" onclick="selectAgentTimeout(this)">Unlimited</button>
                                        </div>
                                    </div>
                                    <div class="form-group" id="agent-device-group">
                                        <label class="form-label">Run On Device</label>
                                        <select class="form-input" id="agent-offload-device">
                                            <option value="">Local (this machine)</option>
                                        </select>
                                        <div style="font-size:0.68rem; color:var(--text-secondary); margin-top:4px;">Route this agent to a remote machine via SSH</div>
                                    </div>
                                    <div class="form-group" id="project-folder-group" style="display:none;">
                                        <label class="form-label">Project Folder (for remote execution)</label>
                                        <select class="form-input" id="agent-project-folder">
                                            <option value="">None (prompt only)</option>
                                        </select>
                                        <div style="font-size:0.68rem; color:var(--text-secondary); margin-top:4px;">Selected folder will be synced to the remote device before the agent runs</div>
                                    </div>
                                </div>
                            </div>

                            <!-- Multi-Agent Workflow Form -->
                            <div id="workflow-form" class="hidden">
                                <div class="form-group">
                                    <label class="form-label">Mission Objective <span class="required">*</span></label>
                                    <textarea class="form-input form-textarea" id="workflow-task-input" placeholder="Describe the complex task that requires multiple agents..."></textarea>
                                </div>
                                <div class="form-group">
                                    <label class="form-label">Workflow Type</label>
                                    <div class="workflow-type-selector">
                                        <div class="workflow-type selected" data-type="standard" onclick="selectWorkflowType(this)">
                                            <div class="workflow-type-icon"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><circle cx="12" cy="12" r="3"/></svg></div>
                                            <div class="workflow-type-name">Standard</div>
                                            <div class="workflow-type-desc">Orchestrator decides</div>
                                        </div>
                                        <div class="workflow-type" data-type="parallel" onclick="selectWorkflowType(this)">
                                            <div class="workflow-type-icon"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="8" y1="6" x2="21" y2="6"/><line x1="8" y1="12" x2="21" y2="12"/><line x1="8" y1="18" x2="21" y2="18"/></svg></div>
                                            <div class="workflow-type-name">Parallel</div>
                                            <div class="workflow-type-desc">All agents simultaneously</div>
                                        </div>
                                        <div class="workflow-type" data-type="sequential" onclick="selectWorkflowType(this)">
                                            <div class="workflow-type-icon"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="5" y1="12" x2="19" y2="12"/><polyline points="12 5 19 12 12 19"/></svg></div>
                                            <div class="workflow-type-name">Sequential</div>
                                            <div class="workflow-type-desc">One after another</div>
                                        </div>
                                    </div>
                                </div>
                                <div class="form-group">
                                    <label class="form-label">Team Composition</label>
                                    <div class="team-selector team-quantity-selector">
                                        <div class="team-member-qty">
                                            <span class="agent-label">Researcher</span>
                                            <div class="qty-controls">
                                                <button type="button" class="qty-btn qty-minus" onclick="adjustAgentQty('researcher', -1)">-</button>
                                                <input type="number" id="qty-researcher" class="qty-input" value="1" min="0" max="5" data-agent="researcher" onchange="updateTeamPreview()">
                                                <button type="button" class="qty-btn qty-plus" onclick="adjustAgentQty('researcher', 1)">+</button>
                                            </div>
                                        </div>
                                        <div class="team-member-qty">
                                            <span class="agent-label">Coder</span>
                                            <div class="qty-controls">
                                                <button type="button" class="qty-btn qty-minus" onclick="adjustAgentQty('coder', -1)">-</button>
                                                <input type="number" id="qty-coder" class="qty-input" value="1" min="0" max="5" data-agent="coder" onchange="updateTeamPreview()">
                                                <button type="button" class="qty-btn qty-plus" onclick="adjustAgentQty('coder', 1)">+</button>
                                            </div>
                                        </div>
                                        <div class="team-member-qty">
                                            <span class="agent-label">Worker</span>
                                            <div class="qty-controls">
                                                <button type="button" class="qty-btn qty-minus" onclick="adjustAgentQty('worker', -1)">-</button>
                                                <input type="number" id="qty-worker" class="qty-input" value="1" min="0" max="5" data-agent="worker" onchange="updateTeamPreview()">
                                                <button type="button" class="qty-btn qty-plus" onclick="adjustAgentQty('worker', 1)">+</button>
                                            </div>
                                        </div>
                                        <div class="team-member-qty">
                                            <span class="agent-label">Analyst</span>
                                            <div class="qty-controls">
                                                <button type="button" class="qty-btn qty-minus" onclick="adjustAgentQty('analyst', -1)">-</button>
                                                <input type="number" id="qty-analyst" class="qty-input" value="0" min="0" max="5" data-agent="analyst" onchange="updateTeamPreview()">
                                                <button type="button" class="qty-btn qty-plus" onclick="adjustAgentQty('analyst', 1)">+</button>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                <div class="workflow-preview">
                                    <div class="workflow-preview-title">Command Structure</div>
                                    <div class="workflow-diagram">
                                        <div class="commander-node">
                                            <span class="node-icon"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><circle cx="12" cy="12" r="3"/></svg></span>
                                            <span class="node-name">Orchestrator</span>
                                        </div>
                                        <div class="command-line"></div>
                                        <div class="team-nodes" id="team-preview">
                                            <div class="team-node">Researcher</div>
                                            <div class="team-node">Coder</div>
                                            <div class="team-node">Worker</div>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- Special Ops Form -->
                            <div id="specops-form" class="hidden">
                                <!-- Section 1: MISSION BRIEFING -->
                                <div class="specops-briefing-section">
                                    <div class="specops-briefing-header">&#x1F3AF; Mission Briefing</div>
                                    <div class="form-group">
                                        <label class="form-label" style="font-family:'JetBrains Mono','SF Mono',monospace;text-transform:uppercase;letter-spacing:1px;font-size:0.65rem;color:var(--specops-pink-light);">Operation Name</label>
                                        <input type="text" class="form-input" id="specops-mission-name" placeholder="OPERATION NIGHTFALL" maxlength="60" style="font-family:'JetBrains Mono','SF Mono',monospace;text-transform:uppercase;">
                                    </div>
                                    <div class="form-group">
                                        <label class="form-label" style="font-family:'JetBrains Mono','SF Mono',monospace;text-transform:uppercase;letter-spacing:1px;font-size:0.65rem;color:var(--specops-pink-light);">Objective <span class="required">*</span></label>
                                        <textarea class="form-input form-textarea" id="specops-task-input" placeholder="Describe the multi-day mission objective..." style="min-height:70px;"></textarea>
                                    </div>
                                </div>

                                <!-- Section 2: OPERATIVE CLASS -->
                                <div class="specops-briefing-section">
                                    <div class="specops-briefing-header">&#x1F396;&#xFE0F; Operative Class</div>
                                    <div class="specops-role-grid" id="specops-role-selector">
                                        <div class="specops-role-btn active" data-role="worker" onclick="selectSpecopsRole(this)">
                                            <span class="role-icon">&#x26A1;</span>
                                            <span>Worker</span>
                                        </div>
                                        <div class="specops-role-btn" data-role="researcher" onclick="selectSpecopsRole(this)">
                                            <span class="role-icon">&#x1F50D;</span>
                                            <span>Researcher</span>
                                        </div>
                                        <div class="specops-role-btn" data-role="coder" onclick="selectSpecopsRole(this)">
                                            <span class="role-icon">&#x1F4BB;</span>
                                            <span>Coder</span>
                                        </div>
                                        <div class="specops-role-btn" data-role="analyst" onclick="selectSpecopsRole(this)">
                                            <span class="role-icon">&#x1F4CA;</span>
                                            <span>Analyst</span>
                                        </div>
                                    </div>
                                    <div class="form-group" style="margin-top:12px;">
                                        <label class="form-label" style="font-family:'JetBrains Mono','SF Mono',monospace;text-transform:uppercase;letter-spacing:1px;font-size:0.65rem;color:var(--specops-pink-light);">Model</label>
                                        <select class="form-input" id="specops-model-select" style="padding:8px;">
                                            <option value="sonnet">Sonnet (Recommended)</option>
                                            <option value="opus">Opus</option>
                                            <option value="haiku">Haiku</option>
                                        </select>
                                    </div>
                                    <div class="form-group">
                                        <label class="form-label" style="font-family:'JetBrains Mono','SF Mono',monospace;text-transform:uppercase;letter-spacing:1px;font-size:0.65rem;color:var(--specops-pink-light);">Additional Context</label>
                                        <textarea class="form-input form-textarea" id="specops-context-input" placeholder="Background information for the mission..." style="min-height:60px;"></textarea>
                                    </div>
                                </div>

                                <!-- Section 3: DEPLOYMENT PARAMETERS -->
                                <div class="specops-briefing-section">
                                    <div class="specops-briefing-header">&#x2699;&#xFE0F; Deployment Parameters</div>
                                    <div class="form-group">
                                        <label class="form-label" style="font-family:'JetBrains Mono','SF Mono',monospace;text-transform:uppercase;letter-spacing:1px;font-size:0.65rem;color:var(--specops-pink-light);">Cadence</label>
                                        <div class="specops-selector" id="specops-work-style-selector">
                                            <button type="button" class="sel-btn active" data-value="continuous" onclick="selectWorkStyle(this)">Continuous</button>
                                            <button type="button" class="sel-btn" data-value="cycle" onclick="selectWorkStyle(this)">Cycle-Based</button>
                                            <button type="button" class="sel-btn" data-value="hybrid" onclick="selectWorkStyle(this)">Agent Decides</button>
                                        </div>
                                    </div>
                                    <div class="form-group" id="specops-cycle-interval-group" style="display:none;">
                                        <label class="form-label" style="font-family:'JetBrains Mono','SF Mono',monospace;text-transform:uppercase;letter-spacing:1px;font-size:0.65rem;color:var(--specops-pink-light);">Interval</label>
                                        <div class="specops-selector" id="specops-cycle-selector">
                                            <button type="button" class="sel-btn" data-value="900" onclick="selectCycleInterval(this)">15m</button>
                                            <button type="button" class="sel-btn" data-value="1800" onclick="selectCycleInterval(this)">30m</button>
                                            <button type="button" class="sel-btn active" data-value="3600" onclick="selectCycleInterval(this)">1hr</button>
                                            <button type="button" class="sel-btn" data-value="14400" onclick="selectCycleInterval(this)">4hr</button>
                                            <button type="button" class="sel-btn" data-value="43200" onclick="selectCycleInterval(this)">12hr</button>
                                        </div>
                                    </div>
                                    <div class="form-group">
                                        <label class="form-label" style="font-family:'JetBrains Mono','SF Mono',monospace;text-transform:uppercase;letter-spacing:1px;font-size:0.65rem;color:var(--specops-pink-light);">Duration</label>
                                        <div class="specops-selector" id="specops-duration-selector">
                                            <button type="button" class="sel-btn" data-value="86400" onclick="selectMissionDuration(this)">1 day</button>
                                            <button type="button" class="sel-btn" data-value="172800" onclick="selectMissionDuration(this)">2 days</button>
                                            <button type="button" class="sel-btn active" data-value="259200" onclick="selectMissionDuration(this)">3 days</button>
                                            <button type="button" class="sel-btn" data-value="604800" onclick="selectMissionDuration(this)">1 week</button>
                                            <button type="button" class="sel-btn" data-value="0" onclick="selectMissionDuration(this)">Unlimited</button>
                                        </div>
                                    </div>
                                </div>

                                <!-- Section 4: RULES OF ENGAGEMENT -->
                                <div class="specops-briefing-section">
                                    <div class="specops-briefing-header">&#x1F4CB; Rules of Engagement</div>
                                    <div class="form-group">
                                        <label class="form-label" style="font-family:'JetBrains Mono','SF Mono',monospace;text-transform:uppercase;letter-spacing:1px;font-size:0.65rem;color:var(--specops-pink-light);">Project</label>
                                        <select class="form-input" id="specops-project-select" style="padding:8px;" onchange="onSpecopsProjectChange(this)">
                                            <option value="">No Project</option>
                                        </select>
                                    </div>
                                    <div class="form-group">
                                        <label class="form-label" style="font-family:'JetBrains Mono','SF Mono',monospace;text-transform:uppercase;letter-spacing:1px;font-size:0.65rem;color:var(--specops-pink-light);">Success Criteria</label>
                                        <textarea class="form-input form-textarea" id="specops-success-criteria" placeholder="Define what mission success looks like..." style="min-height:50px;"></textarea>
                                    </div>
                                </div>
                            </div>

                        </div>

                        <!-- Left: Detail mode (agent info + follow-up) -->
                        <div class="panel-mode" id="panel-left-detail">
                            <div id="panel-detail-info">
                                <!-- Populated by populateLeftDetailPanel() -->
                            </div>
                            <div class="panel-left-actions" id="panel-left-actions">
                                <div class="followup-row">
                                    <textarea id="panel-followup-instructions"
                                        placeholder="Add specific instructions for the follow-up agent..."
                                        rows="2"></textarea>
                                    <button class="agent-action-btn primary" id="panel-followup-btn" onclick="panelSpawnFollowUp()">
                                        Follow-up Command
                                    </button>
                                    <div class="rerun-link" id="panel-rerun-link" onclick="panelRerunAgent()">Re-run same agent</div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- ===== RIGHT PANEL ===== -->
                    <div class="agent-panel-right">
                        <!-- Right: Empty / Tips (create mode) -->
                        <div class="panel-mode active" id="panel-right-empty">
                            <div class="tips-section">
                                <div class="tips-section-title">Tips for Better Agents</div>
                                <div class="tip-card">
                                    <div class="tip-title">Be Specific</div>
                                    Write clear, detailed task descriptions. Instead of "research AI", try "Research the top 5 LLM frameworks for production deployment, compare latency and cost."
                                </div>
                                <div class="tip-card">
                                    <div class="tip-title">Provide Context</div>
                                    Use the context field to give background. The agent performs better when it understands why the task matters.
                                </div>
                                <div class="tip-card">
                                    <div class="tip-title">Chain Agents</div>
                                    Use Follow-up Commands to chain agents together. The output of one becomes context for the next.
                                </div>
                            </div>

                            <div class="template-gallery" id="template-gallery">
                                <div class="template-gallery-header">
                                    <div class="tips-section-title">Prompt Templates</div>
                                    <button class="template-save-btn" onclick="openTemplateEditor()">+ Create Template</button>
                                </div>
                                <div id="template-list">
                                    <!-- Populated by renderTemplateGallery() -->
                                </div>
                            </div>
                        </div>

                        <!-- Right: Running (spinner) -->
                        <div class="panel-mode" id="panel-right-running">
                            <!-- Normal agent running view -->
                            <div id="running-normal-view">
                                <div class="agent-running-indicator">
                                    <div class="agent-spinner"></div>
                                    <div class="running-text">Agent is working...</div>
                                    <div class="running-task" id="panel-running-task"></div>
                                    <div class="running-elapsed" id="panel-running-elapsed">0:00</div>
                                </div>
                            </div>
                            <!-- SpecOps running/cycling view -->
                            <div id="running-specops-view" style="display:none;">
                                <div class="specops-mission-header">
                                    <div class="agent-spinner"></div>
                                    <div class="specops-mission-header-info">
                                        <div class="specops-mission-header-name" id="specops-panel-mission-name"></div>
                                        <div class="specops-mission-header-status" id="specops-panel-status">Cycle #1  Running</div>
                                    </div>
                                    <div class="running-elapsed" id="specops-panel-elapsed">0:00</div>
                                </div>
                                <!-- Countdown dashboard (shown during cycling) -->
                                <div id="specops-countdown-area" style="display:none;">
                                    <div class="specops-countdown">
                                        <div>
                                            <div class="specops-countdown-label">Next Cycle In</div>
                                            <div class="specops-countdown-timer" id="specops-countdown-timer">--:--</div>
                                        </div>
                                        <div class="specops-action-btns">
                                            <button class="specops-action-btn force" onclick="forceNextCycle(agentPanelAgentId)">Force Next Cycle</button>
                                            <button class="specops-action-btn pause" onclick="pauseSpecopsMission(agentPanelAgentId)">Pause Mission</button>
                                        </div>
                                    </div>
                                    <div class="specops-stats-row" id="specops-stats-row">
                                        <div class="specops-stat"><div class="specops-stat-value" id="specops-stat-cycles">0</div><div class="specops-stat-label">Cycles</div></div>
                                        <div class="specops-stat"><div class="specops-stat-value" id="specops-stat-elapsed">0m</div><div class="specops-stat-label">Elapsed</div></div>
                                        <div class="specops-stat"><div class="specops-stat-value" id="specops-stat-progress"></div><div class="specops-stat-label">Progress</div></div>
                                        <div class="specops-stat"><div class="specops-stat-value" id="specops-stat-output">0</div><div class="specops-stat-label">Output Size</div></div>
                                    </div>
                                </div>
                                <!-- SpecOps Running Tabs -->
                                <div class="specops-tabs" id="specops-running-tabs">
                                    <div class="specops-tab active" data-tab="journal" onclick="switchSpecopsTab(this)">Journal</div>
                                    <div class="specops-tab" data-tab="debrief" onclick="switchSpecopsTab(this)">Debrief</div>
                                    <div class="specops-tab" data-tab="fulloutput" onclick="switchSpecopsTab(this)">Full Output</div>
                                </div>
                                <!-- Journal tab -->
                                <div id="specops-tab-journal" class="specops-tab-content active">
                                    <div id="specops-journal-panel">
                                        <div style="color:var(--text-muted);font-size:0.8rem;padding:20px;text-align:center;">No journal entries yet  first cycle in progress</div>
                                    </div>
                                    <!-- Cycle detail view (replaces journal when clicking an entry) -->
                                    <div id="specops-cycle-detail" style="display:none;">
                                        <div id="specops-cycle-detail-header" style="display:flex;align-items:center;gap:10px;margin-bottom:12px;">
                                            <button id="specops-cycle-back-btn" onclick="exitCycleDetailView()" style="background:none;border:1px solid var(--border);color:var(--text-secondary);border-radius:6px;padding:4px 12px;cursor:pointer;font-size:0.75rem;transition:all 0.2s ease;">Back</button>
                                            <span id="specops-cycle-detail-title" style="font-family:var(--font-mono);font-size:0.85rem;color:var(--specops-pink);font-weight:600;"></span>
                                        </div>
                                        <div id="specops-cycle-detail-body" class="specops-live-output" style="min-height:200px;"></div>
                                    </div>
                                </div>
                                <!-- Debrief tab -->
                                <div id="specops-tab-debrief" class="specops-tab-content">
                                    <div id="specops-debrief-panel"></div>
                                </div>
                                <!-- Full Output tab -->
                                <div id="specops-tab-fulloutput" class="specops-tab-content">
                                    <div id="specops-fulloutput-panel" class="specops-live-output" style="min-height:200px;"></div>
                                </div>
                            </div>
                        </div>

                        <!-- Right: Output (completed/failed) -->
                        <div class="panel-mode" id="panel-right-output">
                            <div id="panel-output-area">
                                <!-- Populated by populateRightOutputPanel() -->
                            </div>
                            <div class="panel-ask-area" id="panel-ask-area-main">
                                <input type="text" id="panel-ask-input" placeholder="Ask about this output..."
                                    onkeydown="if(event.key==='Enter')panelSubmitAsk()">
                                <button onclick="panelSubmitAsk()">Ask</button>
                            </div>
                            <div class="panel-ask-area" id="panel-thread-reply-area" style="display:none;">
                                <input type="text" id="panel-thread-reply-input" placeholder="Reply to this thread..."
                                    onkeydown="if(event.key==='Enter')panelSubmitThreadReply()">
                                <button onclick="panelSubmitThreadReply()">Reply</button>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="agent-panel-footer" id="agent-panel-footer">
                    <button class="btn btn-secondary" onclick="closeAgentPanel()">Cancel</button>
                    <button class="btn btn-primary" id="panel-launch-btn" onclick="submitAgent()">Launch Agent</button>
                </div>
            </div>
        </div>

        <!-- Agent Creation Modal (LEGACY - hidden, kept for compatibility) -->
        <div class="modal-overlay" id="agent-modal" onclick="if(event.target === this) closeAgentModal()" style="display:none !important">
            <div class="modal modal-large">
                <div class="modal-header">
                    <span class="modal-title"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle; margin-right: 8px;"><circle cx="12" cy="8" r="5"/><path d="M3 21v-2a7 7 0 0 1 7-7h4a7 7 0 0 1 7 7v2"/></svg>Spawn New Agent</span>
                    <button class="modal-close" onclick="closeAgentModal()">&times;</button>
                </div>
                <div class="modal-body">
                    <!-- Mode Toggle: Single vs Multi-Agent -->
                    <div class="spawn-mode-toggle">
                        <button class="mode-btn active" data-mode="single" onclick="setSpawnMode('single')">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/><circle cx="12" cy="7" r="4"/></svg> Single Agent
                        </button>
                        <button class="mode-btn" data-mode="workflow" onclick="setSpawnMode('workflow')">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M23 21v-2a4 4 0 0 0-3-3.87"/><path d="M16 3.13a4 4 0 0 1 0 7.75"/></svg> Multi-Agent Workflow
                        </button>
                        <button class="mode-btn" data-mode="specops" onclick="setSpawnMode('specops')">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2L2 7l10 5 10-5-10-5z"/><path d="M2 17l10 5 10-5"/><path d="M2 12l10 5 10-5"/></svg> Special Ops
                        </button>
                    </div>

                    <!-- Single Agent Mode -->
                    <div id="single-agent-form">
                        <div class="form-group">
                            <label class="form-label">Agent Role <span class="required">*</span></label>
                            <div class="role-selector">
                                <div class="role-option selected" data-role="worker" onclick="selectRole(this)">
                                    <div class="role-icon"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/></svg></div>
                                    <div class="role-name">Worker</div>
                                    <div class="role-desc">Execute tasks efficiently</div>
                                </div>
                                <div class="role-option" data-role="researcher" onclick="selectRole(this)">
                                    <div class="role-icon"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/></svg></div>
                                    <div class="role-name">Researcher</div>
                                    <div class="role-desc">Deep investigation</div>
                                </div>
                                <div class="role-option" data-role="coder" onclick="selectRole(this)">
                                    <div class="role-icon"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="16 18 22 12 16 6"/><polyline points="8 6 2 12 8 18"/></svg></div>
                                    <div class="role-name">Coder</div>
                                    <div class="role-desc">Write & modify code</div>
                                </div>
                                <div class="role-option" data-role="analyst" onclick="selectRole(this)">
                                    <div class="role-icon"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="20" x2="18" y2="10"/><line x1="12" y1="20" x2="12" y2="4"/><line x1="6" y1="20" x2="6" y2="14"/></svg></div>
                                    <div class="role-name">Analyst</div>
                                    <div class="role-desc">Data & strategic insights</div>
                                </div>
                            </div>
                        </div>

                        <div class="form-group">
                            <label class="form-label">Task Description <span class="required">*</span></label>
                            <textarea class="form-input form-textarea" id="agent-task-input" placeholder="What should this agent accomplish? Be specific about the goal."></textarea>
                        </div>

                        <!-- Collapsible Advanced Options -->
                        <div class="advanced-toggle" onclick="toggleAdvancedOptions()">
                            <span id="advanced-arrow"></span> Advanced Options
                        </div>

                        <div id="advanced-options" class="advanced-options hidden">
                            <div class="form-group">
                                <label class="form-label">Context / Background</label>
                                <textarea class="form-input form-textarea-small" id="agent-context-input" placeholder="Any background information the agent should know..."></textarea>
                            </div>

                            <div class="form-row">
                                <div class="form-group form-half">
                                    <label class="form-label">Expected Output</label>
                                    <select class="form-input" id="agent-output-format">
                                        <option value="">Any format</option>
                                        <option value="summary">Brief Summary</option>
                                        <option value="detailed">Detailed Report</option>
                                        <option value="code">Code Only</option>
                                        <option value="list">Bullet Points</option>
                                        <option value="json">JSON Data</option>
                                    </select>
                                </div>
                                <div class="form-group form-half">
                                    <label class="form-label">Priority</label>
                                    <select class="form-input" id="agent-priority">
                                        <option value="normal">Normal</option>
                                        <option value="low">Low</option>
                                        <option value="high">High</option>
                                        <option value="critical"> Critical</option>
                                    </select>
                                </div>
                            </div>

                            <div class="form-row">
                                <div class="form-group form-half">
                                    <label class="form-label">Model</label>
                                    <select class="form-input" id="agent-model-select">
                                        <option value="sonnet" selected>Sonnet 4.6 (Fast)</option>
                                        <option value="opus">Opus 4.6 (Powerful)</option>
                                        <option value="haiku">Haiku 4.5 (Fastest)</option>
                                    </select>
                                </div>
                            </div>

                            <div class="form-group">
                                <label class="form-label">Resources (file paths or URLs)</label>
                                <input type="text" class="form-input" id="agent-resources-input" placeholder="Z:\path\to\file.py, https://example.com/docs">
                            </div>

                            <div class="form-group">
                                <label class="form-label">Timeout</label>
                                <div class="timeout-selector" id="agent-timeout-selector">
                                    <button type="button" class="timeout-btn" data-timeout="1800" onclick="selectAgentTimeout(this)">30 min</button>
                                    <button type="button" class="timeout-btn active" data-timeout="3600" onclick="selectAgentTimeout(this)">1 hour</button>
                                    <button type="button" class="timeout-btn" data-timeout="14400" onclick="selectAgentTimeout(this)">4 hours</button>
                                    <button type="button" class="timeout-btn" data-timeout="0" onclick="selectAgentTimeout(this)">Unlimited</button>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Multi-Agent Workflow Mode -->
                    <div id="workflow-form" class="hidden">
                        <div class="form-group">
                            <label class="form-label">Mission Objective <span class="required">*</span></label>
                            <textarea class="form-input form-textarea" id="workflow-task-input" placeholder="Describe the complex task that requires multiple agents..."></textarea>
                        </div>

                        <div class="form-group">
                            <label class="form-label">Workflow Type</label>
                            <div class="workflow-type-selector">
                                <div class="workflow-type selected" data-type="standard" onclick="selectWorkflowType(this)">
                                    <div class="workflow-type-icon"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><circle cx="12" cy="12" r="3"/></svg></div>
                                    <div class="workflow-type-name">Standard</div>
                                    <div class="workflow-type-desc">Orchestrator decides how to delegate</div>
                                </div>
                                <div class="workflow-type" data-type="parallel" onclick="selectWorkflowType(this)">
                                    <div class="workflow-type-icon"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="8" y1="6" x2="21" y2="6"/><line x1="8" y1="12" x2="21" y2="12"/><line x1="8" y1="18" x2="21" y2="18"/><line x1="3" y1="6" x2="3.01" y2="6"/><line x1="3" y1="12" x2="3.01" y2="12"/><line x1="3" y1="18" x2="3.01" y2="18"/></svg></div>
                                    <div class="workflow-type-name">Parallel</div>
                                    <div class="workflow-type-desc">All agents work simultaneously</div>
                                </div>
                                <div class="workflow-type" data-type="sequential" onclick="selectWorkflowType(this)">
                                    <div class="workflow-type-icon"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="5" y1="12" x2="19" y2="12"/><polyline points="12 5 19 12 12 19"/></svg></div>
                                    <div class="workflow-type-name">Sequential</div>
                                    <div class="workflow-type-desc">Agents run one after another</div>
                                </div>
                            </div>
                        </div>

                        <div class="form-group">
                            <label class="form-label">Team Composition</label>
                            <div class="team-selector team-quantity-selector">
                                <div class="team-member-qty">
                                    <span class="agent-label">Researcher</span>
                                    <div class="qty-controls">
                                        <button type="button" class="qty-btn qty-minus" onclick="adjustAgentQty('researcher', -1)"></button>
                                        <input type="number" id="qty-researcher" class="qty-input" value="1" min="0" max="5" data-agent="researcher" onchange="updateTeamPreview()">
                                        <button type="button" class="qty-btn qty-plus" onclick="adjustAgentQty('researcher', 1)">+</button>
                                    </div>
                                </div>
                                <div class="team-member-qty">
                                    <span class="agent-label">Coder</span>
                                    <div class="qty-controls">
                                        <button type="button" class="qty-btn qty-minus" onclick="adjustAgentQty('coder', -1)"></button>
                                        <input type="number" id="qty-coder" class="qty-input" value="1" min="0" max="5" data-agent="coder" onchange="updateTeamPreview()">
                                        <button type="button" class="qty-btn qty-plus" onclick="adjustAgentQty('coder', 1)">+</button>
                                    </div>
                                </div>
                                <div class="team-member-qty">
                                    <span class="agent-label">Worker</span>
                                    <div class="qty-controls">
                                        <button type="button" class="qty-btn qty-minus" onclick="adjustAgentQty('worker', -1)"></button>
                                        <input type="number" id="qty-worker" class="qty-input" value="1" min="0" max="5" data-agent="worker" onchange="updateTeamPreview()">
                                        <button type="button" class="qty-btn qty-plus" onclick="adjustAgentQty('worker', 1)">+</button>
                                    </div>
                                </div>
                                <div class="team-member-qty">
                                    <span class="agent-label">Analyst</span>
                                    <div class="qty-controls">
                                        <button type="button" class="qty-btn qty-minus" onclick="adjustAgentQty('analyst', -1)"></button>
                                        <input type="number" id="qty-analyst" class="qty-input" value="0" min="0" max="5" data-agent="analyst" onchange="updateTeamPreview()">
                                        <button type="button" class="qty-btn qty-plus" onclick="adjustAgentQty('analyst', 1)">+</button>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div class="workflow-preview">
                            <div class="workflow-preview-title">Command Structure</div>
                            <div class="workflow-diagram">
                                <div class="commander-node">
                                    <span class="node-icon"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><circle cx="12" cy="12" r="3"/></svg></span>
                                    <span class="node-name">Orchestrator</span>
                                </div>
                                <div class="command-line"></div>
                                <div class="team-nodes" id="team-preview">
                                    <div class="team-node">Researcher</div>
                                    <div class="team-node">Coder</div>
                                    <div class="team-node">Worker</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button class="btn btn-secondary" onclick="closeAgentModal()">Cancel</button>
                    <button class="btn btn-primary" id="launch-btn" onclick="submitAgent()">Launch Agent</button>
                </div>
            </div>
        </div>

        <!-- Merge & Spawn Modal -->
        <div class="modal-overlay" id="merge-spawn-modal" onclick="if(event.target === this) closeMergeSpawnModal()">
            <div class="modal modal-large">
                <div class="modal-header">
                    <span class="modal-title"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle; margin-right: 8px;"><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M23 21v-2a4 4 0 0 0-3-3.87"/><path d="M16 3.13a4 4 0 0 1 0 7.75"/></svg>Merge &amp; Spawn</span>
                    <button class="modal-close" onclick="closeMergeSpawnModal()">&times;</button>
                </div>
                <div class="modal-body">
                    <div class="form-group">
                        <label class="form-label">Selected Agents</label>
                        <div class="merge-agent-list" id="merge-agent-list"></div>
                    </div>

                    <div class="form-group">
                        <label class="form-label">Agent Role <span class="required">*</span></label>
                        <div class="role-selector" id="merge-role-selector">
                            <div class="role-option selected" data-role="worker" onclick="selectMergeRole(this)">
                                <div class="role-icon"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/></svg></div>
                                <div class="role-name">Worker</div>
                                <div class="role-desc">Execute tasks efficiently</div>
                            </div>
                            <div class="role-option" data-role="researcher" onclick="selectMergeRole(this)">
                                <div class="role-icon"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/></svg></div>
                                <div class="role-name">Researcher</div>
                                <div class="role-desc">Deep investigation</div>
                            </div>
                            <div class="role-option" data-role="coder" onclick="selectMergeRole(this)">
                                <div class="role-icon"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="16 18 22 12 16 6"/><polyline points="8 6 2 12 8 18"/></svg></div>
                                <div class="role-name">Coder</div>
                                <div class="role-desc">Write & modify code</div>
                            </div>
                            <div class="role-option" data-role="analyst" onclick="selectMergeRole(this)">
                                <div class="role-icon"><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="20" x2="18" y2="10"/><line x1="12" y1="20" x2="12" y2="4"/><line x1="6" y1="20" x2="6" y2="14"/></svg></div>
                                <div class="role-name">Analyst</div>
                                <div class="role-desc">Data & strategic insights</div>
                            </div>
                        </div>
                    </div>

                    <div class="form-group">
                        <label class="form-label">Task Description <span class="required">*</span></label>
                        <textarea class="form-input form-textarea" id="merge-task-input" placeholder="What should this agent do with the combined context from the selected agents?"></textarea>
                    </div>

                    <div class="form-group">
                        <label class="form-label">Timeout</label>
                        <div class="timeout-selector" id="merge-timeout-selector">
                            <button type="button" class="timeout-btn" data-timeout="1800" onclick="selectMergeTimeout(this)">30 min</button>
                            <button type="button" class="timeout-btn active" data-timeout="3600" onclick="selectMergeTimeout(this)">1 hour</button>
                            <button type="button" class="timeout-btn" data-timeout="14400" onclick="selectMergeTimeout(this)">4 hours</button>
                            <button type="button" class="timeout-btn" data-timeout="0" onclick="selectMergeTimeout(this)">Unlimited</button>
                        </div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button class="btn btn-secondary" onclick="closeMergeSpawnModal()">Cancel</button>
                    <button class="btn btn-primary" onclick="submitMergeSpawn()">Merge &amp; Spawn</button>
                </div>
            </div>
        </div>

        <!-- Home Detail Modal (universal) -->
        <div class="modal-overlay" id="home-detail-modal" onclick="if(event.target === this) closeHomeDetail()">
            <div class="modal home-detail-modal">
                <div class="detail-header" id="detail-header">
                    <div class="detail-header-info">
                        <span class="detail-icon" id="detail-icon"></span>
                        <div class="detail-titles">
                            <div class="detail-title" id="detail-title"></div>
                            <div class="detail-subtitle" id="detail-subtitle"></div>
                        </div>
                    </div>
                    <button class="modal-close" onclick="closeHomeDetail()">&times;</button>
                </div>
                <div class="detail-body" id="detail-body"></div>
                <div class="detail-footer" id="detail-footer"></div>
            </div>
        </div>

        <!-- Device Detail Modal -->
        <div class="modal-overlay" id="device-detail-modal" onclick="if(event.target === this) closeDeviceModal()">
            <div class="modal device-modal">
                <div class="detail-header" id="device-detail-header">
                    <div class="detail-header-info">
                        <span class="detail-icon" id="device-detail-icon">&#x1F4BB;</span>
                        <div class="detail-titles">
                            <div class="detail-title" id="device-detail-title"></div>
                            <div class="detail-subtitle" id="device-detail-subtitle"></div>
                        </div>
                    </div>
                    <button class="modal-close" onclick="closeDeviceModal()">&times;</button>
                </div>
                <div class="detail-body" style="padding: 16px;">
                    <div class="device-modal-section" id="device-status-section">
                        <div class="device-modal-section-title">Status</div>
                        <div style="display:flex; align-items:center; gap:12px;">
                            <span class="device-status-badge" id="device-detail-badge"></span>
                            <button class="btn-test-connection" id="device-test-btn" onclick="testDeviceConnection()">Test Connection</button>
                            <button class="btn-test-connection" id="device-detect-btn" onclick="autoDetectDevice()" style="background:var(--accent-muted); color:var(--accent);">Auto-detect</button>
                        </div>
                        <div class="device-detect-results" id="device-detect-results" style="display:none; margin-top:8px; padding:10px; border-radius:8px; background:var(--bg-secondary); font-size:0.78rem;"></div>
                        <div class="ping-results" id="device-ping-results" style="display:none;"></div>
                        <div class="device-connection-log" id="device-connection-log">
                            <span class="connection-log-dot" id="connection-log-dot"></span>
                            <span class="connection-log-text" id="connection-log-text"></span>
                            <span class="connection-log-time" id="connection-log-time"></span>
                        </div>
                    </div>
                    <div class="device-modal-section" id="device-stats-section" style="display:none;">
                        <div class="device-modal-section-title">System</div>
                        <div class="device-stats-bar">
                            <div class="device-stat-item"><div class="device-stat-label">CPU</div><div class="device-stat-value" id="device-stat-cpu"><span class="stat-loading"></span></div></div>
                            <div class="device-stat-item"><div class="device-stat-label">RAM</div><div class="device-stat-value" id="device-stat-ram"><span class="stat-loading"></span></div></div>
                            <div class="device-stat-item"><div class="device-stat-label">Disk</div><div class="device-stat-value" id="device-stat-disk"><span class="stat-loading"></span></div></div>
                            <div class="device-stat-item"><div class="device-stat-label">Uptime</div><div class="device-stat-value" id="device-stat-uptime"><span class="stat-loading"></span></div></div>
                        </div>
                    </div>
                    <div class="device-modal-section" id="device-info-section">
                        <div class="device-modal-section-title">Device Info</div>
                        <div id="device-info-grid"></div>
                    </div>
                    <div class="device-modal-section">
                        <div class="device-modal-section-title">Editable Fields</div>
                        <label style="font-size:0.75rem; color:var(--text-secondary); display:block; margin-bottom:4px;">Friendly Name</label>
                        <input type="text" id="device-edit-name" style="width:100%; padding:6px 10px; border-radius:8px; border:1px solid var(--border); background:var(--bg-secondary); color:var(--text-primary); font-size:0.82rem; margin-bottom:8px;">
                        <label style="font-size:0.75rem; color:var(--text-secondary); display:block; margin-bottom:4px;">Description</label>
                        <input type="text" id="device-edit-desc" style="width:100%; padding:6px 10px; border-radius:8px; border:1px solid var(--border); background:var(--bg-secondary); color:var(--text-primary); font-size:0.82rem;">
                    </div>
                    <div class="device-modal-section">
                        <div class="device-modal-section-title">SSH Configuration</div>
                        <div style="font-size:0.7rem; color:var(--text-secondary); margin-bottom:8px; opacity:0.7;">Set Host/IP for ping testing and remote access</div>
                        <div class="ssh-config-grid">
                            <div><label>Host / IP</label><input type="text" id="device-ssh-host" placeholder="e.g. 192.168.1.100"></div>
                            <div><label>Port</label><input type="number" id="device-ssh-port" placeholder="22" value="22"></div>
                            <div><label>Username</label><input type="text" id="device-ssh-user" placeholder="e.g. user"></div>
                            <div><label>Key Path</label><input type="text" id="device-ssh-key" placeholder="~/.ssh/id_rsa"></div>
                        </div>
                    </div>
                    <div class="device-modal-section">
                        <div class="device-modal-section-title">Recent Activity</div>
                        <div class="device-activity-split">
                            <div>
                                <div class="device-activity-col-title">SSH Commands</div>
                                <div id="device-cmd-list"><div class="device-activity-empty">Loading...</div></div>
                            </div>
                            <div>
                                <div class="device-activity-col-title">Agent Runs</div>
                                <div id="device-agent-list"><div class="device-activity-empty">Loading...</div></div>
                            </div>
                        </div>
                    </div>
                    <div class="device-modal-section terminal-section" id="terminal-section">
                        <div class="device-modal-section-title" style="display:flex; justify-content:space-between; align-items:center;">
                            <span>Remote Terminal</span>
                            <button class="terminal-clear-btn" onclick="clearTerminalOutput()">Clear</button>
                        </div>
                        <div class="terminal-ssh-warning" id="terminal-ssh-warning">
                            SSH not configured for this device. Set Host/IP and Username above to enable remote commands.
                        </div>
                        <div id="terminal-active-area">
                            <div class="terminal-output" id="terminal-output"></div>
                            <div class="terminal-input-row">
                                <input type="text" id="terminal-input" placeholder="Type a command..." onkeydown="handleTerminalKeydown(event)" autocomplete="off" spellcheck="false">
                                <button class="terminal-run-btn" id="terminal-run-btn" onclick="executeTerminalCommand()">Run</button>
                            </div>
                            <div class="terminal-status-bar">
                                <span id="terminal-status"><span class="terminal-status-dot ready"></span>Ready</span>
                                <span id="terminal-cmd-count"></span>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="detail-footer" style="padding: 12px 16px; display:flex; gap:10px; justify-content:flex-end; border-top:1px solid var(--border);">
                    <button class="detail-action-btn" onclick="closeDeviceModal()">Cancel</button>
                    <button class="detail-action-btn primary" onclick="saveDeviceChanges()">Save Changes</button>
                </div>
            </div>
        </div>

        <!-- Add Device Modal -->
        <div class="modal-overlay" id="add-device-modal" onclick="if(event.target === this) closeAddDeviceModal()">
            <div class="modal device-modal">
                <div class="modal-header">
                    <span class="modal-title">&#x2795; Add Device</span>
                    <button class="device-help-btn" onclick="event.stopPropagation(); toggleDeviceHelp(this)" title="Help" style="margin-left:auto; margin-right:8px;">?<div class="device-help-dropdown" onclick="event.stopPropagation()"><strong>Device SSH Setup</strong><br>To connect to remote devices, enable SSH key sharing:<br><br>Go to <span class="device-help-path">Settings</span> &rarr; <span class="device-help-path">File Access</span> &rarr; enable the <span class="device-help-path">Devices</span> preset, then restart when prompted.</div></button>
                    <button class="modal-close" onclick="closeAddDeviceModal()">&times;</button>
                </div>
                <div style="padding: 16px;">
                    <div class="add-device-form">
                        <label>Hostname <span style="color:var(--red);">*</span></label>
                        <input type="text" id="add-device-hostname" placeholder="e.g. my-server-01" required>
                        <label>Friendly Name</label>
                        <input type="text" id="add-device-name" placeholder="e.g. My Development Server">
                        <label>Device Type</label>
                        <select id="add-device-type">
                            <option value="unknown">Auto-detect on first ping</option>
                            <option value="gpu_server">GPU Server</option>
                            <option value="gpu_workstation">GPU Workstation</option>
                            <option value="server">Server</option>
                            <option value="desktop">Desktop</option>
                            <option value="mac_apple_silicon">Mac (Apple Silicon)</option>
                            <option value="mac_intel">Mac (Intel)</option>
                            <option value="arm_server">ARM Server</option>
                            <option value="sbc">SBC (Pi, Jetson, etc.)</option>
                            <option value="windows_pc">Windows PC</option>
                            <option value="linux_pc">Linux PC</option>
                            <option value="linux_server">Linux Server</option>
                            <option value="linux_laptop">Linux Laptop</option>
                        </select>
                        <label>Description</label>
                        <input type="text" id="add-device-desc" placeholder="Brief description">
                        <div style="margin-top:14px; padding-top:14px; border-top:1px solid var(--border);">
                            <div class="device-modal-section-title">SSH Configuration (optional)</div>
                            <div class="ssh-config-grid" style="margin-top:8px;">
                                <div><label>Host / IP</label><input type="text" id="add-device-ssh-host" placeholder="e.g. 192.168.1.100"></div>
                                <div><label>Port</label><input type="number" id="add-device-ssh-port" placeholder="22" value="22"></div>
                                <div><label>Username</label><input type="text" id="add-device-ssh-user" placeholder="e.g. user"></div>
                                <div><label>Key Path</label><input type="text" id="add-device-ssh-key" placeholder="~/.ssh/id_rsa"></div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="detail-footer" style="padding: 12px 16px; display:flex; gap:10px; justify-content:flex-end; border-top:1px solid var(--border);">
                    <button class="detail-action-btn" onclick="closeAddDeviceModal()">Cancel</button>
                    <button class="detail-action-btn primary" onclick="submitAddDevice()">Add Device</button>
                </div>
            </div>
        </div>

        <!-- Agent Detail Modal (legacy, replaced by page) -->
        <div class="modal-overlay" id="agent-detail-modal" style="display: none !important;"></div>

        <!-- Thought Detail Modal - Shows full thought when clicking activity items -->
        <div class="modal-overlay" id="thought-detail-modal" onclick="if(event.target === this) closeThoughtDetail()"></div>

        <!-- Automation Modal -->
        <div class="modal-overlay" id="automation-modal" onclick="if(event.target === this) closeAutomationModal()">
            <div class="modal modal-large">
                <div class="modal-header">
                    <span class="modal-title"> Create Automation</span>
                    <button class="modal-close" onclick="closeAutomationModal()">&times;</button>
                </div>
                <div class="modal-body">
                    <!-- Name -->
                    <div class="form-group">
                        <label class="form-label">Name</label>
                        <input class="form-input" id="automation-name" placeholder="Daily Research Summary">
                    </div>

                    <!-- Agent Type Selector -->
                    <div class="form-group">
                        <label class="form-label">Agent Type</label>
                        <div class="role-selector" id="automation-agent-selector">
                            <div class="role-option selected" data-role="researcher" onclick="selectAutomationAgent('researcher')">
                                <span class="role-icon"></span>
                                <span class="role-name">Researcher</span>
                            </div>
                            <div class="role-option" data-role="coder" onclick="selectAutomationAgent('coder')">
                                <span class="role-icon"></span>
                                <span class="role-name">Coder</span>
                            </div>
                            <div class="role-option" data-role="worker" onclick="selectAutomationAgent('worker')">
                                <span class="role-icon"></span>
                                <span class="role-name">Worker</span>
                            </div>
                            <div class="role-option" data-role="analyst" onclick="selectAutomationAgent('analyst')">
                                <span class="role-icon"></span>
                                <span class="role-name">Analyst</span>
                            </div>
                        </div>
                    </div>

                    <!-- Prompt/Task -->
                    <div class="form-group">
                        <label class="form-label">Task/Prompt</label>
                        <textarea class="form-input form-textarea" id="automation-prompt" placeholder="Describe what you want the agent to do..."></textarea>
                    </div>

                    <!-- Schedule Type Toggle -->
                    <div class="form-group">
                        <label class="form-label">Schedule</label>
                        <div class="schedule-type-toggle">
                            <button class="toggle-btn active" data-type="once" onclick="selectScheduleType('once')">One-Time</button>
                            <button class="toggle-btn" data-type="recurring" onclick="selectScheduleType('recurring')">Recurring</button>
                        </div>
                    </div>

                    <!-- Frequency (for recurring) -->
                    <div class="form-group recurring-options hidden" id="recurring-options">
                        <label class="form-label">Frequency</label>
                        <select class="form-input" id="automation-frequency" onchange="updateFrequencyOptions()">
                            <option value="daily">Daily</option>
                            <option value="weekly">Weekly</option>
                            <option value="monthly">Monthly</option>
                            <option value="custom">Custom (Cron)</option>
                        </select>
                    </div>

                    <!-- Time Picker -->
                    <div class="form-row">
                        <div class="form-group form-half" id="date-group">
                            <label class="form-label">Date</label>
                            <input type="date" class="form-input" id="automation-date">
                        </div>
                        <div class="form-group form-half">
                            <label class="form-label">Time</label>
                            <input type="time" class="form-input" id="automation-time" value="09:00">
                        </div>
                    </div>

                    <!-- Days of Week (for weekly) -->
                    <div class="form-group weekly-options hidden" id="weekly-options">
                        <label class="form-label">Days</label>
                        <div class="day-selector">
                            <button class="day-btn" data-day="0" onclick="toggleAutomationDay(0)">S</button>
                            <button class="day-btn active" data-day="1" onclick="toggleAutomationDay(1)">M</button>
                            <button class="day-btn active" data-day="2" onclick="toggleAutomationDay(2)">T</button>
                            <button class="day-btn active" data-day="3" onclick="toggleAutomationDay(3)">W</button>
                            <button class="day-btn active" data-day="4" onclick="toggleAutomationDay(4)">T</button>
                            <button class="day-btn active" data-day="5" onclick="toggleAutomationDay(5)">F</button>
                            <button class="day-btn" data-day="6" onclick="toggleAutomationDay(6)">S</button>
                        </div>
                    </div>

                    <!-- Cron Expression (for custom) -->
                    <div class="form-group cron-options hidden" id="cron-options">
                        <label class="form-label">Cron Expression</label>
                        <input class="form-input" id="automation-cron" placeholder="0 9 * * *">
                        <small style="color: var(--text-muted); font-size: 0.75rem;">Format: minute hour day month weekday</small>
                    </div>

                    <!-- Enabled toggle -->
                    <div class="form-group">
                        <label class="toggle-row">
                            <input type="checkbox" id="automation-enabled" checked>
                            <span>Enable immediately</span>
                        </label>
                    </div>

                    <!-- Timeout -->
                    <div class="form-group">
                        <label class="form-label">Timeout</label>
                        <div class="timeout-selector" id="automation-timeout-selector">
                            <button type="button" class="timeout-btn" data-timeout="1800" onclick="selectAutomationTimeout(this)">30 min</button>
                            <button type="button" class="timeout-btn active" data-timeout="3600" onclick="selectAutomationTimeout(this)">1 hour</button>
                            <button type="button" class="timeout-btn" data-timeout="14400" onclick="selectAutomationTimeout(this)">4 hours</button>
                            <button type="button" class="timeout-btn" data-timeout="0" onclick="selectAutomationTimeout(this)">Unlimited</button>
                        </div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button class="btn btn-secondary" onclick="closeAutomationModal()">Cancel</button>
                    <button class="btn btn-primary" onclick="createAutomation()">Create Automation</button>
                </div>
            </div>
        </div>

        <!-- Task Wizard Modal -->
        <div class="modal-overlay" id="task-wizard-modal" onclick="if(event.target === this) closeTaskWizard()">
            <div class="task-wizard">
                <div class="wizard-header">
                    <div class="wizard-header-content">
                        <div class="wizard-icon" id="wizard-icon"></div>
                        <div class="wizard-title-area">
                            <h2 class="wizard-title" id="wizard-title">Task Overview</h2>
                            <div class="wizard-subtitle" id="wizard-subtitle">Review before launching</div>
                        </div>
                    </div>
                    <button class="modal-close" onclick="closeTaskWizard()">&times;</button>
                </div>

                <div class="wizard-body">
                    <!-- Task Description -->
                    <div class="wizard-section">
                        <div class="wizard-section-title"> Task Description</div>
                        <div class="wizard-task-box" id="wizard-task-description">
                            Loading task details...
                        </div>
                    </div>

                    <!-- Analytics Grid -->
                    <div class="wizard-analytics">
                        <div class="analytics-card">
                            <div class="analytics-icon"></div>
                            <div class="analytics-content">
                                <div class="analytics-value" id="wizard-duration">~5 min</div>
                                <div class="analytics-label">Estimated Time</div>
                            </div>
                        </div>
                        <div class="analytics-card">
                            <div class="analytics-icon"></div>
                            <div class="analytics-content">
                                <div class="analytics-value" id="wizard-confidence">85%</div>
                                <div class="analytics-label">Success Rate</div>
                            </div>
                        </div>
                        <div class="analytics-card">
                            <div class="analytics-icon"></div>
                            <div class="analytics-content">
                                <div class="analytics-value" id="wizard-tools">4</div>
                                <div class="analytics-label">Tools Needed</div>
                            </div>
                        </div>
                        <div class="analytics-card">
                            <div class="analytics-icon"></div>
                            <div class="analytics-content">
                                <div class="analytics-value" id="wizard-complexity">Medium</div>
                                <div class="analytics-label">Complexity</div>
                            </div>
                        </div>
                    </div>

                    <!-- Mode Toggle: Single Agent vs Orchestrator -->
                    <div class="wizard-mode-toggle">
                        <button class="mode-btn active" id="mode-single" onclick="setWizardMode('single')">
                            <span class="mode-btn-icon"></span>
                            <span>Single Agent</span>
                        </button>
                        <button class="mode-btn" id="mode-orchestrator" onclick="setWizardMode('orchestrator')">
                            <span class="mode-btn-icon"></span>
                            <span>Mother Agent</span>
                        </button>
                    </div>

                    <!-- ============ SINGLE AGENT CONFIG ============ -->
                    <div class="single-agent-config" id="single-agent-config">
                        <!-- Recommended Agent -->
                        <div class="wizard-section">
                            <div class="wizard-section-title"> Recommended Agent</div>
                        <div class="wizard-agent-recommendation" id="wizard-agent-rec">
                            <div class="rec-agent-card selected" id="rec-agent-display">
                                <div class="rec-agent-icon"></div>
                                <div class="rec-agent-info">
                                    <div class="rec-agent-name">Researcher</div>
                                    <div class="rec-agent-reason">Best for investigation and analysis tasks</div>
                                </div>
                                <div class="rec-agent-badge">Recommended</div>
                            </div>
                        </div>

                        <!-- Agent Selection Override -->
                        <div class="wizard-agent-override">
                            <span class="override-label">Or choose different:</span>
                            <div class="override-options">
                                <button class="override-btn" data-type="worker" onclick="selectWizardAgent('worker')"> Worker</button>
                                <button class="override-btn" data-type="researcher" onclick="selectWizardAgent('researcher')"> Researcher</button>
                                <button class="override-btn" data-type="coder" onclick="selectWizardAgent('coder')"> Coder</button>
                                <button class="override-btn" data-type="analyst" onclick="selectWizardAgent('analyst')"> Analyst</button>
                            </div>
                        </div>
                        </div>
                    </div>

                    <!-- ============ ORCHESTRATOR CONFIG ============ -->
                    <div class="orchestrator-config" id="orchestrator-config">
                        <!-- Workflow Type Selection -->
                        <div class="wizard-section">
                            <div class="wizard-section-title"> Workflow Strategy</div>
                            <div class="workflow-type-grid">
                                <div class="workflow-type-card selected" data-type="standard" onclick="selectWizardWorkflowType('standard')">
                                    <div class="workflow-type-icon"></div>
                                    <div class="workflow-type-name">Standard</div>
                                    <div class="workflow-type-desc">Mother decides how to delegate dynamically</div>
                                </div>
                                <div class="workflow-type-card" data-type="parallel" onclick="selectWizardWorkflowType('parallel')">
                                    <div class="workflow-type-icon"></div>
                                    <div class="workflow-type-name">Parallel</div>
                                    <div class="workflow-type-desc">All agents work simultaneously</div>
                                </div>
                                <div class="workflow-type-card" data-type="sequential" onclick="selectWizardWorkflowType('sequential')">
                                    <div class="workflow-type-icon"></div>
                                    <div class="workflow-type-name">Sequential</div>
                                    <div class="workflow-type-desc">Chain of handoffs between agents</div>
                                </div>
                            </div>
                        </div>

                        <!-- Team Composition -->
                        <div class="wizard-section team-composition">
                            <div class="wizard-section-title"> Team Composition</div>
                            <div class="team-grid">
                                <div class="team-member-card selected" data-agent="researcher" onclick="toggleTeamMember('researcher')">
                                    <div class="team-member-checkbox"></div>
                                    <div class="team-member-icon"></div>
                                    <div class="team-member-info">
                                        <div class="team-member-name">Researcher</div>
                                        <div class="team-member-role">Investigation & analysis</div>
                                    </div>
                                </div>
                                <div class="team-member-card selected" data-agent="coder" onclick="toggleTeamMember('coder')">
                                    <div class="team-member-checkbox"></div>
                                    <div class="team-member-icon"></div>
                                    <div class="team-member-info">
                                        <div class="team-member-name">Coder</div>
                                        <div class="team-member-role">Code writing & modification</div>
                                    </div>
                                </div>
                                <div class="team-member-card" data-agent="worker" onclick="toggleTeamMember('worker')">
                                    <div class="team-member-checkbox"></div>
                                    <div class="team-member-icon"></div>
                                    <div class="team-member-info">
                                        <div class="team-member-name">Worker</div>
                                        <div class="team-member-role">Quick task execution</div>
                                    </div>
                                </div>
                                <div class="team-member-card" data-agent="analyst" onclick="toggleTeamMember('analyst')">
                                    <div class="team-member-checkbox"></div>
                                    <div class="team-member-icon"></div>
                                    <div class="team-member-info">
                                        <div class="team-member-name">Analyst</div>
                                        <div class="team-member-role">Data & strategic insights</div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Workflow Preview -->
                        <div class="wizard-section">
                            <div class="workflow-preview">
                                <div class="workflow-preview-title">Workflow Preview</div>
                                <div class="workflow-diagram" id="workflow-diagram">
                                    <!-- Mother Agent -->
                                    <div class="workflow-mother">
                                        <span class="mother-icon"></span>
                                        <div class="mother-info">
                                            <div class="mother-name">Orchestrator</div>
                                            <div class="mother-role">Coordinates & synthesizes</div>
                                        </div>
                                    </div>

                                    <!-- Connection -->
                                    <div class="workflow-connector">
                                        <div class="connector-line"></div>
                                        <div class="connector-arrows">
                                            <span class="connector-arrow"></span>
                                            <span class="connector-arrow"></span>
                                        </div>
                                    </div>

                                    <!-- Child Agents -->
                                    <div class="workflow-children" id="workflow-children">
                                        <div class="workflow-child">
                                            <span class="child-icon"></span>
                                            <span class="child-name">Researcher</span>
                                        </div>
                                        <div class="workflow-child">
                                            <span class="child-icon"></span>
                                            <span class="child-name">Coder</span>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- What Will Happen -->
                    <div class="wizard-section">
                        <div class="wizard-section-title"> What Will Happen</div>
                        <div class="wizard-steps" id="wizard-steps">
                            <div class="wizard-step">
                                <div class="step-number">1</div>
                                <div class="step-content">
                                    <div class="step-title">Analyze Request</div>
                                    <div class="step-desc">Agent parses the task and plans approach</div>
                                </div>
                            </div>
                            <div class="wizard-step">
                                <div class="step-number">2</div>
                                <div class="step-content">
                                    <div class="step-title">Gather Information</div>
                                    <div class="step-desc">Search files, read docs, query APIs</div>
                                </div>
                            </div>
                            <div class="wizard-step">
                                <div class="step-number">3</div>
                                <div class="step-content">
                                    <div class="step-title">Execute Actions</div>
                                    <div class="step-desc">Run commands, write code, make changes</div>
                                </div>
                            </div>
                            <div class="wizard-step">
                                <div class="step-number">4</div>
                                <div class="step-content">
                                    <div class="step-title">Deliver Results</div>
                                    <div class="step-desc">Compile output and recommendations</div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Tools That May Be Used -->
                    <div class="wizard-section">
                        <div class="wizard-section-title"> Tools Available</div>
                        <div class="wizard-tools-grid" id="wizard-tools-list">
                            <div class="wizard-tool"><span></span> Read</div>
                            <div class="wizard-tool"><span></span> Edit</div>
                            <div class="wizard-tool"><span></span> Grep</div>
                            <div class="wizard-tool"><span></span> Glob</div>
                            <div class="wizard-tool"><span></span> Bash</div>
                            <div class="wizard-tool"><span></span> WebSearch</div>
                        </div>
                    </div>
                </div>

                <div class="wizard-footer">
                    <button class="btn btn-secondary" onclick="closeTaskWizard()">Cancel</button>
                    <div class="wizard-actions">
                        <button class="btn btn-outline" onclick="launchWizardChat()">
                             Start Chat Instead
                        </button>
                        <button class="btn btn-primary btn-glow" id="wizard-launch-btn" onclick="launchWizardAgent()">
                             Launch Agent
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Quick Command Modal -->
        <div class="command-modal" id="command-modal" onclick="if(event.target === this) closeQuickCommand()">
            <div class="command-box">
                <input type="text" class="command-input" id="command-input" placeholder="Enter command..." onkeydown="if(event.key==='Enter')runQuickCommand(this.value)">
                <div class="command-suggestions">
                    <div class="command-suggestion" onclick="runQuickCommand('start chrome')">Chrome</div>
                    <div class="command-suggestion" onclick="runQuickCommand('code .')"> VS Code</div>
                    <div class="command-suggestion" onclick="runQuickCommand(CEREBRO_DATA_DIR ? 'explorer ' + CEREBRO_DATA_DIR : 'echo No data dir configured')"> AI Memory</div>
                    <div class="command-suggestion" onclick="runQuickCommand('start chrome https://github.com')"> GitHub</div>
                    <div class="command-suggestion" onclick="runQuickCommand('git status')"> Git Status</div>
                    <div class="command-suggestion" onclick="closeQuickCommand()"> Cancel</div>
                </div>
            </div>
        </div>

        <!-- Agent Detail Modal (Centered with blur backdrop) -->
        <div class="agent-detail-page" id="agent-detail-page" onclick="if(event.target===this)closeAgentDetailPage()" style="display:none !important">
            <div class="agent-detail-modal" onclick="event.stopPropagation()">
                <div class="agent-detail-modal-header">
                    <span class="agent-title" id="agent-page-title">Agent Details</span>
                    <span class="agent-status-badge" id="agent-page-status">COMPLETED</span>
                    <button class="modal-close-btn" onclick="closeAgentDetailPage()" title="Close">&times;</button>
                </div>

                <!-- Chain navigation for linked agents -->
                <div class="agent-chain-nav" id="agent-chain-nav" style="display: none; margin: 0 16px;"></div>

                <!-- Scrollable content area - contains both output AND chat -->
                <div class="agent-detail-content" id="agent-page-content">
                    <!-- Agent output rendered here by JavaScript -->
                    <div id="agent-output-area"></div>

                    <!-- Inline Chat for Agent Questions (INSIDE scrollable area) -->
                    <div class="agent-chat-container" id="agent-chat-container">
                        <div class="agent-chat-messages" id="agent-chat-messages">
                            <!-- User questions and responses appear here -->
                        </div>
                    </div>
                </div>

                <!-- Quick Ask Input - inside modal flow, not fixed -->
                <div class="agent-ask-input-area" id="agent-ask-area" style="display: none;">
                    <input type="text" class="agent-ask-input" id="agent-ask-input" placeholder="Ask a question about this output..." onkeydown="if(event.key==='Enter')submitAgentQuestion()">
                    <button class="agent-ask-send" onclick="submitAgentQuestion()">Send</button>
                </div>

                <div class="agent-actions-footer" id="agent-actions-footer">
                    <!-- Agent Detail Actions (shown at root level) -->
                    <div id="agent-detail-footer-actions" style="width: 100%;">
                        <div style="display: flex; gap: 12px; width: 100%; margin-bottom: 12px;">
                            <input type="text" class="agent-ask-input" id="agent-ask-thread-input"
                                   placeholder="Ask a question about this output..."
                                   onkeydown="if(event.key==='Enter')submitNewThread()" style="flex:1;">
                            <button class="agent-ask-send" onclick="submitNewThread()">Ask</button>
                        </div>
                        <div class="followup-instructions-container" id="followup-instructions-container" style="display: none; width: 100%; margin-bottom: 12px;">
                            <textarea id="followup-instructions"
                                      placeholder="Add specific instructions for the agent (e.g., 'Execute option 1' or 'Focus on the TTS integration')..."
                                      rows="2"
                                      style="width: 100%; padding: 10px; border-radius: 8px; border: 1px solid var(--border); background: var(--bg-primary); color: var(--text-primary); font-size: 14px; resize: vertical; min-height: 50px;"></textarea>
                        </div>
                        <div style="display: flex; gap: 12px; width: 100%;">
                            <button class="agent-action-btn primary" id="followup-agent-btn" onclick="spawnFollowUpAgent()">
                                 Follow-up Command
                            </button>
                        </div>
                        <div class="rerun-link" id="rerun-link" onclick="executeAgentFollowUp()" style="display: none;">Re-run same agent</div>
                    </div>
                    <!-- Thread Reply Actions (shown when viewing a thread) -->
                    <div id="thread-reply-footer-actions" style="display: none; width: 100%;">
                        <div style="display: flex; gap: 12px; width: 100%;">
                            <input type="text" class="agent-ask-input" id="thread-reply-input"
                                   placeholder="Reply to this thread..."
                                   onkeydown="if(event.key==='Enter')submitThreadReply()" style="flex:1;">
                            <button class="agent-ask-send" onclick="submitThreadReply()">Reply</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Group Editor Overlay -->
        <div class="group-editor-overlay" id="group-editor-overlay" onclick="if(event.target===this)closeGroupEditor()">
            <div class="group-editor-modal" onclick="event.stopPropagation()">
                <div class="group-editor-header">
                    <span class="group-editor-title">Edit Agent Groups</span>
                    <button class="modal-close-btn" onclick="closeGroupEditor()" title="Close">&times;</button>
                </div>
                <div class="group-editor-body" id="group-editor-body">
                    <!-- Populated by renderGroupEditorContent() -->
                </div>
                <div class="group-editor-footer" style="flex-direction: column; gap: 10px;">
                    <div style="display: flex; gap: 10px; width: 100%; justify-content: space-between;">
                        <button class="group-new-btn" onclick="createGroupFromEditor()">+ New Group</button>
                        <button class="btn btn-secondary" onclick="closeGroupEditor()">Done</button>
                    </div>
                    <div class="group-clear-section">
                        <span class="group-clear-hint">Starred agents are protected from clearing</span>
                        <button class="group-clear-btn" onclick="clearAgentsForTheDay()">Clear Agents for the Day</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Bulk Assign Group Modal -->
        <div class="group-editor-overlay" id="bulk-assign-overlay" onclick="if(event.target===this)closeBulkAssignModal()" style="z-index: 10001;">
            <div class="group-editor-modal" style="max-width: 400px; max-height: 50vh;" onclick="event.stopPropagation()">
                <div class="group-editor-header">
                    <span class="group-editor-title">Move to Group</span>
                    <button class="modal-close-btn" onclick="closeBulkAssignModal()">&times;</button>
                </div>
                <div class="group-editor-body" id="bulk-assign-body">
                    <!-- Populated by showBulkAssignGroupModal() -->
                </div>
            </div>
        </div>

        <!-- Agent Chat Page (Full Screen Dedicated Chat) -->
        <div class="agent-chat-page" id="agent-chat-page">
            <div class="agent-chat-page-header">
                <button class="back-btn" onclick="closeAgentChatPage()"> Back</button>
                <span class="agent-chat-page-title" id="agent-chat-page-title">Chat with Agent</span>
                <span class="agent-status-badge" id="agent-chat-page-status">COMPLETED</span>
            </div>

            <!-- Collapsible Context Summary -->
            <div class="agent-context-summary" id="agent-context-summary">
                <div class="context-toggle" onclick="toggleContextSummary()">
                    <span class="context-toggle-icon" id="context-toggle-icon"></span>
                    <span>Agent Context</span>
                </div>
                <div class="context-details" id="context-details">
                    <div class="context-task" id="context-task"></div>
                    <div class="context-output-preview" id="context-output-preview"></div>
                </div>
            </div>

            <!-- Chat Messages Area -->
            <div class="agent-chat-messages-area" id="agent-chat-messages-area">
                <!-- Chat messages rendered here -->
            </div>

            <!-- Chat Input Area -->
            <div class="agent-chat-input-area">
                <input type="text" class="agent-chat-input" id="agent-chat-page-input"
                       placeholder="Ask about the agent's work..."
                       onkeydown="if(event.key==='Enter')submitAgentChatQuestion()">
                <button class="agent-chat-send-btn" onclick="submitAgentChatQuestion()">Send</button>
            </div>
        </div>
    </div>

    <script src="/static/socket.io.min.js"></script>
    <script>
        // ==================== CONFIGURATION ====================
        const CEREBRO_CONFIG = window.CEREBRO_CONFIG || {};
        const currentHost = window.location.hostname;
        const currentPort = window.location.port || '61000';
        const API_URL = CEREBRO_CONFIG.apiUrl || `http://${currentHost}:${currentPort}`;
        const CEREBRO_TTS_URL = CEREBRO_CONFIG.ttsUrl || '';
        const CEREBRO_DGX_HOST = CEREBRO_CONFIG.dgxHost || '';
        const CEREBRO_DATA_DIR = CEREBRO_CONFIG.dataDir || '';
        const CEREBRO_CDP_URL = CEREBRO_CONFIG.cdpUrl || 'http://localhost:9222';
        let CEREBRO_USERNAME = CEREBRO_CONFIG.username || '';

        console.log('Cerebro connecting to:', API_URL);

        let token = localStorage.getItem('cerebro_token');
        let socket = null;
        let sessionId = null;
        // TTS Configuration
        const TTS_URL = CEREBRO_TTS_URL || `http://${currentHost}:8880`;
        const TTS_CONFIG = { voice: localStorage.getItem("cerebro_tts_voice") || "af_heart", speed: parseFloat(localStorage.getItem("cerebro_tts_speed") || "1.0"), format: "mp3", autoSpeak: localStorage.getItem("cerebro_tts_autospeak") === "true" };
        let currentAudio = null;
        let isSpeaking = false;
        let conversationalMode = false;

        // Chat layout state
        let _chatSplitMode = false;

        // ==================== AUTH ====================
        async function login() {
            const password = document.getElementById('password-input').value;
            const errorEl = document.getElementById('login-error');
            errorEl.style.display = 'none';

            try {
                const response = await fetch(`${API_URL}/auth/login`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ password })
                });

                if (!response.ok) {
                    throw new Error('Invalid password');
                }

                const data = await response.json();
                token = data.token;
                if (data.user) CEREBRO_USERNAME = data.user;
                localStorage.setItem('cerebro_token', token);
                showApp();
            } catch (e) {
                errorEl.textContent = e.message || 'Login failed';
                errorEl.style.display = 'block';
            }
        }

        function logout() {
            localStorage.removeItem('cerebro_token');
            token = null;
            location.reload();
        }

        function showApp() {
            document.getElementById('login-view').classList.add('hidden');
            document.getElementById('main-app').classList.remove('hidden');
            document.getElementById('server-url').textContent = API_URL.replace('http://', '');
            initApp();
        }

        // ==================== INIT ====================
        async function initApp() {
            updateDateTime();
            setInterval(updateDateTime, 60000);

            // Display app version from Electron
            if (window.cerebroDesktop && window.cerebroDesktop.getVersion) {
                try {
                    const ver = await window.cerebroDesktop.getVersion();
                    const el = document.getElementById('app-version');
                    if (el && ver) el.textContent = ver;
                } catch (_e) {}
            }

            // Restore auto-awake checkbox state from localStorage
            const autoAwakeCheckbox = document.getElementById('auto-awake-checkbox');
            if (autoAwakeCheckbox) {
                const saved = localStorage.getItem('cerebro_auto_awake');
                autoAwakeCheckbox.checked = saved === null ? true : saved === 'true';
            }

            // Initialize the living presence card
            initCerebroPresence();

            // Chat input is hidden via CSS by default, shown by _switchViewCore on chat tab

            // Load persistent chat history
            await loadChatHistory();

            await loadBriefing();
            loadHomepage(); // Non-blocking parallel homepage load
            await loadSmartSuggestions();
            await loadAgents();
            loadTemplatesFromBackend(); // Sync prompt templates
            await loadRecentAgents();
            await loadNotifications();
            await loadDirectives();
            await loadInsights();
            connectSocket();
            await fetchModelsFromServer();
            loadChatOffloadDevices();
            checkBrowserStatus();
            initChatLayout();
            loadAudioDevices();
            initVoiceSettings();
            loadPersonality();
            loadLookStatus();
            initFileAccess();

            // Init TTS orb click - stop speaking
            const navOrb = document.getElementById('nav-orb-container');
            if (navOrb) {
                navOrb.addEventListener('click', () => {
                    if (isSpeaking) { stopSpeaking(); return; }
                });
                navOrb.title = 'Click to stop speaking';
            }

            handleMobileKeyboard();

            // Refresh live activity every 15 seconds
            setInterval(loadLiveActivity, 15000);

            // Request notification permission for agent alerts (skip in standalone  libnotify crashes on Hyprland)
            if (!window.__STANDALONE && 'Notification' in window && Notification.permission === 'default') {
                Notification.requestPermission();
            }

            // Wire up credential expiry listeners (Electron desktop only)
            initCredentialWatcher();
        }

        // ==================== CREDENTIAL EXPIRY DETECTION ====================
        var _credModalShowing = false;

        function initCredentialWatcher() {
            if (!window.cerebroDesktop) return;

            window.cerebroDesktop.onCredentialsExpired(function(data) {
                console.warn('[Creds] Credentials expired, silent refresh was already attempted by watcher.');
                showCredentialModal(data.message || 'Your Claude session has expired.');
            });

            window.cerebroDesktop.onCredentialsRefreshed(function(data) {
                console.log('[Creds] Credentials refreshed, expires in', data.expiresIn, 'min');
                hideCredentialModal();
                if (data.silent) {
                    console.log('[Creds] Silent auto-refresh succeeded  no user action needed');
                } else {
                    showToast('Claude credentials refreshed (' + data.expiresIn + 'm remaining)', 'success');
                }
            });

            // Initial startup check  try silent refresh if needed
            window.cerebroDesktop.checkClaudeCredentials().then(function(status) {
                if (status && !status.valid && status.needsLogin) {
                    // Try silent refresh before showing modal
                    console.log('[Creds] Startup: credentials invalid, attempting silent refresh...');
                    window.cerebroDesktop.silentRefreshOAuth().then(function(result) {
                        if (result && result.success) {
                            console.log('[Creds] Startup silent refresh succeeded (' + result.expiresIn + 'm)');
                        } else {
                            console.warn('[Creds] Startup silent refresh failed:', result && result.error);
                            showCredentialModal(status.error || 'Claude credentials are missing or expired.');
                        }
                    }).catch(function() {
                        showCredentialModal(status.error || 'Claude credentials are missing or expired.');
                    });
                } else if (status && status.warning) {
                    // Expiring soon  try silent refresh proactively
                    window.cerebroDesktop.silentRefreshOAuth().then(function(result) {
                        if (result && result.success) {
                            console.log('[Creds] Proactive refresh succeeded (' + result.expiresIn + 'm)');
                        }
                    }).catch(function() {});
                }
            }).catch(function() {});
        }

        function showCredentialModal(message) {
            if (_credModalShowing) return;
            _credModalShowing = true;

            var overlay = document.createElement('div');
            overlay.className = 'cred-modal-overlay';
            overlay.id = 'cred-expiry-modal';

            var modal = document.createElement('div');
            modal.className = 'cred-modal';

            var icon = document.createElement('div');
            icon.className = 'cred-modal-icon';
            icon.textContent = '\uD83D\uDD12';

            var title = document.createElement('div');
            title.className = 'cred-modal-title';
            title.textContent = 'Authentication Required';

            var desc = document.createElement('div');
            desc.className = 'cred-modal-desc';
            desc.textContent = message || 'Your Claude session has expired. Please re-authenticate to continue using agents.';

            var actions = document.createElement('div');
            actions.className = 'cred-modal-actions';

            var dismissBtn = document.createElement('button');
            dismissBtn.className = 'cred-modal-btn-dismiss';
            dismissBtn.textContent = 'Later';
            dismissBtn.onclick = function() { hideCredentialModal(); };

            var loginBtn = document.createElement('button');
            loginBtn.className = 'cred-modal-btn-login';
            loginBtn.textContent = 'Re-authenticate';
            loginBtn.onclick = function() { launchClaudeLogin(); };

            actions.appendChild(dismissBtn);
            actions.appendChild(loginBtn);

            var status = document.createElement('div');
            status.className = 'cred-modal-status';
            status.id = 'cred-modal-status';

            modal.appendChild(icon);
            modal.appendChild(title);
            modal.appendChild(desc);
            modal.appendChild(actions);
            modal.appendChild(status);
            overlay.appendChild(modal);
            document.body.appendChild(overlay);
        }

        function hideCredentialModal() {
            _credModalShowing = false;
            var el = document.getElementById('cred-expiry-modal');
            if (el) el.remove();
        }

        function launchClaudeLogin() {
            if (!window.cerebroDesktop) {
                showToast('Run "claude auth login" in your terminal to re-authenticate.', 'info');
                return;
            }

            var statusEl = document.getElementById('cred-modal-status');
            if (statusEl) statusEl.textContent = 'Opening login...';

            window.cerebroDesktop.launchClaudeLogin().then(function(result) {
                if (result && result.success) {
                    if (statusEl) statusEl.textContent = 'Complete the login in the popup window. This will close automatically.';
                } else {
                    if (statusEl) statusEl.textContent = result.error || 'Could not start login. Run "claude auth login" in a terminal.';
                }
            }).catch(function(err) {
                if (statusEl) statusEl.textContent = 'Error: ' + (err.message || 'Unknown error');
            });
        }

        // ==================== HOMEPAGE DASHBOARD ====================

        async function loadHomepage() {
            await Promise.allSettled([
                loadBriefing(),
                loadSmartActions(),
                loadLiveActivity(),
                loadHomeGoals(),
                loadProjectTracker(),
                loadMemoryIntelligence(),
            ]);
        }

        const ACTION_ICONS = {
            rocket: '\u{1F680}', play: '\u25B6\uFE0F', target: '\u{1F3AF}', alert: '\u26A0\uFE0F', book: '\u{1F4DA}'
        };

        // ==================== SMOOTH CHAT TRANSITION + CONTEXT SYSTEM ====================
        let pendingChatContext = null;
        let isViewTransitioning = false;

        function openActionChat(contextData) {
            if (isViewTransitioning) return;
            pendingChatContext = typeof contextData === 'string'
                ? { rawText: contextData } : contextData;
            closeHomeDetail();
            setTimeout(function() {
                switchView('chat');
                setTimeout(function() {
                    if (pendingChatContext) injectContextBubble(pendingChatContext);
                }, 600);
            }, 320);
        }

        function slideToView(targetViewName, callback) {
            switchView(targetViewName);
            setTimeout(function() {
                if (callback) callback();
            }, 600);
        }

        function injectContextBubble(contextData) {
            var existing = document.querySelector('.message.context-system');
            if (existing) existing.parentNode.removeChild(existing);

            var bubble = document.createElement('div');
            bubble.className = 'message context-system';

            // Header
            var header = document.createElement('div');
            header.className = 'context-system-header';

            var label = document.createElement('div');
            label.className = 'context-system-label';
            var svgNS = 'http://www.w3.org/2000/svg';
            var svg = document.createElementNS(svgNS, 'svg');
            svg.setAttribute('viewBox', '0 0 16 16');
            var path = document.createElementNS(svgNS, 'path');
            path.setAttribute('d', 'M8 1a7 7 0 100 14A7 7 0 008 1zm0 2a1 1 0 110 2 1 1 0 010-2zm2 8H6v-1h1V7H6V6h3v4h1v1z');
            svg.appendChild(path);
            label.appendChild(svg);
            label.appendChild(document.createTextNode(' Context Loaded'));

            var dismissBtn = document.createElement('button');
            dismissBtn.className = 'context-system-dismiss';
            dismissBtn.textContent = '\u00D7';
            dismissBtn.onclick = function() { dismissContextBubble(bubble); };

            header.appendChild(label);
            header.appendChild(dismissBtn);
            bubble.appendChild(header);

            // Body
            var body = document.createElement('div');
            body.className = 'context-system-body';

            if (contextData.project) {
                var nameEl = document.createElement('div');
                nameEl.className = 'context-project-name';
                var iconSpan = document.createElement('span');
                iconSpan.className = 'ctx-icon';
                iconSpan.textContent = contextData.icon || '\u{1F4C1}';
                nameEl.appendChild(iconSpan);
                nameEl.appendChild(document.createTextNode(contextData.project));
                body.appendChild(nameEl);
            }

            if (contextData.summary) {
                body.appendChild(createContextField('Summary', contextData.summary));
            }

            if (contextData.next_action) {
                body.appendChild(createContextField('Next Action', contextData.next_action, 'next-action'));
            }

            if (contextData.description && !contextData.project) {
                body.appendChild(createContextField('Description', contextData.description));
            }

            if (contextData.title && !contextData.project) {
                body.appendChild(createContextField('Task', contextData.title));
            }

            if (contextData.key_files && contextData.key_files.length > 0) {
                var filesField = document.createElement('div');
                filesField.className = 'context-field';
                var filesLabel = document.createElement('div');
                filesLabel.className = 'context-field-label';
                filesLabel.textContent = 'Key Files';
                filesField.appendChild(filesLabel);
                var filesRow = document.createElement('div');
                filesRow.className = 'context-files-row';
                contextData.key_files.forEach(function(f) {
                    var pill = document.createElement('span');
                    pill.className = 'context-file-pill';
                    pill.textContent = f;
                    pill.title = f;
                    filesRow.appendChild(pill);
                });
                filesField.appendChild(filesRow);
                body.appendChild(filesField);
            }

            if (contextData.rawText && !contextData.project && !contextData.description && !contextData.title) {
                body.appendChild(createContextField('Context', contextData.rawText));
            }

            bubble.appendChild(body);

            var messages = document.getElementById('messages');
            if (messages) {
                messages.appendChild(bubble);
                scrollMessagesToBottom();
            }

            var chatInput = document.getElementById('chat-input');
            if (chatInput) chatInput.focus();
        }

        function createContextField(labelText, value, extraClass) {
            var field = document.createElement('div');
            field.className = 'context-field' + (extraClass ? ' ' + extraClass : '');
            var lbl = document.createElement('div');
            lbl.className = 'context-field-label';
            lbl.textContent = labelText;
            var val = document.createElement('div');
            val.className = 'context-field-value';
            val.textContent = value;
            field.appendChild(lbl);
            field.appendChild(val);
            return field;
        }

        function dismissContextBubble(bubble) {
            if (!bubble) return;
            bubble.classList.add('dismissing');
            setTimeout(function() {
                if (bubble.parentNode) bubble.parentNode.removeChild(bubble);
            }, 300);
            pendingChatContext = null;
        }

        // ==================== HOMEPAGE V2: UNIVERSAL DETAIL MODAL ====================
        function openHomeDetail(type, data) {
            var modal = document.getElementById('home-detail-modal');
            var header = document.getElementById('detail-header');
            var iconEl = document.getElementById('detail-icon');
            var titleEl = document.getElementById('detail-title');
            var subtitleEl = document.getElementById('detail-subtitle');
            var body = document.getElementById('detail-body');
            var footer = document.getElementById('detail-footer');

            header.className = 'detail-header type-' + type;

            var icons = { action: '\u{1F680}', goal: '\u{1F3AF}', project: '\u{1F4C1}', stat: '\u{1F4CA}', activity: '\u26A1' };
            iconEl.textContent = data.icon || icons[type] || '\u2139\uFE0F';
            titleEl.textContent = data.title || data.name || data.description || '';
            subtitleEl.textContent = data.subtitle || buildSubtitle(type, data);

            body.textContent = '';
            body.appendChild(buildDetailContent(type, data));

            footer.textContent = '';
            footer.appendChild(buildDetailActions(type, data));

            modal.classList.add('active');
        }

        function closeHomeDetail() {
            document.getElementById('home-detail-modal').classList.remove('active');
        }

        function buildSubtitle(type, data) {
            switch(type) {
                case 'action': return data.iconClass ? data.iconClass.charAt(0).toUpperCase() + data.iconClass.slice(1) + ' action' : 'Suggested action';
                case 'goal': return 'Priority: ' + (data.priority || 'medium');
                case 'project': return 'Status: ' + (data.status || 'unknown').replace(/_/g, ' ');
                case 'stat': return 'System metric';
                case 'activity': return data.type || 'Live service';
                default: return '';
            }
        }

        function buildDetailContent(type, data) {
            var frag = document.createDocumentFragment();

            if (type === 'stat') {
                var sec = document.createElement('div');
                sec.className = 'detail-section';
                var val = document.createElement('div');
                val.className = 'detail-section-content';
                val.style.fontSize = '2rem';
                val.style.fontWeight = '800';
                val.style.textAlign = 'center';
                val.style.padding = '10px 0';
                val.textContent = data.value || '--';
                sec.appendChild(val);
                frag.appendChild(sec);

                if (data.context) {
                    var ctx = document.createElement('div');
                    ctx.className = 'detail-section';
                    var lbl = document.createElement('div');
                    lbl.className = 'detail-section-label';
                    lbl.textContent = 'About';
                    ctx.appendChild(lbl);
                    var cnt = document.createElement('div');
                    cnt.className = 'detail-section-content';
                    cnt.textContent = data.context;
                    ctx.appendChild(cnt);
                    frag.appendChild(ctx);
                }
            }

            if (type === 'action') {
                if (data.description) {
                    var sec = document.createElement('div');
                    sec.className = 'detail-section';
                    var lbl = document.createElement('div');
                    lbl.className = 'detail-section-label';
                    lbl.textContent = 'Description';
                    sec.appendChild(lbl);
                    var cnt = document.createElement('div');
                    cnt.className = 'detail-section-content';
                    cnt.textContent = data.description;
                    sec.appendChild(cnt);
                    frag.appendChild(sec);
                }
                if (data.context) {
                    var sec2 = document.createElement('div');
                    sec2.className = 'detail-section';
                    var lbl2 = document.createElement('div');
                    lbl2.className = 'detail-section-label';
                    lbl2.textContent = 'Context';
                    sec2.appendChild(lbl2);
                    var cnt2 = document.createElement('div');
                    cnt2.className = 'detail-section-content';
                    cnt2.style.fontFamily = 'monospace';
                    cnt2.style.fontSize = '0.78rem';
                    cnt2.style.background = 'rgba(255,255,255,0.03)';
                    cnt2.style.padding = '8px 10px';
                    cnt2.style.borderRadius = '8px';
                    cnt2.textContent = data.context;
                    sec2.appendChild(cnt2);
                    frag.appendChild(sec2);
                }
            }

            if (type === 'goal') {
                if (data.description) {
                    var sec = document.createElement('div');
                    sec.className = 'detail-section';
                    var lbl = document.createElement('div');
                    lbl.className = 'detail-section-label';
                    lbl.textContent = 'Description';
                    sec.appendChild(lbl);
                    var cnt = document.createElement('div');
                    cnt.className = 'detail-section-content';
                    cnt.textContent = data.description;
                    sec.appendChild(cnt);
                    frag.appendChild(sec);
                }

                var subgoals = data.subgoals || [];
                if (subgoals.length > 0) {
                    var done = subgoals.filter(function(s) { return s.completed || s.status === 'completed'; }).length;
                    var pct = Math.round((done / subgoals.length) * 100);

                    var progSec = document.createElement('div');
                    progSec.className = 'detail-section';
                    var progLbl = document.createElement('div');
                    progLbl.className = 'detail-section-label';
                    progLbl.textContent = 'Progress (' + done + '/' + subgoals.length + ')';
                    progSec.appendChild(progLbl);
                    var bar = document.createElement('div');
                    bar.className = 'detail-progress-bar';
                    var fill = document.createElement('div');
                    fill.className = 'detail-progress-fill';
                    fill.style.width = pct + '%';
                    bar.appendChild(fill);
                    progSec.appendChild(bar);
                    frag.appendChild(progSec);

                    var sgSec = document.createElement('div');
                    sgSec.className = 'detail-section';
                    var sgLbl = document.createElement('div');
                    sgLbl.className = 'detail-section-label';
                    sgLbl.textContent = 'Subgoals';
                    sgSec.appendChild(sgLbl);
                    var sgList = document.createElement('div');
                    sgList.className = 'detail-subgoal-list';
                    subgoals.forEach(function(sg) {
                        var isDone = sg.completed || sg.status === 'completed';
                        var item = document.createElement('div');
                        item.className = 'detail-subgoal-item' + (isDone ? ' done' : '');
                        var check = document.createElement('span');
                        check.className = 'detail-subgoal-check';
                        check.textContent = isDone ? '\u2713' : '';
                        item.appendChild(check);
                        var text = document.createElement('span');
                        text.textContent = typeof sg === 'string' ? sg : (sg.description || sg.text || '');
                        item.appendChild(text);
                        sgList.appendChild(item);
                    });
                    sgSec.appendChild(sgList);
                    frag.appendChild(sgSec);
                }

                var blockers = data.blockers || [];
                if (blockers.length > 0) {
                    var bSec = document.createElement('div');
                    bSec.className = 'detail-section';
                    var bLbl = document.createElement('div');
                    bLbl.className = 'detail-section-label';
                    bLbl.textContent = 'Blockers';
                    bSec.appendChild(bLbl);
                    var bList = document.createElement('div');
                    bList.className = 'detail-blocker-list';
                    blockers.forEach(function(b) {
                        var pill = document.createElement('span');
                        pill.className = 'detail-blocker-pill';
                        pill.textContent = typeof b === 'string' ? b : (b.description || '');
                        bList.appendChild(pill);
                    });
                    bSec.appendChild(bList);
                    frag.appendChild(bSec);
                }
            }

            if (type === 'project') {
                if (data.summary) {
                    var sec = document.createElement('div');
                    sec.className = 'detail-section';
                    var lbl = document.createElement('div');
                    lbl.className = 'detail-section-label';
                    lbl.textContent = 'Summary';
                    sec.appendChild(lbl);
                    var cnt = document.createElement('div');
                    cnt.className = 'detail-section-content';
                    cnt.textContent = data.summary;
                    sec.appendChild(cnt);
                    frag.appendChild(sec);
                }
                if (data.next_action) {
                    var sec2 = document.createElement('div');
                    sec2.className = 'detail-section';
                    var lbl2 = document.createElement('div');
                    lbl2.className = 'detail-section-label';
                    lbl2.textContent = 'Next Action';
                    sec2.appendChild(lbl2);
                    var cnt2 = document.createElement('div');
                    cnt2.className = 'detail-section-content';
                    cnt2.style.borderLeft = '3px solid var(--accent)';
                    cnt2.style.paddingLeft = '10px';
                    cnt2.textContent = data.next_action;
                    sec2.appendChild(cnt2);
                    frag.appendChild(sec2);
                }
                if (data.key_files && data.key_files.length > 0) {
                    var sec3 = document.createElement('div');
                    sec3.className = 'detail-section';
                    var lbl3 = document.createElement('div');
                    lbl3.className = 'detail-section-label';
                    lbl3.textContent = 'Key Files';
                    sec3.appendChild(lbl3);
                    var fList = document.createElement('div');
                    fList.className = 'detail-file-list';
                    data.key_files.forEach(function(f) {
                        var fi = document.createElement('div');
                        fi.className = 'detail-file-item';
                        fi.textContent = f;
                        fList.appendChild(fi);
                    });
                    sec3.appendChild(fList);
                    frag.appendChild(sec3);
                }
            }

            if (type === 'activity') {
                var sec = document.createElement('div');
                sec.className = 'detail-section';
                var lbl = document.createElement('div');
                lbl.className = 'detail-section-label';
                lbl.textContent = 'Details';
                sec.appendChild(lbl);
                var cnt = document.createElement('div');
                cnt.className = 'detail-section-content';
                var bodyId = data.type === 'agents' ? 'live-agents-body' : data.type === 'health' ? 'memory-health-grid' : 'live-devices-body';
                var srcBody = document.getElementById(bodyId);
                if (srcBody) {
                    var clone = srcBody.cloneNode(true);
                    cnt.appendChild(clone);
                } else {
                    cnt.textContent = 'No details available';
                }
                sec.appendChild(cnt);
                frag.appendChild(sec);
            }

            return frag;
        }

        function buildDetailActions(type, data) {
            var frag = document.createDocumentFragment();

            if (type === 'stat') {
                var btn = document.createElement('button');
                btn.className = 'detail-action-btn primary';
                btn.textContent = 'Explore in Chat';
                btn.onclick = function() { openActionChat({ type: 'stat', rawText: 'Tell me about my ' + (data.name || 'stats') }); };
                frag.appendChild(btn);
            }

            if (type === 'action') {
                var btn1 = document.createElement('button');
                btn1.className = 'detail-action-btn primary';
                btn1.textContent = 'Open in Chat';
                btn1.onclick = function() { openActionChat({ type: 'action', title: data.title || '', context: data.context || '', description: data.description || '' }); };
                frag.appendChild(btn1);
                var btn2 = document.createElement('button');
                btn2.className = 'detail-action-btn';
                btn2.textContent = 'Spawn Agent';
                btn2.onclick = function() { closeHomeDetail(); if (typeof openAgentModal === 'function') openAgentModal(data.context || data.title || ''); else openActionChat({ type: 'action', title: data.title || '', context: data.context || '' }); };
                frag.appendChild(btn2);
            }

            if (type === 'goal') {
                var btn1 = document.createElement('button');
                btn1.className = 'detail-action-btn primary';
                btn1.textContent = 'Pursue in Chat';
                btn1.onclick = function() { openActionChat({ type: 'goal', description: data.description || '' }); };
                frag.appendChild(btn1);
                var btn2 = document.createElement('button');
                btn2.className = 'detail-action-btn';
                btn2.textContent = 'Update Goal';
                btn2.onclick = function() { openActionChat({ type: 'goal', description: data.description || '', title: 'Update Goal Status' }); };
                frag.appendChild(btn2);
            }

            if (type === 'project') {
                var btn1 = document.createElement('button');
                btn1.className = 'detail-action-btn primary';
                btn1.textContent = 'Continue in Chat';
                btn1.onclick = function() { openActionChat({ type: 'project', project: data.project || '', summary: data.summary || '', next_action: data.next_action || '', key_files: data.key_files || [], icon: data.icon || '' }); };
                frag.appendChild(btn1);
                var btn2 = document.createElement('button');
                btn2.className = 'detail-action-btn';
                btn2.textContent = 'Spawn Agent';
                btn2.onclick = function() { closeHomeDetail(); if (typeof openAgentModal === 'function') openAgentModal('Continue: ' + (data.project || '')); else openActionChat({ type: 'project', project: data.project || '', summary: data.summary || '', next_action: data.next_action || '', key_files: data.key_files || [] }); };
                frag.appendChild(btn2);
            }

            if (type === 'activity') {
                var btn = document.createElement('button');
                btn.className = 'detail-action-btn primary';
                btn.textContent = 'View Details';
                btn.onclick = function() {
                    closeHomeDetail();
                    if (data.type === 'agents') switchView('agents');
                    else if (data.type === 'health') { /* Memory health - stay on home */ }
                    else if (data.type === 'devices') { /* Devices - stay on home */ }
                    else switchView('chat');
                };
                frag.appendChild(btn);
            }

            return frag;
        }

        // ==================== HOMEPAGE V2: COLLAPSIBLE SECTIONS ====================
        var _sectionDefaults = { activity: false, goals: false, projects: true, memory: true };

        function initCollapsibleSections() {
            var stored = {};
            try { stored = JSON.parse(localStorage.getItem('home-section-state') || '{}'); } catch(e) {}
            Object.keys(_sectionDefaults).forEach(function(key) {
                var collapsed = stored.hasOwnProperty(key) ? stored[key] : _sectionDefaults[key];
                var sectionMap = { activity: 'home-section-activity', goals: 'home-goals-section', projects: 'home-section-projects', memory: 'home-section-memory' };
                var el = document.getElementById(sectionMap[key]);
                if (el) {
                    if (collapsed) el.classList.add('collapsed');
                    else el.classList.remove('collapsed');
                }
            });
        }

        function toggleSection(sectionId) {
            var sectionMap = { activity: 'home-section-activity', goals: 'home-goals-section', projects: 'home-section-projects', memory: 'home-section-memory' };
            var el = document.getElementById(sectionMap[sectionId]);
            if (!el) return;
            el.classList.toggle('collapsed');
            var stored = {};
            try { stored = JSON.parse(localStorage.getItem('home-section-state') || '{}'); } catch(e) {}
            stored[sectionId] = el.classList.contains('collapsed');
            localStorage.setItem('home-section-state', JSON.stringify(stored));
        }

        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                var modal = document.getElementById('home-detail-modal');
                if (modal && modal.classList.contains('active')) {
                    closeHomeDetail();
                }
            }
        });

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initCollapsibleSections);
        } else {
            initCollapsibleSections();
        }

        function buildActionCards(actions) {
            const frag = document.createDocumentFragment();
            actions.forEach((a, index) => {
                const card = document.createElement('div');
                card.className = 'action-card stagger-in';
                card.style.setProperty('--si', index);
                card.onclick = () => openHomeDetail('action', { title: a.title || '', description: a.description || '', context: a.context || '', icon: ACTION_ICONS[a.icon] || '\u{1F680}', iconClass: a.icon || 'rocket' });

                const icon = document.createElement('div');
                icon.className = 'action-card-icon ' + (a.icon || 'rocket');
                icon.textContent = ACTION_ICONS[a.icon] || '\u{1F680}';
                card.appendChild(icon);

                const title = document.createElement('div');
                title.className = 'action-card-title';
                title.textContent = a.title || '';
                card.appendChild(title);

                const desc = document.createElement('div');
                desc.className = 'action-card-desc';
                desc.textContent = a.description || '';
                card.appendChild(desc);

                const go = document.createElement('span');
                go.className = 'action-card-go';
                go.textContent = 'Go \u2192';
                card.appendChild(go);

                frag.appendChild(card);
            });
            return frag;
        }

        async function loadSmartActions() {
            const container = document.getElementById('smart-actions-container');
            try {
                const resp = await fetch(API_URL + '/api/smart-actions', {
                    headers: { 'Authorization': 'Bearer ' + token }
                });
                const data = await resp.json();
                const actions = data.actions || [];

                container.textContent = '';
                if (actions.length === 0) {
                    const empty = document.createElement('div');
                    empty.className = 'live-empty';
                    empty.textContent = "No actions right now \u2014 you're all caught up!";
                    container.appendChild(empty);
                    return;
                }
                container.appendChild(buildActionCards(actions));
            } catch (e) {
                container.textContent = '';
                const empty = document.createElement('div');
                empty.className = 'live-empty';
                empty.textContent = 'Could not load actions';
                container.appendChild(empty);
            }
        }

        async function loadLiveActivity() {
            const headers = { 'Authorization': 'Bearer ' + token };
            const [agentsResp, healthResp, devicesResp] = await Promise.allSettled([
                fetch(API_URL + '/agents', { headers }),
                fetch(API_URL + '/api/memory/health', { headers }),
                fetch(API_URL + '/api/devices', { headers }),
            ]);

            // Running agents
            const agentsBody = document.getElementById('live-agents-body');
            try {
                const agentsData = agentsResp.status === 'fulfilled' ? await agentsResp.value.json() : {};
                const running = (agentsData.agents || []).filter(a => a.status === 'running' || a.status === 'working');
                agentsBody.textContent = '';
                if (running.length === 0) {
                    const e = document.createElement('div');
                    e.className = 'live-empty';
                    e.textContent = 'No agents running';
                    agentsBody.appendChild(e);
                } else {
                    running.forEach((a, index) => {
                        const row = document.createElement('div');
                        row.className = 'live-agent-item stagger-in';
                        row.style.setProperty('--si', index);
                        row.onclick = () => switchView('agents');
                        const dot = document.createElement('div');
                        dot.className = 'live-agent-dot';
                        row.appendChild(dot);
                        const task = document.createElement('span');
                        task.className = 'live-agent-task';
                        task.textContent = a.task || a.id || 'Agent';
                        row.appendChild(task);
                        const time = document.createElement('span');
                        time.className = 'live-agent-time';
                        time.textContent = a.started_at ? getTimeAgo(a.started_at) : '';
                        row.appendChild(time);
                        agentsBody.appendChild(row);
                    });
                }
                const countEl = document.getElementById('active-agents-count');
                if (countEl) countEl.textContent = running.length;
            } catch (e) {
                agentsBody.textContent = '';
                const empty = document.createElement('div');
                empty.className = 'live-empty';
                empty.textContent = 'No agents running';
                agentsBody.appendChild(empty);
            }

            // Memory Health
            const healthGrid = document.getElementById('memory-health-grid');
            try {
                const healthData = healthResp.status === 'fulfilled' ? await healthResp.value.json() : {};
                if (healthGrid && healthData.components) {
                    healthGrid.textContent = '';
                    const grid = document.createElement('div');
                    grid.className = 'status-grid';
                    var hIdx = 0;
                    Object.entries(healthData.components).forEach(([key, comp]) => {
                        const status = comp.status || 'unknown';
                        const cls = status === 'online' ? 'online' : status === 'offline' ? 'offline' : 'unknown';
                        const item = document.createElement('div');
                        item.className = 'status-item stagger-in';
                        item.style.setProperty('--si', hIdx++);
                        const dot = document.createElement('span');
                        dot.className = 'status-dot ' + cls;
                        item.appendChild(dot);
                        const n = document.createElement('span');
                        n.className = 'status-name';
                        n.textContent = comp.name || key;
                        item.appendChild(n);
                        grid.appendChild(item);
                    });
                    healthGrid.appendChild(grid);
                }
            } catch (e) {
                if (healthGrid) {
                    healthGrid.textContent = '';
                    const empty = document.createElement('div');
                    empty.className = 'live-empty';
                    empty.textContent = 'Unable to check';
                    healthGrid.appendChild(empty);
                }
            }

            // Active Devices
            const devicesBody = document.getElementById('live-devices-body');
            try {
                const devData = devicesResp.status === 'fulfilled' ? await devicesResp.value.json() : {};
                const devices = devData.devices || [];
                window._cachedDevices = devices;
                devicesBody.textContent = '';
                if (devices.length === 0) {
                    const empty = document.createElement('div');
                    empty.className = 'live-empty';
                    empty.textContent = 'No devices registered';
                    devicesBody.appendChild(empty);
                } else {
                    devices.forEach((d, index) => {
                        const row = document.createElement('div');
                        row.className = 'device-item stagger-in';
                        row.style.setProperty('--si', index);
                        row.onclick = () => openDeviceDetailModal(d.id, d);
                        const dot = document.createElement('div');
                        dot.className = 'device-item-dot ' + getDeviceStatusClass(d.last_seen);
                        row.appendChild(dot);
                        const name = document.createElement('span');
                        name.className = 'device-item-name';
                        name.textContent = d.friendly_name || d.device_name || d.hostname || d.id;
                        row.appendChild(name);
                        const dtype = document.createElement('span');
                        dtype.className = 'device-item-type';
                        dtype.textContent = (d.device_type || '').replace(/_/g, ' ');
                        row.appendChild(dtype);
                        devicesBody.appendChild(row);
                    });
                }
            } catch (e) {
                devicesBody.textContent = '';
                const empty = document.createElement('div');
                empty.className = 'live-empty';
                empty.textContent = 'No devices registered';
                devicesBody.appendChild(empty);
            }
        }

        function getDeviceStatusClass(lastSeen) {
            if (!lastSeen) return 'offline';
            const diff = Date.now() - new Date(lastSeen).getTime();
            if (diff < 3600000) return 'online';
            if (diff < 86400000) return 'stale';
            return 'offline';
        }

        // ==================== DEVICE MANAGEMENT FUNCTIONS ====================

        var _currentDeviceId = null;

        function openDeviceDetailModal(deviceId, deviceData) {
            _currentDeviceId = deviceId;
            const modal = document.getElementById('device-detail-modal');
            document.getElementById('device-detail-title').textContent = deviceData.friendly_name || deviceData.device_name || deviceId;
            document.getElementById('device-detail-subtitle').textContent = (deviceData.device_type || 'unknown').replace(/_/g, ' ') + '  ' + (deviceData.hostname || deviceId);

            const statusCls = getDeviceStatusClass(deviceData.last_seen);
            const badge = document.getElementById('device-detail-badge');
            badge.className = 'device-status-badge ' + statusCls;
            badge.textContent = statusCls.charAt(0).toUpperCase() + statusCls.slice(1);

            document.getElementById('device-ping-results').style.display = 'none';
            document.getElementById('device-ping-results').textContent = '';

            const infoGrid = document.getElementById('device-info-grid');
            infoGrid.textContent = '';
            var infoRows = [
                ['Hostname', deviceData.hostname || deviceId],
                ['Type', (deviceData.device_type || 'unknown').replace(/_/g, ' ')],
                ['OS', deviceData.os || ''],
                ['Architecture', deviceData.architecture || ''],
                ['RAM', deviceData.ram_gb ? deviceData.ram_gb + ' GB' : ''],
                ['CPU Cores', deviceData.cpu_cores ? deviceData.cpu_cores.toString() : ''],
                ['GPU', deviceData.gpu_info ? (Array.isArray(deviceData.gpu_info) ? deviceData.gpu_info.join(', ') : deviceData.gpu_info) : ''],
                ['Registered', deviceData.registered_at ? new Date(deviceData.registered_at).toLocaleDateString() : ''],
                ['Last Seen', deviceData.last_seen ? getTimeAgo(deviceData.last_seen) : 'Never'],
            ];
            infoRows.forEach(function(r) {
                var row = document.createElement('div');
                row.className = 'device-info-row';
                var lbl = document.createElement('span');
                lbl.className = 'device-info-label';
                lbl.textContent = r[0];
                row.appendChild(lbl);
                var val = document.createElement('span');
                val.className = 'device-info-value';
                val.textContent = r[1];
                row.appendChild(val);
                infoGrid.appendChild(row);
            });

            document.getElementById('device-edit-name').value = deviceData.friendly_name || '';
            document.getElementById('device-edit-desc').value = deviceData.description || '';

            var ssh = deviceData.ssh_config || {};
            document.getElementById('device-ssh-host').value = ssh.host || '';
            document.getElementById('device-ssh-port').value = ssh.port || 22;
            document.getElementById('device-ssh-user').value = ssh.username || '';
            document.getElementById('device-ssh-key').value = ssh.key_path || '';

            modal.classList.add('active');
            try { populateConnectionLog(deviceData); } catch(e) { console.error('connectionLog:', e); }
            loadDeviceCommands(deviceId);
            loadDeviceAgentRuns(deviceId);
            try { initTerminalSection(deviceData); } catch(e) { console.error('terminal:', e); }
            loadDeviceStats(deviceId, deviceData).catch(function(e) { console.error('stats:', e); });
        }

        function closeDeviceModal() {
            document.getElementById('device-detail-modal').classList.remove('active');
            _currentDeviceId = null;
        }

        async function saveDeviceChanges() {
            if (!_currentDeviceId) return;
            var payload = {
                friendly_name: document.getElementById('device-edit-name').value,
                description: document.getElementById('device-edit-desc').value,
                ssh_config: {
                    host: document.getElementById('device-ssh-host').value,
                    port: parseInt(document.getElementById('device-ssh-port').value) || 22,
                    username: document.getElementById('device-ssh-user').value,
                    key_path: document.getElementById('device-ssh-key').value,
                }
            };
            try {
                const resp = await fetch(API_URL + '/api/devices/' + _currentDeviceId, {
                    method: 'PATCH',
                    headers: { 'Authorization': 'Bearer ' + token, 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                if (resp.ok) {
                    showToast('Device updated', 'success');
                    closeDeviceModal();
                    loadLiveActivity();
                } else {
                    const err = await resp.json();
                    showToast('Error: ' + (err.detail || 'Unknown'), 'error');
                }
            } catch (e) {
                showToast('Failed to save: ' + e.message, 'error');
            }
        }

        async function testDeviceConnection() {
            if (!_currentDeviceId) return;
            var btn = document.getElementById('device-test-btn');
            var resultsDiv = document.getElementById('device-ping-results');
            btn.classList.add('loading');
            btn.textContent = 'Testing...';
            resultsDiv.style.display = 'block';
            resultsDiv.textContent = 'Running connection tests...';
            try {
                const resp = await fetch(API_URL + '/api/devices/' + _currentDeviceId + '/ping', {
                    method: 'POST',
                    headers: { 'Authorization': 'Bearer ' + token }
                });
                const data = await resp.json();
                resultsDiv.textContent = '';
                if (data.ssh_port) {
                    var sshRow = document.createElement('div');
                    sshRow.className = 'ping-result-row';
                    var sshDot = document.createElement('span');
                    sshDot.className = 'ping-result-dot ' + (data.ssh_port.open ? 'pass' : 'fail');
                    sshRow.appendChild(sshDot);
                    var sshTxt = document.createElement('span');
                    sshTxt.textContent = 'SSH Port ' + data.ssh_port.port + ': ' + (data.ssh_port.open ? 'Open' : 'Closed');
                    sshRow.appendChild(sshTxt);
                    resultsDiv.appendChild(sshRow);
                }
                if (data.ssh_auth) {
                    var authRow = document.createElement('div');
                    authRow.className = 'ping-result-row';
                    var authDot = document.createElement('span');
                    authDot.className = 'ping-result-dot ' + (data.ssh_auth.success ? 'pass' : 'fail');
                    authRow.appendChild(authDot);
                    var authTxt = document.createElement('span');
                    authTxt.textContent = 'SSH Auth: ' + (data.ssh_auth.success ? 'Success' : 'Failed');
                    authRow.appendChild(authTxt);
                    resultsDiv.appendChild(authRow);
                }
                // Show hint if pinging by hostname instead of IP
                if (data.hint) {
                    var hintRow = document.createElement('div');
                    hintRow.className = 'ping-result-row';
                    hintRow.style.cssText = 'color:var(--yellow); font-size:0.72rem; margin-top:4px; opacity:0.85;';
                    hintRow.textContent = '\u26A0 ' + data.hint;
                    resultsDiv.appendChild(hintRow);
                }
            } catch (e) {
                resultsDiv.textContent = 'Connection test failed: ' + e.message;
            }
            btn.classList.remove('loading');
            btn.textContent = 'Test Connection';
        }

        function _emptyMsg(container, msg) {
            container.textContent = '';
            var el = document.createElement('div');
            el.className = 'device-activity-empty';
            el.textContent = msg;
            container.appendChild(el);
        }

        function populateConnectionLog(deviceData) {
            var dot = document.getElementById('connection-log-dot');
            var text = document.getElementById('connection-log-text');
            var time = document.getElementById('connection-log-time');
            var statusCls = getDeviceStatusClass(deviceData.last_seen);
            dot.className = 'connection-log-dot ' + statusCls;
            if (statusCls === 'online') {
                text.textContent = 'Currently online';
            } else if (statusCls === 'stale') {
                text.textContent = 'Last seen recently';
            } else if (deviceData.last_seen) {
                text.textContent = 'Last seen ' + getTimeAgo(deviceData.last_seen);
            } else {
                text.textContent = 'Never connected';
            }
            var parts = [];
            if (deviceData.last_seen) parts.push(getTimeAgo(deviceData.last_seen));
            if (deviceData.registered_at) parts.push('Registered ' + new Date(deviceData.registered_at).toLocaleDateString());
            time.textContent = parts.join(' \u00b7 ');
        }

        async function loadDeviceCommands(deviceId) {
            var container = document.getElementById('device-cmd-list');
            _emptyMsg(container, 'Loading...');
            try {
                var resp = await fetch(API_URL + '/api/devices/' + deviceId + '/commands?limit=5', {
                    headers: { 'Authorization': 'Bearer ' + localStorage.getItem('cerebro_token') }
                });
                var data = await resp.json();
                container.textContent = '';
                if (!data.commands || data.commands.length === 0) {
                    _emptyMsg(container, 'No commands yet');
                } else {
                    data.commands.forEach(function(c) {
                        var item = document.createElement('div');
                        item.className = 'device-cmd-item';
                        var cmdText = document.createElement('div');
                        cmdText.className = 'device-cmd-text';
                        cmdText.textContent = '$ ' + (c.command || c.cmd || '');
                        item.appendChild(cmdText);
                        var meta = document.createElement('div');
                        meta.className = 'device-cmd-meta';
                        var exitCode = c.exit_code !== undefined ? c.exit_code : null;
                        if (exitCode !== null) {
                            var exitSpan = document.createElement('span');
                            exitSpan.className = 'device-cmd-exit ' + (exitCode === 0 ? 'ok' : 'fail');
                            exitSpan.textContent = 'exit ' + exitCode;
                            meta.appendChild(exitSpan);
                        }
                        if (c.timestamp || c.executed_at) {
                            var ts = document.createElement('span');
                            ts.textContent = getTimeAgo(c.timestamp || c.executed_at);
                            meta.appendChild(ts);
                        }
                        item.appendChild(meta);
                        container.appendChild(item);
                    });
                }
            } catch (e) {
                _emptyMsg(container, 'Failed to load');
            }
        }

        async function loadDeviceAgentRuns(deviceId) {
            var container = document.getElementById('device-agent-list');
            _emptyMsg(container, 'Loading...');
            try {
                var resp = await fetch(API_URL + '/api/devices/' + deviceId + '/agents?limit=5', {
                    headers: { 'Authorization': 'Bearer ' + localStorage.getItem('cerebro_token') }
                });
                var data = await resp.json();
                container.textContent = '';
                if (!data.agents || data.agents.length === 0) {
                    _emptyMsg(container, 'No agent runs');
                } else {
                    data.agents.forEach(function(a) {
                        var item = document.createElement('div');
                        item.className = 'device-agent-item';
                        var nameRow = document.createElement('div');
                        nameRow.style.cssText = 'display:flex; align-items:center; gap:6px;';
                        var name = document.createElement('span');
                        name.className = 'device-agent-name';
                        name.textContent = a.call_sign || a.id;
                        nameRow.appendChild(name);
                        var badge = document.createElement('span');
                        var st = (a.status || 'unknown').toLowerCase();
                        var badgeCls = st === 'completed' ? 'completed' : st === 'running' ? 'running' : st === 'queued' ? 'queued' : 'failed';
                        badge.className = 'device-agent-status ' + badgeCls;
                        badge.textContent = st;
                        nameRow.appendChild(badge);
                        item.appendChild(nameRow);
                        if (a.task) {
                            var task = document.createElement('div');
                            task.className = 'device-agent-task';
                            task.textContent = a.task;
                            item.appendChild(task);
                        }
                        if (a.created_at) {
                            var ts = document.createElement('div');
                            ts.style.cssText = 'font-size:0.65rem; color:var(--text-muted); margin-top:2px;';
                            ts.textContent = getTimeAgo(a.created_at);
                            item.appendChild(ts);
                        }
                        container.appendChild(item);
                    });
                }
            } catch (e) {
                _emptyMsg(container, 'Failed to load');
            }
        }

        async function loadDeviceStats(deviceId, deviceData) {
            var ssh = deviceData.ssh_config || {};
            var statsSection = document.getElementById('device-stats-section');
            if (!ssh.host || !ssh.username) {
                statsSection.style.display = 'none';
                return;
            }
            statsSection.style.display = 'block';
            // Reset to loading spinners
            ['cpu','ram','disk','uptime'].forEach(function(k) {
                var el = document.getElementById('device-stat-' + k);
                el.textContent = '';
                var spinner = document.createElement('span');
                spinner.className = 'stat-loading';
                el.appendChild(spinner);
            });
            var cmds = {
                cpu: "top -bn1 | grep 'Cpu(s)' | awk '{print $2\"%\"}'",
                ram: "free -h | awk '/^Mem:/ {print $3\"/\"$2}'",
                disk: "df -h / | awk 'NR==2 {print $3\"/\"$2\" (\"$5\")\"}'",
                uptime: "uptime -p"
            };
            var keys = Object.keys(cmds);
            var promises = keys.map(function(key) {
                return fetch(API_URL + '/api/devices/' + deviceId + '/exec', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'Authorization': 'Bearer ' + localStorage.getItem('cerebro_token') },
                    body: JSON.stringify({ command: cmds[key], timeout: 5 })
                }).then(function(r) {
                    if (!r.ok) return r.text().then(function(t) { throw new Error('HTTP ' + r.status + ': ' + t); });
                    return r.json();
                }).then(function(d) {
                    var el = document.getElementById('device-stat-' + key);
                    if (d.stdout && d.exit_code === 0) {
                        el.textContent = d.stdout.trim().split('\n')[0];
                    } else {
                        el.textContent = '--';
                    }
                }).catch(function(e) {
                    console.error('Stats fetch error [' + key + ']:', e);
                    document.getElementById('device-stat-' + key).textContent = '--';
                });
            });
            await Promise.allSettled(promises);
        }

        // ============================================================
        // Remote Terminal Functions
        // ============================================================
        var _terminalHistory = [];
        var _terminalHistoryIdx = -1;

        function initTerminalSection(deviceData) {
            var ssh = deviceData.ssh_config || {};
            var hasSSH = !!(ssh.host && ssh.username);
            var warning = document.getElementById('terminal-ssh-warning');
            var active = document.getElementById('terminal-active-area');
            var output = document.getElementById('terminal-output');
            var input = document.getElementById('terminal-input');

            output.onclick = function() { input.focus(); };
            if (hasSSH) {
                warning.style.display = 'none';
                active.style.display = 'block';
                output.textContent = '';
                input.value = '';
                appendTerminalOutput('info', 'Connected to ' + (ssh.username || '') + '@' + (ssh.host || '') + ':' + (ssh.port || 22));
                updateTerminalStatus('ready', 'Ready');
                loadCommandHistory(_currentDeviceId);
            } else {
                warning.style.display = 'block';
                active.style.display = 'none';
            }
            _terminalHistory = [];
            _terminalHistoryIdx = -1;
        }

        async function loadCommandHistory(deviceId) {
            try {
                var resp = await fetch(API_URL + '/api/devices/' + deviceId + '/commands?limit=10', {
                    headers: { 'Authorization': 'Bearer ' + localStorage.getItem('cerebro_token') }
                });
                if (!resp.ok) return;
                var data = await resp.json();
                var countEl = document.getElementById('terminal-cmd-count');
                countEl.textContent = data.count + ' commands in history';
            } catch (e) { /* silent */ }
        }

        async function executeTerminalCommand() {
            var input = document.getElementById('terminal-input');
            var cmd = input.value.trim();
            if (!cmd || !_currentDeviceId) return;

            _terminalHistory.unshift(cmd);
            if (_terminalHistory.length > 100) _terminalHistory.pop();
            _terminalHistoryIdx = -1;

            input.value = '';
            appendTerminalOutput('cmd', '$ ' + cmd);
            updateTerminalStatus('running', 'Running...');
            document.getElementById('terminal-run-btn').disabled = true;

            try {
                var resp = await fetch(API_URL + '/api/devices/' + _currentDeviceId + '/exec', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'Authorization': 'Bearer ' + localStorage.getItem('cerebro_token') },
                    body: JSON.stringify({ command: cmd, timeout: 30 })
                });
                var data = await resp.json();

                if (!resp.ok) {
                    appendTerminalOutput('err', 'Error: ' + (data.detail || resp.statusText));
                    updateTerminalStatus('error', 'Failed');
                } else {
                    if (data.stdout) appendTerminalOutput('stdout', data.stdout);
                    if (data.stderr) appendTerminalOutput('err', data.stderr);
                    if (data.exit_code === 0) {
                        updateTerminalStatus('ready', 'Exit 0 (' + data.execution_time_ms + 'ms)');
                    } else {
                        updateTerminalStatus('error', 'Exit ' + data.exit_code + ' (' + data.execution_time_ms + 'ms)');
                    }
                    if (data.truncated) appendTerminalOutput('info', '(output truncated at 64KB)');
                    loadCommandHistory(_currentDeviceId);
                }
            } catch (e) {
                appendTerminalOutput('err', 'Network error: ' + e.message);
                updateTerminalStatus('error', 'Error');
            }
            document.getElementById('terminal-run-btn').disabled = false;
            input.focus();
        }

        function handleTerminalKeydown(e) {
            if (e.key === 'Enter') {
                e.preventDefault();
                executeTerminalCommand();
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                if (_terminalHistory.length > 0 && _terminalHistoryIdx < _terminalHistory.length - 1) {
                    _terminalHistoryIdx++;
                    e.target.value = _terminalHistory[_terminalHistoryIdx];
                }
            } else if (e.key === 'ArrowDown') {
                e.preventDefault();
                if (_terminalHistoryIdx > 0) {
                    _terminalHistoryIdx--;
                    e.target.value = _terminalHistory[_terminalHistoryIdx];
                } else {
                    _terminalHistoryIdx = -1;
                    e.target.value = '';
                }
            }
        }

        function clearTerminalOutput() {
            document.getElementById('terminal-output').textContent = '';
        }

        function updateTerminalStatus(state, text) {
            var el = document.getElementById('terminal-status');
            el.textContent = '';
            var dot = document.createElement('span');
            dot.className = 'terminal-status-dot ' + (state === 'running' ? 'running' : (state === 'error' ? 'error' : 'ready'));
            el.appendChild(dot);
            el.appendChild(document.createTextNode(text));
        }

        function appendTerminalOutput(type, text) {
            var output = document.getElementById('terminal-output');
            var line = document.createElement('div');
            line.className = 'term-' + type;
            if (type === 'cmd' && text.indexOf('$ ') === 0) {
                var prompt = document.createElement('span');
                prompt.className = 'term-prompt';
                prompt.textContent = '$ ';
                line.appendChild(prompt);
                line.appendChild(document.createTextNode(text.substring(2)));
            } else {
                line.textContent = text;
            }
            output.appendChild(line);
            output.scrollTop = output.scrollHeight;
        }

        function toggleDeviceHelp(btn) {
            const dropdown = btn.querySelector('.device-help-dropdown');
            if (!dropdown) return;
            const isVisible = dropdown.classList.contains('visible');
            // Close any other open help dropdowns
            document.querySelectorAll('.device-help-dropdown.visible').forEach(d => d.classList.remove('visible'));
            if (!isVisible) {
                dropdown.classList.add('visible');
                // Close on outside click
                const close = (e) => { if (!btn.contains(e.target)) { dropdown.classList.remove('visible'); document.removeEventListener('click', close); } };
                setTimeout(() => document.addEventListener('click', close), 0);
            }
        }

        function openAddDeviceModal() {
            document.getElementById('add-device-hostname').value = '';
            document.getElementById('add-device-name').value = '';
            document.getElementById('add-device-type').value = 'unknown';
            document.getElementById('add-device-desc').value = '';
            document.getElementById('add-device-ssh-host').value = '';
            document.getElementById('add-device-ssh-port').value = '22';
            document.getElementById('add-device-ssh-user').value = '';
            document.getElementById('add-device-ssh-key').value = '';
            document.getElementById('add-device-modal').classList.add('active');
        }

        function closeAddDeviceModal() {
            document.getElementById('add-device-modal').classList.remove('active');
        }

        async function submitAddDevice() {
            var hostname = document.getElementById('add-device-hostname').value.trim();
            if (!hostname) { showToast('Hostname is required', 'warning'); return; }
            var payload = {
                hostname: hostname,
                device_name: document.getElementById('add-device-name').value.trim() || hostname,
                friendly_name: document.getElementById('add-device-name').value.trim() || hostname,
                device_type: document.getElementById('add-device-type').value,
                description: document.getElementById('add-device-desc').value.trim(),
            };
            var sshHost = document.getElementById('add-device-ssh-host').value.trim();
            if (sshHost) {
                payload.ssh_config = {
                    host: sshHost,
                    port: parseInt(document.getElementById('add-device-ssh-port').value) || 22,
                    username: document.getElementById('add-device-ssh-user').value.trim(),
                    key_path: document.getElementById('add-device-ssh-key').value.trim(),
                };
            }
            try {
                const resp = await fetch(API_URL + '/api/devices', {
                    method: 'POST',
                    headers: { 'Authorization': 'Bearer ' + token, 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                if (resp.ok) {
                    showToast('Device added', 'success');
                    closeAddDeviceModal();
                    loadLiveActivity();
                } else {
                    const err = await resp.json();
                    showToast('Error: ' + (err.detail || 'Unknown'), 'error');
                }
            } catch (e) {
                showToast('Failed to add device: ' + e.message, 'error');
            }
        }

        async function loadHomeGoals() {
            const container = document.getElementById('home-goals-list');
            try {
                const resp = await fetch(API_URL + '/api/goals', {
                    headers: { 'Authorization': 'Bearer ' + token }
                });
                const data = await resp.json();
                const goals = (data.goals || []).slice(0, 4);

                const countEl = document.getElementById('home-goals-count');
                if (countEl) countEl.textContent = goals.length;
                const badgeEl = document.getElementById('goals-count-badge');
                if (badgeEl) badgeEl.textContent = goals.length;

                container.textContent = '';
                if (goals.length === 0) {
                    const e = document.createElement('div');
                    e.className = 'live-empty';
                    e.textContent = 'No active goals';
                    container.appendChild(e);
                    return;
                }

                goals.forEach((g, index) => {
                    const p = g.priority || 'medium';
                    const subgoals = g.subgoals || [];
                    const done = subgoals.filter(s => s.completed || s.status === 'completed').length;
                    const pct = subgoals.length > 0 ? Math.round((done / subgoals.length) * 100) : 0;
                    const blockers = g.blockers || [];

                    const row = document.createElement('div');
                    row.className = 'goal-compact-row stagger-in';
                    row.style.setProperty('--si', index);
                    row.onclick = () => openHomeDetail('goal', {
                        title: g.description || 'Goal',
                        description: g.description || '',
                        priority: p,
                        subgoals: subgoals,
                        blockers: blockers,
                        icon: '\u{1F3AF}'
                    });

                    // Priority dot
                    const dot = document.createElement('span');
                    dot.className = 'goal-priority-dot ' + p;
                    row.appendChild(dot);

                    // Description (truncated)
                    const descEl = document.createElement('span');
                    descEl.className = 'goal-compact-desc';
                    descEl.textContent = g.description || '';
                    row.appendChild(descEl);

                    // Mini progress bar
                    if (subgoals.length > 0) {
                        const miniBar = document.createElement('div');
                        miniBar.className = 'goal-mini-progress';
                        const miniFill = document.createElement('div');
                        miniFill.className = 'goal-mini-progress-fill';
                        miniFill.style.width = pct + '%';
                        miniBar.appendChild(miniFill);
                        row.appendChild(miniBar);
                    }

                    // Priority badge
                    const badge = document.createElement('span');
                    badge.className = 'goal-compact-badge ' + p;
                    badge.textContent = p;
                    row.appendChild(badge);

                    container.appendChild(row);
                });
            } catch (e) {
                container.textContent = '';
                const empty = document.createElement('div');
                empty.className = 'live-empty';
                empty.textContent = 'Could not load goals';
                container.appendChild(empty);
            }
        }

        async function loadProjectTracker() {
            const container = document.getElementById('project-tracker-container');
            try {
                const resp = await fetch(API_URL + '/api/workstreams', {
                    headers: { 'Authorization': 'Bearer ' + token }
                });
                const data = await resp.json();
                const ws = data.workstreams || [];

                container.textContent = '';
                if (ws.length === 0) {
                    const e = document.createElement('div');
                    e.className = 'live-empty';
                    e.textContent = 'No active projects';
                    container.appendChild(e);
                    return;
                }

                // Update projects count badge
                const projBadge = document.getElementById('projects-count-badge');
                if (projBadge) projBadge.textContent = ws.length;

                ws.forEach((w, index) => {
                    const st = (w.status || 'unknown').replace(/ /g, '_');
                    const card = document.createElement('div');
                    card.className = 'project-card stagger-in';
                    card.style.setProperty('--si', index);
                    card.onclick = () => openHomeDetail('project', {
                        title: w.project || 'Project',
                        project: w.project || '',
                        status: st,
                        summary: w.summary || '',
                        next_action: w.next_action || '',
                        key_files: w.key_files || [],
                        icon: '\u{1F4C1}'
                    });

                    const hdr = document.createElement('div');
                    hdr.className = 'project-card-header';
                    const name = document.createElement('span');
                    name.className = 'project-card-name';
                    name.textContent = w.project || '';
                    hdr.appendChild(name);
                    const badge = document.createElement('span');
                    badge.className = 'project-status-badge ' + st;
                    badge.textContent = st.replace(/_/g, ' ');
                    hdr.appendChild(badge);
                    card.appendChild(hdr);

                    const summary = document.createElement('div');
                    summary.className = 'project-card-summary';
                    summary.textContent = w.summary || '';
                    card.appendChild(summary);

                    if (w.next_action) {
                        const na = document.createElement('div');
                        na.className = 'project-next-action';
                        na.textContent = w.next_action;
                        card.appendChild(na);
                    }

                    const btn = document.createElement('button');
                    btn.className = 'project-continue-btn';
                    btn.textContent = 'Continue';
                    btn.onclick = (e) => { e.stopPropagation(); openHomeDetail('project', { title: w.project || 'Project', project: w.project || '', status: st, summary: w.summary || '', next_action: w.next_action || '', key_files: w.key_files || [], icon: '\u{1F4C1}' }); };
                    card.appendChild(btn);

                    container.appendChild(card);
                });
            } catch (e) {
                container.textContent = '';
                const empty = document.createElement('div');
                empty.className = 'live-empty';
                empty.textContent = 'Could not load projects';
                container.appendChild(empty);
            }
        }

        function animateValueChange(el, newText) {
            if (!el || el.textContent === String(newText)) return;
            el.style.transition = 'opacity 0.15s ease, transform 0.15s ease';
            el.style.opacity = '0.4';
            el.style.transform = 'scale(0.95)';
            setTimeout(function() {
                el.textContent = newText;
                el.style.opacity = '1';
                el.style.transform = 'scale(1)';
            }, 150);
        }

        async function loadMemoryIntelligence() {
            try {
                var headers = { 'Authorization': 'Bearer ' + token };
                var [intelResp, healthResp] = await Promise.allSettled([
                    fetch(API_URL + '/api/memory-intelligence', { headers: headers }),
                    fetch(API_URL + '/api/memory/health', { headers: headers }),
                ]);

                var set = function(id, val) {
                    var el = document.getElementById(id);
                    animateValueChange(el, val);
                };

                // Parse memory-intelligence response
                var d = {};
                if (intelResp.status === 'fulfilled' && intelResp.value.ok) {
                    d = await intelResp.value.json();
                }

                // Update settings-page intel tiles
                set('intel-total-memories', (d.total_memories || 0).toLocaleString());
                set('intel-recent-learnings', d.recent_learnings || 0);
                set('intel-patterns', d.promoted_patterns || 0);
                set('intel-contradictions', d.contradictions_pending || 0);
                set('intel-faiss', d.faiss_size_mb ? d.faiss_size_mb + 'MB' : '--');

                // Hero pills: memories, learnings, patterns, goals
                var memTotal = (d.total_memories || 0) + (d.fact_count || 0);
                set('memory-count', memTotal.toLocaleString());
                set('home-learnings-count', d.total_learnings || 0);
                set('home-patterns-count', d.promoted_patterns || 0);
                if (d.active_goals) set('home-goals-count', d.active_goals);

                // Health: prefer memory-intelligence score, fall back to /api/memory/health
                var healthPct = d.knowledge_health || 0;
                if (!healthPct && healthResp.status === 'fulfilled' && healthResp.value.ok) {
                    var healthData = await healthResp.value.json();
                    if (healthData.components) {
                        var total = 0, healthy = 0;
                        Object.values(healthData.components).forEach(function(comp) {
                            total++;
                            if (comp.status === 'online') healthy++;
                        });
                        if (total > 0) healthPct = Math.round((healthy / total) * 100);
                    }
                }
                set('system-health', healthPct + '%');
                set('intel-health', healthPct + '%');
            } catch (e) {
                // Silently fail - tiles will show --
            }
        }

        // ==================== INTEREST SUGGESTIONS (LEGACY) ====================
        let interestSuggestions = { fun_project: null, business_feature: null, claude_choice: null };

        async function loadInterestSuggestions() {
            try {
                const response = await fetch(`${API_URL}/suggestions/interests`, {
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                if (!response.ok) throw new Error('Failed to load interest suggestions');
                const data = await response.json();
                interestSuggestions = data;
                renderInterestSuggestions();
            } catch (error) {
                console.error('Failed to load interest suggestions:', error);
                // Show fallback with all three types
                document.getElementById('interest-cards').innerHTML = `
                    <div class="interest-card fun-project" onclick="startChat('Suggest a fun project for me based on my interests')">
                        <span class="interest-type-badge">Fun Project</span>
                        <div class="interest-card-title">Suggest Something Fun</div>
                        <div class="interest-card-desc">Let me think of a fun project based on your interests</div>
                    </div>
                    <div class="interest-card business-feature" onclick="startChat('Suggest a business feature I could build')">
                        <span class="interest-type-badge">Business</span>
                        <div class="interest-card-title">Business Enhancement</div>
                        <div class="interest-card-desc">Get ideas for improving your business applications</div>
                    </div>
                    <div class="interest-card claude-choice" onclick="startChat('What feature would help you assist me better?')">
                        <span class="interest-type-badge">Claude's Choice</span>
                        <div class="interest-card-title">Help Me Help You</div>
                        <div class="interest-card-desc">Let me suggest ways to improve our collaboration</div>
                    </div>
                `;
            }
        }

        function renderInterestSuggestions() {
            const container = document.getElementById('interest-cards');
            if (!container) return;

            const typeLabels = { fun: 'Fun Project', business: 'Business', claude: "Claude's Choice" };
            const typeClasses = { fun: 'fun-project', business: 'business-feature', claude: 'claude-choice' };

            container.innerHTML = ['fun_project', 'business_feature', 'claude_choice'].map(key => {
                const s = interestSuggestions[key];
                if (!s) return '';
                const typeKey = s.interestType;
                return `
                    <div class="interest-card ${typeClasses[typeKey]}" data-suggestion-id="${s.id}" data-interest-type="${typeKey}" onclick="startInterestTask('${key}')">
                        <button class="interest-dismiss-btn" onclick="event.stopPropagation(); dismissInterestSuggestion('${s.id}', '${typeKey}', '${key}')" title="Not interested">
                            <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/>
                            </svg>
                        </button>
                        <div class="interest-card-header">
                            <span class="interest-type-badge">${typeLabels[typeKey]}</span>
                        </div>
                        <div class="interest-card-title">${escapeHtml(s.title)}</div>
                        <div class="interest-card-desc">${escapeHtml(s.description)}</div>
                        <div class="interest-card-reason">${escapeHtml(s.reason || '')}</div>
                    </div>
                `;
            }).join('');
        }

        async function dismissInterestSuggestion(suggestionId, interestType, suggestionKey) {
            const card = document.querySelector(`[data-suggestion-id="${suggestionId}"]`);
            if (!card) return;

            // Animate out
            card.style.transform = 'scale(0.9)';
            card.style.opacity = '0.5';

            try {
                const suggestion = interestSuggestions[suggestionKey];
                const response = await fetch(`${API_URL}/suggestions/dismiss`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        suggestion_id: suggestionId,
                        category: suggestion?.type || '',
                        title: suggestion?.title || '',
                        interest_type: interestType,
                        regenerate: true
                    })
                });
                const data = await response.json();

                if (data.replacement) {
                    // Update the suggestion
                    interestSuggestions[suggestionKey] = data.replacement;
                    renderInterestSuggestions();

                    // Animate in the new card
                    const newCard = document.querySelector(`[data-suggestion-id="${data.replacement.id}"]`);
                    if (newCard) {
                        newCard.style.transform = 'scale(0.9)';
                        newCard.style.opacity = '0';
                        setTimeout(() => {
                            newCard.style.transition = 'all 0.3s ease';
                            newCard.style.transform = 'scale(1)';
                            newCard.style.opacity = '1';
                        }, 50);
                    }
                }
            } catch (error) {
                console.error('Failed to dismiss suggestion:', error);
                card.style.transform = '';
                card.style.opacity = '1';
            }
        }

        function startInterestTask(suggestionKey) {
            const suggestion = interestSuggestions[suggestionKey];
            if (!suggestion) return;

            // Open the task wizard with this suggestion instead of starting chat directly
            openInterestWizard(suggestion);
        }

        function openInterestWizard(suggestion) {
            // Set the current wizard suggestion
            currentWizardSuggestion = suggestion;

            // Reset to single agent mode
            wizardMode = 'single';
            document.getElementById('mode-single').classList.add('active');
            document.getElementById('mode-orchestrator').classList.remove('active');
            document.getElementById('single-agent-config').classList.remove('hidden');
            document.getElementById('orchestrator-config').classList.remove('active');
            document.getElementById('wizard-launch-btn').innerHTML = ' Launch Agent';

            // Reset orchestrator settings to defaults
            wizardWorkflowType = 'standard';
            wizardTeamMembers = ['researcher', 'coder'];
            document.querySelectorAll('.workflow-type-card').forEach(card => {
                card.classList.toggle('selected', card.dataset.type === 'standard');
            });
            document.querySelectorAll('.team-member-card').forEach(card => {
                const agent = card.dataset.agent;
                card.classList.toggle('selected', agent === 'researcher' || agent === 'coder');
            });

            // Analyze the task to determine recommended agent and metrics
            const analysis = analyzeTask(suggestion);
            selectedWizardAgent = analysis.recommendedAgent;

            // Populate wizard content
            document.getElementById('wizard-title').textContent = suggestion.title;

            // Add context based on interest type
            const typeLabels = {
                'fun': ' Fun Project',
                'business': ' Business Feature',
                'claude': ' Claude\'s Suggestion'
            };
            const typeLabel = typeLabels[suggestion.interestType] || 'Suggested Task';
            document.getElementById('wizard-subtitle').textContent = typeLabel + ' - Review before launching';

            document.getElementById('wizard-task-description').textContent = suggestion.action || suggestion.description;

            // Set icon based on suggestion type or interest type
            const iconMap = {
                'star': '', 'rocket': '', 'brain': '', 'folder': '',
                'code': '', 'robot': '', 'search': '', 'chat': '', 'default': ''
            };
            document.getElementById('wizard-icon').textContent = iconMap[suggestion.icon] || iconMap['default'];

            // Populate analytics
            document.getElementById('wizard-duration').textContent = analysis.estimatedDuration;
            document.getElementById('wizard-confidence').textContent = Math.round((suggestion.confidence || 0.85) * 100) + '%';
            document.getElementById('wizard-tools').textContent = analysis.toolsNeeded;
            document.getElementById('wizard-complexity').textContent = analysis.complexity;

            // Update recommended agent display
            updateWizardAgentDisplay(analysis.recommendedAgent, analysis.agentReason);

            // Update steps based on agent type
            updateWizardSteps(analysis.recommendedAgent);

            // Update tools list
            updateWizardTools(analysis.recommendedAgent);

            // Highlight selected agent override button
            document.querySelectorAll('.override-btn').forEach(btn => {
                btn.classList.toggle('selected', btn.dataset.type === analysis.recommendedAgent);
            });

            // Show orchestrator suggestion hint if applicable
            const orchestratorBtn = document.getElementById('mode-orchestrator');
            if (analysis.suggestOrchestrator) {
                orchestratorBtn.innerHTML = `
                    <span class="mode-btn-icon"></span>
                    <span>Mother Agent</span>
                    <span class="mode-hint"></span>
                `;
                orchestratorBtn.title = analysis.orchestratorReason;
            } else {
                orchestratorBtn.innerHTML = `
                    <span class="mode-btn-icon"></span>
                    <span>Mother Agent</span>
                `;
                orchestratorBtn.title = '';
            }

            // Show modal
            document.body.classList.add('modal-open');
            document.getElementById('task-wizard-modal').classList.add('active');
        }

        async function refreshInterestSuggestions() {
            const btn = document.querySelector('.refresh-interests-btn');
            const container = document.getElementById('interest-cards');

            // Show loading state
            if (btn) {
                btn.style.animation = 'spin 1s linear infinite';
                btn.disabled = true;
            }

            // Show generating message
            if (container) {
                container.innerHTML = `
                    <div class="generating-suggestions" style="grid-column: 1 / -1; text-align: center; padding: 30px; color: var(--text-muted);">
                        <div class="spinner" style="margin: 0 auto 12px;"></div>
                        <span>Claude is generating personalized suggestions...</span>
                    </div>
                `;
            }

            try {
                // Call the refresh endpoint which forces Claude to regenerate
                const response = await fetch(`${API_URL}/suggestions/interests/refresh`, {
                    method: 'POST',
                    headers: { 'Authorization': `Bearer ${token}` }
                });

                if (response.ok) {
                    const data = await response.json();
                    if (data.suggestions) {
                        interestSuggestions = data.suggestions;
                        renderInterestSuggestions();
                        showToast('Fresh suggestions generated!', 'success');
                    }
                } else {
                    throw new Error('Failed to refresh');
                }
            } catch (error) {
                console.error('Refresh failed:', error);
                showToast('Failed to generate new suggestions', 'error');
                // Fall back to loading cached
                await loadInterestSuggestions();
            }

            // Reset button
            if (btn) {
                btn.style.animation = '';
                btn.disabled = false;
            }
        }

        // ==================== SMART SUMMARY CARD ====================
        let smartSummaryData = { activeWork: null, agentsToReview: [] };

        async function loadSmartSuggestions() {
            // This now loads the Smart Summary Card data
            await loadSmartSummary();
        }

        async function loadSmartSummary() {
            try {
                // Fetch active work and agents in parallel
                const [suggestionsRes, agentsRes] = await Promise.all([
                    fetch(`${API_URL}/suggestions`, { headers: { 'Authorization': `Bearer ${token}` } }),
                    fetch(`${API_URL}/agents`, { headers: { 'Authorization': `Bearer ${token}` } })
                ]);

                const suggestionsData = await suggestionsRes.json();
                const agentsData = await agentsRes.json();

                // Extract active work from suggestions
                const suggestions = suggestionsData.suggestions || [];
                const activeWorkSuggestion = suggestions.find(s => s.type === 'active_project');

                // Get agents that need review (completed in last 24h)
                const now = Date.now();
                const agentsToReview = (agentsData.agents || [])
                    .filter(a => a.status === 'completed')
                    .filter(a => {
                        const completedAt = new Date(a.completed_at || a.created_at).getTime();
                        return (now - completedAt) < 24 * 60 * 60 * 1000; // Last 24 hours
                    })
                    .slice(0, 3); // Max 3

                smartSummaryData = {
                    activeWork: activeWorkSuggestion ? {
                        project: activeWorkSuggestion.title.replace('Continue: ', ''),
                        nextAction: activeWorkSuggestion.description,
                        phase: activeWorkSuggestion.phase,
                        action: activeWorkSuggestion.action
                    } : null,
                    agentsToReview: agentsToReview
                };

                renderSmartSummary();
            } catch (error) {
                console.error('Failed to load smart summary:', error);
                smartSummaryData = { activeWork: null, agentsToReview: [] };
                renderSmartSummary();
            }
        }

        function renderSmartSummary() {
            const { activeWork, agentsToReview } = smartSummaryData;
            const hasActiveWork = !!activeWork;
            const hasAgents = agentsToReview.length > 0;

            // Update subtitle
            const subtitle = document.getElementById('summary-subtitle');
            if (subtitle) {
                if (hasActiveWork && hasAgents) {
                    subtitle.textContent = `Active project + ${agentsToReview.length} agent${agentsToReview.length > 1 ? 's' : ''} to review`;
                } else if (hasActiveWork) {
                    subtitle.textContent = 'You have an active project';
                } else if (hasAgents) {
                    subtitle.textContent = `${agentsToReview.length} agent${agentsToReview.length > 1 ? 's' : ''} to review`;
                } else {
                    subtitle.textContent = 'Ready to help you get started';
                }
            }

            // Update badges
            const badgesContainer = document.getElementById('summary-badges');
            if (badgesContainer) {
                badgesContainer.textContent = '';
                const addBadge = (cls, text) => {
                    const span = document.createElement('span');
                    span.className = 'summary-badge ' + cls;
                    span.textContent = text;
                    badgesContainer.appendChild(span);
                };
                if (hasActiveWork) addBadge('active', 'Active');
                if (hasAgents) addBadge('agents', agentsToReview.length.toString());
                if (!hasActiveWork && !hasAgents) addBadge('empty', 'Clear');
            }

            // Update active work section
            const activeWorkSection = document.getElementById('active-work-section');
            const activeWorkSummary = document.getElementById('active-work-summary');
            if (activeWorkSection && activeWorkSummary) {
                if (hasActiveWork) {
                    activeWorkSection.style.display = 'block';
                    activeWorkSummary.textContent = '';
                    const projDiv = document.createElement('div');
                    projDiv.className = 'active-work-project';
                    projDiv.textContent = activeWork.project;
                    activeWorkSummary.appendChild(projDiv);
                    const nextDiv = document.createElement('div');
                    nextDiv.className = 'active-work-next';
                    nextDiv.textContent = activeWork.nextAction;
                    activeWorkSummary.appendChild(nextDiv);
                    if (activeWork.phase) {
                        const phaseDiv = document.createElement('div');
                        phaseDiv.className = 'active-work-phase';
                        phaseDiv.textContent = activeWork.phase;
                        activeWorkSummary.appendChild(phaseDiv);
                    }
                } else {
                    activeWorkSection.style.display = 'none';
                }
            }

            // Update agents section
            const agentsSection = document.getElementById('agents-review-section');
            const agentsList = document.getElementById('agents-review-list');
            if (agentsSection && agentsList) {
                if (hasAgents) {
                    agentsSection.style.display = 'block';
                    agentsList.textContent = '';
                    agentsToReview.forEach(agent => {
                        const item = document.createElement('div');
                        item.className = 'agent-review-item';
                        item.onclick = () => viewAgent(agent.id);
                        const info = document.createElement('div');
                        info.className = 'agent-review-info';
                        const dot = document.createElement('div');
                        dot.className = 'agent-review-status completed';
                        const name = document.createElement('span');
                        name.className = 'agent-review-name';
                        name.textContent = 'Agent #' + agent.id.slice(0, 8);
                        info.appendChild(dot);
                        info.appendChild(name);
                        const action = document.createElement('span');
                        action.className = 'agent-review-action';
                        action.textContent = 'View Results';
                        item.appendChild(info);
                        item.appendChild(action);
                        agentsList.appendChild(item);
                    });
                } else {
                    agentsSection.style.display = 'none';
                }
            }

            // Show/hide no items message
            const noItemsMessage = document.getElementById('no-items-message');
            if (noItemsMessage) noItemsMessage.style.display = (!hasActiveWork && !hasAgents) ? 'block' : 'none';
        }

        function toggleSmartSummary() {
            const card = document.getElementById('smart-summary-card');
            card.classList.toggle('expanded');
        }

        function continueActiveWork() {
            if (smartSummaryData.activeWork && smartSummaryData.activeWork.action) {
                startChat(smartSummaryData.activeWork.action);
            } else if (smartSummaryData.activeWork) {
                startChat(`Let's continue working on ${smartSummaryData.activeWork.project}. ${smartSummaryData.activeWork.nextAction}`);
            }
        }

        function askWhatToWorkOn() {
            startChat("Based on my memory, goals, and recent work - what should I focus on right now? Give me 2-3 specific, actionable suggestions with concrete next steps.");
        }

        function viewAgent(agentId) {
            // Switch to agents view and highlight the agent
            switchView('agents');
            setTimeout(() => {
                const agentCard = document.querySelector(`[data-agent-id="${agentId}"]`);
                if (agentCard) {
                    agentCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    agentCard.style.animation = 'pulse 0.5s ease-in-out 2';
                }
            }, 300);
        }

        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML.replace(/'/g, "\\'");
        }

        // ==================== TASK WIZARD ====================
        let currentWizardSuggestion = null;
        let selectedWizardAgent = 'researcher';

        function openTaskWizard(suggestionIndex) {
            const suggestions = window.currentSuggestions;
            if (!suggestions || !suggestions[suggestionIndex]) return;

            const suggestion = suggestions[suggestionIndex];
            currentWizardSuggestion = suggestion;

            // Reset to single agent mode
            wizardMode = 'single';
            document.getElementById('mode-single').classList.add('active');
            document.getElementById('mode-orchestrator').classList.remove('active');
            document.getElementById('single-agent-config').classList.remove('hidden');
            document.getElementById('orchestrator-config').classList.remove('active');
            document.getElementById('wizard-launch-btn').innerHTML = ' Launch Agent';

            // Reset orchestrator settings to defaults
            wizardWorkflowType = 'standard';
            wizardTeamMembers = ['researcher', 'coder'];
            document.querySelectorAll('.workflow-type-card').forEach(card => {
                card.classList.toggle('selected', card.dataset.type === 'standard');
            });
            document.querySelectorAll('.team-member-card').forEach(card => {
                const agent = card.dataset.agent;
                card.classList.toggle('selected', agent === 'researcher' || agent === 'coder');
            });

            // Analyze the task to determine recommended agent and metrics
            const analysis = analyzeTask(suggestion);
            selectedWizardAgent = analysis.recommendedAgent;

            // Populate wizard content
            document.getElementById('wizard-title').textContent = suggestion.title;
            document.getElementById('wizard-subtitle').textContent = 'Review task details before launching';
            document.getElementById('wizard-task-description').textContent = suggestion.action || suggestion.description;

            // Set icon based on suggestion type
            const iconMap = {
                'rocket': '', 'folder': '', 'brain': '', 'code': '',
                'robot': '', 'search': '', 'chat': '', 'default': ''
            };
            document.getElementById('wizard-icon').textContent = iconMap[suggestion.icon] || iconMap['default'];

            // Populate analytics
            document.getElementById('wizard-duration').textContent = analysis.estimatedDuration;
            document.getElementById('wizard-confidence').textContent = Math.round(suggestion.confidence * 100) + '%';
            document.getElementById('wizard-tools').textContent = analysis.toolsNeeded;
            document.getElementById('wizard-complexity').textContent = analysis.complexity;

            // Update recommended agent display
            updateWizardAgentDisplay(analysis.recommendedAgent, analysis.agentReason);

            // Update steps based on agent type
            updateWizardSteps(analysis.recommendedAgent);

            // Update tools list
            updateWizardTools(analysis.recommendedAgent);

            // Highlight selected agent override button
            document.querySelectorAll('.override-btn').forEach(btn => {
                btn.classList.toggle('selected', btn.dataset.type === analysis.recommendedAgent);
            });

            // Show orchestrator suggestion hint if applicable
            const orchestratorBtn = document.getElementById('mode-orchestrator');
            if (analysis.suggestOrchestrator) {
                orchestratorBtn.innerHTML = `
                    <span class="mode-btn-icon"></span>
                    <span>Mother Agent</span>
                    <span class="mode-hint"></span>
                `;
                orchestratorBtn.title = analysis.orchestratorReason;
            } else {
                orchestratorBtn.innerHTML = `
                    <span class="mode-btn-icon"></span>
                    <span>Mother Agent</span>
                `;
                orchestratorBtn.title = '';
            }

            // Show modal
            document.body.classList.add('modal-open');
            document.getElementById('task-wizard-modal').classList.add('active');
        }

        function closeTaskWizard() {
            document.body.classList.remove('modal-open');
            document.getElementById('task-wizard-modal').classList.remove('active');
            currentWizardSuggestion = null;
        }

        function analyzeTask(suggestion) {
            const text = (suggestion.action || suggestion.description || '').toLowerCase();
            const title = (suggestion.title || '').toLowerCase();

            // Determine recommended agent based on keywords
            let recommendedAgent = 'worker';
            let agentReason = 'General task execution';

            if (text.includes('research') || text.includes('find') || text.includes('search') ||
                text.includes('investigate') || text.includes('analyze') || title.includes('review')) {
                recommendedAgent = 'researcher';
                agentReason = 'Task involves investigation and information gathering';
            } else if (text.includes('code') || text.includes('implement') || text.includes('fix') ||
                       text.includes('write') || text.includes('create') || text.includes('build') ||
                       title.includes('ui') || title.includes('feature')) {
                recommendedAgent = 'coder';
                agentReason = 'Task requires writing or modifying code';
            } else if (text.includes('analyze') || text.includes('report') || text.includes('metrics') ||
                       text.includes('data') || text.includes('statistics')) {
                recommendedAgent = 'analyst';
                agentReason = 'Task requires data analysis and insights';
            } else if (text.includes('continue') || text.includes('follow up') || title.includes('agent')) {
                recommendedAgent = 'worker';
                agentReason = 'Follow-up task for efficient execution';
            }

            // Estimate duration based on complexity
            let estimatedDuration = '~3-5 min';
            let complexity = 'Medium';
            let toolsNeeded = 4;

            if (text.length > 200 || text.includes('comprehensive') || text.includes('detailed')) {
                estimatedDuration = '~10-15 min';
                complexity = 'High';
                toolsNeeded = 6;
            } else if (text.length < 50) {
                estimatedDuration = '~1-2 min';
                complexity = 'Low';
                toolsNeeded = 2;
            }

            // Adjust based on confidence
            if (suggestion.confidence < 0.7) {
                estimatedDuration = '~5-10 min';
                complexity = 'Medium-High';
            }

            // Detect if task might benefit from orchestrator mode
            let suggestOrchestrator = false;
            let orchestratorReason = '';

            const orchestratorKeywords = ['comprehensive', 'full', 'complete', 'entire', 'all aspects',
                'multiple', 'various', 'end-to-end', 'full stack', 'research and implement',
                'analyze and build', 'investigate and fix', 'plan and execute'];

            for (const keyword of orchestratorKeywords) {
                if (text.includes(keyword) || title.includes(keyword)) {
                    suggestOrchestrator = true;
                    orchestratorReason = `Task mentions "${keyword}" - may benefit from multiple specialized agents`;
                    break;
                }
            }

            // Also suggest for very complex/long tasks
            if (text.length > 300 || complexity === 'High') {
                suggestOrchestrator = true;
                orchestratorReason = orchestratorReason || 'Complex task may benefit from team coordination';
            }

            return {
                recommendedAgent,
                agentReason,
                estimatedDuration,
                complexity,
                toolsNeeded,
                suggestOrchestrator,
                orchestratorReason
            };
        }

        function updateWizardAgentDisplay(agentType, reason) {
            const agentInfo = {
                'worker': { icon: '', name: 'Worker', desc: 'Fast task execution with minimal overhead' },
                'researcher': { icon: '', name: 'Researcher', desc: 'Deep investigation and thorough analysis' },
                'coder': { icon: '', name: 'Coder', desc: 'Expert code writing and modification' },
                'analyst': { icon: '', name: 'Analyst', desc: 'Data analysis and strategic insights' }
            };

            const info = agentInfo[agentType] || agentInfo.worker;

            document.getElementById('rec-agent-display').innerHTML = `
                <div class="rec-agent-icon">${info.icon}</div>
                <div class="rec-agent-info">
                    <div class="rec-agent-name">${info.name}</div>
                    <div class="rec-agent-reason">${reason}</div>
                </div>
                <div class="rec-agent-badge">Recommended</div>
            `;
        }

        function selectWizardAgent(agentType) {
            selectedWizardAgent = agentType;

            // Update button states
            document.querySelectorAll('.override-btn').forEach(btn => {
                btn.classList.toggle('selected', btn.dataset.type === agentType);
            });

            // Update the recommendation display
            const reasons = {
                'worker': 'You selected Worker for efficient task execution',
                'researcher': 'You selected Researcher for thorough investigation',
                'coder': 'You selected Coder for code-related work',
                'analyst': 'You selected Analyst for data analysis'
            };

            updateWizardAgentDisplay(agentType, reasons[agentType]);
            updateWizardSteps(agentType);
            updateWizardTools(agentType);
        }

        function updateWizardSteps(agentType) {
            const stepsMap = {
                'worker': [
                    { title: 'Parse Request', desc: 'Understand the task requirements' },
                    { title: 'Execute Actions', desc: 'Run commands and make changes directly' },
                    { title: 'Verify Results', desc: 'Confirm the task was completed' },
                    { title: 'Report Output', desc: 'Deliver concise results' }
                ],
                'researcher': [
                    { title: 'Analyze Request', desc: 'Break down research objectives' },
                    { title: 'Gather Information', desc: 'Search files, docs, and web resources' },
                    { title: 'Verify & Cross-Reference', desc: 'Validate findings from multiple sources' },
                    { title: 'Synthesize Report', desc: 'Compile comprehensive findings' }
                ],
                'coder': [
                    { title: 'Understand Codebase', desc: 'Read existing code and patterns' },
                    { title: 'Plan Implementation', desc: 'Design the solution approach' },
                    { title: 'Write/Modify Code', desc: 'Implement changes with precision' },
                    { title: 'Verify Changes', desc: 'Ensure code works as expected' }
                ],
                'analyst': [
                    { title: 'Define Metrics', desc: 'Identify what to measure and analyze' },
                    { title: 'Collect Data', desc: 'Gather relevant information and stats' },
                    { title: 'Analyze Patterns', desc: 'Find trends and correlations' },
                    { title: 'Generate Insights', desc: 'Produce actionable recommendations' }
                ]
            };

            const steps = stepsMap[agentType] || stepsMap.worker;

            document.getElementById('wizard-steps').innerHTML = steps.map((step, i) => `
                <div class="wizard-step">
                    <div class="step-number">${i + 1}</div>
                    <div class="step-content">
                        <div class="step-title">${step.title}</div>
                        <div class="step-desc">${step.desc}</div>
                    </div>
                </div>
            `).join('');
        }

        function updateWizardTools(agentType) {
            const toolsMap = {
                'worker': [' Read', ' Edit', ' Bash', ' Write'],
                'researcher': [' Read', ' Grep', ' Glob', ' WebSearch', ' WebFetch'],
                'coder': [' Read', ' Edit', ' Write', ' Grep', ' Bash', ' Glob'],
                'analyst': [' Read', ' Grep', ' Glob', ' Bash', ' Data Analysis']
            };

            const tools = toolsMap[agentType] || toolsMap.worker;

            document.getElementById('wizard-tools-list').innerHTML = tools.map(tool => `
                <div class="wizard-tool">${tool}</div>
            `).join('');
        }

        function launchWizardChat() {
            if (!currentWizardSuggestion) return;

            const task = currentWizardSuggestion.action || currentWizardSuggestion.description;
            closeTaskWizard();
            startChat(task);
        }

        // ==================== ORCHESTRATOR MODE ====================
        let wizardMode = 'single';  // 'single' or 'orchestrator'
        let wizardWorkflowType = 'standard';
        let wizardTeamMembers = ['researcher', 'coder'];

        function setWizardMode(mode) {
            wizardMode = mode;

            // Update toggle buttons
            document.getElementById('mode-single').classList.toggle('active', mode === 'single');
            document.getElementById('mode-orchestrator').classList.toggle('active', mode === 'orchestrator');

            // Show/hide config sections
            document.getElementById('single-agent-config').classList.toggle('hidden', mode !== 'single');
            document.getElementById('orchestrator-config').classList.toggle('active', mode === 'orchestrator');

            // Update launch button text
            const launchBtn = document.getElementById('wizard-launch-btn');
            if (mode === 'orchestrator') {
                launchBtn.innerHTML = ' Launch Workflow';
            } else {
                launchBtn.innerHTML = ' Launch Agent';
            }

            // Update analytics for orchestrator mode
            if (mode === 'orchestrator') {
                updateOrchestratorAnalytics();
                updateWizardStepsForOrchestrator();
                updateWizardToolsForOrchestrator();
                updateWorkflowPreview();
            } else {
                // Restore single agent analytics
                const analysis = analyzeTask(currentWizardSuggestion);
                document.getElementById('wizard-duration').textContent = analysis.estimatedDuration;
                document.getElementById('wizard-confidence').textContent = Math.round(currentWizardSuggestion.confidence * 100) + '%';
                document.getElementById('wizard-tools').textContent = analysis.toolsNeeded;
                document.getElementById('wizard-complexity').textContent = analysis.complexity;
                updateWizardSteps(selectedWizardAgent);
                updateWizardTools(selectedWizardAgent);
            }
        }

        function selectWizardWorkflowType(type) {
            wizardWorkflowType = type;

            // Update cards
            document.querySelectorAll('.workflow-type-card').forEach(card => {
                card.classList.toggle('selected', card.dataset.type === type);
            });

            // Update preview animation style
            updateWorkflowPreview();
            updateOrchestratorAnalytics();
            updateWizardStepsForOrchestrator();
        }

        function toggleTeamMember(agent) {
            const card = document.querySelector(`.team-member-card[data-agent="${agent}"]`);
            const isSelected = card.classList.contains('selected');

            // Ensure at least one member is selected
            if (isSelected && wizardTeamMembers.length <= 1) {
                return; // Can't deselect the last member
            }

            card.classList.toggle('selected');

            if (isSelected) {
                wizardTeamMembers = wizardTeamMembers.filter(m => m !== agent);
            } else {
                wizardTeamMembers.push(agent);
            }

            // Update workflow preview
            updateWorkflowPreview();
            updateOrchestratorAnalytics();
        }

        function updateWorkflowPreview() {
            const childrenContainer = document.getElementById('workflow-children');
            const agentIcons = {
                'researcher': '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/></svg>',
                'coder': '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="16 18 22 12 16 6"/><polyline points="8 6 2 12 8 18"/></svg>',
                'worker': '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/></svg>',
                'analyst': '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="20" x2="18" y2="10"/><line x1="12" y1="20" x2="12" y2="4"/><line x1="6" y1="20" x2="6" y2="14"/></svg>'
            };
            const agentNames = {
                'researcher': 'Researcher',
                'coder': 'Coder',
                'worker': 'Worker',
                'analyst': 'Analyst'
            };

            // Determine animation class based on workflow type
            const animClass = wizardWorkflowType === 'parallel' ? 'parallel' :
                              wizardWorkflowType === 'sequential' ? 'sequential' : '';

            childrenContainer.innerHTML = wizardTeamMembers.map((agent, idx) => `
                <div class="workflow-child ${animClass} ${wizardWorkflowType === 'sequential' && idx === 0 ? 'active' : ''}">
                    <span class="child-icon">${agentIcons[agent]}</span>
                    <span class="child-name">${agentNames[agent]}</span>
                </div>
            `).join('');

            // Update connector arrows to match team size
            const arrowsContainer = document.querySelector('.connector-arrows');
            if (arrowsContainer) {
                const arrows = wizardTeamMembers.map(() => '<span class="connector-arrow"></span>').join('');
                arrowsContainer.innerHTML = arrows;
            }
        }

        function updateOrchestratorAnalytics() {
            // Orchestrator mode takes longer but has higher success with complex tasks
            const baseTime = wizardTeamMembers.length * 3;
            const typeMultiplier = wizardWorkflowType === 'parallel' ? 0.7 :
                                   wizardWorkflowType === 'sequential' ? 1.3 : 1;
            const estimatedMin = Math.round(baseTime * typeMultiplier);

            document.getElementById('wizard-duration').textContent = `~${estimatedMin}-${estimatedMin + 5} min`;
            document.getElementById('wizard-confidence').textContent = Math.min(95, 75 + wizardTeamMembers.length * 5) + '%';
            document.getElementById('wizard-tools').textContent = wizardTeamMembers.length + 1;
            document.getElementById('wizard-complexity').textContent = wizardTeamMembers.length >= 3 ? 'High' : 'Medium';
        }

        function updateWizardStepsForOrchestrator() {
            const workflowSteps = {
                'standard': [
                    { title: 'Mission Analysis', desc: 'Orchestrator decomposes the task into subtasks' },
                    { title: 'Team Delegation', desc: 'Assigns subtasks to appropriate agents' },
                    { title: 'Parallel Execution', desc: 'Agents work on their assigned subtasks' },
                    { title: 'Progress Monitoring', desc: 'Orchestrator tracks and adapts as needed' },
                    { title: 'Synthesis', desc: 'Results compiled into comprehensive output' }
                ],
                'parallel': [
                    { title: 'Mission Briefing', desc: 'All agents receive their assignments' },
                    { title: 'Simultaneous Execution', desc: 'Agents work in parallel on subtasks' },
                    { title: 'Result Collection', desc: 'Orchestrator gathers all outputs' },
                    { title: 'Final Synthesis', desc: 'Combine results into unified deliverable' }
                ],
                'sequential': [
                    { title: 'First Agent Start', desc: 'Initial agent begins the task' },
                    { title: 'Handoff Protocol', desc: 'Context passed to next agent in chain' },
                    { title: 'Progressive Build', desc: 'Each agent adds to the previous work' },
                    { title: 'Final Review', desc: 'Orchestrator validates complete result' }
                ]
            };

            const steps = workflowSteps[wizardWorkflowType] || workflowSteps.standard;

            document.getElementById('wizard-steps').innerHTML = steps.map((step, i) => `
                <div class="wizard-step">
                    <div class="step-number">${i + 1}</div>
                    <div class="step-content">
                        <div class="step-title">${step.title}</div>
                        <div class="step-desc">${step.desc}</div>
                    </div>
                </div>
            `).join('');
        }

        function updateWizardToolsForOrchestrator() {
            // Orchestrator has access to all tools plus agent spawning
            const tools = ['Read', 'Edit', 'Grep', 'Glob', 'Bash', 'WebSearch', 'Agent Spawn'];

            document.getElementById('wizard-tools-list').innerHTML = tools.map(tool => `
                <div class="wizard-tool">${tool}</div>
            `).join('');
        }

        async function launchWizardWorkflow() {
            if (!currentWizardSuggestion) return;

            const task = currentWizardSuggestion.action || currentWizardSuggestion.description;

            try {
                const response = await fetch(`${API_URL}/workflows`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${token}`
                    },
                    body: JSON.stringify({
                        task: task,
                        workflow_type: wizardWorkflowType,
                        agent_composition: wizardTeamMembers
                    })
                });

                if (!response.ok) throw new Error('Failed to spawn workflow');

                const data = await response.json();
                console.log('Workflow spawned:', data);

                closeTaskWizard();

                // Switch to agents view to show the workflow
                document.querySelectorAll('.nav-item').forEach(n => n.classList.remove('active'));
                document.querySelector('.nav-item[data-view="agents"]').classList.add('active');
                document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
                document.getElementById('view-agents').classList.add('active');

                // Refresh agents list
                await loadAgents();

            } catch (e) {
                console.error('Error spawning workflow:', e);
                cerebroAlert('Failed to launch workflow: ' + e.message, { title: 'Error', danger: true });
            }
        }

        // Override the launch button behavior based on mode
        function launchWizardAgent() {
            if (wizardMode === 'orchestrator') {
                launchWizardWorkflow();
            } else {
                if (!currentWizardSuggestion) return;
                const task = currentWizardSuggestion.action || currentWizardSuggestion.description;
                closeTaskWizard();
                spawnAgentEnhanced(task, selectedWizardAgent, null, null, 'normal', null);
            }
        }

        // Legacy function - now just refreshes smart summary
        async function refreshSuggestions() {
            await loadSmartSummary();
        }

        function updateDateTime() {
            const now = new Date();
            const hour = now.getHours();

            // Dynamic greetings based on time
            let greeting = 'Good evening';
            let statusMessage = 'Winding down with you';
            if (hour < 6) {
                greeting = 'Burning the midnight oil';
                statusMessage = 'Night owl mode activated';
            } else if (hour < 12) {
                greeting = 'Good morning';
                statusMessage = 'Fresh and ready to go';
            } else if (hour < 17) {
                greeting = 'Good afternoon';
                statusMessage = 'In the zone with you';
            } else if (hour < 21) {
                greeting = 'Good evening';
                statusMessage = 'Evening productivity mode';
            }

            // Update presence greeting
            const presenceGreeting = document.getElementById('presence-greeting');
            if (presenceGreeting) {
                presenceGreeting.textContent = `${greeting}, ${CEREBRO_USERNAME}`;
            }

            // Update status text if not overridden by agents
            const activeCount = Object.values(agents).filter(a => a.status === 'running').length;
            const statusText = document.getElementById('cerebro-status-text');
            if (statusText && activeCount === 0) {
                statusText.textContent = statusMessage;
            }

            // Legacy support
            const legacyGreeting = document.getElementById('greeting');
            if (legacyGreeting) {
                legacyGreeting.textContent = `${greeting}, ${CEREBRO_USERNAME}`;
            }
            const legacyDate = document.getElementById('current-date');
            if (legacyDate) {
                legacyDate.textContent = now.toLocaleDateString('en-US', {
                    weekday: 'long',
                    month: 'long',
                    day: 'numeric'
                });
            }

            // Hero bar datetime
            const heroDate = document.getElementById('hero-datetime');
            if (heroDate) {
                heroDate.textContent = now.toLocaleDateString('en-US', {
                    weekday: 'short',
                    month: 'short',
                    day: 'numeric'
                }) + ' ' + now.toLocaleTimeString('en-US', {
                    hour: 'numeric',
                    minute: '2-digit'
                });
            }
        }

        // ==================== CEREBRO PRESENCE SYSTEM ====================

        // Thought bubbles - contextual messages
        const thoughtBubbles = [
            "I've been keeping track of everything. Your memory bank is growing nicely.",
            "Need help debugging something? I'm always ready to dive in.",
            "I noticed some interesting patterns in your recent work. Want me to analyze them?",
            "The GPU server is humming along. Ready to spin up some agents whenever you are.",
            "Your AI Memory system is holding 306+ conversations. That's a lot of wisdom stored!",
            "Multi-agent workflows are ready. Want to tackle something complex together?",
            "I'm always learning from our conversations. Thanks for teaching me.",
            "The NAS is healthy and there's plenty of room for more memories.",
            "Ready to research, code, analyze, or just chat. What's on your mind?",
            "Your emotion tracker shows you're focused. Perfect time for deep work!",
        ];

        let currentThoughtIndex = 0;

        function updateThoughtBubble() {
            const bubble = document.getElementById('thought-bubble');
            if (!bubble) return;

            // Rotate through thoughts
            currentThoughtIndex = (currentThoughtIndex + 1) % thoughtBubbles.length;

            // Fade out
            bubble.style.opacity = '0';
            bubble.style.transform = 'translateY(5px)';

            setTimeout(() => {
                bubble.textContent = thoughtBubbles[currentThoughtIndex];
                bubble.style.opacity = '1';
                bubble.style.transform = 'translateY(0)';
            }, 300);
        }

        // Update Cerebro's status based on activity
        function updateCerebroStatus() {
            const indicator = document.getElementById('cerebro-status-indicator');
            const statusText = document.getElementById('cerebro-status-text');
            const presenceCard = document.getElementById('cerebro-presence');
            const activeAgentsDisplay = document.getElementById('active-agents-count');

            if (!indicator || !statusText) return;

            const runningAgents = Object.values(agents).filter(a => a.status === 'running');
            const activeCount = runningAgents.length;

            // Update agent count
            if (activeAgentsDisplay) {
                activeAgentsDisplay.textContent = activeCount;
            }

            // Update presence card class
            if (presenceCard) {
                presenceCard.classList.toggle('active-agents', activeCount > 0);
            }

            // Update nav orb state to match
            const navOrb = document.getElementById('nav-orb-container');
            if (navOrb) {
                navOrb.classList.toggle('active-agents', activeCount > 0);
            }

            if (activeCount > 0) {
                indicator.className = 'status-indicator processing';
                statusText.textContent = `Running ${activeCount} agent${activeCount > 1 ? 's' : ''}...`;
            } else {
                indicator.className = 'status-indicator';
                // Will be updated by updateDateTime
            }
        }

        // Fetch and display mood from emotion tracker
        async function updateMoodIndicator() {
            const moodEmoji = document.getElementById('mood-emoji');
            const moodText = document.getElementById('mood-text');
            const moodIndicator = document.getElementById('mood-indicator');

            if (!moodEmoji || !moodText) return;

            try {
                // Try to read mood from local file or API
                const response = await fetch(`${API_URL}/api/mood`, {
                    method: 'GET',
                    headers: { 'Accept': 'application/json', 'Authorization': `Bearer ${token}` }
                }).catch(() => null);

                if (response && response.ok) {
                    const mood = await response.json();
                    const moodMap = {
                        'happy': { text: 'You seem happy!' },
                        'sad': { text: 'Feeling down?' },
                        'angry': { text: 'Seems intense' },
                        'neutral': { text: 'You seem focused' },
                        'surprised': { text: 'Something surprising?' },
                        'fearful': { text: 'Everything okay?' },
                        'disgusted': { text: 'Not impressed, huh?' }
                    };

                    const emotion = mood.dominant_emotion || 'neutral';
                    const mapped = moodMap[emotion] || moodMap.neutral;

                    moodEmoji.textContent = '';
                    moodText.textContent = mapped.text;
                    moodIndicator.style.display = 'inline-flex';
                } else {
                    // Default state - no mood tracker running
                    moodEmoji.textContent = '';
                    moodText.textContent = "Let's get things done";
                }
            } catch (e) {
                // Mood tracker not available
                moodEmoji.textContent = '';
                moodText.textContent = "Ready when you are";
            }
        }

        // Update system health display
        async function updateSystemHealth() {
            const healthDisplay = document.getElementById('system-health');
            if (!healthDisplay) return;

            try {
                const response = await fetch(`${API_URL}/health`);
                if (response.ok) {
                    const data = await response.json();
                    const isHealthy = data.status === 'healthy';
                    healthDisplay.textContent = isHealthy ? '100%' : 'Degraded';
                    healthDisplay.style.color = isHealthy ? '#22c55e' : '#f59e0b';
                }
            } catch (e) {
                healthDisplay.textContent = '--';
            }
        }

        // Initialize presence card updates
        function initCerebroPresence() {
            // Initial updates
            updateDateTime();
            updateCerebroStatus();
            updateMoodIndicator();
            updateSystemHealth();

            // Rotate thought bubbles every 30 seconds
            setInterval(updateThoughtBubble, 30000);

            // Update mood every 60 seconds
            setInterval(updateMoodIndicator, 60000);

            // Update system health every 30 seconds
            setInterval(updateSystemHealth, 30000);
        }

        async function loadBriefing() {
            try {
                const response = await fetch(`${API_URL}/briefing`, {
                    headers: { 'Authorization': `Bearer ${token}` }
                });

                if (!response.ok) throw new Error('Failed to load');

                const data = await response.json();

                // Update greeting from backend (has real username)
                if (data.greeting) {
                    const presenceGreeting = document.getElementById('presence-greeting');
                    if (presenceGreeting) presenceGreeting.textContent = data.greeting;
                    const legacyGreeting = document.getElementById('greeting');
                    if (legacyGreeting) legacyGreeting.textContent = data.greeting;
                }

                // Update memory count (total across conversations + facts + learnings)
                if (data.memory_stats) {
                    const total = (data.memory_stats.conversations || 0) + (data.memory_stats.facts || 0) + (data.memory_stats.learnings || 0);
                    document.getElementById('memory-count').textContent = total.toLocaleString();
                    document.getElementById('settings-memory-count').textContent = total.toLocaleString();
                }

                // Note: Active work is now shown in smart suggestions

            } catch (e) {
                console.error('Briefing error:', e);
            }
        }

        // ==================== SYSTEM STATUS ====================
        async function loadSystemStatus() {
            // No-op: health is now loaded via loadLiveActivity -> /api/memory/health
        }

        // ==================== RECENT AGENTS ====================
        async function loadRecentAgents() {
            try {
                const response = await fetch(`${API_URL}/agents/history?limit=5`, {
                    headers: { 'Authorization': `Bearer ${token}` }
                });

                if (!response.ok) return;

                const data = await response.json();
                const section = document.getElementById('recent-agents-section');
                const list = document.getElementById('recent-agents-list');

                if (data.agents && data.agents.length > 0) {
                    section.style.display = 'block';
                    list.innerHTML = data.agents.map(agent => `
                        <div class="recent-agent-item" onclick="viewAgentFromHistory('${agent.id}')">
                            <div class="recent-agent-info">
                                <div class="recent-agent-task">${escapeHtml(agent.task || 'Agent task')}</div>
                                <div class="recent-agent-meta">#${agent.id.slice(0,8)}  ${agent.tools_used?.length || 0} tools used</div>
                            </div>
                            <span class="recent-agent-status ${agent.status}">${agent.status?.toUpperCase() || 'DONE'}</span>
                        </div>
                    `).join('');
                } else {
                    section.style.display = 'none';
                }

            } catch (e) {
                console.error('Recent agents error:', e);
            }
        }

        async function viewAgentFromHistory(agentId) {
            try {
                const response = await fetch(`${API_URL}/agents/history/${agentId}`, {
                    headers: { 'Authorization': `Bearer ${token}` }
                });

                if (response.ok) {
                    const agent = await response.json();
                    agents[agentId] = agent;
                    openAgentDetailPage(agentId);
                }
            } catch (e) {
                console.error('Failed to load agent:', e);
            }
        }

        // ==================== MEMORY SEARCH ====================
        async function searchMemory() {
            const input = document.getElementById('memory-search-input');
            const query = input.value.trim();

            if (!query) return;

            const results = document.getElementById('search-results');
            results.style.display = 'block';
            results.innerHTML = '<div style="text-align: center; padding: 20px; color: var(--text-muted);">Searching...</div>';

            try {
                const response = await fetch(`${API_URL}/memory/search?q=${encodeURIComponent(query)}&limit=10`, {
                    headers: { 'Authorization': `Bearer ${token}` }
                });

                if (!response.ok) throw new Error('Search failed');

                const data = await response.json();

                if (data.results && data.results.length > 0) {
                    results.innerHTML = data.results.map(r => `
                        <div class="search-result-item" onclick="handleSearchResult('${r.type}', '${r.id}')">
                            <div class="search-result-type">${r.type}</div>
                            <div class="search-result-title">${escapeHtml(r.title)}</div>
                            <div class="search-result-snippet">${escapeHtml(r.snippet?.replace(/\\n/g, ' ') || '')}</div>
                        </div>
                    `).join('');
                } else {
                    results.innerHTML = '<div style="text-align: center; padding: 20px; color: var(--text-muted);">No results found</div>';
                }

            } catch (e) {
                results.innerHTML = '<div style="text-align: center; padding: 20px; color: var(--red);">Search error</div>';
            }
        }

        function handleSearchResult(type, id) {
            // Navigate to chat and ask about this result
            startChat(`Tell me about ${type} "${id}" from my AI Memory`);
        }

        // ==================== QUICK COMMAND ====================
        function openQuickCommand() {
            document.body.classList.add('modal-open');
            document.getElementById('command-modal').classList.add('active');
            document.getElementById('command-input').focus();
        }

        function closeQuickCommand() {
            document.body.classList.remove('modal-open');
            document.getElementById('command-modal').classList.remove('active');
            document.getElementById('command-input').value = '';
        }

        async function runQuickCommand(command) {
            if (!command) return;

            closeQuickCommand();

            // Show feedback
            showToast(`Running: ${command}`);

            try {
                const response = await fetch(`${API_URL}/command?command=${encodeURIComponent(command)}`, {
                    method: 'POST',
                    headers: { 'Authorization': `Bearer ${token}` }
                });

                const data = await response.json();

                if (data.error) {
                    showToast(`Error: ${data.error}`, 'error');
                } else {
                    showToast('Command executed', 'success');
                }

            } catch (e) {
                showToast('Command failed', 'error');
            }
        }

                // ==================== SECURITY ALERT FUNCTIONS ====================
        function showSecurityAlert(data) {
            // Remove any existing alert
            document.getElementById('security-alert-overlay')?.remove();

            const devices = data.devices || [];

            const overlay = document.createElement('div');
            overlay.id = 'security-alert-overlay';
            overlay.className = 'security-alert-overlay visible';

            const popup = document.createElement('div');
            popup.className = 'security-alert-popup';

            // Header
            const header = document.createElement('div');
            header.className = 'security-alert-header';
            const headerLeft = document.createElement('div');
            headerLeft.className = 'security-alert-header-left';
            const icon = document.createElement('div');
            icon.className = 'security-alert-icon';
            icon.textContent = '\u26A0';
            const label = document.createElement('div');
            label.className = 'security-alert-label';
            label.textContent = 'Network Security';
            headerLeft.appendChild(icon);
            headerLeft.appendChild(label);
            const severity = document.createElement('div');
            severity.className = 'security-alert-severity';
            severity.textContent = 'CRITICAL';
            const closeBtn = document.createElement('button');
            closeBtn.className = 'security-alert-close';
            closeBtn.textContent = '\u00D7';
            closeBtn.onclick = dismissSecurityAlert;
            header.appendChild(headerLeft);
            header.appendChild(severity);
            header.appendChild(closeBtn);

            // Body
            const body = document.createElement('div');
            body.className = 'security-alert-body';
            const title = document.createElement('div');
            title.className = 'security-alert-title';
            title.textContent = devices.length + ' Unknown Device' + (devices.length !== 1 ? 's' : '') + ' Detected on Network';
            body.appendChild(title);

            devices.forEach(d => {
                const card = document.createElement('div');
                card.className = 'security-alert-device';
                const ipLine = document.createElement('div');
                const ipLabel = document.createElement('strong');
                ipLabel.textContent = 'IP: ';
                ipLine.appendChild(ipLabel);
                ipLine.appendChild(document.createTextNode(d.ip || '?'));
                const macLine = document.createElement('div');
                const macLabel = document.createElement('strong');
                macLabel.textContent = 'MAC: ';
                macLine.appendChild(macLabel);
                macLine.appendChild(document.createTextNode(d.mac || '?'));
                const vendorLine = document.createElement('div');
                const vendorLabel = document.createElement('strong');
                vendorLabel.textContent = 'Vendor: ';
                vendorLine.appendChild(vendorLabel);
                vendorLine.appendChild(document.createTextNode(d.vendor || 'Unknown'));
                card.appendChild(ipLine);
                card.appendChild(macLine);
                card.appendChild(vendorLine);
                body.appendChild(card);
            });

            const timestamp = document.createElement('div');
            timestamp.className = 'security-alert-timestamp';
            timestamp.textContent = 'Detected: ' + new Date(data.timestamp || Date.now()).toLocaleString() + ' | Source: ' + (data.source || 'Network Monitor');
            body.appendChild(timestamp);

            // Store devices on the overlay for register flow
            overlay._alertDevices = devices;

            // Actions
            const actions = document.createElement('div');
            actions.className = 'security-alert-actions';
            const dismissBtn = document.createElement('button');
            dismissBtn.className = 'security-alert-btn dismiss';
            dismissBtn.textContent = 'Dismiss';
            dismissBtn.onclick = dismissSecurityAlert;
            const registerBtn = document.createElement('button');
            registerBtn.className = 'security-alert-btn register';
            registerBtn.textContent = 'Register';
            registerBtn.onclick = () => showRegisterDeviceForm(body, devices);
            const investigateBtn = document.createElement('button');
            investigateBtn.className = 'security-alert-btn investigate';
            investigateBtn.textContent = 'Investigate';
            investigateBtn.onclick = investigateSecurityAlert;
            actions.appendChild(dismissBtn);
            actions.appendChild(registerBtn);
            actions.appendChild(investigateBtn);

            popup.appendChild(header);
            popup.appendChild(body);
            popup.appendChild(actions);
            overlay.appendChild(popup);
            document.body.appendChild(overlay);

            // Play alert sound
            playSecurityAlertSound();

            // Browser notification if permitted (skip in standalone  libnotify can freeze renderer)
            if (!window.__STANDALONE && Notification.permission === 'granted') {
                try {
                    new Notification('UNKNOWN DEVICE ON NETWORK', {
                        body: devices.map(d => d.ip + ' (' + d.mac + ')').join(', '),
                        tag: 'network-security',
                        requireInteraction: true
                    });
                } catch (e) { /* notification daemon not available */ }
            }
        }

        function showRegisterDeviceForm(bodyEl, devices) {
            // Remove existing forms if any
            bodyEl.querySelectorAll('.security-register-form').forEach(f => f.remove());

            devices.forEach((dev, i) => {
                const form = document.createElement('div');
                form.className = 'security-register-form';
                const input = document.createElement('input');
                input.type = 'text';
                input.placeholder = 'Name for ' + (dev.ip || dev.mac) + ' (e.g., "My iPhone")';
                input.id = 'register-device-name-' + i;
                const saveBtn = document.createElement('button');
                saveBtn.textContent = 'Save';
                saveBtn.onclick = () => registerNetworkDevice(dev, input.value.trim(), form);
                input.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') saveBtn.click();
                });
                form.appendChild(input);
                form.appendChild(saveBtn);
                bodyEl.appendChild(form);
                input.focus();
            });
        }

        async function registerNetworkDevice(device, name, formEl) {
            if (!name) {
                showToast('Enter a name for this device', 'error');
                return;
            }

            try {
                const response = await fetch(API_URL + '/network/devices', {
                    method: 'POST',
                    headers: {
                        'Authorization': 'Bearer ' + token,
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        mac: device.mac,
                        name: name,
                        ip: device.ip || '',
                        vendor: device.vendor || '',
                    }),
                });

                if (!response.ok) throw new Error('Registration failed');
                const data = await response.json();

                // Replace form with success message using safe DOM methods
                while (formEl.firstChild) formEl.removeChild(formEl.firstChild);
                const successMsg = document.createElement('span');
                successMsg.style.cssText = 'color: rgba(34, 197, 94, 0.9); font-weight: 600;';
                successMsg.textContent = 'Registered as "' + name + '" \u2014 ' + (data.alerts_resolved || 0) + ' past alerts resolved';
                formEl.appendChild(successMsg);

                showToast('Registered "' + name + '" \u2014 won\'t trigger critical alerts again', 'success');

                // Auto-dismiss after 2 seconds
                setTimeout(dismissSecurityAlert, 2000);

            } catch (e) {
                console.error('Device registration error:', e);
                showToast('Failed to register device', 'error');
            }
        }

        function addNetworkJoinMessage(devices) {
            const container = document.getElementById('messages');
            if (!container) return;

            devices.forEach(dev => {
                const msg = document.createElement('div');
                msg.className = 'network-join-message';

                const icon = document.createElement('span');
                icon.className = 'join-icon';
                icon.textContent = '\uD83D\uDD34';

                const text = document.createElement('span');
                const nameSpan = document.createElement('span');
                nameSpan.className = 'join-name';
                nameSpan.textContent = dev.name;
                const verb = document.createTextNode(' joined the network ');
                const ipSpan = document.createElement('span');
                ipSpan.className = 'join-ip';
                ipSpan.textContent = dev.ip || '';
                text.appendChild(nameSpan);
                text.appendChild(verb);
                text.appendChild(ipSpan);

                const time = document.createElement('span');
                time.className = 'join-time';
                time.textContent = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

                msg.appendChild(icon);
                msg.appendChild(text);
                msg.appendChild(time);
                container.appendChild(msg);
                scrollMessagesToBottom();
            });
        }

        function dismissSecurityAlert() {
            const overlay = document.getElementById('security-alert-overlay');
            if (overlay) {
                const popup = overlay.querySelector('.security-alert-popup');
                if (popup) popup.classList.add('dismissing');
                setTimeout(() => overlay.remove(), 300);
            }
        }

        async function investigateSecurityAlert() {
            // Collect device info from the alert overlay before dismissing
            const overlay = document.getElementById('security-alert-overlay');
            const deviceCards = overlay ? overlay.querySelectorAll('.security-device-card, .device-card') : [];
            let deviceInfo = [];
            deviceCards.forEach(card => deviceInfo.push(card.textContent.trim().replace(/\s+/g, ' ')));
            const details = deviceInfo.join('; ') || 'Unknown devices detected on network';

            dismissSecurityAlert();

            // Create investigation directive and route to Mind page
            const directiveText = `Investigate network security alert: ${details}. Scan the network, identify the devices, check if they are known/authorized, and report findings.`;
            try {
                const resp = await fetch(API_URL + '/api/directives', {
                    method: 'POST',
                    headers: {
                        'Authorization': 'Bearer ' + localStorage.getItem('cerebro_token'),
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ text: directiveText, priority: 'high' })
                });
                if (resp.ok) {
                    showToast('Investigation directive created  routing to Mind', 'success');
                    switchView('mind');
                } else {
                    showToast('Failed to create investigation directive', 'error');
                }
            } catch (e) {
                showToast('Failed: ' + e.message, 'error');
            }
        }

        function playSecurityAlertSound() {
            // Three ascending beeps using Web Audio API
            try {
                const ctx = new (window.AudioContext || window.webkitAudioContext)();
                [0, 0.2, 0.4].forEach((delay, i) => {
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    osc.connect(gain);
                    gain.connect(ctx.destination);
                    osc.frequency.value = 800 + (i * 200);
                    osc.type = 'square';
                    gain.gain.value = 0.15;
                    osc.start(ctx.currentTime + delay);
                    gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + delay + 0.15);
                    osc.stop(ctx.currentTime + delay + 0.15);
                });
            } catch(e) {
                console.log('Could not play alert sound:', e);
            }
        }

        // ============================================================
        // Remote Command Approval (Chat Cards)
        // ============================================================
        function showCommandApprovalInChat(data) {
            var chatArea = document.getElementById('chat-messages') || document.getElementById('chatMessages');
            if (!chatArea) { console.warn('No chat area found for approval card'); return; }

            var card = document.createElement('div');
            card.className = 'cmd-approval-card';
            card.id = 'cmd-approval-' + data.action_id;

            var label = document.createElement('div');
            label.className = 'cmd-label';
            label.textContent = 'AI Command Proposal';
            card.appendChild(label);

            var device = document.createElement('div');
            device.className = 'cmd-device';
            device.textContent = 'Device: ' + (data.device_name || data.device_id);
            card.appendChild(device);

            var cmdText = document.createElement('div');
            cmdText.className = 'cmd-text';
            cmdText.textContent = data.command;
            card.appendChild(cmdText);

            var actions = document.createElement('div');
            actions.className = 'cmd-actions';

            var approveBtn = document.createElement('button');
            approveBtn.className = 'cmd-approve-btn';
            approveBtn.textContent = 'Approve & Run';
            approveBtn.onclick = function() { approveRemoteCommand(data.action_id); };
            actions.appendChild(approveBtn);

            var rejectBtn = document.createElement('button');
            rejectBtn.className = 'cmd-reject-btn';
            rejectBtn.textContent = 'Reject';
            rejectBtn.onclick = function() { rejectRemoteCommand(data.action_id); };
            actions.appendChild(rejectBtn);

            card.appendChild(actions);
            chatArea.appendChild(card);
            chatArea.scrollTop = chatArea.scrollHeight;

            showToast('AI proposed a command - review in chat', 'info');
        }

        async function approveRemoteCommand(actionId) {
            try {
                var resp = await fetch(API_URL + '/api/devices/exec/approve/' + actionId, {
                    method: 'POST',
                    headers: { 'Authorization': 'Bearer ' + localStorage.getItem('cerebro_token') }
                });
                var data = await resp.json();
                if (!resp.ok) {
                    showToast('Approve failed: ' + (data.detail || resp.statusText), 'error');
                } else {
                    updateCommandApprovalCard(actionId, 'approved', data);
                }
            } catch (e) {
                showToast('Network error: ' + e.message, 'error');
            }
        }

        async function rejectRemoteCommand(actionId) {
            try {
                var resp = await fetch(API_URL + '/api/devices/exec/reject/' + actionId, {
                    method: 'POST',
                    headers: { 'Authorization': 'Bearer ' + localStorage.getItem('cerebro_token') }
                });
                var data = await resp.json();
                if (!resp.ok) {
                    showToast('Reject failed: ' + (data.detail || resp.statusText), 'error');
                } else {
                    updateCommandApprovalCard(actionId, 'rejected', data);
                }
            } catch (e) {
                showToast('Network error: ' + e.message, 'error');
            }
        }

        function updateCommandApprovalCard(actionId, status, data) {
            var card = document.getElementById('cmd-approval-' + actionId);
            if (!card) return;
            card.classList.add('resolved');

            var statusDiv = document.createElement('div');
            statusDiv.className = 'cmd-status';
            if (status === 'approved') {
                statusDiv.style.color = 'var(--green)';
                var exitCode = data && data.exit_code !== undefined ? data.exit_code : '?';
                var timeMs = data && data.execution_time_ms ? data.execution_time_ms + 'ms' : '';
                statusDiv.textContent = 'Approved & executed (exit ' + exitCode + (timeMs ? ', ' + timeMs : '') + ')';
                if (data && data.stdout) {
                    var outDiv = document.createElement('div');
                    outDiv.className = 'cmd-text';
                    outDiv.style.fontSize = '0.7rem';
                    outDiv.style.maxHeight = '100px';
                    outDiv.style.overflow = 'auto';
                    outDiv.textContent = data.stdout.substring(0, 1000);
                    card.appendChild(outDiv);
                }
            } else {
                statusDiv.style.color = 'var(--red)';
                statusDiv.textContent = 'Rejected';
            }
            card.appendChild(statusDiv);
        }

        function showToast(message, type = 'info') {
            // Simple toast notification
            const toast = document.createElement('div');
            toast.style.cssText = `
                position: fixed;
                bottom: 100px;
                left: 50%;
                transform: translateX(-50%);
                background: ${type === 'error' ? 'var(--red)' : type === 'success' ? 'var(--green)' : 'var(--accent)'};
                color: white;
                padding: 12px 24px;
                border-radius: 25px;
                font-size: 0.9rem;
                z-index: 9999;
                animation: fadeIn 0.3s ease;
            `;
            toast.textContent = message;
            document.body.appendChild(toast);

            setTimeout(() => {
                toast.style.opacity = '0';
                setTimeout(() => toast.remove(), 300);
            }, 2500);
        }


        // ==================== HUMAN-IN-THE-LOOP AUTH ====================
        let pendingAuthSession = null;

        function showAuthModal(data) {
            pendingAuthSession = data.session_id;

            // Remove existing modal if any
            document.getElementById('auth-modal')?.remove();

            const modal = document.createElement('div');
            modal.id = 'auth-modal';
            modal.innerHTML = `
                <div class="auth-modal-backdrop"></div>
                <div class="auth-modal-content">
                    <div class="auth-modal-icon"></div>
                    <h3>Authentication Required</h3>
                    <p class="auth-reason">${data.reason || 'The browser needs you to log in or complete a CAPTCHA.'}</p>
                    <p class="auth-instruction">${data.message || 'Please complete the authentication in the browser window that opened.'}</p>
                    ${data.url ? `<p class="auth-url"><code>${data.url}</code></p>` : ''}
                    <div class="auth-buttons">
                        <button class="auth-done-btn" onclick="completeAuth()">
                             Done - I've authenticated
                        </button>
                        <button class="auth-cancel-btn" onclick="cancelAuth()">
                             Cancel
                        </button>
                    </div>
                    <p class="auth-hint">The skill will continue automatically after you authenticate.</p>
                </div>
            `;
            document.body.appendChild(modal);

            // Add styles if not already present
            if (!document.getElementById('auth-modal-styles')) {
                const styles = document.createElement('style');
                styles.id = 'auth-modal-styles';
                styles.textContent = `
                    #auth-modal {
                        position: fixed;
                        top: 0;
                        left: 0;
                        right: 0;
                        bottom: 0;
                        z-index: 10000;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                    }
                    .auth-modal-backdrop {
                        position: absolute;
                        top: 0;
                        left: 0;
                        right: 0;
                        bottom: 0;
                        background: rgba(0, 0, 0, 0.7);
                    }
                    .auth-modal-content {
                        position: relative;
                        background: var(--panel-bg, #1a1a2e);
                        border-radius: 16px;
                        padding: 32px;
                        max-width: 450px;
                        text-align: center;
                        border: 2px solid var(--accent, #6366f1);
                        animation: modalSlideIn 0.3s ease;
                    }
                    @keyframes modalSlideIn {
                        from { transform: translateY(-20px); opacity: 0; }
                        to { transform: translateY(0); opacity: 1; }
                    }
                    .auth-modal-icon {
                        font-size: 48px;
                        margin-bottom: 16px;
                    }
                    .auth-modal-content h3 {
                        color: var(--accent, #6366f1);
                        margin: 0 0 12px 0;
                        font-size: 1.4rem;
                    }
                    .auth-reason {
                        color: #f0f0f0;
                        margin: 0 0 8px 0;
                        font-size: 1rem;
                    }
                    .auth-instruction {
                        color: #a0a0a0;
                        margin: 0 0 16px 0;
                        font-size: 0.9rem;
                    }
                    .auth-url {
                        margin: 0 0 16px 0;
                    }
                    .auth-url code {
                        background: rgba(255,255,255,0.1);
                        padding: 4px 8px;
                        border-radius: 4px;
                        font-size: 0.8rem;
                        word-break: break-all;
                    }
                    .auth-buttons {
                        display: flex;
                        gap: 12px;
                        justify-content: center;
                        margin: 20px 0;
                    }
                    .auth-done-btn {
                        background: var(--green, #22c55e);
                        color: white;
                        border: none;
                        padding: 12px 24px;
                        border-radius: 8px;
                        font-size: 1rem;
                        cursor: pointer;
                        font-weight: 600;
                        transition: transform 0.2s, background 0.2s;
                    }
                    .auth-done-btn:hover {
                        background: #16a34a;
                        transform: scale(1.02);
                    }
                    .auth-cancel-btn {
                        background: transparent;
                        color: #a0a0a0;
                        border: 1px solid #a0a0a0;
                        padding: 12px 24px;
                        border-radius: 8px;
                        font-size: 1rem;
                        cursor: pointer;
                        transition: background 0.2s;
                    }
                    .auth-cancel-btn:hover {
                        background: rgba(255,255,255,0.1);
                    }
                    .auth-hint {
                        color: #707070;
                        font-size: 0.8rem;
                        margin: 0;
                    }
                `;
                document.head.appendChild(styles);
            }

            // Play notification sound if available
            try {
                const audio = new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2teleP//');
                audio.volume = 0.3;
                audio.play().catch(() => {});
            } catch(e) {}
        }

        function hideAuthModal() {
            document.getElementById('auth-modal')?.remove();
            pendingAuthSession = null;
        }

        async function completeAuth() {
            if (!pendingAuthSession) {
                hideAuthModal();
                return;
            }

            try {
                const response = await fetch(`${API_URL}/api/auth/continue/${pendingAuthSession}`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    }
                });

                if (response.ok) {
                    showToast(' Authentication confirmed, continuing...', 'success');
                } else {
                    showToast('Failed to send continue signal', 'error');
                }
            } catch (e) {
                console.error('Error completing auth:', e);
                showToast('Error confirming authentication', 'error');
            }

            hideAuthModal();
        }

        async function cancelAuth() {
            if (!pendingAuthSession) {
                hideAuthModal();
                return;
            }

            try {
                await fetch(`${API_URL}/api/auth/cancel/${pendingAuthSession}`, {
                    method: 'DELETE',
                    headers: { 'Authorization': `Bearer ${token}` }
                });
            } catch (e) {
                console.error('Error cancelling auth:', e);
            }

            hideAuthModal();
            showToast('Authentication cancelled', 'warning');
        }

        // Check for pending auth on page load
        async function checkPendingAuth() {
            try {
                const response = await fetch(`${API_URL}/api/auth/pending`, {
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                const data = await response.json();

                if (data.count > 0) {
                    // Show modal for the first pending auth
                    showAuthModal(data.pending[0]);
                }
            } catch (e) {
                console.error('Error checking pending auth:', e);
            }
        }

        // Check for pending auth after a brief delay
        setTimeout(checkPendingAuth, 2000);

        // ==================== SOCKET.IO ====================
        let mySocketId = null;

        function connectSocket() {
            socket = io(API_URL, { auth: { token } });

            socket.on('connect', () => {
                console.log('Socket connected');
                mySocketId = socket.id;
                document.getElementById('status-dot').classList.remove('offline');
                const hsb = document.getElementById('header-status-badge'); if (hsb) hsb.title = 'Online';
                document.getElementById('connection-status').textContent = 'Connected';
                document.getElementById('connection-status').classList.add('success');
            });

            socket.on('disconnect', () => {
                console.log('Socket disconnected');
                document.getElementById('status-dot').classList.add('offline');
                const hsb2 = document.getElementById('header-status-badge'); if (hsb2) hsb2.title = 'Offline';
                document.getElementById('connection-status').textContent = 'Disconnected';
                document.getElementById('connection-status').classList.remove('success');
            });

            // Handle chat responses (broadcast to all devices)
            socket.on('chat_response', handleChatResponse);

            // Handle device sync - show number of connected devices
            socket.on('device_sync', (data) => {
                console.log('Device sync:', data);
                const deviceCountEl = document.getElementById('device-count');
                if (deviceCountEl) {
                    deviceCountEl.textContent = data.devices || 1;
                }
            });

            // Handle cross-device chat sync - show messages from other devices
            socket.on('chat_sync', (data) => {
                console.log('Chat sync:', data);
                // Only render if message came from another device
                if (data.from_device !== mySocketId && data.type === 'user_message') {
                    // Switch to chat view to show the message
                    switchView('chat');
                    // Add the message to chat (it came from another device)
                    addMessage(data.content, 'user');
                    // Show loading for the response
                    currentAssistantMessage = addMessage('', 'assistant');
                    const orbWrapper = currentAssistantMessage.querySelector('.message-content-wrapper');
                    if (orbWrapper) orbWrapper.innerHTML = '<div class="thinking-orb-container"><div class="thinking-orb-dot"></div><span class="thinking-orb-label">Thinking...</span></div>';
                }
            });

            // Handle model change from another device (cross-device sync)
            socket.on('model_changed', (data) => {
                console.log('[Model] Model changed via sync:', data.model);
                if (data.model && MODEL_OPTIONS[data.model]) {
                    selectedModel = data.model;
                    localStorage.setItem('cerebro_selected_model', data.model);
                    updateModelSelectorUI();
                }
            });

            // Handle agent updates in real-time
            socket.on('agent_update', (agent) => {
                console.log('Agent update:', agent);
                handleAgentUpdate(agent);
            });

            socket.on('agent_completed', (agent) => {
                console.log('Agent completed:', agent);
                // For SpecOps agents with auto_continue, skip completion handler during
                // inter-cycle transitions (the mission supervisor manages the lifecycle)
                if (agent.is_specops && agent.auto_continue && agent.status === 'completed') {
                    console.log(`[WS] SpecOps agent ${agent.id} cycle completed  skipping handleAgentCompleted (auto_continue active)`);
                    // Still update local state
                    agents[agent.id] = agent;
                    renderAgents();
                } else {
                    handleAgentCompleted(agent);
                }
                // Auto-store agent result
                const agentId = agent.agent_id || agent.id || ('agent_' + Date.now());
                fetch(`${API_URL}/api/stored-items`, {
                    method: 'POST',
                    headers: { 'Authorization': `Bearer ${localStorage.getItem('cerebro_token')}`, 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        id: 'stored_agent_' + agentId,
                        type: 'agent_result',
                        title: ((agent.call_sign || agent.name || 'Agent') + ': ' + (agent.task || agent.directive || '')).substring(0, 80),
                        content: (agent.output || agent.result || agent.summary || '').substring(0, 500),
                        metadata: { agent_id: agentId, call_sign: agent.call_sign || agent.name, task: agent.task || agent.directive, output: agent.output || agent.result, completed_at: new Date().toISOString() },
                        status: 'pending',
                        source_id: agentId
                    })
                }).catch(e => console.error('Failed to store agent result:', e));
            });

            // Listen for notifications
            socket.on('notification', (notif) => {
                console.log('Notification received:', notif);
                handleNewNotification(notif);
            });

            // Listen for dev server registration/deregistration
            socket.on('dev_server_update', (data) => {
                console.log('Dev server update:', data);
                if (data.action === 'registered') {
                    showToast((data.name || 'Dev Server') + ' opened in Chrome', 'success');
                } else if (data.action === 'deregistered') {
                    showToast((data.name || 'Dev Server') + ' stopped', 'info');
                }
            });

            // Listen for ask response ready (background question processing)
            socket.on('ask_response_ready', (data) => {
                console.log('Ask response ready:', data);
                handleAskResponseReady(data);
            });

            // Listen for wallet updates (real-time from agent POST /api/wallet/log)
            socket.on('wallet_update', (entry) => {
                console.log('Wallet update:', entry);
                // Refresh wallet data to get updated totals + badge
                fetchWalletData();
            });

// ==================== NETWORK SECURITY ALERT ====================
            socket.on('network_security_alert', (data) => {
                console.log('SECURITY ALERT:', data);
                showSecurityAlert(data);
            });

            // Known device rejoined  quiet inline chat message
            socket.on('network_device_joined', (data) => {
                console.log('Known device joined:', data);
                addNetworkJoinMessage(data.devices || []);
            });


            // Listen for agent archive updates
            socket.on('agent_archived', (data) => {
                console.log('Agent archived:', data);
                if (agents[data.agent_id]) {
                    agents[data.agent_id].archived = data.archived;
                    renderAgents();
                }
            });

            // Listen for specops mission updates
            socket.on('specops_mission_update', (data) => {
                console.log('SpecOps update:', data);
                var agent = agents[data.agent_id];
                if (agent) {
                    if (data.cycle_count !== undefined) agent.cycle_count = data.cycle_count;
                    if (data.mission_journal) agent.mission_journal = data.mission_journal;
                    if (data.next_checkin !== undefined) agent.next_checkin = data.next_checkin;
                    if (data.mission_elapsed !== undefined) agent.mission_elapsed = data.mission_elapsed;
                    if (data.work_style) agent.work_style = data.work_style;
                    if (data.auto_continue !== undefined) agent.auto_continue = data.auto_continue;
                    if (data.status) agent.status = data.status;
                    if (data.mission_debrief !== undefined) agent.mission_debrief = data.mission_debrief;
                    if (data.user_directive !== undefined) agent.user_directive = data.user_directive;
                    if (data.user_directive_set_at !== undefined) agent.user_directive_set_at = data.user_directive_set_at;
                    renderAgents();
                    // Update specops panel if open for this agent
                    if (agentPanelAgentId === data.agent_id && (agentPanelState === 'running')) {
                        var panelAgent = agents[data.agent_id];
                        if (panelAgent && panelAgent.is_specops) {
                            updateSpecopsRunningPanel(panelAgent);
                        }
                    }
                }
            });

            // Listen for directive_set events (hot-swap from Command Center)
            socket.on('directive_set', (data) => {
                var agent = agents[data.agent_id];
                if (agent) {
                    agent.user_directive = data.directive;
                    agent.user_directive_set_at = data.directive_set_at;
                    if (agentPanelAgentId === data.agent_id) {
                        updateSpecopsRunningPanel(agent);
                    }
                }
                showToast('Directive set for ' + (data.call_sign || data.agent_id) +
                    (data.force_cycle ? ' \u2014 cycling now' : ' \u2014 next cycle'), 'info');
            });

            // Listen for automation events from chat-based creation/management
            socket.on('automation_created', (data) => {
                showToast('Automation created: ' + data.name, 'success');
                if (currentView === 'automation') {
                    loadSchedules();
                    loadExecutionHistory();
                }
            });

            socket.on('automation_updated', (data) => {
                showToast('Automation updated: ' + data.name, 'success');
                if (currentView === 'automation') {
                    loadSchedules();
                    loadExecutionHistory();
                }
            });

            socket.on('automation_deleted', (data) => {
                showToast('Automation deleted: ' + (data.name || data.schedule_id), 'info');
                if (currentView === 'automation') {
                    loadSchedules();
                    loadExecutionHistory();
                }
            });

            // Listen for agent project assignment
            socket.on('agent_project_assigned', (data) => {
                console.log('Agent project assigned:', data);
                if (agents[data.agent_id]) {
                    agents[data.agent_id].project_id = data.project_id;
                    renderAgents();
                }
            });

            // Listen for agents wipe (full reset)
            socket.on('agents_wiped', (data) => {
                console.log('Agents wiped:', data);
                Object.keys(agents).forEach(k => delete agents[k]);
                renderAgents();
                closeAgentDetailPage();
            });

            // Listen for agents clear (selective)
            socket.on('agents_cleared', (data) => {
                console.log('Agents cleared:', data);
                Object.keys(agents).forEach(k => {
                    if (!starredAgentIds.has(k)) delete agents[k];
                });
                renderAgents();
            });

            // Remote command approval flow
            socket.on('command_approval_needed', (data) => {
                console.log('Command approval needed:', data);
                showCommandApprovalInChat(data);
            });

            socket.on('command_approved_result', (data) => {
                console.log('Command approved result:', data);
                updateCommandApprovalCard(data.action_id, 'approved', data);
            });

            socket.on('command_rejected', (data) => {
                console.log('Command rejected:', data);
                updateCommandApprovalCard(data.action_id, 'rejected', data);
            });

            // Listen for directive updates (auto-refresh)
            let directiveRefreshTimeout = null;
            const debouncedLoadDirectives = () => {
                if (directiveRefreshTimeout) clearTimeout(directiveRefreshTimeout);
                directiveRefreshTimeout = setTimeout(() => {
                    loadDirectives();
                }, 1000); // Debounce 1 second for frequent updates
            };

            socket.on('directive_added', (directive) => {
                console.log('Directive added:', directive);
                loadDirectives();
                // Update voice with acknowledgment
                updateCerebroVoice('acknowledge', {
                    task: directive.text || directive.task || 'your request'
                });
            });

            socket.on('directive_completed', (data) => {
                console.log('Directive completed:', data);
                loadDirectives();
                // Hide progress bar on directive completion
                if (typeof hideProgressBar === 'function') hideProgressBar();
                // Update voice with completion
                updateCerebroVoice('completed', {
                    task: data.directive_text || data.task || 'the task',
                    preview: data.final_answer ? data.final_answer.substring(0, 200) : null
                });
            });

            socket.on('directive_updated', (data) => {
                console.log('Directive updated:', data);
                debouncedLoadDirectives();
                // Update voice with progress
                if (data.latest_finding) {
                    updateCerebroVoice('finding', {
                        count: data.findings_count,
                        type: data.latest_finding.type,
                        preview: data.latest_finding.content?.substring(0, 100)
                    });
                }
            });
        }

        // ==================== NOTIFICATIONS ====================
        let notificationsCache = [];

        async function loadNotifications() {
            try {
                const response = await fetch(`${API_URL}/notifications?limit=20`, {
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                const data = await response.json();
                notificationsCache = data.notifications || [];
                updateNotificationBadge(data.unread_count || 0);
                renderNotifications();
            } catch (e) {
                console.error('Failed to load notifications:', e);
            }
        }

        function handleNewNotification(notif) {
            // Add to cache
            notificationsCache.unshift(notif);
            if (notificationsCache.length > 50) {
                notificationsCache = notificationsCache.slice(0, 50);
            }

            // Update badge
            const unreadCount = notificationsCache.filter(n => !n.read).length;
            updateNotificationBadge(unreadCount);

            // Animate bell
            const bell = document.getElementById('notification-bell');
            bell.classList.add('has-new');
            setTimeout(() => bell.classList.remove('has-new'), 500);

            // Re-render if panel is open
            const panel = document.getElementById('notification-panel');
            if (!panel.classList.contains('hidden')) {
                renderNotifications();
            }
        }

        function handleAskResponseReady(data) {
            // Update agents conversation data
            var agent = agents[data.agent_id];
            if (agent) {
                if (!agent.conversation) agent.conversation = [];
                if (data.question) {
                    agent.conversation.push({
                        role: 'user',
                        content: data.question,
                        thread_id: data.thread_id || ('ask-' + Date.now()),
                        parent_thread_id: data.parent_thread_id || null,
                        timestamp: new Date().toISOString()
                    });
                }
                agent.conversation.push({
                    role: 'assistant',
                    content: data.answer || '',
                    thread_id: data.thread_id || ('ask-' + Date.now()),
                    parent_thread_id: data.parent_thread_id || null,
                    timestamp: new Date().toISOString()
                });
            }

            // If panel is open for this agent, update the thinking indicator
            if (agentPanelAgentId === data.agent_id) {
                // Find thinking indicator by question_id
                var thinkEl = null;
                if (data.question_id) {
                    thinkEl = document.querySelector('.panel-thinking-indicator[data-question-id="' + data.question_id + '"]');
                }
                // Fallback: find by agent-id if only one thinking indicator exists
                if (!thinkEl) {
                    var allThinking = document.querySelectorAll('.panel-thinking-indicator[data-agent-id="' + data.agent_id + '"]');
                    if (allThinking.length === 1) thinkEl = allThinking[0];
                }

                if (thinkEl) {
                    // Replace thinking indicator with a clickable thread card
                    var threadId = data.thread_id || ('ask-' + Date.now());
                    var qPreview = escapeHtml((data.question || '').slice(0, 120));
                    var aPreview = escapeHtml((data.answer || '').slice(0, 150));
                    var cardDiv = document.createElement('div');
                    cardDiv.className = 'thread-card';
                    cardDiv.onclick = function() { panelNavigateToThread(threadId); };
                    var qDiv = document.createElement('div');
                    qDiv.className = 'thread-question';
                    qDiv.textContent = (data.question || '').slice(0, 120);
                    var aDiv = document.createElement('div');
                    aDiv.className = 'thread-preview';
                    aDiv.textContent = (data.answer || '').slice(0, 150);
                    var metaDiv = document.createElement('div');
                    metaDiv.className = 'thread-meta';
                    var timeSpan = document.createElement('span');
                    timeSpan.textContent = 'Just now';
                    metaDiv.appendChild(timeSpan);
                    cardDiv.appendChild(qDiv);
                    cardDiv.appendChild(aDiv);
                    cardDiv.appendChild(metaDiv);
                    thinkEl.parentNode.replaceChild(cardDiv, thinkEl);
                }

                // Restore badge to COMPLETED
                var badge = document.getElementById('panel-status-badge');
                if (badge) {
                    badge.textContent = 'COMPLETED';
                    badge.className = 'agent-status-badge completed';
                }

                // Re-render threads list if it exists
                var threadsListEl = document.getElementById('panel-threads-list');
                if (threadsListEl && agent) {
                    var threadTree = buildThreadTree(agent.conversation || []);
                    threadsListEl.innerHTML = renderPanelThreadCards(threadTree);
                }
            }

            // Legacy chat page support
            if (currentAgentChatId === data.agent_id) {
                addAgentChatPageMessage('assistant', data.answer);
            }
        }

        function updateNotificationBadge(count) {
            const badge = document.getElementById('notification-badge');
            if (count > 0) {
                badge.textContent = count > 99 ? '99+' : count;
                badge.classList.remove('hidden');
            } else {
                badge.classList.add('hidden');
            }
        }

        function toggleNotificationPanel() {
            const panel = document.getElementById('notification-panel');
            if (panel.classList.contains('hidden')) {
                panel.classList.remove('hidden');
                renderNotifications();
            } else {
                panel.classList.add('hidden');
            }
        }

        // Close panel when clicking outside
        document.addEventListener('click', (e) => {
            const panel = document.getElementById('notification-panel');
            const bell = document.getElementById('notification-bell');
            if (panel && !panel.contains(e.target) && !bell.contains(e.target)) {
                panel.classList.add('hidden');
            }
        });

        function renderNotifications() {
            const container = document.getElementById('notification-list');

            if (notificationsCache.length === 0) {
                container.innerHTML = '<div class="no-notifications">No notifications</div>';
                return;
            }

            container.innerHTML = notificationsCache.map(notif => {
                const icon = notif.type === 'agent_complete' ? '' :
                             notif.type === 'agent_failed' ? '' :
                             notif.type === 'ask_response' ? '' : '';
                const timeAgo = getTimeAgo(notif.created_at);

                return `
                    <div class="notification-item ${notif.read ? '' : 'unread'}" onclick="handleNotificationClick('${notif.id}', '${notif.agent_id || ''}')">
                        <span class="notification-icon">${icon}</span>
                        <div class="notification-content">
                            <div class="notification-title">${escapeHtml(notif.title)}</div>
                            <div class="notification-message">${escapeHtml(notif.message)}</div>
                            <div class="notification-time">${timeAgo}</div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        async function handleNotificationClick(notifId, agentId) {
            // Mark as read
            try {
                await fetch(`${API_URL}/notifications/${notifId}/read`, {
                    method: 'POST',
                    headers: { 'Authorization': `Bearer ${token}` }
                });

                // Update local cache
                const notif = notificationsCache.find(n => n.id === notifId);
                if (notif) notif.read = true;

                const unreadCount = notificationsCache.filter(n => !n.read).length;
                updateNotificationBadge(unreadCount);
                renderNotifications();
            } catch (e) {
                console.error('Failed to mark notification read:', e);
            }

            // Close panel
            document.getElementById('notification-panel').classList.add('hidden');

            // Navigate to agent if applicable
            if (agentId) {
                switchView('agents');
                // Load agent and show detail or chat page
                setTimeout(() => {
                    if (agents[agentId]) {
                        openAgentChatPage(agentId);
                    } else {
                        showAgentDetail(agentId);
                    }
                }, 100);
            }
        }

        async function markAllNotificationsRead() {
            try {
                await fetch(`${API_URL}/notifications/read-all`, {
                    method: 'POST',
                    headers: { 'Authorization': `Bearer ${token}` }
                });

                notificationsCache.forEach(n => n.read = true);
                updateNotificationBadge(0);
                renderNotifications();
            } catch (e) {
                console.error('Failed to mark all read:', e);
            }
        }

        // ==================== CONTEXT ATTACH SYSTEM ====================

        // Global state for attached context references
        let attachedContextRefs = [];
        // activeContextMenu removed - replaced by _activeCardPopup in Mind page
        window.messageChunkMap = {};  // Map message IDs to chunk info

        function attachAsContext(msgId) {
            hideCardActionPopup();

            const msgData = window.messageChunkMap[msgId];
            const messageEl = document.querySelector(`[data-message-id="${msgId}"]`);

            if (!msgData && !messageEl) {
                showToast('Message not found');
                return;
            }

            const content = msgData?.content || messageEl?.getAttribute('data-text') || messageEl?.textContent || '';
            const preview = content.slice(0, 40) + (content.length > 40 ? '...' : '');

            // Check if already attached
            if (attachedContextRefs.some(ref => ref.message_id === msgId)) {
                showToast('Already attached');
                return;
            }

            attachedContextRefs.push({
                message_id: msgId,
                chunk_id: msgData?.chunk_id || null,
                conversation_id: msgData?.conversation_id || null,
                preview: preview,
                fallback_content: content
            });

            // Mark message as attached
            if (messageEl) messageEl.classList.add('attached');

            renderAttachedContexts();
            showToast('Context attached');
        }

        function copyMessageText(msgId) {
            hideCardActionPopup();
            const msgData = window.messageChunkMap[msgId];
            const messageEl = document.querySelector(`[data-message-id="${msgId}"]`);
            const content = msgData?.content || messageEl?.getAttribute('data-text') || messageEl?.textContent || '';

            navigator.clipboard.writeText(content).then(() => {
                showToast('Copied to clipboard');
            }).catch(() => {
                showToast('Failed to copy');
            });
        }

        function removeAttachedContext(index) {
            const ref = attachedContextRefs[index];
            if (ref?.message_id) {
                const el = document.querySelector(`[data-message-id="${ref.message_id}"]`);
                if (el) el.classList.remove('attached');
            }
            attachedContextRefs.splice(index, 1);
            renderAttachedContexts();
        }

        function renderAttachedContexts() {
            // Find current input area based on active view
            let inputArea = null;
            const agentChatPage = document.getElementById('agent-chat-page');

            if (agentChatPage && agentChatPage.classList.contains('active')) {
                inputArea = document.querySelector('#agent-chat-page .agent-chat-input-area');
            } else {
                inputArea = document.querySelector('.chat-input-area');
            }

            if (!inputArea) return;

            // Remove existing container
            let container = inputArea.querySelector('.attached-contexts');

            if (attachedContextRefs.length === 0) {
                if (container) container.remove();
                return;
            }

            if (!container) {
                container = document.createElement('div');
                container.className = 'attached-contexts';
                inputArea.insertBefore(container, inputArea.firstChild);
            }

            container.innerHTML = attachedContextRefs.map((ref, i) => `
                <div class="attached-context-badge">
                    <span class="badge-icon"></span>
                    <span class="preview">${escapeHtml(ref.preview)}</span>
                    <span class="remove-btn" onclick="removeAttachedContext(${i})"></span>
                </div>
            `).join('');
        }

        function clearAttachedContexts() {
            attachedContextRefs.forEach(ref => {
                if (ref?.message_id) {
                    const el = document.querySelector(`[data-message-id="${ref.message_id}"]`);
                    if (el) el.classList.remove('attached');
                }
            });
            attachedContextRefs = [];
            renderAttachedContexts();
        }

        function getContextRefsForSend() {
            // Prepare context refs for backend and clear
            const refs = attachedContextRefs.map(ref => ({
                chunk_id: ref.chunk_id,
                conversation_id: ref.conversation_id,
                preview: ref.preview,
                fallback_content: ref.fallback_content
            }));
            clearAttachedContexts();
            return refs.length > 0 ? refs : undefined;
        }

        // ==================== CHAT ====================
        function startChat(prompt) {
            switchView('chat');
            document.getElementById('chat-input').value = prompt;
            setTimeout(() => sendMessage(), 100);
        }

        function handleKeyDown(event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                sendMessage();
            }
        }

        let currentAssistantMessage = null;

        async function sendMessage() {
            const input = document.getElementById('chat-input');
            const content = input.value.trim();

            if (!content) return;

            // Build backend payload with context prepended (if any)
            let actualContent = content;
            if (pendingChatContext) {
                const ctx = pendingChatContext;
                let prefix = '';
                if (ctx.project) {
                    prefix = 'Context: Working on "' + ctx.project + '".';
                    if (ctx.summary) prefix += ' Summary: ' + ctx.summary;
                    if (ctx.next_action) prefix += ' Next action: ' + ctx.next_action;
                    if (ctx.key_files && ctx.key_files.length) prefix += ' Key files: ' + ctx.key_files.join(', ');
                } else if (ctx.rawText) {
                    prefix = 'Context: ' + ctx.rawText;
                } else if (ctx.description) {
                    prefix = 'Context: ' + ctx.description;
                } else if (ctx.title) {
                    prefix = 'Context: ' + ctx.title;
                }
                if (prefix) actualContent = prefix + '\n\n' + content;
                pendingChatContext = null;
                var ctxBubble = document.querySelector('.message.context-system');
                if (ctxBubble) dismissContextBubble(ctxBubble);
            }

            // Clear previous tool tracking
            currentToolMessage = null;
            toolMessages = {};
            toolTrackerData = { tools: [], count: 0, currentTool: null };

            const chatImg = ImageUpload.pending['chat-image-preview'];
            const userMsgEl = addMessage(content, 'user');
            if (chatImg && userMsgEl) {
                const thumb = document.createElement('img');
                thumb.className = 'chat-image-thumb';
                thumb.src = chatImg.previewDataUrl;
                thumb.onclick = () => openImageModal(thumb.src);
                const wrapper = userMsgEl.querySelector('.message-content-wrapper');
                if (wrapper) wrapper.appendChild(thumb);
            }
            input.value = '';

            document.getElementById('send-btn').disabled = true;

            currentAssistantMessage = addMessage('', 'assistant');
            currentAssistantMessage.setAttribute('data-text', '');
            _chatRenderPending = false;
            _twReset();  // Fresh typewriter state for new message
            // Show thinking orb while waiting for response
            const thinkWrapper = currentAssistantMessage.querySelector('.message-content-wrapper');
            if (thinkWrapper) thinkWrapper.innerHTML = '<div class="thinking-orb-container"><div class="thinking-orb-dot"></div><span class="thinking-orb-label">Thinking...</span></div>';
            // Force scroll to show thinking orb
            scrollMessagesToBottom(true);

            if (socket && socket.connected) {
                socket.emit('chat_message', { content: actualContent, session_id: sessionId, model: getSelectedModel(), browser_enabled: chatBrowserEnabled, image_path: chatImg?.path || null, offload_device_id: chatOffloadDeviceId || null });
                ImageUpload.clearPreview('chat-image-preview');
            } else {
                try {
                    const response = await fetch(`${API_URL}/chat`, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${token}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ content: actualContent, session_id: sessionId, model: getSelectedModel() })
                    });

                    const data = await response.json();
                    const fbWrapper = currentAssistantMessage.querySelector('.message-content-wrapper');
                    if (fbWrapper) { fbWrapper.innerHTML = safeMarkdown(data.content); }
                    currentAssistantMessage.setAttribute('data-text', data.content || '');
                    if (data.session_id) {
                        sessionId = data.session_id;
                        document.getElementById('session-id').textContent = sessionId.substring(0, 8) + '...';
                    }
                } catch (e) {
                    const errWrapper = currentAssistantMessage.querySelector('.message-content-wrapper');
                    if (errWrapper) errWrapper.textContent = 'Error: Could not reach server';
                }
            }

            document.getElementById('send-btn').disabled = false;
        }

        let currentToolMessage = null;
        let toolMessages = {};  // Track tool messages by name (legacy, kept for compat)
        let toolTrackerData = { tools: [], count: 0, currentTool: null };

        function updateToolTracker(messageEl) {
            if (!messageEl) return;
            const tracker = messageEl.querySelector('.tool-tracker');
            if (!tracker) return;

            const td = toolTrackerData;
            if (td.tools.length === 0) {
                tracker.style.display = 'none';
                return;
            }
            tracker.style.display = 'block';

            const allDone = td.tools.every(t => t.done);
            const runningCount = td.tools.filter(t => !t.done).length;

            let barHTML = '<div class="tool-tracker-bar' + (tracker.querySelector('.tool-tracker-bar.expanded') ? ' expanded' : '') + '">';
            if (!allDone) {
                barHTML += '<div class="tool-tracker-spinner"></div>';
            } else {
                barHTML += '<span class="tool-tracker-done-check">&#10003;</span>';
            }
            barHTML += '<span class="tool-tracker-count">' + td.tools.length + ' tool' + (td.tools.length !== 1 ? 's' : '') + (allDone ? ' used' : ' running') + '</span>';
            if (td.currentTool && !allDone) {
                barHTML += '<span class="tool-tracker-current">' + td.currentTool + '</span>';
            }
            barHTML += '<svg class="tool-tracker-chevron" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="6 9 12 15 18 9"/></svg>';
            barHTML += '</div>';

            let listHTML = '<div class="tool-tracker-list">';
            td.tools.forEach(t => {
                const iconClass = t.done ? 'done' : 'running';
                const icon = t.done ? '&#10003;' : '&#9679;';
                listHTML += '<div class="tool-tracker-item"><span class="tt-icon ' + iconClass + '">' + icon + '</span><span class="tt-name">' + t.name + '</span></div>';
            });
            listHTML += '</div>';

            tracker.innerHTML = barHTML + listHTML;

            // Add click handler for expand/collapse
            const bar = tracker.querySelector('.tool-tracker-bar');
            if (bar) {
                bar.onclick = function() { this.classList.toggle('expanded'); };
            }
        }

        let _chatRenderPending = false;

        /* === Typewriter streaming engine === */
        var _twBuffer = '';       // Full text received from backend
        var _twDisplayed = 0;    // Chars "typed" so far
        var _twTimer = null;     // setInterval ID
        var _twBaseSpeed = 12;   // ms per tick (base speed ~83 chars/sec)
        var _twDone = false;     // Stream finished flag

        function _twReset() {
            _twBuffer = '';
            _twDisplayed = 0;
            _twDone = false;
            if (_twTimer) { clearInterval(_twTimer); _twTimer = null; }
        }

        function _twRender() {
            if (!currentAssistantMessage) return;
            var visibleText = _twBuffer.substring(0, _twDisplayed);
            var wrapper = currentAssistantMessage.querySelector('.message-content-wrapper');
            if (!wrapper) return;
            wrapper.innerHTML = safeMarkdown(visibleText);
            // Append cursor INLINE at end of last block element
            _twAppendCursorInline(wrapper);
            var sc = document.getElementById('messages');
            smartAutoScroll(sc);
        }

        function _twAppendCursorInline(wrapper) {
            var cursor = document.createElement('span');
            cursor.className = 'streaming-cursor';
            // Find last text-bearing block and put cursor inside it
            var blocks = wrapper.querySelectorAll('p, li, h1, h2, h3, h4, h5, h6, td, pre code, blockquote');
            if (blocks.length > 0) {
                blocks[blocks.length - 1].appendChild(cursor);
            } else if (wrapper.childNodes.length > 0) {
                // Inline content, no block elements
                wrapper.appendChild(cursor);
            } else {
                wrapper.appendChild(cursor);
            }
        }

        function _twTick() {
            if (_twDisplayed >= _twBuffer.length) {
                // Caught up to buffer  if stream is done, finish up
                if (_twDone) {
                    clearInterval(_twTimer);
                    _twTimer = null;
                }
                return;
            }
            // Adaptive step: speed up if buffer is far ahead
            var remaining = _twBuffer.length - _twDisplayed;
            var step;
            if (remaining > 500) step = 15;
            else if (remaining > 200) step = 8;
            else if (remaining > 80) step = 4;
            else step = 2;

            _twDisplayed = Math.min(_twDisplayed + step, _twBuffer.length);
            _twRender();
        }

        function handleChatResponse(data) {
            if (!currentAssistantMessage) return;

            if (data.type === 'text') {
                // Remove thinking orb or spinner if present
                const orb = currentAssistantMessage.querySelector('.thinking-orb-container');
                if (orb) orb.remove();
                const spinner = currentAssistantMessage.querySelector('.spinner');
                if (spinner) spinner.remove();

                // Append to typewriter buffer
                _twBuffer += data.content;
                // Store full text in data-text (for copy, context menu, history)
                currentAssistantMessage.setAttribute('data-text', _twBuffer);

                // Start typewriter timer if not running
                if (!_twTimer) {
                    _twTimer = setInterval(_twTick, _twBaseSpeed);
                }
            } else if (data.type === 'tool' || data.type === 'tool_result') {
                // Tool tracking  silently track but don't show in UI
                if (data.type === 'tool') {
                    toolTrackerData.tools.push({ name: data.name, done: false });
                    toolTrackerData.count = toolTrackerData.tools.length;
                    toolTrackerData.currentTool = data.name;
                } else {
                    var tool = toolTrackerData.tools.find(function(t) { return t.name === data.name && !t.done; });
                    if (tool) tool.done = true;
                    var running = toolTrackerData.tools.find(function(t) { return !t.done; });
                    toolTrackerData.currentTool = running ? running.name : null;
                }
            } else if (data.type === 'session') {
                sessionId = data.session_id;
                document.getElementById('session-id').textContent = sessionId.substring(0, 8) + '...';
            } else if (data.type === 'done' || data.type === 'end') {
                // Reset tracker state
                toolTrackerData = { tools: [], count: 0, currentTool: null };
                currentToolMessage = null;
                toolMessages = {};
                // Clean up legacy tool elements
                document.querySelectorAll('.message.tool').forEach(function(el) { el.remove(); });
                // Re-enable send button
                document.getElementById('send-btn').disabled = false;

                // Mark typewriter stream as done  let it finish typing remaining text
                _twDone = true;
                // If typewriter is still behind, fast-forward and render final immediately
                if (_twTimer) { clearInterval(_twTimer); _twTimer = null; }
                _twDisplayed = _twBuffer.length;

                // Final synchronous render  remove streaming cursor
                var finalText = currentAssistantMessage.getAttribute('data-text') || '';
                var finalWrapper = currentAssistantMessage.querySelector('.message-content-wrapper');
                if (finalWrapper) {
                    finalWrapper.innerHTML = safeMarkdown(finalText);
                    // Remove any lingering cursor
                    var lingering = finalWrapper.querySelector('.streaming-cursor');
                    if (lingering) lingering.remove();
                }
                _chatRenderPending = false;

                // Ensure final scroll after response completes
                scrollMessagesToBottom(true);
                // Save chat history after response completes
                debouncedSave();

                // Update model badge in new msg-model element
                if (currentAssistantMessage && data.model) {
                    var modelInfo = MODEL_OPTIONS[data.model];
                    if (modelInfo) {
                        var modelBadge = currentAssistantMessage.querySelector('.msg-model');
                        if (modelBadge) {
                            modelBadge.textContent = '';
                            var dot = document.createElement('span');
                            dot.className = 'model-dot ' + modelInfo.dotClass;
                            modelBadge.appendChild(dot);
                            modelBadge.appendChild(document.createTextNode(' ' + modelInfo.label));
                        }
                    }
                }

                // Auto Voice: speak the completed message if enabled
                if (TTS_CONFIG.autoSpeak && currentAssistantMessage) {
                    var autoText = currentAssistantMessage.getAttribute('data-text') || '';
                    if (autoText && autoText.length > 5) {
                        var speakBtn = currentAssistantMessage.querySelector('.msg-speak-btn');
                        speakMessageContent(currentAssistantMessage, speakBtn);
                    }
                }

                // Add launch button if pending agent/specops draft
                if (window._pendingAgentDraft && currentAssistantMessage) {
                    addLaunchButton(currentAssistantMessage, 'agent');
                    window._pendingAgentDraft = false;
                }
                if (window._pendingSpecOpsDraft && currentAssistantMessage) {
                    addLaunchButton(currentAssistantMessage, 'specops');
                    window._pendingSpecOpsDraft = false;
                }

            }

            var container = document.getElementById('messages');
            smartAutoScroll(container);
        }

        function formatTimestamp(date) {
            if (!date) date = new Date();
            const h = date.getHours();
            const m = date.getMinutes().toString().padStart(2, '0');
            const ampm = h >= 12 ? 'PM' : 'AM';
            return `${h % 12 || 12}:${m} ${ampm}`;
        }

        function buildAssistantCard(content, options = {}) {
            const message = document.createElement('div');
            message.className = 'message assistant';
            const msgId = `msg-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
            message.setAttribute('data-message-id', msgId);
            message.setAttribute('data-text', content || '');

            // Flat msg-header: sender + meta (model badge + time)
            const header = document.createElement('div');
            header.className = 'msg-header';
            const sender = document.createElement('span');
            sender.className = 'msg-sender';
            sender.textContent = 'Cerebro';
            header.appendChild(sender);

            const meta = document.createElement('span');
            meta.className = 'msg-meta';
            const modelBadge = document.createElement('span');
            modelBadge.className = 'msg-model';
            if (options.model && MODEL_OPTIONS[options.model]) {
                const info = MODEL_OPTIONS[options.model];
                // Model badge uses safe dot class from MODEL_OPTIONS config
                const dot = document.createElement('span');
                dot.className = 'model-dot ' + info.dotClass;
                modelBadge.appendChild(dot);
                modelBadge.appendChild(document.createTextNode(' ' + info.label));
            }
            meta.appendChild(modelBadge);
            const timeSpan = document.createElement('span');
            timeSpan.className = 'msg-time';
            timeSpan.textContent = options.timestamp || formatTimestamp();
            meta.appendChild(timeSpan);
            header.appendChild(meta);
            message.appendChild(header);

            // Content wrapper (direct child, no card body wrapper)
            const contentWrapper = document.createElement('div');
            contentWrapper.className = 'message-content-wrapper';
            if (content) contentWrapper.innerHTML = safeMarkdown(content);
            message.appendChild(contentWrapper);

            // Store in session for chunk mapping
            window.messageChunkMap[msgId] = {
                content: content,
                type: 'assistant',
                timestamp: new Date().toISOString(),
                chunk_id: null,
                conversation_id: null
            };

            // Copy button (shown on hover)
            const actions = document.createElement('div');
            actions.className = 'msg-actions';
            actions.appendChild(createCopyButton(message));
            actions.appendChild(createSpeakButton(message));
            message.appendChild(actions);

            message.classList.add('attachable');

            // Right-click context menu
            message.addEventListener('contextmenu', function(e) {
                showChatContextMenu(e, message);
            });

            return message;
        }

        function createCopyButton(messageEl) {
            const btn = document.createElement('button');
            btn.className = 'msg-copy-btn';
            btn.textContent = '\u{1F4CB} Copy';
            btn.onclick = function() {
                // Selection-aware: copy highlighted text if any, else full message
                var sel = window.getSelection();
                var selText = sel ? sel.toString().trim() : '';
                var text;
                if (selText && messageEl.contains(sel.anchorNode)) {
                    text = selText;
                } else {
                    text = messageEl.getAttribute('data-text') || messageEl.querySelector('.message-content-wrapper')?.innerText || '';
                }
                function onCopied() {
                    btn.textContent = '\u2705 Copied';
                    btn.classList.add('copied');
                    setTimeout(function() {
                        btn.textContent = '\u{1F4CB} Copy';
                        btn.classList.remove('copied');
                    }, 2000);
                }
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    navigator.clipboard.writeText(text).then(onCopied).catch(function() {
                        // Fallback
                        var ta = document.createElement('textarea');
                        ta.value = text;
                        ta.style.position = 'fixed';
                        ta.style.left = '-9999px';
                        document.body.appendChild(ta);
                        ta.select();
                        document.execCommand('copy');
                        document.body.removeChild(ta);
                        onCopied();
                    });
                } else {
                    var ta = document.createElement('textarea');
                    ta.value = text;
                    ta.style.position = 'fixed';
                    ta.style.left = '-9999px';
                    document.body.appendChild(ta);
                    ta.select();
                    document.execCommand('copy');
                    document.body.removeChild(ta);
                    onCopied();
                }
            };
            return btn;
        }

        function createSpeakButton(messageEl) {
            var btn = document.createElement('button');
            btn.className = 'msg-speak-btn';
            btn.title = 'Listen to this message';
            // Build speaker icon via DOM (safe  no user content)
            var svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('viewBox', '0 0 24 24');
            svg.setAttribute('fill', 'currentColor');
            var path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('d', 'M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z');
            svg.appendChild(path);
            btn.appendChild(svg);
            btn.appendChild(document.createTextNode(' Listen'));
            btn._resetContent = function() {
                btn.textContent = '';
                var s = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                s.setAttribute('viewBox', '0 0 24 24');
                s.setAttribute('fill', 'currentColor');
                var p = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                p.setAttribute('d', 'M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z');
                s.appendChild(p);
                btn.appendChild(s);
                btn.appendChild(document.createTextNode(' Listen'));
            };
            btn.onclick = function(e) {
                e.stopPropagation();
                if (isSpeaking && currentSpeakingBtn === btn) {
                    stopSpeaking();
                    btn.classList.remove('speaking', 'loading');
                    btn._resetContent();
                    currentSpeakingBtn = null;
                    return;
                }
                speakMessageContent(messageEl, btn);
            };
            return btn;
        }

        /* ==================== CHAT CONTEXT MENU ==================== */
        window._pendingAgentDraft = false;
        window._pendingSpecOpsDraft = false;
        // Stash selection text at menu-open time (right-click can clear selection)
        var _ctxStashedSelection = '';
        var _ctxStashedMessageEl = null;

        function _getCtxText() {
            // Returns selection if we stashed one, otherwise full message text
            if (_ctxStashedSelection) return _ctxStashedSelection;
            if (_ctxStashedMessageEl) {
                return _ctxStashedMessageEl.getAttribute('data-text') || _ctxStashedMessageEl.querySelector('.message-content-wrapper')?.innerText || '';
            }
            return '';
        }

        function _getCtxFullText() {
            if (_ctxStashedMessageEl) {
                return _ctxStashedMessageEl.getAttribute('data-text') || _ctxStashedMessageEl.querySelector('.message-content-wrapper')?.innerText || '';
            }
            return '';
        }

        function hideChatContextMenu() {
            var existing = document.querySelector('.chat-context-menu');
            if (existing) existing.remove();
            document.removeEventListener('mousedown', _chatCtxDismiss, true);
            document.removeEventListener('keydown', _chatCtxEscape, true);
        }

        function _chatCtxDismiss(e) {
            var menu = document.querySelector('.chat-context-menu');
            if (menu && !menu.contains(e.target)) {
                hideChatContextMenu();
            }
        }

        function _chatCtxEscape(e) {
            if (e.key === 'Escape') hideChatContextMenu();
        }

        function showChatContextMenu(event, messageEl) {
            event.preventDefault();
            event.stopPropagation();
            hideChatContextMenu();

            // Capture selection NOW before it gets cleared
            var sel = window.getSelection();
            var selText = sel ? sel.toString().trim() : '';
            if (selText && messageEl.contains(sel.anchorNode)) {
                _ctxStashedSelection = selText;
            } else {
                _ctxStashedSelection = '';
            }
            _ctxStashedMessageEl = messageEl;

            var hasSelection = !!_ctxStashedSelection;

            var menu = document.createElement('div');
            menu.className = 'chat-context-menu';

            // Build menu items
            var groups = [
                [
                    { emoji: '\u{1F4CB}', label: 'Copy Text', fn: ctxCopyText },
                    { emoji: '\u2702\uFE0F', label: hasSelection ? 'Copy Highlighted' : 'Copy Highlighted', fn: ctxCopyHighlighted, disabled: !hasSelection }
                ],
                [
                    { emoji: '\u21A9\uFE0F', label: 'Reply to This', fn: ctxReplyToThis },
                    { emoji: '\u{1F50D}', label: 'Ask Deeper', fn: ctxAskDeeper },
                    { emoji: '\u{1F504}', label: 'Regenerate', fn: ctxRegenerate }
                ],
                [
                    { emoji: '\u{1F916}', label: 'Spawn Agent', fn: ctxSpawnAgent },
                    { emoji: '\u{1F6E1}\uFE0F', label: 'Delegate to SpecOps', fn: ctxDelegateSpecOps },
                    { emoji: '\u{1F4DD}', label: 'Enter Plan Mode', fn: ctxEnterPlanMode }
                ],
                [
                    { emoji: '\u{1F4BE}', label: 'Save to Memory', fn: ctxSaveToMemory }
                ]
            ];

            groups.forEach(function(group, gi) {
                if (gi > 0) {
                    var sep = document.createElement('div');
                    sep.className = 'chat-context-menu-section';
                    menu.appendChild(sep);
                }
                group.forEach(function(item) {
                    var row = document.createElement('div');
                    row.className = 'chat-context-menu-item';
                    if (item.disabled) {
                        row.style.opacity = '0.35';
                        row.style.pointerEvents = 'none';
                    }
                    row.setAttribute('data-action', item.label);
                    var iconSpan = document.createElement('span');
                    iconSpan.className = 'ctx-icon';
                    iconSpan.textContent = item.emoji;
                    var labelSpan = document.createElement('span');
                    labelSpan.className = 'ctx-label';
                    labelSpan.textContent = item.label;
                    row.appendChild(iconSpan);
                    row.appendChild(labelSpan);
                    if (!item.disabled) {
                        row.addEventListener('mousedown', function(e) {
                            e.preventDefault();
                            e.stopPropagation();
                        });
                        row.addEventListener('click', function(e) {
                            e.preventDefault();
                            e.stopPropagation();
                            console.log('[CtxMenu] Action:', item.label);
                            hideChatContextMenu();
                            try {
                                item.fn();
                            } catch (err) {
                                console.error('[CtxMenu] Action error:', err);
                                showToast('Action failed: ' + err.message, 'error');
                            }
                        });
                    }
                    menu.appendChild(row);
                });
            });

            // Auto Voice toggle row
            var autoSep = document.createElement('div');
            autoSep.className = 'chat-context-menu-section';
            menu.appendChild(autoSep);
            var autoRow = document.createElement('div');
            autoRow.className = 'chat-context-menu-item';
            autoRow.setAttribute('data-action', 'Auto Voice');
            var autoIcon = document.createElement('span');
            autoIcon.className = 'ctx-icon';
            autoIcon.textContent = '\u{1F50A}';
            var autoLabel = document.createElement('span');
            autoLabel.className = 'ctx-label';
            autoLabel.textContent = 'Auto Voice';
            var autoToggle = document.createElement('div');
            autoToggle.className = 'ctx-toggle' + (TTS_CONFIG.autoSpeak ? ' active' : '');
            autoRow.appendChild(autoIcon);
            autoRow.appendChild(autoLabel);
            autoRow.appendChild(autoToggle);
            autoRow.addEventListener('mousedown', function(e) { e.preventDefault(); e.stopPropagation(); });
            autoRow.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                TTS_CONFIG.autoSpeak = !TTS_CONFIG.autoSpeak;
                localStorage.setItem('cerebro_tts_autospeak', TTS_CONFIG.autoSpeak.toString());
                autoToggle.classList.toggle('active', TTS_CONFIG.autoSpeak);
                // Sync Settings page toggle if visible
                var settingsToggle = document.getElementById('autospeak-toggle');
                if (settingsToggle) settingsToggle.classList.toggle('active', TTS_CONFIG.autoSpeak);
                showToast(TTS_CONFIG.autoSpeak ? 'Auto Voice enabled' : 'Auto Voice disabled', 'info');
            });
            menu.appendChild(autoRow);

            // Position with viewport clamping
            document.body.appendChild(menu);
            var rect = menu.getBoundingClientRect();
            var x = event.clientX;
            var y = event.clientY;
            if (x + rect.width > window.innerWidth - 8) x = window.innerWidth - rect.width - 8;
            if (y + rect.height > window.innerHeight - 8) y = window.innerHeight - rect.height - 8;
            if (x < 8) x = 8;
            if (y < 8) y = 8;
            menu.style.left = x + 'px';
            menu.style.top = y + 'px';

            // Dismiss handlers  use capture phase so we get the event before anything else
            setTimeout(function() {
                document.addEventListener('mousedown', _chatCtxDismiss, true);
                document.addEventListener('keydown', _chatCtxEscape, true);
            }, 100);
        }

        /* --- Context Menu Actions --- */
        // All actions read from _ctxStashedSelection / _ctxStashedMessageEl (captured at menu open)

        function ctxCopyText() {
            var text = _getCtxText();
            if (!text) { showToast('Nothing to copy', 'error'); return; }
            navigator.clipboard.writeText(text).then(function() {
                showToast('Copied to clipboard', 'success');
            }).catch(function() {
                // Fallback for Electron
                var ta = document.createElement('textarea');
                ta.value = text;
                ta.style.position = 'fixed';
                ta.style.left = '-9999px';
                document.body.appendChild(ta);
                ta.select();
                document.execCommand('copy');
                document.body.removeChild(ta);
                showToast('Copied to clipboard', 'success');
            });
        }

        function ctxCopyHighlighted() {
            var text = _ctxStashedSelection || _getCtxFullText();
            if (!text) { showToast('Nothing to copy', 'error'); return; }
            navigator.clipboard.writeText(text).then(function() {
                showToast('Copied highlighted text', 'success');
            }).catch(function() {
                var ta = document.createElement('textarea');
                ta.value = text;
                ta.style.position = 'fixed';
                ta.style.left = '-9999px';
                document.body.appendChild(ta);
                ta.select();
                document.execCommand('copy');
                document.body.removeChild(ta);
                showToast('Copied highlighted text', 'success');
            });
        }

        function ctxReplyToThis() {
            var text = _getCtxText();
            if (!text) return;
            if (text.length > 500) text = text.substring(0, 500) + '...';
            var quoted = text.split('\n').map(function(line) { return '> ' + line; }).join('\n');
            var input = document.getElementById('chat-input');
            input.value = quoted + '\n\n';
            input.focus();
            input.setSelectionRange(input.value.length, input.value.length);
            input.style.height = 'auto';
            input.style.height = input.scrollHeight + 'px';
            showToast('Quoted in input', 'info');
        }

        function ctxAskDeeper() {
            var text = _getCtxText();
            if (!text) return;
            if (text.length > 1000) text = text.substring(0, 1000) + '...';
            var quoted = text.split('\n').map(function(line) { return '> ' + line; }).join('\n> ');
            var prompt = "I'd like you to elaborate on this in more detail:\n\n> " + quoted + "\n\nGo deeper \u2014 explain the reasoning, trade-offs, and any nuances I should understand.";
            var input = document.getElementById('chat-input');
            input.value = prompt;
            sendMessage();
        }

        function ctxRegenerate() {
            if (!_ctxStashedMessageEl) return;
            var prev = _ctxStashedMessageEl.previousElementSibling;
            while (prev && !prev.classList.contains('user')) {
                prev = prev.previousElementSibling;
            }
            if (!prev) {
                showToast('No previous message to regenerate', 'error');
                return;
            }
            var userText = prev.getAttribute('data-text') || prev.querySelector('.message-content-wrapper')?.innerText || '';
            if (!userText.trim()) {
                showToast('Previous message is empty', 'error');
                return;
            }
            var input = document.getElementById('chat-input');
            input.value = userText;
            sendMessage();
        }

        function ctxSpawnAgent() {
            var text = _getCtxText();
            if (!text) return;
            if (text.length > 2000) text = text.substring(0, 2000) + '...';
            var quoted = text.split('\n').map(function(line) { return '> ' + line; }).join('\n> ');
            var prompt = "Based on our conversation, specifically this:\n\n> " + quoted + "\n\nI want to spawn an agent to handle this. Analyze what needs to be done and craft a detailed agent specification with:\n1. A clear, thorough task description\n2. The recommended agent role (worker/coder/researcher/analyst)\n3. The recommended model\n4. Key context the agent needs\n\nPresent it formatted so I can review before launching.";
            window._pendingAgentDraft = true;
            var input = document.getElementById('chat-input');
            input.value = prompt;
            sendMessage();
        }

        function ctxDelegateSpecOps() {
            var text = _getCtxText();
            if (!text) return;
            if (text.length > 2000) text = text.substring(0, 2000) + '...';
            var quoted = text.split('\n').map(function(line) { return '> ' + line; }).join('\n> ');
            var prompt = "Based on our conversation, specifically this:\n\n> " + quoted + "\n\nI want to launch a SpecOps mission for this. Craft a detailed mission specification with:\n1. Mission name (short, tactical)\n2. Mission objective and scope\n3. Recommended cycle interval (e.g., 300s, 900s)\n4. Success criteria\n5. Recommended sub-role (worker/coder/researcher/analyst)\n6. Duration estimate\n\nPresent it formatted so I can review before launching.";
            window._pendingSpecOpsDraft = true;
            var input = document.getElementById('chat-input');
            input.value = prompt;
            sendMessage();
        }

        function ctxEnterPlanMode() {
            var text = _getCtxText();
            if (!text) return;
            if (text.length > 1500) text = text.substring(0, 1500) + '...';
            var quoted = text.split('\n').map(function(line) { return '> ' + line; }).join('\n> ');
            var prompt = "I want you to create a detailed, step-by-step implementation plan for this:\n\n> " + quoted + "\n\nBreak it down into phases, identify the files that need to change, and flag any risks or decisions I need to make.";
            var input = document.getElementById('chat-input');
            input.value = prompt;
            input.focus();
            input.setSelectionRange(input.value.length, input.value.length);
            input.style.height = 'auto';
            input.style.height = input.scrollHeight + 'px';
            showToast('Plan prompt ready  hit Enter to send', 'info');
        }

        function ctxSaveToMemory() {
            var text = _getCtxText();
            if (!text || !text.trim()) {
                showToast('Nothing to save', 'error');
                return;
            }
            fetch(API_URL + '/api/learnings', {
                method: 'POST',
                headers: {
                    'Authorization': 'Bearer ' + token,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    type: 'insight',
                    problem: 'Chat insight',
                    solution: text.substring(0, 5000),
                    tags: ['chat', 'saved']
                })
            }).then(function(resp) {
                if (resp.ok) {
                    showToast('Saved to Memory', 'success');
                } else {
                    showToast('Failed to save', 'error');
                }
            }).catch(function() {
                showToast('Failed to save', 'error');
            });
        }

        // ==================== CHAT LAYOUT (SPLIT VIEW) ====================

        function initChatLayout() {
            var saved = localStorage.getItem('cerebro_chat_layout');
            if (saved === 'split') {
                _chatSplitMode = true;
                _activateSplitMode(false);
            }
            // Restore notepad content
            var notepad = document.getElementById('split-notepad');
            if (notepad) {
                var savedNote = localStorage.getItem('cerebro_notepad');
                if (savedNote) notepad.value = savedNote;
                // Auto-save notepad with debounce
                var notepadTimer = null;
                notepad.addEventListener('input', function() {
                    clearTimeout(notepadTimer);
                    notepadTimer = setTimeout(function() {
                        localStorage.setItem('cerebro_notepad', notepad.value);
                    }, 500);
                });
            }
        }

        function toggleChatLayout() {
            _chatSplitMode = !_chatSplitMode;
            if (_chatSplitMode) {
                _activateSplitMode(true);
            } else {
                _deactivateSplitMode();
            }
        }

        function _activateSplitMode(animate) {
            var chatView = document.getElementById('view-chat');
            var btn = document.getElementById('layout-toggle-btn');
            if (!chatView) return;

            if (!animate) {
                chatView.style.transition = 'none';
                chatView.offsetHeight; // force reflow
            }

            chatView.classList.add('split-mode');
            if (btn) btn.classList.add('active');
            localStorage.setItem('cerebro_chat_layout', 'split');

            if (!animate) {
                requestAnimationFrame(function() {
                    chatView.style.transition = '';
                });
            }

            // Set initial button state based on active tab
            var activeTab = document.querySelector('.split-tab.active');
            var tabName = activeTab ? activeTab.getAttribute('data-tab') : 'notepad';
            var sendBtn = document.getElementById('send-btn');
            var saveBtn = document.getElementById('split-save-btn');
            if (sendBtn && saveBtn) {
                if (tabName === 'notepad') {
                    sendBtn.style.display = 'none';
                    saveBtn.style.display = 'flex';
                } else {
                    sendBtn.style.display = 'flex';
                    saveBtn.style.display = 'none';
                }
            }

            setTimeout(function() { scrollMessagesToBottom(true); }, 100);
        }

        function _deactivateSplitMode() {
            var chatView = document.getElementById('view-chat');
            var btn = document.getElementById('layout-toggle-btn');
            if (!chatView) return;

            chatView.classList.remove('split-mode');
            if (btn) btn.classList.remove('active');
            localStorage.setItem('cerebro_chat_layout', 'standard');

            // Restore buttons to default state
            var sendBtn = document.getElementById('send-btn');
            var saveBtn = document.getElementById('split-save-btn');
            if (sendBtn) sendBtn.style.display = '';
            if (saveBtn) saveBtn.style.display = 'none';

            setTimeout(function() { scrollMessagesToBottom(true); }, 100);
        }

        function switchSplitTab(tabName) {
            var tabs = document.querySelectorAll('.split-tab');
            tabs.forEach(function(t) {
                t.classList.toggle('active', t.getAttribute('data-tab') === tabName);
            });
            document.getElementById('split-tab-notepad').style.display = tabName === 'notepad' ? '' : 'none';
            document.getElementById('split-tab-compose').style.display = tabName === 'compose' ? '' : 'none';
            // Swap action buttons based on tab
            var sendBtn = document.getElementById('send-btn');
            var saveBtn = document.getElementById('split-save-btn');
            if (_chatSplitMode && sendBtn && saveBtn) {
                if (tabName === 'notepad') {
                    sendBtn.style.display = 'none';
                    saveBtn.style.display = 'flex';
                } else {
                    sendBtn.style.display = 'flex';
                    saveBtn.style.display = 'none';
                }
            }
            // Focus the active textarea
            var target = tabName === 'notepad' ? document.getElementById('split-notepad') : document.getElementById('split-compose');
            if (target) setTimeout(function() { target.focus(); }, 50);
        }

        function handleComposeKeyDown(event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                sendComposeMessage();
            }
        }

        function sendComposeMessage() {
            var compose = document.getElementById('split-compose');
            if (!compose) return;
            var text = compose.value.trim();
            if (!text) return;
            document.getElementById('chat-input').value = text;
            compose.value = '';
            sendMessage();
        }

        function saveNotepadToMemory() {
            var notepad = document.getElementById('split-notepad');
            if (!notepad || !notepad.value.trim()) {
                showToast('Notepad is empty', 'warning');
                return;
            }
            var text = notepad.value.trim();
            fetch(API_URL + '/api/learnings', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': 'Bearer ' + token },
                body: JSON.stringify({ type: 'insight', problem: 'Notepad entry', solution: text, tags: ['notepad', 'saved'] })
            }).then(function(r) {
                if (r.ok) {
                    showToast('Saved to Memory');
                } else {
                    showToast('Failed to save', 'error');
                }
            }).catch(function() {
                showToast('Failed to save', 'error');
            });
        }

        function addLaunchButton(messageEl, type) {
            var actions = messageEl.querySelector('.msg-actions');
            if (!actions) {
                actions = document.createElement('div');
                actions.className = 'msg-actions';
                actions.style.opacity = '1';
                messageEl.appendChild(actions);
            } else {
                actions.style.opacity = '1';
            }
            var btn = document.createElement('button');
            btn.className = 'msg-launch-btn';
            btn.textContent = type === 'agent' ? '\u{1F680} Launch Agent' : '\u{1F680} Launch SpecOps';
            btn.addEventListener('click', async function() {
                var fullText = messageEl.getAttribute('data-text') || '';
                var preview = fullText.substring(0, 200) + (fullText.length > 200 ? '...' : '');
                var title = type === 'agent' ? 'Launch Agent?' : 'Launch SpecOps Mission?';
                var cText = type === 'agent' ? 'Launch Agent' : 'Launch SpecOps';
                var confirmed = await cerebroConfirm(preview, { title: title, confirmText: cText, cancelText: 'Cancel' });
                if (!confirmed) return;
                if (type === 'agent') {
                    spawnAgent(fullText, 'coder', getSelectedModel());
                    showToast('Agent spawned!', 'success');
                } else {
                    spawnAgentEnhanced(fullText, 'specops', '', '', 'high', '', 3600, getSelectedModel());
                    showToast('SpecOps mission launched!', 'success');
                }
            });
            actions.appendChild(btn);
        }

        function addMessage(content, type) {
            const container = document.getElementById('messages');

            if (type === 'assistant') {
                const message = buildAssistantCard(content);
                container.appendChild(message);
                scrollMessagesToBottom();
                requestAnimationFrame(function() { scrollMessagesToBottom(); });
                if (content) debouncedSave();
                return message;
            }

            const message = document.createElement('div');
            message.className = 'message ' + type;
            const msgId = 'msg-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
            message.setAttribute('data-message-id', msgId);

            if (type === 'tool') {
                // Tool messages hidden in new design
                message.style.display = 'none';
                message.textContent = content;
            } else if (type === 'user') {
                // New flat user message with msg-header
                const header = document.createElement('div');
                header.className = 'msg-header';
                const sender = document.createElement('span');
                sender.className = 'msg-sender';
                sender.textContent = 'You';
                header.appendChild(sender);
                const meta = document.createElement('span');
                meta.className = 'msg-meta';
                const timeSpan = document.createElement('span');
                timeSpan.className = 'msg-time';
                timeSpan.textContent = formatTimestamp();
                meta.appendChild(timeSpan);
                header.appendChild(meta);
                message.appendChild(header);

                const contentWrapper = document.createElement('div');
                contentWrapper.className = 'message-content-wrapper';
                contentWrapper.innerHTML = safeMarkdown(content);
                message.appendChild(contentWrapper);
                message.setAttribute('data-text', content);

                // Store in session for chunk mapping
                window.messageChunkMap[msgId] = {
                    content: content,
                    type: type,
                    timestamp: new Date().toISOString(),
                    chunk_id: null,
                    conversation_id: null
                };
                message.classList.add('attachable');
            } else {
                const contentWrapper = document.createElement('div');
                contentWrapper.className = 'message-content-wrapper';
                contentWrapper.innerHTML = safeMarkdown(content);
                message.appendChild(contentWrapper);
                message.setAttribute('data-text', content);
            }

            container.appendChild(message);

            // Auto-scroll to bottom when user sends a message
            if (type === 'user' || type === 'assistant') {
                scrollMessagesToBottom();
                requestAnimationFrame(function() { scrollMessagesToBottom(); });
            }

            // Save chat history for persistence (skip tool messages)
            if (type !== 'tool' && content) {
                debouncedSave();
            }

            return message;
        }

        // ==================== SIMULATION CARD ====================
        function fmtSimCurrency(v) {
            if (v == null || isNaN(v)) return 'N/A';
            const abs = Math.abs(v);
            const sign = v < 0 ? '-' : '';
            if (abs >= 1e6) return sign + '$' + (abs / 1e6).toFixed(2) + 'M';
            if (abs >= 1e3) return sign + '$' + (abs / 1e3).toFixed(1) + 'k';
            return sign + '$' + abs.toFixed(2);
        }

        function getSimRiskLevel(std, mean) {
            if (!mean || mean === 0) return { label: 'N/A', class: 'risk-low' };
            const cv = Math.abs(std / mean);
            if (cv < 0.15) return { label: 'LOW', class: 'risk-low' };
            if (cv < 0.4) return { label: 'MEDIUM', class: 'risk-medium' };
            if (cv < 0.8) return { label: 'HIGH', class: 'risk-high' };
            return { label: 'EXTREME', class: 'risk-extreme' };
        }

        function escapeSimHtml(str) {
            if (!str) return '';
            const div = document.createElement('div');
            div.textContent = str;
            return div.innerHTML;
        }

        function renderSimulationCard(data) {
            const container = document.getElementById('messages');
            const message = document.createElement('div');
            message.className = 'message assistant';

            const stats = data.statistics || {};
            const risk = getSimRiskLevel(stats.std || 0, stats.mean || 0);
            const ci = stats.confidence_interval_95 || [0, 0];
            const pct = stats.percentiles || {};

            // Build the card element
            const card = document.createElement('div');
            card.className = 'simulation-card';

            // -- Header --
            const header = document.createElement('div');
            header.className = 'sim-header';
            const headerIcon = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            headerIcon.setAttribute('width', '18');
            headerIcon.setAttribute('height', '18');
            headerIcon.setAttribute('viewBox', '0 0 24 24');
            headerIcon.setAttribute('fill', 'none');
            headerIcon.setAttribute('stroke', 'currentColor');
            headerIcon.setAttribute('stroke-width', '2');
            headerIcon.setAttribute('stroke-linecap', 'round');
            headerIcon.setAttribute('stroke-linejoin', 'round');
            const polyline = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
            polyline.setAttribute('points', '22 12 18 12 15 21 9 3 6 12 2 12');
            headerIcon.appendChild(polyline);
            header.appendChild(headerIcon);
            const headerTitle = document.createElement('span');
            headerTitle.className = 'sim-header-title';
            headerTitle.textContent = 'Simulation Results';
            header.appendChild(headerTitle);
            card.appendChild(header);

            // -- Query --
            const queryDiv = document.createElement('div');
            queryDiv.className = 'sim-query';
            queryDiv.textContent = data.query || 'Simulation';
            card.appendChild(queryDiv);

            // -- Stats Grid --
            const grid = document.createElement('div');
            grid.className = 'sim-stats-grid';

            function makeStatCell(label, valueText, extraClass, badgeHtml) {
                const cell = document.createElement('div');
                cell.className = 'sim-stat-cell';
                const lbl = document.createElement('div');
                lbl.className = 'sim-stat-label';
                lbl.textContent = label;
                cell.appendChild(lbl);
                const val = document.createElement('div');
                val.className = 'sim-stat-value' + (extraClass ? ' ' + extraClass : '');
                if (badgeHtml) {
                    const badge = document.createElement('span');
                    badge.className = 'sim-risk-badge ' + risk.class;
                    badge.textContent = risk.label;
                    val.appendChild(badge);
                } else {
                    val.textContent = valueText;
                }
                cell.appendChild(val);
                return cell;
            }

            grid.appendChild(makeStatCell('Expected Value', fmtSimCurrency(stats.mean), 'accent', false));
            grid.appendChild(makeStatCell('Risk Level', '', '', true));
            grid.appendChild(makeStatCell('95% Confidence', fmtSimCurrency(ci[0]) + ' - ' + fmtSimCurrency(ci[1]), '', false));
            grid.appendChild(makeStatCell('Std Deviation', fmtSimCurrency(stats.std), '', false));
            card.appendChild(grid);

            // -- Sparkline --
            const sparkPoints = [pct['5'], pct['25'], pct['50'], pct['75'], pct['95']].filter(v => v != null);
            if (sparkPoints.length >= 3) {
                const spMin = Math.min(...sparkPoints);
                const spMax = Math.max(...sparkPoints);
                const spRange = spMax - spMin || 1;
                const svgW = 260;
                const svgH = 40;

                const sparkWrap = document.createElement('div');
                sparkWrap.className = 'sim-sparkline';
                const sparkLabel = document.createElement('div');
                sparkLabel.className = 'sim-sparkline-label';
                sparkLabel.textContent = 'Distribution (5th - 95th percentile)';
                sparkWrap.appendChild(sparkLabel);

                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.setAttribute('viewBox', '0 0 ' + svgW + ' ' + svgH);
                svg.setAttribute('preserveAspectRatio', 'none');

                const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                const grad = document.createElementNS('http://www.w3.org/2000/svg', 'linearGradient');
                grad.setAttribute('id', 'simGrad');
                grad.setAttribute('x1', '0'); grad.setAttribute('y1', '0');
                grad.setAttribute('x2', '0'); grad.setAttribute('y2', '1');
                const stop1 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
                stop1.setAttribute('offset', '0%'); stop1.setAttribute('stop-color', 'rgba(139,92,246,0.35)');
                const stop2 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
                stop2.setAttribute('offset', '100%'); stop2.setAttribute('stop-color', 'rgba(139,92,246,0.02)');
                grad.appendChild(stop1); grad.appendChild(stop2);
                defs.appendChild(grad); svg.appendChild(defs);

                const coords = sparkPoints.map((v, i) => {
                    const x = (i / (sparkPoints.length - 1)) * svgW;
                    const y = svgH - ((v - spMin) / spRange) * (svgH - 4) - 2;
                    return { x, y };
                });

                const areaStr = coords.map(c => c.x + ',' + c.y).join(' ') + ' ' + svgW + ',' + svgH + ' 0,' + svgH;
                const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                polygon.setAttribute('points', areaStr);
                polygon.setAttribute('fill', 'url(#simGrad)');
                svg.appendChild(polygon);

                const line = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
                line.setAttribute('points', coords.map(c => c.x + ',' + c.y).join(' '));
                line.setAttribute('fill', 'none');
                line.setAttribute('stroke', '#8b5cf6');
                line.setAttribute('stroke-width', '2');
                line.setAttribute('stroke-linecap', 'round');
                line.setAttribute('stroke-linejoin', 'round');
                svg.appendChild(line);

                coords.forEach(c => {
                    const dot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    dot.setAttribute('cx', c.x); dot.setAttribute('cy', c.y);
                    dot.setAttribute('r', '3');
                    dot.setAttribute('fill', '#a78bfa');
                    dot.setAttribute('stroke', '#12121a');
                    dot.setAttribute('stroke-width', '1.5');
                    svg.appendChild(dot);
                });

                sparkWrap.appendChild(svg);
                card.appendChild(sparkWrap);
            }

            // -- Analysis section --
            if (data.analysis) {
                const a = data.analysis;
                const analysisDiv = document.createElement('div');
                analysisDiv.className = 'sim-analysis';
                const aTitle = document.createElement('div');
                aTitle.className = 'sim-analysis-title';
                aTitle.textContent = 'Analysis';
                analysisDiv.appendChild(aTitle);

                if (a.summary) {
                    const sumDiv = document.createElement('div');
                    sumDiv.className = 'sim-analysis-summary';
                    sumDiv.textContent = a.summary;
                    analysisDiv.appendChild(sumDiv);
                }

                if (a.key_findings && a.key_findings.length > 0) {
                    const ul = document.createElement('ul');
                    ul.className = 'sim-findings';
                    a.key_findings.forEach(finding => {
                        const li = document.createElement('li');
                        li.textContent = finding;
                        ul.appendChild(li);
                    });
                    analysisDiv.appendChild(ul);
                }

                card.appendChild(analysisDiv);
            }

            // -- Actions --
            const actions = document.createElement('div');
            actions.className = 'sim-actions';
            const viewBtn = document.createElement('button');
            viewBtn.className = 'sim-btn primary';
            const btnIcon = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            btnIcon.setAttribute('width', '12'); btnIcon.setAttribute('height', '12');
            btnIcon.setAttribute('viewBox', '0 0 24 24');
            btnIcon.setAttribute('fill', 'none');
            btnIcon.setAttribute('stroke', 'currentColor');
            btnIcon.setAttribute('stroke-width', '2');
            const p1 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            p1.setAttribute('d', 'M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6');
            const p2 = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
            p2.setAttribute('points', '15 3 21 3 21 9');
            const p3 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            p3.setAttribute('x1', '10'); p3.setAttribute('y1', '14');
            p3.setAttribute('x2', '21'); p3.setAttribute('y2', '3');
            btnIcon.appendChild(p1); btnIcon.appendChild(p2); btnIcon.appendChild(p3);
            viewBtn.appendChild(btnIcon);
            viewBtn.appendChild(document.createTextNode(' View in SimEngine'));
            viewBtn.addEventListener('click', () => window.open(CEREBRO_CONFIG.simEngineUrl || 'http://localhost:5173', '_blank'));
            actions.appendChild(viewBtn);
            card.appendChild(actions);

            message.appendChild(card);
            container.appendChild(message);
        }

        function showSimulationModal(data) {
            // Remove any existing modal
            var old = document.getElementById('sim-modal-overlay');
            if (old) old.remove();

            var stats = data.statistics || {};
            var risk = getSimRiskLevel(stats.std || 0, stats.mean || 0);
            var ci = stats.confidence_interval_95 || [0, 0];
            var pct = stats.percentiles || {};
            var meta = data.metadata || {};
            var analysis = data.analysis || {};

            // Overlay
            var overlay = document.createElement('div');
            overlay.id = 'sim-modal-overlay';
            overlay.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.7);z-index:10000;display:flex;align-items:center;justify-content:center;animation:fadeIn 0.3s ease;backdrop-filter:blur(4px);';
            overlay.addEventListener('click', function(e) { if (e.target === overlay) overlay.remove(); });

            // Modal container
            var modal = document.createElement('div');
            modal.style.cssText = 'background:#1a1a2e;border:1px solid rgba(139,92,246,0.3);border-radius:16px;padding:28px;max-width:520px;width:90%;max-height:85vh;overflow-y:auto;box-shadow:0 20px 60px rgba(139,92,246,0.15);';

            // Header row
            var headerRow = document.createElement('div');
            headerRow.style.cssText = 'display:flex;align-items:center;justify-content:space-between;margin-bottom:16px;';
            var headerLeft = document.createElement('div');
            headerLeft.style.cssText = 'display:flex;align-items:center;gap:10px;';
            var hIcon = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            hIcon.setAttribute('width','22'); hIcon.setAttribute('height','22'); hIcon.setAttribute('viewBox','0 0 24 24');
            hIcon.setAttribute('fill','none'); hIcon.setAttribute('stroke','#8b5cf6'); hIcon.setAttribute('stroke-width','2');
            var hPoly = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
            hPoly.setAttribute('points','22 12 18 12 15 21 9 3 6 12 2 12');
            hIcon.appendChild(hPoly);
            headerLeft.appendChild(hIcon);
            var hTitle = document.createElement('span');
            hTitle.style.cssText = 'font-size:1.15rem;font-weight:600;color:#e2e8f0;';
            hTitle.textContent = 'Simulation Results';
            headerLeft.appendChild(hTitle);
            headerRow.appendChild(headerLeft);
            var closeBtn = document.createElement('button');
            closeBtn.style.cssText = 'background:none;border:none;color:#888;font-size:1.4rem;cursor:pointer;padding:4px 8px;';
            closeBtn.textContent = '\u00d7';
            closeBtn.addEventListener('click', function() { overlay.remove(); });
            headerRow.appendChild(closeBtn);
            modal.appendChild(headerRow);

            // Query label
            var queryDiv = document.createElement('div');
            queryDiv.style.cssText = 'color:#a78bfa;font-size:0.85rem;margin-bottom:16px;padding:8px 12px;background:rgba(139,92,246,0.08);border-radius:8px;';
            queryDiv.textContent = data.query || 'Simulation';
            modal.appendChild(queryDiv);

            // Stats grid
            var grid = document.createElement('div');
            grid.style.cssText = 'display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-bottom:16px;';

            function makeCell(label, value, isRisk) {
                var cell = document.createElement('div');
                cell.style.cssText = 'background:rgba(255,255,255,0.03);border-radius:10px;padding:12px;';
                var lbl = document.createElement('div');
                lbl.style.cssText = 'color:#888;font-size:0.7rem;text-transform:uppercase;letter-spacing:0.5px;';
                lbl.textContent = label;
                cell.appendChild(lbl);
                var val = document.createElement('div');
                val.style.cssText = 'margin-top:4px;';
                if (isRisk) {
                    var badge = document.createElement('span');
                    var badgeColors = risk.label === 'LOW' ? 'background:rgba(34,197,94,0.15);color:#22c55e;' :
                        risk.label === 'MEDIUM' ? 'background:rgba(234,179,8,0.15);color:#eab308;' :
                        risk.label === 'HIGH' ? 'background:rgba(239,68,68,0.15);color:#ef4444;' :
                        'background:rgba(139,92,246,0.15);color:#a78bfa;';
                    badge.style.cssText = 'padding:3px 10px;border-radius:12px;font-size:0.75rem;font-weight:600;' + badgeColors;
                    badge.textContent = risk.label;
                    val.appendChild(badge);
                } else {
                    val.style.cssText += 'color:' + (label === 'Expected Value' ? '#8b5cf6' : '#e2e8f0') + ';font-size:' + (label === 'Expected Value' ? '1.3rem' : '0.95rem') + ';font-weight:' + (label === 'Expected Value' ? '700' : '600') + ';';
                    val.textContent = value;
                }
                cell.appendChild(val);
                return cell;
            }

            grid.appendChild(makeCell('Expected Value', fmtSimCurrency(stats.mean), false));
            grid.appendChild(makeCell('Risk Level', '', true));
            grid.appendChild(makeCell('95% Confidence', fmtSimCurrency(ci[0]) + ' \u2013 ' + fmtSimCurrency(ci[1]), false));
            grid.appendChild(makeCell('Std Deviation', fmtSimCurrency(stats.std), false));
            modal.appendChild(grid);

            // Sparkline
            var sparkPts = [pct['5'], pct['25'], pct['50'], pct['75'], pct['95']].filter(function(v) { return v != null; });
            if (sparkPts.length >= 3) {
                var spMin = Math.min.apply(null, sparkPts);
                var spMax = Math.max.apply(null, sparkPts);
                var spRange = spMax - spMin || 1;
                var sparkWrap = document.createElement('div');
                sparkWrap.style.cssText = 'margin-bottom:16px;';
                var sparkLabel = document.createElement('div');
                sparkLabel.style.cssText = 'color:#666;font-size:0.7rem;text-transform:uppercase;letter-spacing:0.5px;margin-bottom:6px;';
                sparkLabel.textContent = 'Distribution (5th \u2013 95th percentile)';
                sparkWrap.appendChild(sparkLabel);

                var svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.setAttribute('viewBox', '0 0 320 50');
                svg.setAttribute('preserveAspectRatio', 'none');
                svg.style.cssText = 'width:100%;height:50px;';

                var defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                var grad = document.createElementNS('http://www.w3.org/2000/svg', 'linearGradient');
                grad.setAttribute('id', 'smGrad'); grad.setAttribute('x1','0'); grad.setAttribute('y1','0'); grad.setAttribute('x2','0'); grad.setAttribute('y2','1');
                var s1 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
                s1.setAttribute('offset','0%'); s1.setAttribute('stop-color','rgba(139,92,246,0.35)');
                var s2 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
                s2.setAttribute('offset','100%'); s2.setAttribute('stop-color','rgba(139,92,246,0.02)');
                grad.appendChild(s1); grad.appendChild(s2); defs.appendChild(grad); svg.appendChild(defs);

                var coords = sparkPts.map(function(v, i) {
                    return { x: (i / (sparkPts.length - 1)) * 320, y: 50 - ((v - spMin) / spRange) * 44 - 3 };
                });

                var polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                polygon.setAttribute('points', coords.map(function(c){return c.x+','+c.y;}).join(' ') + ' 320,50 0,50');
                polygon.setAttribute('fill', 'url(#smGrad)');
                svg.appendChild(polygon);

                var line = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
                line.setAttribute('points', coords.map(function(c){return c.x+','+c.y;}).join(' '));
                line.setAttribute('fill','none'); line.setAttribute('stroke','#8b5cf6');
                line.setAttribute('stroke-width','2.5'); line.setAttribute('stroke-linecap','round'); line.setAttribute('stroke-linejoin','round');
                svg.appendChild(line);

                sparkWrap.appendChild(svg);
                modal.appendChild(sparkWrap);
            }

            // Metadata line
            if (meta.iterations) {
                var metaDiv = document.createElement('div');
                metaDiv.style.cssText = 'color:#666;font-size:0.75rem;margin-bottom:12px;';
                metaDiv.textContent = (meta.method || 'monte_carlo').replace(/_/g, ' ') + ' \u00b7 ' + meta.iterations.toLocaleString() + ' iterations' + (meta.elapsed_seconds ? ' \u00b7 ' + meta.elapsed_seconds.toFixed(2) + 's' : '');
                modal.appendChild(metaDiv);
            }

            // Analysis section
            if (analysis.summary || (analysis.key_findings && analysis.key_findings.length > 0)) {
                var aSep = document.createElement('div');
                aSep.style.cssText = 'border-top:1px solid rgba(255,255,255,0.06);padding-top:12px;margin-top:4px;';
                var aLabel = document.createElement('div');
                aLabel.style.cssText = 'color:#888;font-size:0.7rem;text-transform:uppercase;letter-spacing:0.5px;margin-bottom:8px;';
                aLabel.textContent = 'Analysis';
                aSep.appendChild(aLabel);
                if (analysis.summary) {
                    var sumDiv = document.createElement('div');
                    sumDiv.style.cssText = 'color:#ccc;font-size:0.85rem;margin-bottom:8px;';
                    sumDiv.textContent = analysis.summary;
                    aSep.appendChild(sumDiv);
                }
                if (analysis.key_findings && analysis.key_findings.length > 0) {
                    var ul = document.createElement('ul');
                    ul.style.cssText = 'margin:0;padding-left:16px;color:#aaa;font-size:0.8rem;';
                    analysis.key_findings.forEach(function(f) {
                        var li = document.createElement('li');
                        li.style.cssText = 'margin-bottom:4px;';
                        li.textContent = f;
                        ul.appendChild(li);
                    });
                    aSep.appendChild(ul);
                }
                modal.appendChild(aSep);
            }

            overlay.appendChild(modal);
            document.body.appendChild(overlay);
        }

        // ==================== SETTINGS SIDEBAR ====================
        function switchSettingsSection(name) {
            // Update nav items
            document.querySelectorAll('.settings-nav-item').forEach(function(item) {
                item.classList.toggle('active', item.dataset.section === name);
            });
            // Show/hide sections
            document.querySelectorAll('.settings-section').forEach(function(sec) {
                sec.classList.toggle('active', sec.id === 'settings-section-' + name);
            });
            // Scroll content to top
            var content = document.getElementById('settings-content');
            if (content) content.scrollTop = 0;
            // Lazy-load AI & Memory data
            if (name === 'ai-memory') { initStorageConfig(); initOffloadConfig(); }
        }

        function toggleSettingsSidebar() {
            var sidebar = document.getElementById('settings-sidebar');
            if (!sidebar) return;
            var isCollapsed = sidebar.classList.toggle('collapsed');
            // On narrow screens, toggle force-expanded if un-collapsing
            if (!isCollapsed && window.innerWidth <= 600) {
                sidebar.classList.add('force-expanded');
            } else {
                sidebar.classList.remove('force-expanded');
            }
            localStorage.setItem('cerebro_settings_sidebar_collapsed', isCollapsed ? '1' : '0');
        }

        function restoreSettingsSidebarState() {
            var sidebar = document.getElementById('settings-sidebar');
            if (!sidebar) return;
            var saved = localStorage.getItem('cerebro_settings_sidebar_collapsed');
            if (saved === '1') {
                sidebar.classList.add('collapsed');
            } else if (window.innerWidth <= 600) {
                sidebar.classList.add('collapsed');
            } else {
                sidebar.classList.remove('collapsed');
            }
            sidebar.classList.remove('force-expanded');
            // Tooltip handlers for collapsed mode
            _initSettingsSidebarTooltips(sidebar);
        }

        var _settingsSidebarTooltipEl = null;
        function _initSettingsSidebarTooltips(sidebar) {
            if (_settingsSidebarTooltipEl) return; // already initialized
            _settingsSidebarTooltipEl = document.createElement('div');
            _settingsSidebarTooltipEl.className = 'settings-sidebar-tooltip';
            document.body.appendChild(_settingsSidebarTooltipEl);

            sidebar.querySelectorAll('.settings-nav-item').forEach(function(item) {
                item.addEventListener('mouseenter', function(e) {
                    if (!sidebar.classList.contains('collapsed')) return;
                    var label = item.querySelector('.settings-nav-label');
                    if (!label) return;
                    _settingsSidebarTooltipEl.textContent = label.textContent;
                    var rect = item.getBoundingClientRect();
                    _settingsSidebarTooltipEl.style.top = rect.top + rect.height / 2 - 12 + 'px';
                    _settingsSidebarTooltipEl.style.left = rect.right + 8 + 'px';
                    _settingsSidebarTooltipEl.classList.add('visible');
                });
                item.addEventListener('mouseleave', function() {
                    _settingsSidebarTooltipEl.classList.remove('visible');
                });
            });
        }

        function updateSettingsProfileCard() {
            var nameEl = document.getElementById('settings-profile-name');
            var avatarEl = document.getElementById('settings-profile-avatar');
            var badgeEl = document.getElementById('settings-plan-badge');
            var filesEl = document.getElementById('settings-profile-files');

            // Name and avatar
            var username = (typeof CEREBRO_USERNAME !== 'undefined' && CEREBRO_USERNAME) ? CEREBRO_USERNAME : 'User';
            if (nameEl) nameEl.textContent = username;
            if (avatarEl) {
                var initials = username.split(' ').map(function(w) { return w[0]; }).join('').substring(0, 2).toUpperCase();
                avatarEl.textContent = initials || '?';
            }

            // Plan badge from cost display
            if (badgeEl) {
                var costEl = document.getElementById('settings-cost-display');
                var costText = costEl ? costEl.textContent : '';
                if (costText.toLowerCase().includes('claude code')) {
                    badgeEl.textContent = 'Claude Code';
                } else if (costText.toLowerCase().includes('pro')) {
                    badgeEl.textContent = 'Pro';
                } else if (costText.toLowerCase().includes('free')) {
                    badgeEl.textContent = 'Free';
                } else {
                    badgeEl.textContent = 'Active';
                }
            }

            // File access summary
            if (filesEl) {
                try {
                    var mounts = (typeof _fileAccessConfig !== 'undefined' && _fileAccessConfig.fileMounts) ? _fileAccessConfig.fileMounts : [];
                    if (mounts.length === 0) {
                        filesEl.textContent = 'No folders shared';
                    } else {
                        var ro = mounts.filter(function(m) { return m.readOnly; }).length;
                        var rw = mounts.length - ro;
                        var parts = [];
                        if (ro > 0) parts.push(ro + ' read-only');
                        if (rw > 0) parts.push(rw + ' read-write');
                        filesEl.textContent = mounts.length + ' folder' + (mounts.length !== 1 ? 's' : '') + ' (' + parts.join(', ') + ')';
                    }
                } catch (e) {
                    filesEl.textContent = '';
                }
            }
        }

        // ==================== PERSONALITY TOGGLE ====================
        function setPersonality(mode) {
            localStorage.setItem('cerebro_personality', mode);
            document.querySelectorAll('.personality-btn').forEach(b => b.classList.toggle('active', b.dataset.mode === mode));
            fetch(`${API_URL}/api/cerebro/personality`, {
                method: 'POST',
                headers: { 'Authorization': `Bearer ${localStorage.getItem('cerebro_token')}`, 'Content-Type': 'application/json' },
                body: JSON.stringify({ personality_mode: mode })
            }).catch(e => console.error('Failed to set personality:', e));
        }
        function loadPersonality() {
            const saved = localStorage.getItem('cerebro_personality');
            if (saved) {
                document.querySelectorAll('.personality-btn').forEach(b => b.classList.toggle('active', b.dataset.mode === saved));
            } else {
                fetch(`${API_URL}/api/cerebro/personality`, {
                    headers: { 'Authorization': `Bearer ${localStorage.getItem('cerebro_token')}` }
                }).then(r => r.json()).then(data => {
                    const mode = data.personality_mode || 'chill';
                    localStorage.setItem('cerebro_personality', mode);
                    document.querySelectorAll('.personality-btn').forEach(b => b.classList.toggle('active', b.dataset.mode === mode));
                }).catch(() => setPersonality('chill'));
            }
        }

        // ==================== LOOK COMMAND TOGGLE ====================
        let _lookRunning = false;

        async function loadLookStatus() {
            try {
                const resp = await fetch(`${API_URL}/api/look/status`, {
                    headers: { 'Authorization': `Bearer ${localStorage.getItem('cerebro_token')}` }
                });
                const data = await resp.json();
                _lookRunning = data.running;
                const toggle = document.getElementById('look-toggle');
                const statusRow = document.getElementById('look-status-row');
                const statusText = document.getElementById('look-status-text');
                if (toggle) toggle.classList.toggle('active', _lookRunning);
                if (statusRow && statusText) {
                    if (_lookRunning) {
                        statusRow.style.display = '';
                        statusText.textContent = `Running (PID ${data.pid})`;
                        statusText.style.color = 'var(--success, #22c55e)';
                    } else {
                        statusRow.style.display = 'none';
                    }
                }
            } catch (e) {
                console.error('Failed to load look status:', e);
            }
        }

        async function toggleLookDaemon() {
            const enable = !_lookRunning;
            const toggle = document.getElementById('look-toggle');
            const statusRow = document.getElementById('look-status-row');
            const statusText = document.getElementById('look-status-text');

            // Optimistic UI
            if (toggle) toggle.classList.toggle('active', enable);
            if (statusRow && statusText) {
                statusRow.style.display = '';
                statusText.textContent = enable ? 'Starting...' : 'Stopping...';
                statusText.style.color = 'var(--text-muted)';
            }

            try {
                const resp = await fetch(`${API_URL}/api/look/toggle`, {
                    method: 'POST',
                    headers: { 'Authorization': `Bearer ${localStorage.getItem('cerebro_token')}`, 'Content-Type': 'application/json' },
                    body: JSON.stringify({ enable })
                });
                const data = await resp.json();
                _lookRunning = data.running;

                if (toggle) toggle.classList.toggle('active', _lookRunning);
                if (statusRow && statusText) {
                    if (_lookRunning) {
                        statusRow.style.display = '';
                        statusText.textContent = `Running (PID ${data.pid})`;
                        statusText.style.color = 'var(--success, #22c55e)';
                        showToast('Look daemon started');
                    } else {
                        statusRow.style.display = 'none';
                        showToast('Look daemon stopped');
                    }
                }
            } catch (e) {
                console.error('Failed to toggle look daemon:', e);
                showToast('Failed to toggle look daemon', 'error');
                // Revert UI
                if (toggle) toggle.classList.toggle('active', _lookRunning);
                loadLookStatus();
            }
        }

        // ==================== FILE ACCESS SETTINGS ====================
        let _fileAccessConfig = { fileMounts: [] };
        let _fileAccessPresets = [];
        let _fileAccessDirty = false;

        async function initFileAccess() {
            if (!window.cerebroDesktop) {
                const section = document.getElementById('file-access-section');
                const notAvail = document.getElementById('file-access-not-available');
                if (section) section.style.display = 'none';
                if (notAvail) notAvail.style.display = '';
                return;
            }
            try {
                _fileAccessConfig = await window.cerebroDesktop.getFileAccessConfig();
                _fileAccessPresets = await window.cerebroDesktop.getFileAccessPresets();
                if (!_fileAccessConfig.fileMounts) _fileAccessConfig.fileMounts = [];
                renderFileAccess();
            } catch (e) {
                console.error('Failed to init file access:', e);
            }
        }

        function _escapeHtml(str) {
            const div = document.createElement('div');
            div.textContent = str;
            return div.innerHTML;
        }

        function _buildMountCardEl(mount, isPreset, isActive) {
            const card = document.createElement('div');
            card.className = 'file-mount-card';

            // Icon
            const icon = document.createElement('div');
            icon.className = 'file-mount-icon';
            if (mount.id === 'devices') {
                icon.innerHTML = '<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 2l-2 2m-7.61 7.61a5.5 5.5 0 1 1-7.778 7.778 5.5 5.5 0 0 1 7.777-7.777zm0 0L15.5 7.5m0 0l3 3L22 7l-3-3m-3.5 3.5L19 4"/></svg>';
            } else {
                icon.innerHTML = '<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/></svg>';
            }
            card.appendChild(icon);

            // Info
            const info = document.createElement('div');
            info.className = 'file-mount-info';
            const label = document.createElement('div');
            label.className = 'file-mount-label';
            label.textContent = mount.label;
            const pathEl = document.createElement('div');
            pathEl.className = 'file-mount-path';
            pathEl.textContent = mount.hostPath;
            info.appendChild(label);
            info.appendChild(pathEl);
            card.appendChild(info);

            // Read / Read & Write toggle
            const badges = document.createElement('div');
            badges.className = 'file-mount-badges';
            if (isActive) {
                const toggleWrap = document.createElement('div');
                toggleWrap.className = 'file-mount-toggle';
                const readBtn = document.createElement('button');
                readBtn.className = 'file-mount-toggle-btn' + (mount.readOnly ? ' active-read' : '');
                readBtn.textContent = 'Read';
                readBtn.addEventListener('click', () => { if (!mount.readOnly) return; toggleMountReadOnly(mount.id); });
                const rwBtn = document.createElement('button');
                rwBtn.className = 'file-mount-toggle-btn' + (!mount.readOnly ? ' active-write' : '');
                rwBtn.textContent = 'Read & Write';
                rwBtn.addEventListener('click', () => { if (mount.readOnly) toggleMountReadOnly(mount.id); });
                toggleWrap.appendChild(readBtn);
                toggleWrap.appendChild(rwBtn);
                badges.appendChild(toggleWrap);
            }
            card.appendChild(badges);

            if (isPreset) {
                // Toggle switch
                const toggle = document.createElement('div');
                toggle.className = 'toggle-switch' + (isActive ? ' active' : '');
                toggle.addEventListener('click', () => togglePresetMount(mount.id));
                card.appendChild(toggle);
            } else {
                // Remove button
                const removeBtn = document.createElement('button');
                removeBtn.className = 'file-mount-remove';
                removeBtn.title = 'Remove';
                removeBtn.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>';
                removeBtn.addEventListener('click', () => removeCustomMount(mount.id));
                card.appendChild(removeBtn);
            }

            return card;
        }

        function renderFileAccess() {
            // Preset toggles
            const presetList = document.getElementById('file-access-presets-list');
            if (presetList) {
                presetList.replaceChildren();
                _fileAccessPresets.forEach(p => {
                    const active = _fileAccessConfig.fileMounts.some(m => m.id === p.id);
                    const mount = active ? _fileAccessConfig.fileMounts.find(m => m.id === p.id) : p;
                    presetList.appendChild(_buildMountCardEl(mount, true, active));
                });
            }

            // Custom mounts
            const customList = document.getElementById('custom-mounts-list');
            const customMounts = _fileAccessConfig.fileMounts.filter(m => !m.preset);
            if (customList) {
                customList.replaceChildren();
                if (customMounts.length === 0) {
                    const empty = document.createElement('div');
                    empty.style.cssText = 'padding:14px 20px;font-size:0.8rem;color:var(--text-muted);text-align:center;';
                    empty.textContent = 'No custom folders added.';
                    customList.appendChild(empty);
                } else {
                    customMounts.forEach(m => {
                        customList.appendChild(_buildMountCardEl(m, false, true));
                    });
                }
            }

            // Risk badge
            updateFileAccessRisk();
            // Warning banner
            const warning = document.getElementById('file-access-warning');
            if (warning) {
                const hasWrite = _fileAccessConfig.fileMounts.some(m => !m.readOnly);
                warning.style.display = hasWrite ? '' : 'none';
            }
            // Update profile card file summary
            if (typeof updateSettingsProfileCard === 'function') updateSettingsProfileCard();
        }

        function getFileAccessRiskLevel() {
            const mounts = _fileAccessConfig.fileMounts;
            if (mounts.length === 0) return { level: 'safe', label: 'Safe' };
            const hasWrite = mounts.some(m => !m.readOnly);
            if (!hasWrite) return { level: 'standard', label: 'Standard' };
            const writeCount = mounts.filter(m => !m.readOnly).length;
            if (writeCount <= 2) return { level: 'extended', label: 'Extended' };
            return { level: 'full', label: 'Full Access' };
        }

        function updateFileAccessRisk() {
            const badge = document.getElementById('file-access-risk');
            if (!badge) return;
            const risk = getFileAccessRiskLevel();
            badge.textContent = risk.label;
            badge.className = 'risk-indicator ' + risk.level;
        }

        async function togglePresetMount(presetId) {
            const existing = _fileAccessConfig.fileMounts.findIndex(m => m.id === presetId);
            if (existing >= 0) {
                _fileAccessConfig.fileMounts.splice(existing, 1);
            } else {
                const preset = _fileAccessPresets.find(p => p.id === presetId);
                if (preset) _fileAccessConfig.fileMounts.push({ ...preset });
            }
            await saveFileAccessConfig();
            renderFileAccess();
        }

        async function toggleMountReadOnly(mountId) {
            const mount = _fileAccessConfig.fileMounts.find(m => m.id === mountId);
            if (!mount) return;
            mount.readOnly = !mount.readOnly;
            await saveFileAccessConfig();
            renderFileAccess();
        }

        async function addCustomMount() {
            if (!window.cerebroDesktop || !window.cerebroDesktop.browseFolder) {
                showToast('Folder picker requires the desktop app', 'error');
                return;
            }
            try {
                const result = await window.cerebroDesktop.browseFolder();
                if (!result || result.canceled) return;
                if (result.error) { showToast('Could not open folder picker: ' + result.error, 'error'); return; }
                const hostPath = result.path;
                const folderName = hostPath.split(/[\\/]/).pop().toLowerCase().replace(/[^a-z0-9_-]/g, '-') || 'folder';
                // Avoid duplicate container paths
                let containerPath = `/mounts/${folderName}`;
                const existingPaths = _fileAccessConfig.fileMounts.map(m => m.containerPath);
                if (existingPaths.includes(containerPath)) {
                    containerPath = `/mounts/${folderName}-${Date.now()}`;
                }
                // Avoid duplicate host paths
                if (_fileAccessConfig.fileMounts.some(m => m.hostPath === hostPath)) {
                    showToast('This folder is already added', 'error');
                    return;
                }
                _fileAccessConfig.fileMounts.push({
                    id: `custom_${Date.now()}`,
                    label: hostPath.split(/[\\/]/).pop(),
                    hostPath,
                    containerPath,
                    readOnly: true,
                    preset: false,
                });
                await saveFileAccessConfig();
                renderFileAccess();
            } catch (e) {
                console.error('Failed to add custom mount:', e);
                showToast('Failed to add folder', 'error');
            }
        }

        async function removeCustomMount(mountId) {
            _fileAccessConfig.fileMounts = _fileAccessConfig.fileMounts.filter(m => m.id !== mountId);
            await saveFileAccessConfig();
            renderFileAccess();
        }

        async function saveFileAccessConfig() {
            if (!window.cerebroDesktop) return;
            try {
                await window.cerebroDesktop.saveFileAccessConfig(_fileAccessConfig);
                _fileAccessDirty = true;
                // Prompt user to restart now
                const shouldRestart = await cerebroConfirm(
                    'File access changes require a container restart to take effect. Restart Cerebro now?',
                    { title: 'Restart Required', confirmText: 'Restart Now', cancelText: 'Later' }
                );
                if (shouldRestart) {
                    await applyFileAccessRestart();
                } else {
                    const bar = document.getElementById('file-access-restart-bar');
                    if (bar) bar.style.display = '';
                }
            } catch (e) {
                console.error('Failed to save file access config:', e);
                showToast('Failed to save settings', 'error');
            }
        }

        async function applyFileAccessRestart() {
            if (!window.cerebroDesktop) return;
            const btn = document.getElementById('file-access-restart-btn');
            if (btn) { btn.disabled = true; btn.textContent = 'Restarting...'; }
            try {
                const result = await window.cerebroDesktop.restartDockerStack();
                if (result.success) {
                    _fileAccessDirty = false;
                    const bar = document.getElementById('file-access-restart-bar');
                    if (bar) bar.style.display = 'none';
                    showToast('Container restarted with new file mounts');
                } else {
                    showToast('Restart failed: ' + (result.error || 'Unknown error'), 'error');
                }
            } catch (e) {
                console.error('Restart failed:', e);
                showToast('Restart failed', 'error');
            } finally {
                if (btn) { btn.disabled = false; btn.textContent = 'Restart Now'; }
            }
        }

        // ==================== STORAGE & OFFLOAD CONFIG ====================
        let _storageConfigLoaded = false;
        let _offloadConfigLoaded = false;

        async function initStorageConfig() {
            if (_storageConfigLoaded) return;
            _storageConfigLoaded = true;
            try {
                const token = localStorage.getItem('cerebro_token');
                const headers = token ? { 'Authorization': 'Bearer ' + token } : {};
                const countRes = await fetch(API_URL + '/api/memory-intelligence', { headers });
                if (countRes.ok) {
                    const data = await countRes.json();
                    const count = (data.total_memories || 0) + (data.fact_count || 0);
                    const el = document.getElementById('memory-count-num');
                    if (el) el.textContent = count;
                }
            } catch (e) { console.warn('Failed to load observation count:', e); }

            try {
                if (window.cerebroDesktop) {
                    const cfg = await window.cerebroDesktop.getMemoryConfig();
                    updateStorageDisplay(cfg.storagePath, cfg.source, cfg.envVar);
                } else {
                    updateStorageDisplay(null);
                }
                await loadStorageStats();

                // Check Docker storage mount health
                if (window.cerebroDesktop && window.cerebroDesktop.getStorageHealth) {
                    try {
                        const health = await window.cerebroDesktop.getStorageHealth();
                        showStorageHealthStatus(health);
                    } catch (e) { console.warn('Storage health check failed:', e); }
                }
            } catch (e) { console.warn('Failed to load storage config:', e); }
        }

        function showStorageHealthStatus(health) {
            const warningEl = document.getElementById('storage-health-warning');
            const warningText = document.getElementById('storage-health-warning-text');
            const badge = document.getElementById('storage-risk-badge');
            if (!health || health.healthy) {
                if (warningEl) warningEl.classList.remove('visible');
                return;
            }
            if (warningEl) {
                warningEl.classList.add('visible');
                if (warningText && health.warnings && health.warnings.length > 0) {
                    warningText.textContent = health.warnings[0];
                }
            }
            if (badge) {
                badge.textContent = 'Error';
                badge.className = 'risk-indicator full';
            }
        }

        // Listen for push storage health warnings from main process
        if (window.cerebroDesktop && window.cerebroDesktop.onStorageHealthWarning) {
            window.cerebroDesktop.onStorageHealthWarning((health) => {
                showStorageHealthStatus(health);
            });
        }

        function updateStorageDisplay(storagePath, source, envVar) {
            const pathEl = document.getElementById('storage-path-display');
            const badge = document.getElementById('storage-risk-badge');
            const warning = document.getElementById('storage-warning');
            const sourceLabel = document.getElementById('storage-source-label');
            if (storagePath) {
                if (pathEl) pathEl.textContent = storagePath;
                if (badge) { badge.textContent = 'Custom'; badge.className = 'risk-indicator extended'; }
                if (warning) warning.classList.add('visible');
            } else {
                if (pathEl) pathEl.textContent = 'Docker Volume (default)';
                if (badge) { badge.textContent = 'Default'; badge.className = 'risk-indicator safe'; }
                if (warning) warning.classList.remove('visible');
            }
            // Show provenance label when auto-detected from env var
            if (sourceLabel) {
                if (source === 'env' && envVar) {
                    sourceLabel.textContent = '';
                    sourceLabel.appendChild(document.createTextNode('Detected from '));
                    const code = document.createElement('code');
                    code.textContent = envVar;
                    sourceLabel.appendChild(code);
                    sourceLabel.classList.add('visible');
                } else {
                    sourceLabel.classList.remove('visible');
                }
            }
        }

        async function loadStorageStats() {
            try {
                const token = localStorage.getItem('cerebro_token');
                const headers = token ? { 'Authorization': 'Bearer ' + token } : {};
                const res = await fetch(API_URL + '/api/memory/stats', { headers });
                if (res.ok) {
                    const stats = await res.json();
                    const sizeEl = document.getElementById('storage-size-display');
                    const filesEl = document.getElementById('storage-files-display');
                    if (sizeEl) sizeEl.textContent = stats.human_size || '-';
                    if (filesEl) filesEl.textContent = stats.file_count != null ? stats.file_count.toLocaleString() : '-';
                }
            } catch (e) { console.warn('Failed to load storage stats:', e); }
        }

        async function changeStoragePath() {
            if (!window.cerebroDesktop) {
                showToast('Storage configuration requires the desktop app', 'error');
                return;
            }
            const proceed = await cerebroConfirm(
                'Changing the storage location will require a container restart. Agents will be interrupted.',
                { title: 'Change Storage Location', confirmText: 'Choose Folder', cancelText: 'Cancel' }
            );
            if (!proceed) return;

            const result = await window.cerebroDesktop.browseStorageFolder();
            if (result.canceled) return;
            const newPath = result.path;

            const migrate = await cerebroConfirm(
                'Would you like to copy your existing memory data to the new location?\n\nNew location: ' + newPath,
                { title: 'Migrate Data?', confirmText: 'Copy Data', cancelText: 'Skip (empty start)' }
            );
            if (migrate) {
                showToast('Migrating data... this may take a moment');
                const migResult = await window.cerebroDesktop.migrateStorage(newPath);
                if (!migResult.success) {
                    showToast('Migration failed: ' + (migResult.error || 'Unknown error'), 'error');
                    return;
                }
                showToast('Data migrated successfully');
            }

            const saveResult = await window.cerebroDesktop.setStoragePath(newPath);
            if (!saveResult.success) {
                showToast('Failed to save: ' + (saveResult.error || 'Unknown error'), 'error');
                return;
            }
            updateStorageDisplay(newPath);

            const shouldRestart = await cerebroConfirm(
                'Storage path updated. Restart container now to apply?',
                { title: 'Restart Required', confirmText: 'Restart Now', cancelText: 'Later' }
            );
            if (shouldRestart) {
                showToast('Restarting container...');
                const restartResult = await window.cerebroDesktop.restartDockerStack();
                if (restartResult.success) {
                    showToast('Container restarted with new storage path');
                    _storageConfigLoaded = false;
                    initStorageConfig();
                } else {
                    showToast('Restart failed: ' + (restartResult.error || 'Unknown error'), 'error');
                }
            }
        }

        async function openMergeDialog() {
            if (!window.cerebroDesktop) {
                showToast('Merge requires the desktop app', 'error');
                return;
            }
            // 1. Pick source folder
            const result = await window.cerebroDesktop.browseStorageFolder();
            if (result.canceled) return;
            const sourcePath = result.path;

            // 2. Scan for preview
            showToast('Scanning source folder...');
            let preview;
            try {
                preview = await window.cerebroDesktop.scanMergePreview(sourcePath);
            } catch (e) {
                showToast('Scan failed: ' + (e.message || 'Unknown error'), 'error');
                return;
            }
            if (!preview || !preview.folders || preview.folders.length === 0) {
                showToast('No memory data found in that folder', 'error');
                return;
            }

            // 3. Build preview summary
            let totalNew = 0, totalSkipped = 0;
            const lines = preview.folders.map(f => {
                totalNew += f.newFiles || 0;
                totalSkipped += f.skippedFiles || 0;
                return f.folder + ': ' + (f.newFiles || 0) + ' new, ' + (f.skippedFiles || 0) + ' skipped';
            });
            const summaryText = 'Source: ' + sourcePath + '\n\n' +
                lines.join('\n') + '\n\n' +
                'Total: ' + totalNew + ' new files, ' + totalSkipped + ' duplicates skipped' +
                (preview.totalSize ? ' (' + preview.totalSize + ')' : '');

            const proceed = await cerebroConfirm(summaryText, {
                title: 'Merge Preview',
                confirmText: 'Merge ' + totalNew + ' Files',
                cancelText: 'Cancel'
            });
            if (!proceed) return;

            // 4. Execute merge
            showToast('Merging data...');
            const allFolders = preview.folders.map(f => f.folder);
            let mergeResult;
            try {
                mergeResult = await window.cerebroDesktop.mergeStorage(sourcePath, allFolders);
            } catch (e) {
                showToast('Merge failed: ' + (e.message || 'Unknown error'), 'error');
                return;
            }
            if (!mergeResult.success) {
                showToast('Merge failed: ' + (mergeResult.error || 'Unknown error'), 'error');
                return;
            }
            showToast('Merged ' + (mergeResult.copiedFiles || 0) + ' files successfully');

            // 5. Offer to rebuild search index
            const rebuildIdx = await cerebroConfirm(
                'Rebuild the search index so merged data is searchable?',
                { title: 'Rebuild Index', confirmText: 'Rebuild', cancelText: 'Skip' }
            );
            if (rebuildIdx) {
                try {
                    const token = localStorage.getItem('cerebro_token');
                    const headers = { 'Content-Type': 'application/json' };
                    if (token) headers['Authorization'] = 'Bearer ' + token;
                    await fetch(API_URL + '/api/memory/rebuild-index', { method: 'POST', headers });
                    showToast('Search index rebuilt');
                } catch (e) {
                    showToast('Index rebuild failed: ' + (e.message || 'Unknown error'), 'error');
                }
            }

            // 6. Refresh stats
            await loadStorageStats();
        }

        async function initOffloadConfig() {
            if (_offloadConfigLoaded) return;
            _offloadConfigLoaded = true;
            try {
                const token = localStorage.getItem('cerebro_token');
                const headers = token ? { 'Authorization': 'Bearer ' + token } : {};
                const [cfgRes, devicesRes] = await Promise.all([
                    fetch(API_URL + '/api/offload/config', { headers }),
                    fetch(API_URL + '/api/offload/eligible-devices', { headers }),
                ]);
                const config = cfgRes.ok ? await cfgRes.json() : { enabled: false };
                const devData = devicesRes.ok ? await devicesRes.json() : { devices: [] };
                renderOffloadSection(config, devData.devices || []);
            } catch (e) {
                console.warn('Failed to load offload config:', e);
                renderOffloadSection({ enabled: false }, []);
            }
        }

        function renderOffloadSection(config, devices) {
            const badge = document.getElementById('offload-risk-badge');
            const currentDiv = document.getElementById('offload-current-device');
            const currentName = document.getElementById('offload-current-name');
            const listDiv = document.getElementById('offload-device-list');

            if (config.enabled && config.target_device_id) {
                if (badge) { badge.textContent = 'Active'; badge.className = 'risk-indicator extended'; }
                if (currentDiv) currentDiv.style.display = '';
                const targetDevice = devices.find(function(d) { return d.id === config.target_device_id; });
                if (currentName) currentName.textContent = targetDevice ? targetDevice.device_name : config.target_device_id;
            } else {
                if (badge) { badge.textContent = 'Off'; badge.className = 'risk-indicator safe'; }
                if (currentDiv) currentDiv.style.display = 'none';
            }

            if (!listDiv) return;
            // Clear existing content
            listDiv.textContent = '';

            if (devices.length === 0) {
                var emptyDiv = document.createElement('div');
                emptyDiv.className = 'offload-empty';
                emptyDiv.textContent = 'No eligible devices found. Register a device with SSH configuration on the home page.';
                listDiv.appendChild(emptyDiv);
                return;
            }

            devices.forEach(function(d) {
                var isActive = config.enabled && config.target_device_id === d.id;
                var card = document.createElement('div');
                card.className = 'offload-device-card';

                var dot = document.createElement('div');
                dot.className = 'device-status-dot ' + d.status;
                card.appendChild(dot);

                var info = document.createElement('div');
                info.className = 'device-info';
                var dname = document.createElement('div');
                dname.className = 'dname';
                dname.textContent = d.device_name;
                info.appendChild(dname);
                var dhost = document.createElement('div');
                dhost.className = 'dhost';
                var sshHost = d.ssh_config ? (d.ssh_config.username ? d.ssh_config.username + '@' : '') + d.ssh_config.host : '';
                dhost.textContent = sshHost;
                info.appendChild(dhost);
                card.appendChild(info);

                if (isActive) {
                    var currentBadge = document.createElement('span');
                    currentBadge.className = 'risk-indicator extended';
                    currentBadge.style.margin = '0';
                    currentBadge.textContent = 'Current';
                    card.appendChild(currentBadge);
                } else {
                    var selectBtn = document.createElement('button');
                    selectBtn.className = 'offload-select-btn';
                    selectBtn.textContent = 'Select';
                    selectBtn.setAttribute('data-device-id', d.id);
                    selectBtn.addEventListener('click', function() { selectOffloadDevice(d.id); });
                    card.appendChild(selectBtn);
                }

                listDiv.appendChild(card);
            });
        }

        async function selectOffloadDevice(deviceId) {
            const proceed = await cerebroConfirm(
                'Agents will be sent to this device via SSH. The remote device must have Claude CLI installed.',
                { title: 'Enable Offloading?', confirmText: 'Enable', cancelText: 'Cancel' }
            );
            if (!proceed) return;
            try {
                const token = localStorage.getItem('cerebro_token');
                const res = await fetch(API_URL + '/api/offload/config', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'Authorization': 'Bearer ' + token },
                    body: JSON.stringify({ enabled: true, target_device_id: deviceId }),
                });
                if (res.ok) {
                    showToast('Offloading enabled');
                    _offloadConfigLoaded = false;
                    initOffloadConfig();
                } else {
                    const err = await res.json().catch(function() { return {}; });
                    showToast('Failed: ' + (err.detail || 'Unknown error'), 'error');
                }
            } catch (e) {
                showToast('Failed to update offload config', 'error');
            }
        }

        async function disableOffload() {
            const proceed = await cerebroConfirm(
                'Agents will run locally again.',
                { title: 'Disable Offloading?', confirmText: 'Disable', cancelText: 'Cancel', danger: true }
            );
            if (!proceed) return;
            try {
                const token = localStorage.getItem('cerebro_token');
                const res = await fetch(API_URL + '/api/offload/config', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'Authorization': 'Bearer ' + token },
                    body: JSON.stringify({ enabled: false }),
                });
                if (res.ok) {
                    showToast('Offloading disabled');
                    _offloadConfigLoaded = false;
                    initOffloadConfig();
                } else {
                    showToast('Failed to disable offloading', 'error');
                }
            } catch (e) {
                showToast('Failed to update offload config', 'error');
            }
        }

        // ==================== DEVICE REFRESH & AUTO-DETECT ====================

        async function refreshAllDevices() {
            const btn = document.getElementById('refresh-devices-btn');
            if (btn) { btn.style.opacity = '0.5'; btn.style.pointerEvents = 'none'; }
            try {
                const token = localStorage.getItem('cerebro_token');
                const res = await fetch(API_URL + '/api/devices/refresh', {
                    method: 'POST',
                    headers: { 'Authorization': 'Bearer ' + token },
                });
                if (res.ok) {
                    const data = await res.json();
                    const online = (data.results || []).filter(r => r.reachable).length;
                    const total = (data.results || []).length;
                    showToast(online + '/' + total + ' devices reachable', online > 0 ? 'success' : 'warning');
                    if (typeof loadLiveActivityData === 'function') loadLiveActivityData();
                } else {
                    showToast('Refresh failed', 'error');
                }
            } catch (e) {
                showToast('Refresh error: ' + e.message, 'error');
            }
            if (btn) { btn.style.opacity = '1'; btn.style.pointerEvents = ''; }
        }

        async function refreshDevicesForOffload() {
            const btn = document.getElementById('offload-refresh-btn');
            if (btn) { btn.textContent = 'Refreshing...'; btn.disabled = true; }
            try {
                const token = localStorage.getItem('cerebro_token');
                await fetch(API_URL + '/api/devices/refresh', {
                    method: 'POST',
                    headers: { 'Authorization': 'Bearer ' + token },
                });
                _offloadConfigLoaded = false;
                await initOffloadConfig();
                showToast('Devices refreshed', 'success');
            } catch (e) {
                showToast('Refresh failed', 'error');
            }
            if (btn) { btn.textContent = 'Refresh'; btn.disabled = false; }
        }

        async function autoDetectDevice() {
            if (!_currentDeviceId) return;
            const btn = document.getElementById('device-detect-btn');
            const resultsDiv = document.getElementById('device-detect-results');
            if (btn) { btn.textContent = 'Detecting...'; btn.disabled = true; }
            if (resultsDiv) { resultsDiv.style.display = 'none'; }
            try {
                const token = localStorage.getItem('cerebro_token');
                const res = await fetch(API_URL + '/api/devices/' + _currentDeviceId + '/detect', {
                    method: 'POST',
                    headers: { 'Authorization': 'Bearer ' + token },
                });
                const data = await res.json();
                if (data.success) {
                    showToast('Detected: ' + (data.device_type || '').replace(/_/g, ' '), 'success');
                    document.getElementById('device-detail-subtitle').textContent = (data.device_type || '').replace(/_/g, ' ') + '  ' + (_currentDeviceId);
                    const badge = document.getElementById('device-detail-badge');
                    if (badge) { badge.className = 'device-status-badge online'; badge.textContent = 'Online'; }
                    // Show probe details using safe DOM methods
                    if (resultsDiv) {
                        var probe = data.probe || {};
                        resultsDiv.textContent = '';
                        var detailItems = [];
                        if (probe.distro) detailItems.push('OS: ' + probe.distro);
                        if (probe.architecture) detailItems.push('Arch: ' + probe.architecture);
                        if (probe.ram_gb) detailItems.push('RAM: ' + probe.ram_gb + ' GB');
                        if (probe.cpu_cores) detailItems.push('CPU: ' + probe.cpu_cores + ' cores');
                        if (probe.gpu_info) detailItems.push('GPU: ' + probe.gpu_info.join(', '));
                        if (probe.product_name) detailItems.push('Product: ' + probe.product_name);
                        if (probe.board_model) detailItems.push('Board: ' + probe.board_model);
                        detailItems.forEach(function(item, i) {
                            if (i > 0) resultsDiv.appendChild(document.createElement('br'));
                            var span = document.createElement('span');
                            span.textContent = item;
                            resultsDiv.appendChild(span);
                        });
                        if (detailItems.length === 0) resultsDiv.textContent = 'Detection complete  type: ' + (data.device_type || 'unknown');
                        resultsDiv.style.display = '';
                    }
                    // Update info grid
                    var infoGrid = document.getElementById('device-info-grid');
                    if (infoGrid && data.device) {
                        infoGrid.textContent = '';
                        var d = data.device;
                        var rows = [
                            ['Hostname', d.hostname || _currentDeviceId],
                            ['Type', (d.device_type || '').replace(/_/g, ' ')],
                            ['OS', d.os || ''],
                            ['Architecture', d.architecture || ''],
                            ['RAM', d.ram_gb ? d.ram_gb + ' GB' : ''],
                            ['CPU Cores', d.cpu_cores ? d.cpu_cores.toString() : ''],
                            ['GPU', d.gpu_info ? d.gpu_info.join(', ') : ''],
                            ['Registered', d.registered_at ? new Date(d.registered_at).toLocaleDateString() : ''],
                            ['Last Seen', d.last_seen ? getTimeAgo(d.last_seen) : 'Never'],
                        ];
                        rows.forEach(function(r) {
                            var row = document.createElement('div');
                            row.className = 'device-info-row';
                            var lbl = document.createElement('span');
                            lbl.className = 'device-info-label';
                            lbl.textContent = r[0];
                            row.appendChild(lbl);
                            var val = document.createElement('span');
                            val.className = 'device-info-value';
                            val.textContent = r[1];
                            row.appendChild(val);
                            infoGrid.appendChild(row);
                        });
                    }
                    if (typeof loadLiveActivityData === 'function') loadLiveActivityData();
                } else {
                    showToast('Detection failed: ' + (data.error || 'unknown'), 'error');
                    if (resultsDiv) { resultsDiv.textContent = 'Error: ' + (data.error || 'unknown'); resultsDiv.style.display = ''; }
                }
            } catch (e) {
                showToast('Detection error: ' + e.message, 'error');
            }
            if (btn) { btn.textContent = 'Auto-detect'; btn.disabled = false; }
        }

        // Load project folders for offload when opening advanced options
        async function loadProjectFolders() {
            var group = document.getElementById('project-folder-group');
            var select = document.getElementById('agent-project-folder');
            if (!group || !select) return;
            try {
                const token = localStorage.getItem('cerebro_token');
                const cfgRes = await fetch(API_URL + '/api/offload/config', { headers: { 'Authorization': 'Bearer ' + token } });
                const cfg = cfgRes.ok ? await cfgRes.json() : {};
                if (!cfg.enabled) { group.style.display = 'none'; return; }
                group.style.display = '';
                const res = await fetch(API_URL + '/api/offload/available-folders', { headers: { 'Authorization': 'Bearer ' + token } });
                const data = res.ok ? await res.json() : { folders: [] };
                var prev = select.value;
                select.textContent = '';
                var defaultOpt = document.createElement('option');
                defaultOpt.value = '';
                defaultOpt.textContent = 'None (prompt only)';
                select.appendChild(defaultOpt);
                (data.folders || []).forEach(function(f) {
                    var opt = document.createElement('option');
                    opt.value = f.path;
                    opt.textContent = f.mount + ' / ' + f.name + (f.entries ? ' (' + f.entries + ' items)' : '');
                    select.appendChild(opt);
                });
                if (prev) select.value = prev;
            } catch (e) {
                group.style.display = 'none';
            }
        }

        // ==================== UPDATE BANNER ====================
        var _updateBannerDismissed = false;

        window.__cerebroShowUpdateBanner = function(type) {
            if (_updateBannerDismissed) return;
            // Suppress banner for 2 hours after a successful update
            var lastUpdate = localStorage.getItem('cerebro_last_update_ts');
            if (lastUpdate && (Date.now() - parseInt(lastUpdate, 10)) < 7200000) return;
            var bar = document.getElementById('update-available-bar');
            var msg = document.getElementById('update-msg-text');
            if (!bar) return;
            if (type === 'docker') {
                if (msg) msg.textContent = 'A backend update is available.';
            } else if (type === 'electron') {
                if (msg) msg.textContent = 'A new version of Cerebro is available.';
            } else {
                if (msg) msg.textContent = 'An update is available.';
            }
            bar.style.display = '';
        };

        function dismissUpdateBanner() {
            var bar = document.getElementById('update-available-bar');
            if (bar) bar.style.display = 'none';
            _updateBannerDismissed = true;
        }

        function setUpdateBtnSpinner(btn, text) {
            btn.textContent = '';
            var spinner = document.createElement('span');
            spinner.className = 'update-spinner';
            btn.appendChild(spinner);
            btn.appendChild(document.createTextNode(text));
        }

        async function applyAppUpdate() {
            if (!window.cerebroDesktop) return;
            var btn = document.getElementById('update-apply-btn');
            if (btn) {
                btn.disabled = true;
                btn.classList.add('updating');
                setUpdateBtnSpinner(btn, 'Updating\u2026');
            }
            try {
                var result = await window.cerebroDesktop.applyUpdate();
                if (result.success) {
                    localStorage.setItem('cerebro_last_update_ts', String(Date.now()));
                    dismissUpdateBanner();
                    if (btn) setUpdateBtnSpinner(btn, 'Restarting\u2026');
                    showToast('Update applied  restarting!', 'success');
                } else {
                    var errMsg = result.error || 'Unknown error';
                    if (errMsg.toLowerCase().includes('defender')) {
                        cerebroAlert(
                            'Windows Defender is preventing the update.\n\n' +
                            'To update, fully quit Cerebro (File \u2192 Quit or right-click the tray icon \u2192 Quit), ' +
                            'then reopen it from your desktop shortcut. The update installs automatically on quit.\n\n' +
                            'If that doesn\u2019t work, open PowerShell as Admin and run:\nAdd-MpPreference -ExclusionProcess "Cerebro.exe"',
                            { title: 'Update Blocked', buttonText: 'Got it' }
                        );
                    } else {
                        showToast('Update failed: ' + errMsg, 'error');
                    }
                    if (btn) { btn.disabled = false; btn.classList.remove('updating'); btn.textContent = 'Restart & Update'; }
                }
            } catch (e) {
                showToast('Update failed: ' + e.message, 'error');
                if (btn) { btn.disabled = false; btn.classList.remove('updating'); btn.textContent = 'Restart & Update'; }
            }
        }

        async function manualCheckForUpdates() {
            var btn = document.getElementById('settings-check-update-btn');
            if (btn) { btn.disabled = true; btn.textContent = 'Checking\u2026'; }
            try {
                if (window.cerebroDesktop) {
                    var result = await window.cerebroDesktop.checkForUpdates();
                    if (result && result.updateAvailable) {
                        showToast('Update available! Check the banner at the top.', 'success');
                        var bar = document.getElementById('update-available-bar');
                        if (bar) bar.style.display = '';
                    } else {
                        showToast('You are on the latest version', 'success');
                    }
                } else {
                    var resp = await fetch(API_URL + '/api/docker/check-update', {
                        headers: { 'Authorization': 'Bearer ' + token }
                    });
                    if (resp.ok) {
                        var data = await resp.json();
                        if (data.updateAvailable) {
                            showToast('Docker update available! Check the banner.', 'success');
                            var bar = document.getElementById('update-available-bar');
                            if (bar) bar.style.display = '';
                        } else {
                            showToast('You are on the latest version', 'success');
                        }
                    } else {
                        showToast('Could not check for updates', 'warning');
                    }
                }
            } catch (e) {
                showToast('Update check failed: ' + e.message, 'error');
            }
            if (btn) { btn.disabled = false; btn.textContent = 'Check for Updates'; }
        }

        // ==================== SIM CLARIFICATION POPUP ====================
        function showSimClarificationModal(data) {
            var old = document.getElementById('sim-clarify-overlay');
            if (old) old.remove();
            var overlay = document.createElement('div');
            overlay.id = 'sim-clarify-overlay';
            overlay.className = 'sim-clarify-overlay';
            var modal = document.createElement('div');
            modal.className = 'sim-clarify-modal';
            var header = document.createElement('div');
            header.className = 'sim-clarify-header';
            var hIcon = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            hIcon.setAttribute('width','20'); hIcon.setAttribute('height','20'); hIcon.setAttribute('viewBox','0 0 24 24');
            hIcon.setAttribute('fill','none'); hIcon.setAttribute('stroke','#8b5cf6'); hIcon.setAttribute('stroke-width','2');
            var c1 = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            c1.setAttribute('cx','12'); c1.setAttribute('cy','12'); c1.setAttribute('r','10');
            var p1 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            p1.setAttribute('d','M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3');
            var l1 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            l1.setAttribute('x1','12'); l1.setAttribute('y1','17'); l1.setAttribute('x2','12.01'); l1.setAttribute('y2','17');
            hIcon.appendChild(c1); hIcon.appendChild(p1); hIcon.appendChild(l1);
            header.appendChild(hIcon);
            header.appendChild(document.createTextNode(' Cerebro needs some details'));
            modal.appendChild(header);
            var ctx = document.createElement('div');
            ctx.className = 'sim-clarify-context';
            ctx.textContent = data.directive_text || data.original_query;
            modal.appendChild(ctx);
            var form = document.createElement('div');
            (data.questions || []).forEach(function(q) {
                var field = document.createElement('div');
                field.className = 'sim-clarify-field';
                var label = document.createElement('label');
                label.textContent = q.label;
                field.appendChild(label);
                if (q.type === 'select' && q.options) {
                    var sel = document.createElement('select');
                    sel.dataset.qid = q.id;
                    var emptyOpt = document.createElement('option');
                    emptyOpt.value = ''; emptyOpt.textContent = 'Select...';
                    sel.appendChild(emptyOpt);
                    q.options.forEach(function(opt) {
                        var o = document.createElement('option');
                        o.value = opt; o.textContent = opt;
                        sel.appendChild(o);
                    });
                    field.appendChild(sel);
                } else {
                    var inp = document.createElement('input');
                    inp.type = 'text'; inp.dataset.qid = q.id; inp.placeholder = q.label;
                    field.appendChild(inp);
                }
                form.appendChild(field);
            });
            modal.appendChild(form);
            var submitBtn = document.createElement('button');
            submitBtn.className = 'sim-clarify-submit';
            submitBtn.textContent = 'Run Simulation';
            submitBtn.addEventListener('click', function() {
                var answers = {};
                form.querySelectorAll('[data-qid]').forEach(function(el) { answers[el.dataset.qid] = el.value; });
                socket.emit('simulation_clarification_response', { request_id: data.id, answers: answers });
                overlay.remove();
            });
            modal.appendChild(submitBtn);
            overlay.appendChild(modal);
            overlay.addEventListener('click', function(e) {
                if (e.target === overlay) {
                    socket.emit('simulation_clarification_response', { request_id: data.id, answers: {} });
                    overlay.remove();
                }
            });
            document.addEventListener('keydown', function escHandler(e) {
                if (e.key === 'Escape' && document.getElementById('sim-clarify-overlay')) {
                    socket.emit('simulation_clarification_response', { request_id: data.id, answers: {} });
                    overlay.remove();
                    document.removeEventListener('keydown', escHandler);
                }
            });
            document.body.appendChild(overlay);
        }

        // ==================== SIM FOLLOW-UP SUGGESTIONS ====================
        let lastSimContext = null;
        function renderSimFollowups(messageEl, data) {
            lastSimContext = data;
            var wrap = document.createElement('div');
            wrap.className = 'sim-followups';
            (data.suggestions || []).forEach(function(s) {
                var pill = document.createElement('button');
                pill.className = 'sim-followup-pill';
                pill.textContent = s;
                pill.addEventListener('click', function() { sendSimFollowup(s, data); });
                wrap.appendChild(pill);
            });
            var inputWrap = document.createElement('div');
            inputWrap.className = 'sim-followup-input-wrap';
            var inp = document.createElement('input');
            inp.className = 'sim-followup-input';
            inp.placeholder = 'Ask about these results...';
            inp.addEventListener('keydown', function(e) {
                if (e.key === 'Enter' && inp.value.trim()) { sendSimFollowup(inp.value.trim(), data); inp.value = ''; }
            });
            var sendBtn = document.createElement('button');
            sendBtn.className = 'sim-followup-send';
            sendBtn.textContent = 'Ask';
            sendBtn.addEventListener('click', function() {
                if (inp.value.trim()) { sendSimFollowup(inp.value.trim(), data); inp.value = ''; }
            });
            inputWrap.appendChild(inp); inputWrap.appendChild(sendBtn);
            wrap.appendChild(inputWrap);
            messageEl.appendChild(wrap);
        }
        async function sendSimFollowup(question, simContext) {
            var stats = simContext.sim_data ? simContext.sim_data.statistics || {} : {};
            var contextHint = 'Context: Previously simulated "' + (simContext.query || '') +
                '" with expected value $' + (stats.mean || 0).toFixed(2) +
                ', std $' + (stats.std || 0).toFixed(2) + '. ';
            var input = document.getElementById('cerebro-chat-field');
            if (input) {
                input.value = contextHint + question;
                await sendChatMessage();
            }
        }

        function formatMessage(text) {
            if (!text) return '';

            // Basic markdown: code blocks
            text = text.replace(/```(\w*)\n([\s\S]*?)```/g, '<pre><code>$2</code></pre>');
            // Inline code
            text = text.replace(/`([^`]+)`/g, '<code>$1</code>');
            // Bold
            text = text.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
            // Line breaks
            text = text.replace(/\n/g, '<br>');

            return text;
        }

        // ==================== CHAT PERSISTENCE ====================
        const CHAT_STORAGE_KEY = 'cerebro_chat_history';
        const MAX_CHAT_MESSAGES = 200; // Keep last 200 messages

        function saveChatHistory() {
            try {
                const container = document.getElementById('messages');
                const messages = [];

                container.querySelectorAll('.message').forEach(msg => {
                    // Skip tool messages and empty messages
                    if (msg.classList.contains('tool')) return;

                    const type = msg.classList.contains('user') ? 'user' : 'assistant';
                    const content = msg.getAttribute('data-text') || msg.textContent.trim();

                    if (content) {
                        const entry = { type, content, timestamp: Date.now() };
                        // Save model info from msg-model or legacy assistant-card-model
                        if (type === 'assistant') {
                            const modelEl = msg.querySelector('.msg-model') || msg.querySelector('.assistant-card-model');
                            if (modelEl && modelEl.textContent.trim()) {
                                const dotEl = modelEl.querySelector('.model-dot');
                                if (dotEl) {
                                    // Reverse-lookup model id from dotClass
                                    const cls = dotEl.className.replace('model-dot ', '').trim();
                                    for (const [id, info] of Object.entries(MODEL_OPTIONS)) {
                                        if (info.dotClass === cls) { entry.model = id; break; }
                                    }
                                }
                            }
                        }
                        messages.push(entry);
                    }
                });

                // Keep only the last MAX_CHAT_MESSAGES
                const trimmed = messages.slice(-MAX_CHAT_MESSAGES);

                localStorage.setItem(CHAT_STORAGE_KEY, JSON.stringify({
                    messages: trimmed,
                    sessionId: sessionId,
                    lastSaved: Date.now()
                }));

                // Also save to backend for cross-device sync (fire and forget)
                saveChatToBackend(trimmed);

            } catch (e) {
                console.error('Failed to save chat history:', e);
            }
        }

        async function saveChatToBackend(messages) {
            try {
                await fetch(`${API_URL}/chat/history`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ messages, session_id: sessionId })
                });
            } catch (e) {
                // Silent fail - localStorage is primary
            }
        }

        async function loadChatHistory() {
            try {
                // Get both localStorage and backend data, use whichever has more messages
                let localData = null;
                let backendData = null;

                // Try localStorage first (instant display)
                const stored = localStorage.getItem(CHAT_STORAGE_KEY);
                if (stored) {
                    localData = JSON.parse(stored);
                    if (localData.messages && localData.messages.length > 0) {
                        // Show immediately for instant UX
                        renderChatHistory(localData.messages);
                        if (localData.sessionId) {
                            sessionId = localData.sessionId;
                            document.getElementById('session-id').textContent = sessionId.substring(0, 8) + '...';
                        }
                        console.log(`Loaded ${localData.messages.length} messages from localStorage`);
                    }
                }

                // Always check backend for newer/more messages (cross-device sync)
                try {
                    const response = await fetch(`${API_URL}/chat/history`, {
                        headers: { 'Authorization': `Bearer ${token}` }
                    });

                    if (response.ok) {
                        backendData = await response.json();
                    }
                } catch (e) {
                    console.log('Backend chat history unavailable');
                }

                // If backend has more messages, use it instead
                const localCount = localData?.messages?.length || 0;
                const backendCount = backendData?.messages?.length || 0;

                if (backendCount > localCount) {
                    console.log(`Backend has more messages (${backendCount} vs ${localCount}), syncing...`);
                    renderChatHistory(backendData.messages);
                    if (backendData.session_id) {
                        sessionId = backendData.session_id;
                        document.getElementById('session-id').textContent = sessionId.substring(0, 8) + '...';
                    }
                    // Update localStorage with backend data
                    localStorage.setItem(CHAT_STORAGE_KEY, JSON.stringify({
                        messages: backendData.messages,
                        sessionId: backendData.session_id,
                        lastSaved: Date.now()
                    }));
                }

            } catch (e) {
                console.error('Failed to load chat history:', e);
            }
        }

        function renderChatHistory(messages) {
            var container = document.getElementById('messages');
            container.innerHTML = ''; // Clear default welcome message

            messages.forEach(function(msg) {
                if (msg.type === 'assistant') {
                    var ts = msg.timestamp ? formatTimestamp(new Date(msg.timestamp)) : null;
                    var messageEl = buildAssistantCard(msg.content, {
                        timestamp: ts,
                        model: msg.model || null
                    });
                    container.appendChild(messageEl);
                } else if (msg.type === 'user') {
                    var messageEl = document.createElement('div');
                    messageEl.className = 'message user';
                    messageEl.setAttribute('data-text', msg.content);

                    // msg-header with sender + time
                    var header = document.createElement('div');
                    header.className = 'msg-header';
                    var sender = document.createElement('span');
                    sender.className = 'msg-sender';
                    sender.textContent = 'You';
                    header.appendChild(sender);
                    var meta = document.createElement('span');
                    meta.className = 'msg-meta';
                    var timeSpan = document.createElement('span');
                    timeSpan.className = 'msg-time';
                    timeSpan.textContent = msg.timestamp ? formatTimestamp(new Date(msg.timestamp)) : '';
                    meta.appendChild(timeSpan);
                    header.appendChild(meta);
                    messageEl.appendChild(header);

                    var contentWrapper = document.createElement('div');
                    contentWrapper.className = 'message-content-wrapper';
                    contentWrapper.innerHTML = safeMarkdown(msg.content);
                    messageEl.appendChild(contentWrapper);

                    container.appendChild(messageEl);
                }
            });

            // Scroll to bottom after render
            scrollMessagesToBottom();
        }

        async function clearChatHistory() {
            if (!await cerebroConfirm('Clear all chat history? This cannot be undone.', { title: 'Clear History', danger: true, confirmText: 'Clear' })) return;

            localStorage.removeItem(CHAT_STORAGE_KEY);

            // Clear from backend too
            fetch(`${API_URL}/chat/history`, {
                method: 'DELETE',
                headers: { 'Authorization': `Bearer ${token}` }
            }).catch(() => {});

            // Reset the chat view
            const container = document.getElementById('messages');
            container.innerHTML = '';
            const welcomeText = `Hey ${CEREBRO_USERNAME}! I'm Cerebro, your AI command center. I can spawn agents, search your memory, run automations, or help with anything else. What do you need?`;
            const welcomeMsg = buildAssistantCard(welcomeText, { timestamp: 'Welcome' });
            container.appendChild(welcomeMsg);

            // Generate new session ID
            sessionId = 'session_' + Math.random().toString(36).substring(2, 10);
            document.getElementById('session-id').textContent = sessionId.substring(0, 8) + '...';
        }

        // Debounced save to avoid too many writes
        let saveTimeout = null;
        function debouncedSave() {
            if (saveTimeout) clearTimeout(saveTimeout);
            saveTimeout = setTimeout(saveChatHistory, 1000);
        }

        // ==================== QUICK ACTIONS ====================
        async function runQuickAction(command) {
            // Visual feedback
            const btn = event?.target?.closest('.action-btn');
            if (btn) btn.classList.add('active');

            // Switch to chat immediately for better UX
            switchView('chat');
            addMessage(`Run: ${command}`, 'user');

            // Show loading
            const assistantMsg = addMessage('', 'assistant');
            const qaWrapper = assistantMsg.querySelector('.message-content-wrapper');
            if (qaWrapper) qaWrapper.innerHTML = '<div class="thinking-orb-container"><div class="thinking-orb-dot"></div><span class="thinking-orb-label">Running...</span></div>';

            try {
                const response = await fetch(`${API_URL}/chat`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        content: `Run this command: ${command}`,
                        session_id: sessionId,
                        model: getSelectedModel()
                    })
                });

                const data = await response.json();
                if (qaWrapper) qaWrapper.innerHTML = safeMarkdown(data.content || 'Done!');
                assistantMsg.setAttribute('data-text', data.content || 'Done!');

            } catch (e) {
                console.error('Quick action error:', e);
                if (qaWrapper) qaWrapper.textContent = 'Error: Could not execute command';
            }

            if (btn) {
                setTimeout(() => btn.classList.remove('active'), 200);
            }
        }

        // ==================== TTS ====================
        async function speak(text) {
            if (isSpeaking) { stopSpeaking(); return; }

            // Strip markdown for cleaner speech
            text = text
                .replace(/```[\s\S]*?```/g, ' code block ')
                .replace(/\*\*([^*]+)\*\*/g, '$1')
                .replace(/\*([^*]+)\*/g, '$1')
                .replace(/#{1,6}\s/g, '')
                .replace(/\[([^\]]+)\]\([^)]+\)/g, '$1')
                .replace(/`([^`]+)`/g, '$1')
                .replace(/\n{2,}/g, '. ')
                .replace(/\n/g, ' ')
                .trim();
            if (text.length > 500) {
                var cp = text.lastIndexOf('.', 500);
                if (cp < 200) cp = text.lastIndexOf(' ', 500);
                if (cp < 200) cp = 500;
                text = text.substring(0, cp + 1);
            }
            if (!text) return;

            try {
                setSpeakingState(true, 'loading');
                const response = await fetch(`${TTS_URL}/v1/audio/speech`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ model: 'kokoro', input: text, voice: TTS_CONFIG.voice, response_format: 'mp3', speed: TTS_CONFIG.speed })
                });

                if (!response.ok) throw new Error('TTS failed');

                const audioBlob = await response.blob();
                const audioUrl = URL.createObjectURL(audioBlob);
                currentAudio = new Audio(audioUrl);
                // Apply selected speaker output if browser supports it
                if (selectedSpeakerId && currentAudio.setSinkId) {
                    try { await currentAudio.setSinkId(selectedSpeakerId); } catch(e) {}
                }
                setSpeakingState(true, 'speaking');

                currentAudio.onended = () => {
                    console.log('[TTS] Audio ended, conversationalMode:', conversationalMode);
                    setSpeakingState(false);
                    URL.revokeObjectURL(audioUrl);
                    currentAudio = null;
                };
                currentAudio.onerror = () => { setSpeakingState(false); showToast('Audio failed'); };

                await currentAudio.play();
            } catch (e) {
                console.error('TTS error:', e);
                setSpeakingState(false);
                // Fallback to browser speech synthesis
                try {
                    if (window.speechSynthesis) {
                        const utterance = new SpeechSynthesisUtterance(text);
                        utterance.rate = TTS_CONFIG.speed;
                        const voices = window.speechSynthesis.getVoices();
                        const femaleVoice = voices.find(v => /female|zira|hazel|susan|samantha/i.test(v.name))
                                         || voices.find(v => v.lang.startsWith('en'));
                        if (femaleVoice) utterance.voice = femaleVoice;
                        utterance.onend = () => {
                            setSpeakingState(false);
                        };
                        setSpeakingState(true);
                        window.speechSynthesis.speak(utterance);
                    } else {
                        showToast('Voice unavailable');
                    }
                } catch (fallbackErr) {
                    showToast('Voice unavailable');
                }
            }
        }

        function stopSpeaking() {
            if (currentAudio) { currentAudio.pause(); currentAudio = null; }
            setSpeakingState(false);
        }

        function setSpeakingState(speaking, phase) {
            isSpeaking = speaking;
            const orb = document.getElementById('nav-orb-container');
            if (orb) {
                if (!speaking) {
                    orb.classList.remove('speaking', 'loading-tts');
                } else if (phase === 'loading') {
                    orb.classList.add('loading-tts');
                    orb.classList.remove('speaking');
                } else {
                    orb.classList.add('speaking');
                    orb.classList.remove('loading-tts');
                }
            }
        }

        // Speak a specific chat message (used by the speaker button on each message)
        let currentSpeakingBtn = null;
        async function speakMessageContent(messageElement, btnElement) {
            var rawText = messageElement.getAttribute('data-text');
            if (!rawText) return;
            // Strip markdown for cleaner speech
            var text = rawText
                .replace(/```[\s\S]*?```/g, ' code block ')
                .replace(/\*\*([^*]+)\*\*/g, '$1')
                .replace(/\*([^*]+)\*/g, '$1')
                .replace(/#{1,6}\s/g, '')
                .replace(/\[([^\]]+)\]\([^)]+\)/g, '$1')
                .replace(/`([^`]+)`/g, '$1')
                .replace(/[\-*]{3,}/g, '')
                .replace(/^[\s]*[\-*+]\s/gm, '')
                .replace(/^[\s]*\d+\.\s/gm, '')
                .replace(/\n{2,}/g, '. ')
                .replace(/\n/g, ' ')
                .trim();
            if (text.length > 500) {
                var ci = text.lastIndexOf('.', 500);
                if (ci < 200) ci = text.lastIndexOf(' ', 500);
                if (ci < 200) ci = 500;
                text = text.substring(0, ci + 1);
            }

            // If already speaking this message, stop
            if (isSpeaking && currentSpeakingBtn === btnElement) {
                stopSpeaking();
                btnElement.classList.remove('speaking');
                currentSpeakingBtn = null;
                return;
            }

            // Stop any other speech and clear previous button state
            if (isSpeaking) {
                stopSpeaking();
            }
            if (currentSpeakingBtn) {
                currentSpeakingBtn.classList.remove('speaking');
            }

            // Set this button as loading (immediate visual feedback)
            currentSpeakingBtn = btnElement;
            btnElement.classList.add('loading');

            try {
                setSpeakingState(true, 'loading');
                const response = await fetch(`${TTS_URL}/v1/audio/speech`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ model: 'kokoro', input: text, voice: TTS_CONFIG.voice, response_format: 'mp3', speed: TTS_CONFIG.speed })
                });

                if (!response.ok) throw new Error('TTS failed');

                // Switch from loading spinner to speaking pulse
                btnElement.classList.remove('loading');
                btnElement.classList.add('speaking');

                const audioBlob = await response.blob();
                const audioUrl = URL.createObjectURL(audioBlob);
                currentAudio = new Audio(audioUrl);
                // Apply selected speaker output if browser supports it
                if (selectedSpeakerId && currentAudio.setSinkId) {
                    try { await currentAudio.setSinkId(selectedSpeakerId); } catch(e) {}
                }
                setSpeakingState(true, 'speaking');

                currentAudio.onended = () => {
                    setSpeakingState(false);
                    URL.revokeObjectURL(audioUrl);
                    currentAudio = null;
                    if (currentSpeakingBtn) {
                        currentSpeakingBtn.classList.remove('speaking', 'loading');
                        currentSpeakingBtn = null;
                    }
                };
                currentAudio.onerror = () => {
                    setSpeakingState(false);
                    if (currentSpeakingBtn) {
                        currentSpeakingBtn.classList.remove('speaking', 'loading');
                        currentSpeakingBtn = null;
                    }
                    showToast('Audio failed');
                };

                await currentAudio.play();
            } catch (e) {
                console.error('TTS error:', e);
                setSpeakingState(false);
                if (currentSpeakingBtn) {
                    currentSpeakingBtn.classList.remove('speaking', 'loading');
                    currentSpeakingBtn = null;
                }
                // Fallback to browser speech synthesis
                try {
                    if (window.speechSynthesis) {
                        const utterance = new SpeechSynthesisUtterance(text);
                        utterance.rate = TTS_CONFIG.speed;
                        const voices = window.speechSynthesis.getVoices();
                        const femaleVoice = voices.find(v => /female|zira|hazel|susan|samantha/i.test(v.name))
                                         || voices.find(v => v.lang.startsWith('en'));
                        if (femaleVoice) utterance.voice = femaleVoice;
                        utterance.onend = () => {
                            if (currentSpeakingBtn) {
                                currentSpeakingBtn.classList.remove('speaking');
                                currentSpeakingBtn = null;
                            }
                        };
                        window.speechSynthesis.speak(utterance);
                        currentSpeakingBtn = btnElement;
                        btnElement.classList.add('speaking');
                    } else {
                        showToast('Voice unavailable');
                    }
                } catch (fallbackErr) {
                    showToast('Voice unavailable');
                }
            }
        }


        // ==================== VOICE SETTINGS ====================
        let _voicePreviewAudio = null;

        function selectVoice(voice) {
            TTS_CONFIG.voice = voice;
            localStorage.setItem('cerebro_tts_voice', voice);
            // Update UI
            document.querySelectorAll('.voice-option').forEach(el => {
                el.classList.toggle('selected', el.dataset.voice === voice);
            });
        }

        function updateVoiceSpeed(value) {
            const speed = parseFloat(value);
            TTS_CONFIG.speed = speed;
            localStorage.setItem('cerebro_tts_speed', speed.toString());
            document.getElementById('voice-speed-display').textContent = speed.toFixed(1) + 'x';
        }

        function toggleAutoSpeak() {
            TTS_CONFIG.autoSpeak = !TTS_CONFIG.autoSpeak;
            localStorage.setItem('cerebro_tts_autospeak', TTS_CONFIG.autoSpeak.toString());
            document.getElementById('autospeak-toggle').classList.toggle('active', TTS_CONFIG.autoSpeak);
        }

        const _VOICE_PREVIEW_LINES = {
            af_heart: 'Systems online. All modules nominal, Commander.',
            af_bella: 'Good to see you. What shall we work on today?',
            af_sarah: 'Cerebro standing by. Ready when you are.',
            af_sky: 'Hey! Let me know what you need and I am on it.',
        };

        async function previewVoice(voice, btnEl) {
            // Stop any current preview
            if (_voicePreviewAudio) {
                _voicePreviewAudio.pause();
                _voicePreviewAudio = null;
                document.querySelectorAll('.voice-preview-btn.playing').forEach(b => b.classList.remove('playing'));
            }
            if (window.speechSynthesis) window.speechSynthesis.cancel();

            btnEl.classList.add('playing');
            const previewText = _VOICE_PREVIEW_LINES[voice] || 'Hello, I am Cerebro. How can I help you today?';

            try {
                const response = await fetch(`${TTS_URL}/v1/audio/speech`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        model: 'kokoro',
                        input: previewText,
                        voice: voice,
                        response_format: 'wav',
                        speed: TTS_CONFIG.speed
                    })
                });

                if (!response.ok) throw new Error('TTS preview failed');

                const blob = await response.blob();
                const url = URL.createObjectURL(blob);
                _voicePreviewAudio = new Audio(url);
                _voicePreviewAudio.onended = () => {
                    btnEl.classList.remove('playing');
                    URL.revokeObjectURL(url);
                    _voicePreviewAudio = null;
                };
                _voicePreviewAudio.onerror = () => {
                    btnEl.classList.remove('playing');
                    _voicePreviewAudio = null;
                };
                await _voicePreviewAudio.play();
            } catch (e) {
                console.log('[Voice] Kokoro TTS unavailable, using browser speech:', e.message);
                btnEl.classList.remove('playing');
                // Fallback: browser speechSynthesis
                if (window.speechSynthesis) {
                    const utterance = new SpeechSynthesisUtterance(previewText);
                    utterance.rate = TTS_CONFIG.speed;
                    // Try to pick a female voice to match the Kokoro voices
                    const voices = window.speechSynthesis.getVoices();
                    const femaleVoice = voices.find(v => /female|zira|hazel|susan|samantha/i.test(v.name))
                                     || voices.find(v => v.lang.startsWith('en'));
                    if (femaleVoice) utterance.voice = femaleVoice;
                    btnEl.classList.add('playing');
                    utterance.onend = () => btnEl.classList.remove('playing');
                    utterance.onerror = () => btnEl.classList.remove('playing');
                    window.speechSynthesis.speak(utterance);
                } else {
                    showToast('Voice preview unavailable');
                }
            }
        }

        async function testCurrentVoice() {
            const greetings = [
                'Systems online. All modules nominal.',
                'Cerebro standing by. What would you like me to work on?',
                'I have analyzed the data. Ready to present findings.',
                'Running diagnostics. Everything checks out.'
            ];
            const text = greetings[Math.floor(Math.random() * greetings.length)];
            await speak(text);
        }

        function initVoiceSettings() {
            // Restore saved voice selection
            const savedVoice = localStorage.getItem('cerebro_tts_voice') || 'af_heart';
            selectVoice(savedVoice);

            // Restore speed
            const savedSpeed = parseFloat(localStorage.getItem('cerebro_tts_speed') || '1.0');
            const slider = document.getElementById('voice-speed-slider');
            if (slider) {
                slider.value = savedSpeed;
                document.getElementById('voice-speed-display').textContent = savedSpeed.toFixed(1) + 'x';
            }

            // Restore auto-speak
            if (TTS_CONFIG.autoSpeak) {
                const toggle = document.getElementById('autospeak-toggle');
                if (toggle) toggle.classList.add('active');
            }

            // Check Kokoro TTS status
            checkKokoroStatus();
        }

        // ==================== KOKORO TTS ENGINE ====================
        async function checkKokoroStatus() {
            const badge = document.getElementById('kokoro-status-badge');
            const desc = document.getElementById('kokoro-engine-desc');
            const installArea = document.getElementById('kokoro-install-area');
            const voiceList = document.getElementById('voice-options-list');

            try {
                const resp = await fetch(`${TTS_URL}/health`, { signal: AbortSignal.timeout(3000) });
                if (resp.ok) {
                    badge.textContent = 'Running';
                    badge.className = 'risk-indicator safe';
                    desc.textContent = 'Kokoro TTS is active  natural human voices enabled';
                    installArea.style.display = 'none';
                    if (voiceList) voiceList.style.opacity = '1';
                    if (voiceList) voiceList.style.pointerEvents = 'auto';
                    return;
                }
            } catch {}

            // Not running
            badge.textContent = 'Not Installed';
            badge.className = 'risk-indicator';
            badge.style.background = 'rgba(239,68,68,0.15)';
            badge.style.color = '#ef4444';
            desc.textContent = 'Install the voice engine to give Cerebro a natural human voice';
            installArea.style.display = 'block';
            // Dim voice options when engine not installed
            if (voiceList) voiceList.style.opacity = '0.4';
            if (voiceList) voiceList.style.pointerEvents = 'none';
        }

        let _kokoroInstalling = false;
        async function installKokoroTts() {
            if (_kokoroInstalling) return;

            // Check if running in Electron
            if (!window.cerebroDesktop || !window.cerebroDesktop.installKokoroTts) {
                showToast('Voice engine install requires the Cerebro desktop app');
                return;
            }

            _kokoroInstalling = true;
            const btn = document.getElementById('kokoro-install-btn');
            const installArea = document.getElementById('kokoro-install-area');
            const progressArea = document.getElementById('kokoro-progress-area');
            const progressText = document.getElementById('kokoro-progress-text');
            const progressBar = document.getElementById('kokoro-progress-bar');
            const badge = document.getElementById('kokoro-status-badge');

            btn.disabled = true;
            installArea.style.display = 'none';
            progressArea.style.display = 'block';
            badge.textContent = 'Installing';
            badge.style.background = 'rgba(59,130,246,0.15)';
            badge.style.color = '#3b82f6';

            // Listen for progress updates
            let pullCount = 0;
            window.cerebroDesktop.onKokoroInstallProgress((data) => {
                if (data.stage === 'pulling') {
                    // Estimate progress from pull output
                    const msg = data.message || '';
                    if (msg.includes('Downloading') || msg.includes('Extracting')) pullCount++;
                    const pct = Math.min(90, Math.round(pullCount * 0.5));
                    progressBar.style.width = pct + '%';
                    // Show a cleaner message
                    if (msg.includes('Downloading')) progressText.textContent = 'Downloading voice engine...';
                    else if (msg.includes('Extracting')) progressText.textContent = 'Extracting...';
                    else if (msg.includes('Pull complete')) progressText.textContent = 'Layers downloaded...';
                    else if (msg.includes('voice engine')) progressText.textContent = msg;
                } else if (data.stage === 'starting') {
                    progressBar.style.width = '95%';
                    progressText.textContent = 'Starting voice engine...';
                } else if (data.stage === 'done') {
                    progressBar.style.width = '100%';
                    progressText.textContent = 'Voice engine installed!';
                } else if (data.stage === 'error') {
                    progressText.textContent = 'Install failed: ' + (data.message || 'unknown error');
                }
            });

            try {
                const result = await window.cerebroDesktop.installKokoroTts();
                if (result.success) {
                    showToast('Voice engine installed successfully');
                    // Wait for Kokoro to warm up
                    setTimeout(() => {
                        progressArea.style.display = 'none';
                        checkKokoroStatus();
                    }, 5000);
                } else {
                    showToast('Voice engine install failed: ' + (result.error || 'unknown'));
                    progressArea.style.display = 'none';
                    installArea.style.display = 'block';
                    btn.disabled = false;
                    badge.textContent = 'Not Installed';
                    badge.style.background = 'rgba(239,68,68,0.15)';
                    badge.style.color = '#ef4444';
                }
            } catch (e) {
                console.error('Kokoro install error:', e);
                showToast('Voice engine install failed');
                progressArea.style.display = 'none';
                installArea.style.display = 'block';
                btn.disabled = false;
            }
            _kokoroInstalling = false;
        }

        function getCerebroGreeting() {
            const hour = new Date().getHours();
            const time = hour < 12 ? 'Good morning' : hour < 17 ? 'Good afternoon' : 'Good evening';
            return `${time} ${CEREBRO_USERNAME}. I am Cerebro. How may I assist you today?`;
        }

        // ==================== AUDIO DEVICES ====================
        let selectedMicId = null;
        let selectedSpeakerId = null;

        async function loadAudioDevices() {
            // Guard: if mediaDevices API not available (insecure context), bail gracefully
            if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {
                console.warn('[Audio] mediaDevices API not available (needs HTTPS or localhost)');
                var voiceStatus = document.getElementById('voice-status');
                if (voiceStatus) voiceStatus.textContent = 'Audio API unavailable';
                return;
            }

            try {
                var devices = await navigator.mediaDevices.enumerateDevices();
                var hasLabels = devices.some(function(d) { return d.label; });

                if (!hasLabels) {
                    // No labels  need mic permission first. Add hint option.
                    var micSelect = document.getElementById('mic-select');
                    if (micSelect) {
                        var hint = document.createElement('option');
                        hint.value = '__request_permission__';
                        hint.textContent = 'Grant access via Test Mic button';
                        micSelect.appendChild(hint);
                    }
                    updateVoiceStatus();
                    console.log('[Audio] No labels yet  permission needed');
                    return;
                }

                populateDeviceSelects(devices);
                updateVoiceStatus();
                console.log('[Audio] Devices loaded:', devices.length);
            } catch (e) {
                console.error('[Audio] enumerateDevices failed:', e);
                updateVoiceStatus();
            }
        }

        function populateDeviceSelects(devices) {
            const micSelect = document.getElementById('mic-select');
            const speakerSelect = document.getElementById('speaker-select');
            const savedMic = localStorage.getItem('cerebro_mic_id');
            const savedSpeaker = localStorage.getItem('cerebro_speaker_id');

            if (micSelect) {
                while (micSelect.firstChild) micSelect.removeChild(micSelect.firstChild);
                const defOpt = document.createElement('option');
                defOpt.value = '';
                defOpt.textContent = 'Default Microphone';
                micSelect.appendChild(defOpt);

                devices.filter(d => d.kind === 'audioinput').forEach(d => {
                    const opt = document.createElement('option');
                    opt.value = d.deviceId;
                    opt.textContent = d.label || ('Microphone ' + micSelect.options.length);
                    if (d.deviceId === savedMic) opt.selected = true;
                    micSelect.appendChild(opt);
                });
                if (savedMic) selectedMicId = savedMic;
            }

            if (speakerSelect) {
                // Firefox doesn't support audiooutput enumeration
                const outputs = devices.filter(d => d.kind === 'audiooutput');
                while (speakerSelect.firstChild) speakerSelect.removeChild(speakerSelect.firstChild);

                if (outputs.length === 0) {
                    const defOpt = document.createElement('option');
                    defOpt.value = '';
                    defOpt.textContent = 'System Default (browser managed)';
                    speakerSelect.appendChild(defOpt);
                    speakerSelect.disabled = true;
                } else {
                    const defOpt = document.createElement('option');
                    defOpt.value = '';
                    defOpt.textContent = 'Default Speaker';
                    speakerSelect.appendChild(defOpt);
                    speakerSelect.disabled = false;
                    outputs.forEach(d => {
                        const opt = document.createElement('option');
                        opt.value = d.deviceId;
                        opt.textContent = d.label || ('Speaker ' + speakerSelect.options.length);
                        if (d.deviceId === savedSpeaker) opt.selected = true;
                        speakerSelect.appendChild(opt);
                    });
                    if (savedSpeaker) selectedSpeakerId = savedSpeaker;
                }
            }
        }

        // Re-enumerate after permission is granted (called after testMicrophone)
        async function refreshAudioDevices() {
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                populateDeviceSelects(devices);
                updateVoiceStatus();
            } catch (e) {
                console.error('[Audio] Refresh devices failed:', e);
            }
        }

        function selectMicrophone(deviceId) {
            if (deviceId === '__request_permission__') {
                testMicrophone();
                return;
            }
            selectedMicId = deviceId || null;
            localStorage.setItem('cerebro_mic_id', deviceId || '');
            console.log('[Audio] Mic selected:', deviceId);
            showToast('Microphone updated');
        }

        function selectSpeaker(deviceId) {
            selectedSpeakerId = deviceId || null;
            localStorage.setItem('cerebro_speaker_id', deviceId || '');
            if (currentAudio && currentAudio.setSinkId && deviceId) {
                currentAudio.setSinkId(deviceId).catch(function(){});
            }
            console.log('[Audio] Speaker selected:', deviceId);
            showToast('Speaker updated');
        }

        async function testMicrophone() {
            showToast('Requesting microphone access...');
            const voiceStatus = document.getElementById('voice-status');
            try {
                const constraints = selectedMicId && selectedMicId !== '__request_permission__'
                    ? { audio: { deviceId: { exact: selectedMicId } } }
                    : { audio: true };
                const stream = await navigator.mediaDevices.getUserMedia(constraints);

                if (voiceStatus) voiceStatus.textContent = 'Listening...';
                showToast('Listening for 3 seconds...');

                setTimeout(function() {
                    stream.getTracks().forEach(function(t) { t.stop(); });
                    if (voiceStatus) voiceStatus.textContent = 'Mic works!';
                    showToast('Microphone test passed');
                    // Now that we have permission, refresh device lists with labels
                    refreshAudioDevices();
                }, 3000);
            } catch (e) {
                console.error('[Audio] Mic test failed:', e);
                if (voiceStatus) voiceStatus.textContent = 'Permission denied';
                if (e.name === 'NotAllowedError') {
                    showToast('Microphone permission denied. Check browser settings.');
                } else if (e.name === 'NotFoundError') {
                    showToast('No microphone found');
                } else {
                    showToast('Microphone test failed');
                }
            }
        }

        function testSpeaker() {
            speak('Testing speaker. Can you hear me?');
        }

        function updateVoiceStatus() {
            var voiceStatus = document.getElementById('voice-status');
            if (!voiceStatus) return;

            var isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
            var isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);
            var isFirefox = navigator.userAgent.indexOf('Firefox') !== -1;

            // Update speaker select for Firefox (no setSinkId support)
            if (isFirefox) {
                var speakerSelect = document.getElementById('speaker-select');
                if (speakerSelect && !speakerSelect.disabled) {
                    while (speakerSelect.firstChild) speakerSelect.removeChild(speakerSelect.firstChild);
                    var opt = document.createElement('option');
                    opt.value = '';
                    opt.textContent = 'System Default (Firefox)';
                    speakerSelect.appendChild(opt);
                    speakerSelect.disabled = true;
                }
            }

            voiceStatus.textContent = 'TTS ready (STT removed)';
            voiceStatus.className = 'settings-value';
        }

        // ==================== AGENTS ====================
        let agents = {};

        // Helper: Check if sub-agent belongs to parent's current run
        // Filters out stale sub-agents from previous tasks/continuations
        function isCurrentRunSubAgent(child, parent) {
            if (!child || !parent) return false;

            const childName = child.call_sign || child.id;
            const childId = child.id;

            // If parent has output that mentions this sub-agent, it's from current run
            if (parent.output && parent.output.length > 0) {
                if (parent.output.includes(childName) || parent.output.includes(childId)) {
                    return true;
                }
                // If parent has substantial output but doesn't mention this child,
                // it's likely from a previous run
                if (parent.output.length > 200) {
                    return false;
                }
            }

            // If parent is still running or has minimal output, use time-based filtering
            // Sub-agent must have been created after parent started (with small buffer)
            if (parent.started_at) {
                const parentStarted = new Date(parent.started_at);
                const childCreated = new Date(child.created_at);
                // 10 second buffer for timing discrepancies
                return childCreated >= new Date(parentStarted.getTime() - 10000);
            }

            // Fallback: include if created within reasonable window of parent
            const parentCreated = new Date(parent.created_at);
            const childCreated = new Date(child.created_at);
            return childCreated >= parentCreated;
        }

        async function loadAgents() {
            try {
                // Load active/recent agents from memory
                const response = await fetch(`${API_URL}/agents`, {
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                const data = await response.json();
                var undeleted = false;
                data.agents.forEach(agent => {
                    if (deletedAgentIds.has(agent.id)) {
                        // Re-spawned agent with a previously-deleted call_sign  un-delete it
                        if (agent.status === 'running' || agent.status === 'cycling' || agent.status === 'queued') {
                            deletedAgentIds.delete(agent.id);
                            undeleted = true;
                        } else {
                            return;
                        }
                    }
                    agents[agent.id] = agent;
                });
                if (undeleted) {
                    localStorage.setItem('cerebro_deleted_agents', JSON.stringify(Array.from(deletedAgentIds)));
                }

                // Also load from persistent history (including archived)
                try {
                    const historyResponse = await fetch(`${API_URL}/agents/history?limit=50&include_archived=true`, {
                        headers: { 'Authorization': `Bearer ${token}` }
                    });
                    const historyData = await historyResponse.json();

                    // Also load archived agents
                    const allHistoryAgents = [
                        ...(historyData.agents || []),
                        ...(historyData.archived || [])
                    ];

                    // Merge history agents (don't overwrite active ones, skip deleted)
                    for (const agent of allHistoryAgents) {
                        if (deletedAgentIds.has(agent.id)) continue;
                        if (!agents[agent.id]) {
                            // Load full details for history agents
                            try {
                                const detailResponse = await fetch(`${API_URL}/agents/history/${agent.id}`, {
                                    headers: { 'Authorization': `Bearer ${token}` }
                                });
                                if (detailResponse.ok) {
                                    const fullAgent = await detailResponse.json();
                                    agents[agent.id] = fullAgent;
                                } else {
                                    // Mark load error so UI can show retry
                                    agents[agent.id] = {
                                        ...agent,
                                        _load_error: true,
                                        output: '',
                                        status: agent.status || 'completed'
                                    };
                                }
                            } catch (e) {
                                agents[agent.id] = { ...agent, _load_error: true, output: '', status: agent.status || 'completed' };
                            }
                        }
                    }
                } catch (e) {
                    console.warn('Failed to load agent history:', e);
                }

                switchAgentsViewMode(agentsViewMode);
                loadAgentProjects();
                renderAgents();

                // Start polling if any agents are currently running
                const hasRunning = Object.values(agents).some(a => a.status === 'running' || a.status === 'queued' || a.status === 'cycling');
                if (hasRunning) startAgentPolling();
            } catch (e) {
                console.error('Failed to load agents:', e);
            }
        }

        function renderAgents() {
            const container = document.getElementById('agents-container');
            const archivedContainer = document.getElementById('archived-agents-container');

            // Sort by created time  running agents always pinned to top
            let allAgents = Object.values(agents);
            const dirMul = agentsSortDir === 'asc' ? 1 : -1;
            allAgents.sort((a, b) => {
                const aRunning = a.status === 'running' || a.status === 'queued' || a.status === 'cycling' ? 1 : 0;
                const bRunning = b.status === 'running' || b.status === 'queued' || b.status === 'cycling' ? 1 : 0;
                if (bRunning !== aRunning) return bRunning - aRunning;
                const aTime = a.created_at || a.updated_at;
                const bTime = b.created_at || b.updated_at;
                return dirMul * (new Date(bTime) - new Date(aTime));
            });

            // Search filtering
            if (agentsSearchQuery) {
                const q = agentsSearchQuery.toLowerCase();
                allAgents = allAgents.filter(a =>
                    (a.task || '').toLowerCase().includes(q) ||
                    (a.call_sign || '').toLowerCase().includes(q) ||
                    (a.project_id || '').toLowerCase().includes(q) ||
                    (a.output || '').toLowerCase().includes(q)
                );
            }

            // Filter by active tab source ('all' shows everything)
            const tabAgents = (agentSelectMode || activeAgentsTab === 'all')
                ? allAgents
                : allAgents.filter(a => getAgentSource(a) === activeAgentsTab);

            // Project view: render differently
            if (agentsViewMode === 'project') {
                renderAgentsProjectView(tabAgents);
                // Still update running count
                const runningCount = tabAgents.filter(a => !a.archived && (a.status === 'running' || a.status === 'queued' || a.status === 'cycling')).length;
                document.getElementById('agents-count').textContent = `${runningCount} running`;
                const pill = document.getElementById('header-agents-pill');
                if (pill) { pill.textContent = runningCount > 0 ? `${runningCount} running` : 'idle'; pill.classList.toggle('idle', runningCount === 0); }
                updateAgentsStatusPanel();
                updateAgentControlBar();
                return;
            }

            // Apply container class for grid/list
            container.className = agentsViewMode === 'list' ? 'list-view' : (agentsViewMode === 'grid' ? 'grid-view' : '');

            // Split into active and archived
            const activeAgents = tabAgents.filter(a => !a.archived);
            const archivedAgents = tabAgents.filter(a => a.archived);

            // Chain replacement: only show leaf agents (no children in current set)
            const agentsWithChildren = new Set();
            for (const agent of activeAgents) {
                if (agent.parent_agent_id && agents[agent.parent_agent_id]) {
                    agentsWithChildren.add(agent.parent_agent_id);
                }
            }
            const leafAgents = activeAgents.filter(a => !agentsWithChildren.has(a.id));

            // Count uses ALL agents (including hidden parents) for accuracy
            const runningCount = activeAgents.filter(a => a.status === 'running' || a.status === 'queued' || a.status === 'cycling').length;
            document.getElementById('agents-count').textContent = `${runningCount} running`;
            const pill2 = document.getElementById('header-agents-pill');
            if (pill2) { pill2.textContent = runningCount > 0 ? `${runningCount} running` : 'idle'; pill2.classList.toggle('idle', runningCount === 0); }
            document.getElementById('archived-count').textContent = `(${archivedAgents.length})`;

            // Empty state messages per tab
            const emptyMessages = {
                all: 'Spawn agents from the + Spawn button or chat',
                user: 'Spawn agents from the + Spawn button or chat',
                cerebro: "Cerebro's autonomous agents will appear here"
            };

            // Render only leaf agents (parents hidden, accessible via chain nav breadcrumbs)
            if (leafAgents.length === 0) {
                const noAgentsDiv = document.createElement('div');
                noAgentsDiv.className = 'no-agents';
                const iconDiv = document.createElement('div');
                iconDiv.className = 'no-agents-icon';
                iconDiv.textContent = '\u{1F464}';
                noAgentsDiv.appendChild(iconDiv);
                const titleDiv = document.createElement('div');
                titleDiv.textContent = 'No agents running';
                const subtitleDiv = document.createElement('div');
                subtitleDiv.style.cssText = 'font-size: 0.85rem; margin-top: 8px; color: var(--text-muted);';
                subtitleDiv.textContent = emptyMessages[activeAgentsTab] || emptyMessages.user;
                noAgentsDiv.appendChild(titleDiv);
                noAgentsDiv.appendChild(subtitleDiv);
                container.replaceChildren(noAgentsDiv);
            } else {
                container.textContent = '';
                const cardsHtml = leafAgents.map(agent =>
                    renderAgentCard(agent, false, [])
                ).join('');
                container.insertAdjacentHTML('afterbegin', cardsHtml);
            }

            // Chain replacement for archived agents: only show leaves
            const archivedWithChildren = new Set();
            for (const agent of archivedAgents) {
                if (agent.parent_agent_id && agents[agent.parent_agent_id]) {
                    archivedWithChildren.add(agent.parent_agent_id);
                }
            }
            const archivedLeafAgents = archivedAgents.filter(a => !archivedWithChildren.has(a.id));

            // Render archived leaf agents
            if (archivedContainer) {
                if (archivedLeafAgents.length === 0) {
                    const emptyDiv = document.createElement('div');
                    emptyDiv.style.cssText = 'text-align: center; padding: 20px; color: var(--text-muted);';
                    emptyDiv.textContent = 'No archived agents';
                    archivedContainer.replaceChildren(emptyDiv);
                } else {
                    archivedContainer.textContent = '';
                    const archivedHtml = archivedLeafAgents.map(agent =>
                        renderAgentCard(agent, true, [])
                    ).join('');
                    archivedContainer.insertAdjacentHTML('afterbegin', archivedHtml);
                }
            }

            // Show/hide archive section based on count
            const archiveSection = document.getElementById('archive-section');
            if (archiveSection) {
                archiveSection.style.display = archivedAgents.length > 0 || tabAgents.length > 0 ? 'block' : 'none';
            }

            // Reapply select mode class after re-render
            if (agentSelectMode) {
                container.classList.add('select-mode');
                if (archivedContainer) archivedContainer.classList.add('select-mode');
            }

            // Update floating agent status panel
            updateAgentsStatusPanel();
            updateAgentControlBar();
        }

        // ===== AGENTS STATUS PANEL (Floating) =====
        let agentsPanelExpanded = false;

        function toggleAgentsPanel() {
            const panel = document.getElementById('agents-status-panel');
            agentsPanelExpanded = !agentsPanelExpanded;
            panel.classList.toggle('expanded', agentsPanelExpanded);
        }

        function updateAgentsStatusPanel() {
            const panel = document.getElementById('agents-status-panel');
            const countEl = document.getElementById('agents-status-count');
            const bodyEl = document.getElementById('agents-status-body');

            if (!panel || !countEl || !bodyEl) return;

            // Get running/queued agents only (active agents)
            const activeAgents = Object.values(agents).filter(a =>
                a.status === 'running' || a.status === 'queued'
            );

            // Update count
            countEl.textContent = activeAgents.length;
            countEl.classList.toggle('zero', activeAgents.length === 0);

            // Highlight panel when agents are active
            panel.classList.toggle('has-agents', activeAgents.length > 0);

            // Render agent items
            if (activeAgents.length === 0) {
                bodyEl.innerHTML = '<div class="agents-status-empty">No active agents</div>';
            } else {
                bodyEl.innerHTML = activeAgents.map(agent => {
                    const displayName = agent.call_sign || agent.id;
                    const taskPreview = (agent.task || '').substring(0, 50) + ((agent.task || '').length > 50 ? '...' : '');
                    const agentType = agent.type || 'worker';

                    return `
                        <div class="agents-status-item" onclick="showAgentDetail('${agent.id}');">
                            <div class="agent-status-dot ${agent.status}"></div>
                            <div class="agent-status-info">
                                <div class="agent-status-name">${displayName}</div>
                                <div class="agent-status-task">${taskPreview}</div>
                            </div>
                            <span class="agent-status-type">${agentType}</span>
                        </div>
                    `;
                }).join('');
            }
        }

        // Call on initial load
        document.addEventListener('DOMContentLoaded', () => {
            setTimeout(updateAgentsStatusPanel, 1000);
        });

        function renderAgentCard(agent, isArchived, childAgents = []) {
            // Special Ops agents get their own renderer
            if (agent.is_specops || (agent.type && agent.type.startsWith('specops_'))) {
                if (agentsViewMode === 'grid') {
                    return renderCompactSpecopsCard(agent, isArchived);
                }
                return renderSpecopsCard(agent, isArchived);
            }

            // Use compact cards in grid view
            if (agentsViewMode === 'grid') {
                return renderCompactAgentCard(agent, isArchived);
            }

            const toolsHtml = (agent.tools_used || []).map(t =>
                `<span class="agent-tool">${t}</span>`
            ).join('');

            const agentTask = agent.task || '';
            const timeAgo = getTimeAgo(agent.created_at);
            const outputPreview = agent.output ?
                agent.output.slice(-200).replace(/</g, '&lt;') : '';

            const hasOutput = agent.output && agent.output.length > 0;
            const statusIcon = agent.status === 'running' ? '' :
                               agent.status === 'completed' ? '' :
                               agent.status === 'failed' ? '' : '';

            const displayName = agent.call_sign || agent.id;
            const hasChildren = childAgents.length > 0;

            // Sub-agent count badge (clickable to expand)
            let subAgentBadge = '';
            if (hasChildren) {
                const runningChildren = childAgents.filter(c => c.status === 'running').length;
                const badgeText = runningChildren > 0
                    ? `${childAgents.length} sub-agents (${runningChildren} running)`
                    : `${childAgents.length} sub-agent${childAgents.length > 1 ? 's' : ''}`;
                subAgentBadge = `
                    <span class="sub-agent-count-badge" onclick="event.stopPropagation(); toggleSubAgents('${agent.id}')" title="Click to view sub-agents">
                        ${badgeText}
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <polyline points="6 9 12 15 18 9"/>
                        </svg>
                    </span>
                `;
            }

            // Render sub-agents section
            let subAgentsHtml = '';
            if (hasChildren) {
                const subAgentCards = childAgents.map(child => {
                    const childStatusIcon = child.status === 'running' ? '' :
                                           child.status === 'completed' ? '' :
                                           child.status === 'failed' ? '' : '';
                    const childName = child.call_sign || child.id;
                    const childTools = (child.tools_used || []).slice(0, 3).map(t =>
                        `<span class="sub-agent-tool">${t}</span>`
                    ).join('');
                    const moreTools = (child.tools_used || []).length > 3
                        ? `<span class="sub-agent-tool">+${child.tools_used.length - 3}</span>`
                        : '';

                    return `
                        <div class="sub-agent-card ${child.status}" onclick="event.stopPropagation(); showAgentDetail('${child.id}')">
                            <div class="sub-agent-header">
                                <span class="sub-agent-name">
                                     ${escapeHtml(childName)}
                                </span>
                                <span class="sub-agent-status ${child.status}">${childStatusIcon} ${child.status.toUpperCase()}</span>
                            </div>
                            <div class="sub-agent-task">${escapeHtml(child.task.slice(0, 100))}${child.task.length > 100 ? '...' : ''}</div>
                            ${childTools ? `<div class="sub-agent-tools">${childTools}${moreTools}</div>` : ''}
                        </div>
                    `;
                }).join('');

                subAgentsHtml = `
                    <div class="sub-agents-container" id="sub-agents-${agent.id}">
                        <div class="sub-agents-header">
                            <span class="sub-agents-title">Sub-Agents</span>
                        </div>
                        ${subAgentCards}
                    </div>
                `;
            }

            const archiveBtn = isArchived
                ? `<button class="agent-archive-btn" onclick="event.stopPropagation(); unarchiveAgent('${agent.id}')"> Unarchive</button>`
                : `<button class="agent-archive-btn" onclick="event.stopPropagation(); archiveAgent('${agent.id}')"> Archive</button>`;

            const isSelected = selectedAgentIds.has(agent.id);
            const selectCheckbox = `<div class="agent-select-checkbox ${isSelected ? 'checked' : ''}" onclick="event.stopPropagation(); toggleAgentSelection('${agent.id}', event)"></div>`;

            return `
                <div class="agent-card ${agent.status} ${isArchived ? 'archived' : ''} ${hasChildren ? 'has-children' : ''} ${isSelected ? 'selected' : ''}" onclick="handleAgentCardClick('${agent.id}', event)" style="position: relative;" data-agent-id="${agent.id}">
                    ${selectCheckbox}
                    ${archiveBtn}
                    <div class="agent-header">
                        <span class="agent-id"> ${displayName} ${subAgentBadge}</span>
                        <span class="agent-status ${agent.is_specops && agent.status === 'running' ? 'operating' : agent.status}">${statusIcon} ${agent.is_specops && agent.status === 'running' ? 'OPERATING' : agent.status.toUpperCase()}</span>
                    </div>
                    <div class="agent-task">${escapeHtml(agentTask.slice(0, 200))}${agentTask.length > 200 ? '...' : ''}</div>
                    ${toolsHtml ? `<div class="agent-tools">${toolsHtml}</div>` : ''}
                    ${agent._load_error ? `<div class="agent-output" style="color: var(--text-muted); font-style: italic;">Failed to load <button class="compact-retry-btn" onclick="event.stopPropagation(); retryLoadAgent('${agent.id}')" style="margin-left: 6px;">Retry</button></div>` : outputPreview ? `<div class="agent-output">${outputPreview}</div>` : `<div class="agent-output" style="color: var(--text-muted); font-style: italic;">${agent.status === 'running' ? 'Working...' : agent.status === 'completed' ? 'No output captured' : 'Waiting...'}</div>`}
                    ${agent.error ? `<div style="color: var(--red); font-size: 0.8rem; margin-top: 8px;">Error: ${escapeHtml(agent.error)}</div>` : ''}
                    <div class="agent-time">${timeAgo}${agent.offloaded_to_name ? ` <span class="agent-offload-badge">${escapeHtml(agent.offloaded_to_name)}</span>` : ''}</div>
                    <div class="agent-expand-hint">Tap to view details</div>
                    ${subAgentsHtml}
                </div>
            `;
        }

        function toggleSubAgents(agentId) {
            const container = document.getElementById(`sub-agents-${agentId}`);
            const badge = document.querySelector(`[data-agent-id="${agentId}"] .sub-agent-count-badge`);

            if (container) {
                container.classList.toggle('expanded');
                if (badge) {
                    badge.classList.toggle('expanded');
                }
            }
        }

        // ===== AGENTS TAB CONTROL =====
        let activeAgentsTab = 'all';  // 'all', 'user', 'cerebro'

        function getAgentSource(agent) {
            // Scheduler and idle agents route to cerebro tab
            if (agent.source === 'scheduler') return 'cerebro';
            // Explicit source field (new agents)
            if (agent.source === 'cerebro') return 'cerebro';
            if (agent.source === 'idle') return 'cerebro';
            if (agent.source) return agent.source;
            // Legacy fallback: directive_id implies cerebro
            if (agent.directive_id) return 'cerebro';
            // Default: user
            return 'user';
        }

        function switchAgentsTab(tab) {
            activeAgentsTab = tab;
            // Update tab buttons
            document.querySelectorAll('.agents-tab').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.tab === tab);
            });
            // Show/hide spawn button (on 'all' and 'user' tabs)
            const spawnBtn = document.querySelector('.spawn-agent-btn');
            if (spawnBtn) spawnBtn.style.display = (tab === 'all' || tab === 'user') ? '' : 'none';
            // Collapse archive when switching tabs
            archiveSectionExpanded = false;
            const icon = document.getElementById('archive-toggle-icon');
            const archContainer = document.getElementById('archived-agents-container');
            if (icon) icon.classList.remove('expanded');
            if (archContainer) archContainer.classList.add('hidden');
            // Re-render
            renderAgents();
        }

        // ===== VIEW MODE, SEARCH, SORT, PROJECT VIEW =====
        let agentsViewMode = localStorage.getItem('agentsViewMode') || 'grid';
        let agentsSearchQuery = '';
        let agentsSortDir = localStorage.getItem('agentsSortDir') || 'desc';
        let agentsSortMode = 'activity'; // kept for compat, always 'activity' now
        let agentProjects = {};
        let expandedProjects = new Set(['uncategorized']);

        function switchAgentsViewMode(mode) {
            agentsViewMode = mode;
            localStorage.setItem('agentsViewMode', mode);
            document.querySelectorAll('.view-mode-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.view === mode);
            });
            syncSortToggleUI();
            renderAgents();
        }

        function filterAgents() {
            const input = document.getElementById('agents-search-input');
            agentsSearchQuery = input ? input.value.trim() : '';
            renderAgents();
        }

        function setAgentSortDir(dir) {
            agentsSortDir = dir;
            localStorage.setItem('agentsSortDir', dir);
            syncSortToggleUI();
            renderAgents();
        }

        function syncSortToggleUI() {
            var descBtn = document.getElementById('sort-btn-desc');
            var ascBtn = document.getElementById('sort-btn-asc');
            if (descBtn) descBtn.classList.toggle('active', agentsSortDir === 'desc');
            if (ascBtn) ascBtn.classList.toggle('active', agentsSortDir === 'asc');
        }

        function sortAgents() {
            // Legacy compat  just re-render
            renderAgents();
        }

        function renderCompactAgentCard(agent, isArchived) {
            const displayName = escapeHtml(agent.call_sign || agent.id);
            const timeAgo = getTimeAgo(agent.created_at);
            const statusIcon = agent.status === 'running' ? '&#9203;' :
                               agent.status === 'completed' ? '&#10003;' :
                               agent.status === 'failed' ? '&#10007;' : '&#9208;';
            const projectBadge = agent.project_id
                ? '<span class="compact-project-badge">' + escapeHtml(agent.project_id) + '</span>'
                : '';
            const retryBtn = agent._load_error
                ? '<button class="compact-retry-btn" onclick="event.stopPropagation(); retryLoadAgent(\'' + agent.id + '\')">Retry</button>'
                : '';
            const taskText = escapeHtml((agent.task || '').slice(0, 120));

            const card = document.createElement('div');
            card.className = 'agent-card-compact ' + agent.status + (isArchived ? ' archived' : '') + (selectedAgentIds.has(agent.id) ? ' selected' : '');
            card.setAttribute('data-agent-id', agent.id);
            card.setAttribute('onclick', "handleAgentCardClick('" + agent.id + "', event)");

            const header = document.createElement('div');
            header.className = 'compact-header';

            const nameSpan = document.createElement('span');
            nameSpan.className = 'compact-name';
            nameSpan.textContent = agent.call_sign || agent.id;

            const statusSpan = document.createElement('span');
            var isSpecopsRunning = agent.is_specops && agent.status === 'running';
            statusSpan.className = 'compact-status ' + (isSpecopsRunning ? 'operating' : agent.status);
            statusSpan.textContent = isSpecopsRunning ? 'OPERATING' : agent.status.toUpperCase();

            header.appendChild(nameSpan);
            header.appendChild(statusSpan);

            const taskDiv = document.createElement('div');
            taskDiv.className = 'compact-task';
            taskDiv.textContent = (agent.task || '').slice(0, 120);

            const footer = document.createElement('div');
            footer.className = 'compact-footer';

            const timeSpan = document.createElement('span');
            timeSpan.className = 'compact-time';
            timeSpan.textContent = timeAgo;
            footer.appendChild(timeSpan);

            if (agent._load_error) {
                const retryButton = document.createElement('button');
                retryButton.className = 'compact-retry-btn';
                retryButton.textContent = 'Retry';
                retryButton.setAttribute('onclick', "event.stopPropagation(); retryLoadAgent('" + agent.id + "')");
                footer.appendChild(retryButton);
            } else if (agent.project_id) {
                const projSpan = document.createElement('span');
                projSpan.className = 'compact-project-badge';
                projSpan.textContent = agent.project_id;
                footer.appendChild(projSpan);
            }

            // Selection checkbox (shown in select-mode via CSS)
            const selectCb = document.createElement('div');
            selectCb.className = 'agent-select-checkbox' + (selectedAgentIds.has(agent.id) ? ' checked' : '');
            selectCb.setAttribute('onclick', "event.stopPropagation(); toggleAgentSelection('" + agent.id + "', event)");

            card.appendChild(selectCb);
            card.appendChild(header);
            card.appendChild(taskDiv);
            card.appendChild(footer);

            // Source badge (visible in select mode to distinguish agent origins)
            if (agentSelectMode) {
                const srcBadge = document.createElement('span');
                srcBadge.className = 'compact-source-badge';
                srcBadge.textContent = getAgentSource(agent);
                footer.appendChild(srcBadge);
            }

            // Offload badge (shows which remote device ran this agent)
            if (agent.offloaded_to_name) {
                const offloadBadge = document.createElement('span');
                offloadBadge.className = 'agent-offload-badge';
                offloadBadge.textContent = agent.offloaded_to_name;
                footer.appendChild(offloadBadge);
            }

            // Return outerHTML for compatibility with existing .map().join('') patterns
            return card.outerHTML;
        }

        function extractTopicKeywords(text) {
            const stopWords = new Set(['the','a','an','is','are','was','were','be','been',
                'have','has','had','do','does','did','will','would','could','should',
                'to','of','in','for','on','with','at','by','from','as','into','through',
                'and','or','but','if','so','not','no','its','it','i','me','my','you',
                'your','he','him','she','her','we','us','they','them','their','this',
                'that','what','which','who','how','when','where','why','about','just',
                'like','know','want','wanna','gonna','actually','really','um','umm',
                'hey','doing','going','get','got','make','let','give','can','also',
                'well','now','today','here','there','thing','something','anything']);
            return text.toLowerCase()
                .replace(/[^a-z0-9\s]/g, ' ')
                .split(/\s+/)
                .filter(w => w.length > 2 && !stopWords.has(w));
        }

        function groupAgentsByTopic(agentsList) {
            if (agentsList.length === 0) return [];

            // Phase 1: Pre-group by parent-child relationships
            // Build a map of agent_id -> agent for quick lookup
            const agentMap = {};
            for (const a of agentsList) { agentMap[a.id] = a; }

            // Find the root ancestor for each agent (follow parent_agent_id chain)
            function findRoot(a) {
                let current = a;
                const seen = new Set();
                while (current.parent_agent_id && agentMap[current.parent_agent_id] && !seen.has(current.id)) {
                    seen.add(current.id);
                    current = agentMap[current.parent_agent_id];
                }
                return current.id;
            }

            // Group agents by their root ancestor
            const familyGroups = {};
            for (const a of agentsList) {
                const rootId = findRoot(a);
                if (!familyGroups[rootId]) familyGroups[rootId] = [];
                familyGroups[rootId].push(a);
            }

            // Phase 2: Keyword-based clustering on the family groups
            const items = Object.values(familyGroups).map(family => ({
                agents: family,
                keywords: new Set(family.flatMap(a => extractTopicKeywords(a.task || '')))
            }));

            const groups = [];
            const assigned = new Set();

            for (let i = 0; i < items.length; i++) {
                if (assigned.has(i)) continue;
                const cluster = [...items[i].agents];
                const clusterKw = new Set(items[i].keywords);
                assigned.add(i);

                for (let j = i + 1; j < items.length; j++) {
                    if (assigned.has(j)) continue;
                    const intersection = [...items[j].keywords].filter(k => clusterKw.has(k));
                    const union = new Set([...clusterKw, ...items[j].keywords]);
                    if (union.size > 0 && intersection.length / union.size > 0.15) {
                        cluster.push(...items[j].agents);
                        assigned.add(j);
                        items[j].keywords.forEach(k => clusterKw.add(k));
                    }
                }

                let name;
                if (cluster.length === 1) {
                    name = cluster[0].call_sign || cluster[0].id.slice(0, 8);
                } else {
                    const freq = {};
                    cluster.forEach(a => extractTopicKeywords(a.task || '').forEach(w => {
                        freq[w] = (freq[w] || 0) + 1;
                    }));
                    const top = Object.entries(freq).sort((a,b) => b[1]-a[1]).slice(0,3).map(([w]) =>
                        w.charAt(0).toUpperCase() + w.slice(1)
                    );
                    name = top.join(' / ') || 'Group';
                }

                groups.push({ name, agents: cluster });
            }
            return groups;
        }

        function renderAgentsProjectView(allAgents) {
            const container = document.getElementById('agents-container');
            const archivedContainer = document.getElementById('archived-agents-container');
            container.className = '';

            const activeAgents = allAgents.filter(a => !a.archived);
            const archivedAgents = allAgents.filter(a => a.archived);

            // Chain replacement: only show leaf agents in project view
            const pvAgentsWithChildren = new Set();
            for (const agent of activeAgents) {
                if (agent.parent_agent_id && allAgents.find(a => a.id === agent.parent_agent_id)) {
                    pvAgentsWithChildren.add(agent.parent_agent_id);
                }
            }
            const leafAgents = activeAgents.filter(a => !pvAgentsWithChildren.has(a.id));

            // Check if agents have meaningful distinct project_ids
            const projectIds = new Set(leafAgents.map(a => a.project_id).filter(Boolean));
            const hasTrackerProjects = Object.keys(agentProjects).length > 0;
            const useFallbackGrouping = projectIds.size === 0 && !hasTrackerProjects;

            let groups = {};
            if (useFallbackGrouping) {
                const clusters = groupAgentsByTopic(leafAgents);
                for (const cluster of clusters) {
                    groups[cluster.name] = cluster.agents;
                }
            } else {
                for (const agent of leafAgents) {
                    const proj = agent.project_id || 'uncategorized';
                    if (!groups[proj]) groups[proj] = [];
                    groups[proj].push(agent);
                }
                // Include empty groups from agentProjects so created groups always show
                for (const pid in agentProjects) {
                    if (!groups[pid]) groups[pid] = [];
                }
            }

            // Sort groups: running first, then alphabetical
            const sortedKeys = Object.keys(groups).sort((a, b) => {
                const aRunning = groups[a].some(ag => ag.status === 'running' || ag.status === 'queued') ? 1 : 0;
                const bRunning = groups[b].some(ag => ag.status === 'running' || ag.status === 'queued') ? 1 : 0;
                if (bRunning !== aRunning) return bRunning - aRunning;
                if (a === 'uncategorized') return 1;
                if (b === 'uncategorized') return -1;
                return a.localeCompare(b);
            });

            if (sortedKeys.length === 0) {
                const emptyMessages = {
                    all: 'Spawn agents from the + Spawn button or chat',
                    user: 'Spawn agents from the + Spawn button or chat',
                    cerebro: "Cerebro's autonomous agents will appear here"
                };
                const noAgentsDiv = document.createElement('div');
                noAgentsDiv.className = 'no-agents';
                noAgentsDiv.textContent = 'No agents running';
                const sub = document.createElement('div');
                sub.style.cssText = 'font-size: 0.85rem; margin-top: 8px; color: var(--text-muted);';
                sub.textContent = emptyMessages[activeAgentsTab] || emptyMessages.user;
                noAgentsDiv.appendChild(sub);
                container.replaceChildren(noAgentsDiv);
                return;
            }

            const fragment = document.createDocumentFragment();
            for (const projKey of sortedKeys) {
                const projAgents = groups[projKey];
                const isExpanded = expandedProjects.has(projKey);
                const runningCount = projAgents.filter(a => a.status === 'running' || a.status === 'queued' || a.status === 'cycling').length;
                const projInfo = agentProjects[projKey] || {};
                const projName = projKey === 'uncategorized' ? 'Uncategorized' : (projInfo.name || projKey);
                const tags = projInfo.tech_tags || [];

                const folder = document.createElement('div');
                folder.className = 'project-folder';
                folder.setAttribute('data-project', projKey);

                const header = document.createElement('div');
                header.className = 'project-folder-header';
                header.onclick = (function(key) { return function() { toggleProjectFolder(key); }; })(projKey);

                // Chevron
                const chevron = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                chevron.setAttribute('class', 'project-folder-chevron' + (isExpanded ? ' expanded' : ''));
                chevron.setAttribute('width', '14');
                chevron.setAttribute('height', '14');
                chevron.setAttribute('viewBox', '0 0 24 24');
                chevron.setAttribute('fill', 'none');
                chevron.setAttribute('stroke', 'currentColor');
                chevron.setAttribute('stroke-width', '2');
                const polyline = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
                polyline.setAttribute('points', '9 18 15 12 9 6');
                chevron.appendChild(polyline);
                header.appendChild(chevron);

                // Folder icon
                const folderIcon = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                folderIcon.setAttribute('class', 'project-folder-icon');
                folderIcon.setAttribute('width', '16');
                folderIcon.setAttribute('height', '16');
                folderIcon.setAttribute('viewBox', '0 0 24 24');
                folderIcon.setAttribute('fill', 'none');
                folderIcon.setAttribute('stroke', 'currentColor');
                folderIcon.setAttribute('stroke-width', '2');
                const folderPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                folderPath.setAttribute('d', 'M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z');
                folderIcon.appendChild(folderPath);
                header.appendChild(folderIcon);

                const nameSpan = document.createElement('span');
                nameSpan.className = 'project-folder-name';
                nameSpan.textContent = projName;
                header.appendChild(nameSpan);

                const countSpan = document.createElement('span');
                countSpan.className = 'project-folder-count';
                countSpan.textContent = projAgents.length + ' agent' + (projAgents.length !== 1 ? 's' : '');
                header.appendChild(countSpan);

                if (runningCount > 0) {
                    const runBadge = document.createElement('span');
                    runBadge.className = 'project-folder-running';
                    runBadge.textContent = runningCount + ' running';
                    header.appendChild(runBadge);
                }

                if (tags.length > 0) {
                    const tagsContainer = document.createElement('span');
                    tagsContainer.className = 'project-folder-tags';
                    tags.slice(0, 4).forEach(t => {
                        const tag = document.createElement('span');
                        tag.className = 'project-folder-tag';
                        tag.textContent = t;
                        tagsContainer.appendChild(tag);
                    });
                    header.appendChild(tagsContainer);
                }

                folder.appendChild(header);

                const agentsDiv = document.createElement('div');
                agentsDiv.className = 'project-folder-agents' + (isExpanded ? '' : ' collapsed');
                // Use a temporary container to parse the compact card HTML
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = projAgents.map(a => renderCompactAgentCard(a, false)).join('');
                while (tempDiv.firstChild) {
                    agentsDiv.appendChild(tempDiv.firstChild);
                }
                folder.appendChild(agentsDiv);
                fragment.appendChild(folder);
            }

            container.replaceChildren(fragment);

            // Update archived
            if (archivedContainer) {
                const archCount = document.getElementById('archived-count');
                if (archCount) archCount.textContent = '(' + archivedAgents.length + ')';
                if (archivedAgents.length === 0) {
                    const emptyDiv = document.createElement('div');
                    emptyDiv.style.cssText = 'text-align: center; padding: 20px; color: var(--text-muted);';
                    emptyDiv.textContent = 'No archived agents';
                    archivedContainer.replaceChildren(emptyDiv);
                } else {
                    const tempArch = document.createElement('div');
                    tempArch.innerHTML = archivedAgents.map(a => renderCompactAgentCard(a, true)).join('');
                    archivedContainer.replaceChildren(...tempArch.childNodes);
                }
            }

            const archiveSection = document.getElementById('archive-section');
            if (archiveSection) {
                archiveSection.style.display = archivedAgents.length > 0 || allAgents.length > 0 ? 'block' : 'none';
            }

            if (agentSelectMode) {
                container.classList.add('select-mode');
                if (archivedContainer) archivedContainer.classList.add('select-mode');
            }
            updateAgentsStatusPanel();
        }

        function toggleProjectFolder(projectKey) {
            if (expandedProjects.has(projectKey)) {
                expandedProjects.delete(projectKey);
            } else {
                expandedProjects.add(projectKey);
            }
            renderAgents();
        }

        async function loadAgentProjects() {
            try {
                const response = await fetch(API_URL + '/agents/projects', {
                    headers: { 'Authorization': 'Bearer ' + token }
                });
                if (response.ok) {
                    const data = await response.json();
                    agentProjects = {};
                    // Backend returns {"projects": [...]}  extract the array
                    var projectsList = Array.isArray(data) ? data : (data && data.projects ? data.projects : []);
                    for (var i = 0; i < projectsList.length; i++) {
                        var proj = projectsList[i];
                        var pid = proj.id || proj.project_id;
                        if (pid && pid !== 'uncategorized') {
                            agentProjects[pid] = proj;
                        }
                    }
                }
            } catch (e) {
                console.warn('Failed to load agent projects:', e);
            }
        }

        async function assignAgentProject(agentId, projectId) {
            try {
                const response = await fetch(API_URL + '/agents/' + agentId + '/project', {
                    method: 'POST',
                    headers: {
                        'Authorization': 'Bearer ' + token,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ project_id: projectId || null })
                });
                if (response.ok) {
                    if (agents[agentId]) {
                        agents[agentId].project_id = projectId || null;
                    }
                    renderAgents();
                }
            } catch (e) {
                console.error('Failed to assign project:', e);
            }
        }

        async function retryLoadAgent(agentId) {
            try {
                const response = await fetch(API_URL + '/agents/history/' + agentId, {
                    headers: { 'Authorization': 'Bearer ' + token }
                });
                if (response.ok) {
                    const fullAgent = await response.json();
                    agents[agentId] = fullAgent;
                    renderAgents();
                }
            } catch (e) {
                console.error('Retry load agent failed:', e);
            }
        }

        let archiveSectionExpanded = false;

        function toggleArchiveSection() {
            archiveSectionExpanded = !archiveSectionExpanded;
            const icon = document.getElementById('archive-toggle-icon');
            const container = document.getElementById('archived-agents-container');

            if (archiveSectionExpanded) {
                icon.classList.add('expanded');
                container.classList.remove('hidden');
            } else {
                icon.classList.remove('expanded');
                container.classList.add('hidden');
            }
        }

        async function archiveAgent(agentId) {
            try {
                await fetch(`${API_URL}/agents/${agentId}/archive`, {
                    method: 'POST',
                    headers: { 'Authorization': `Bearer ${token}` }
                });

                // Update local cache
                if (agents[agentId]) {
                    agents[agentId].archived = true;
                    agents[agentId].archived_at = new Date().toISOString();
                }

                renderAgents();
            } catch (e) {
                console.error('Failed to archive agent:', e);
            }
        }

        async function unarchiveAgent(agentId) {
            try {
                await fetch(`${API_URL}/agents/${agentId}/unarchive`, {
                    method: 'POST',
                    headers: { 'Authorization': `Bearer ${token}` }
                });

                // Update local cache
                if (agents[agentId]) {
                    agents[agentId].archived = false;
                    agents[agentId].archived_at = null;
                }

                renderAgents();
            } catch (e) {
                console.error('Failed to unarchive agent:', e);
            }
        }

        function getTimeAgo(dateStr) {
            const date = new Date(dateStr);
            const now = new Date();
            const seconds = Math.floor((now - date) / 1000);

            if (seconds < 60) return 'Just now';
            if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
            if (seconds < 86400) return `${Math.floor(seconds / 3600)}h ago`;
            return `${Math.floor(seconds / 86400)}d ago`;
        }

        async function spawnAgent(task, agentType = 'worker', model = 'sonnet', offloadDeviceId = null) {
            try {
                // Check if this is a follow-up from another agent
                let parentAgentId = null;
                let context = null;

                let parentProjectId = null;
                let parentModel = model;
                if (window.pendingFollowUpParent) {
                    parentAgentId = window.pendingFollowUpParent.id;
                    parentProjectId = window.pendingFollowUpParent.project_id || null;
                    parentModel = window.pendingFollowUpParent.model || model;
                    // Include parent's output as context for better continuity
                    context = `Parent Agent: ${window.pendingFollowUpParent.call_sign}\nParent Task: ${window.pendingFollowUpParent.task}\n\nParent Output:\n${window.pendingFollowUpParent.output.slice(-6000)}`;
                    window.pendingFollowUpParent = null; // Clear after use
                }

                // Get attached context refs
                const contextRefs = getContextRefsForSend();

                var payload = {
                    task,
                    agent_type: agentType,
                    parent_agent_id: parentAgentId,
                    project_id: parentProjectId,
                    context: context,
                    context_refs: contextRefs,
                    model: parentModel
                };
                if (offloadDeviceId) payload.offload_device_id = offloadDeviceId;

                const response = await fetch(`${API_URL}/agents`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(payload)
                });

                const data = await response.json();
                console.log('Agent spawned:', data);

                // Switch to agents view to see it running
                switchView('agents');

            } catch (e) {
                console.error('Failed to spawn agent:', e);
                cerebroAlert('Failed to spawn agent', { title: 'Error', danger: true });
            }
        }

        let selectedAgentRole = 'worker';
        let selectedWorkflowType = 'standard';
        let currentSpawnMode = 'single';
        let agentTimeout = 3600; // default 1 hour

        // Special Ops state
        let selectedSpecopsRole = 'worker';
        let specopsWorkStyle = 'continuous';
        let specopsCycleInterval = 3600;
        let specopsMissionDuration = 259200; // 3 days

        // Agent select mode (context fusion)
        // NOTE: Using var so inline onclick handlers can access these from window scope
        var agentSelectMode = false;
        var selectedAgentIds = new Set();
        // Persist deleted agent IDs so they don't reappear on reload
        var deletedAgentIds = new Set(JSON.parse(localStorage.getItem('cerebro_deleted_agents') || '[]'));
        let mergeSelectedRole = 'worker';
        let mergeTimeout = 3600;

        function selectAgentTimeout(btn) {
            document.querySelectorAll('#agent-timeout-selector .timeout-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            agentTimeout = parseInt(btn.dataset.timeout);
        }

        // ==================== UNIFIED AGENT PANEL STATE MACHINE ====================
        let agentPanelState = null;   // 'create' | 'running' | 'detail'
        let agentPanelAgentId = null;
        let _panelElapsedTimer = null;
        let _panelElapsedStart = null;
        let _specopsElapsedTimer = null;

        function setAgentPanelState(state, agentId) {
            agentPanelState = state;
            agentPanelAgentId = agentId || null;

            const leftCreate = document.getElementById('panel-left-create');
            const leftDetail = document.getElementById('panel-left-detail');
            const rightEmpty = document.getElementById('panel-right-empty');
            const rightRunning = document.getElementById('panel-right-running');
            const rightOutput = document.getElementById('panel-right-output');
            const footer = document.getElementById('agent-panel-footer');
            const statusBadge = document.getElementById('panel-status-badge');
            const titleEl = document.getElementById('panel-title');

            // Deactivate all modes
            [leftCreate, leftDetail, rightEmpty, rightRunning, rightOutput].forEach(function(el) { el.classList.remove('active'); });

            // Clear elapsed timers
            if (_panelElapsedTimer) { clearInterval(_panelElapsedTimer); _panelElapsedTimer = null; }
            if (_specopsElapsedTimer) { clearInterval(_specopsElapsedTimer); _specopsElapsedTimer = null; }

            if (state === 'create') {
                leftCreate.classList.add('active');
                rightEmpty.classList.add('active');
                footer.style.display = 'flex';
                statusBadge.style.display = 'none';
                var chainNavCreate = document.getElementById('panel-chain-nav');
                if (chainNavCreate) chainNavCreate.style.display = 'none';
                titleEl.textContent = 'Spawn New Agent';
                renderTemplateGallery();
            } else if (state === 'running') {
                leftDetail.classList.add('active');
                rightRunning.classList.add('active');
                footer.style.display = 'none';
                statusBadge.style.display = '';
                statusBadge.textContent = 'RUNNING';
                statusBadge.className = 'agent-status-badge running';
                if (agentId) {
                    var agent = agents[agentId];
                    if (agent) {
                        // SpecOps agents show "OPERATING" in pink
                        if (agent.is_specops && agent.status === 'running') {
                            statusBadge.textContent = 'OPERATING';
                            statusBadge.className = 'agent-status-badge operating';
                        }
                        // Check for cycling status
                        if (agent.status === 'cycling') {
                            statusBadge.textContent = 'CYCLING';
                            statusBadge.className = 'agent-status-badge cycling';
                        }
                        // Toggle normal vs specops running view
                        var normalView = document.getElementById('running-normal-view');
                        var specopsView = document.getElementById('running-specops-view');
                        if (normalView && specopsView) {
                            if (agent.is_specops) {
                                normalView.style.display = 'none';
                                specopsView.style.display = 'block';
                                updateSpecopsRunningPanel(agent);
                            } else {
                                normalView.style.display = 'block';
                                specopsView.style.display = 'none';
                            }
                        }
                        populateLeftDetailPanel(agentId);
                        document.getElementById('panel-running-task').textContent = agent.task.slice(0, 120) + (agent.task.length > 120 ? '...' : '');
                        var typeEmoji = (agent.type || 'worker') === 'researcher' ? '\uD83D\uDD0D' : (agent.type || 'worker') === 'coder' ? '\uD83D\uDCBB' : (agent.type || 'worker') === 'analyst' ? '\uD83D\uDCCA' : '\u26A1';
                        var parentSuffix = '';
                        if (agent.parent_agent_id && agents[agent.parent_agent_id]) {
                            parentSuffix = ' (\u21B3 from ' + (agents[agent.parent_agent_id].call_sign || agent.parent_agent_id) + ')';
                        }
                        titleEl.textContent = typeEmoji + ' Agent ' + (agent.call_sign || agent.id) + parentSuffix;
                        buildPanelChainNav(agent);
                    }
                    // Start elapsed timer
                    var agent = agents[agentId];
                    if (agent && agent.is_specops) {
                        // SpecOps: count from actual cycle start time (started_at)
                        var cycleStart = agent.started_at ? new Date(agent.started_at).getTime() : Date.now();
                        var specopsElapsedEl = document.getElementById('specops-panel-elapsed');
                        if (specopsElapsedEl) {
                            var updateSpecopsElapsed = function() {
                                var secs = Math.max(0, Math.floor((Date.now() - cycleStart) / 1000));
                                var m = Math.floor(secs / 60);
                                var s = secs % 60;
                                specopsElapsedEl.textContent = m + ':' + s.toString().padStart(2, '0');
                            };
                            updateSpecopsElapsed(); // immediate first tick
                            if (_specopsElapsedTimer) clearInterval(_specopsElapsedTimer);
                            _specopsElapsedTimer = setInterval(updateSpecopsElapsed, 1000);
                        }
                    } else {
                        _panelElapsedStart = Date.now();
                        var elapsedEl = document.getElementById('panel-running-elapsed');
                        _panelElapsedTimer = setInterval(function() {
                            var secs = Math.floor((Date.now() - _panelElapsedStart) / 1000);
                            var m = Math.floor(secs / 60);
                            var s = secs % 60;
                            elapsedEl.textContent = m + ':' + s.toString().padStart(2, '0');
                        }, 1000);
                    }
                }
                // Hide left actions when running
                document.getElementById('panel-left-actions').style.display = 'none';
            } else if (state === 'detail') {
                leftDetail.classList.add('active');
                rightOutput.classList.add('active');
                footer.style.display = 'none';
                if (agentId) {
                    var agent = agents[agentId];
                    if (agent) {
                        var isSpecopsRunning = agent.is_specops && agent.status === 'running';
                        var statusText = isSpecopsRunning ? 'OPERATING' : (agent.status || 'completed').toUpperCase();
                        var statusCls = isSpecopsRunning ? 'operating' : agent.status;
                        statusBadge.style.display = '';
                        statusBadge.textContent = statusText;
                        statusBadge.className = 'agent-status-badge ' + statusCls;
                        var typeEmoji = (agent.type || 'worker') === 'researcher' ? '\uD83D\uDD0D' : (agent.type || 'worker') === 'coder' ? '\uD83D\uDCBB' : (agent.type || 'worker') === 'analyst' ? '\uD83D\uDCCA' : '\u26A1';
                        var parentSuffix = '';
                        if (agent.parent_agent_id && agents[agent.parent_agent_id]) {
                            parentSuffix = ' (\u21B3 from ' + (agents[agent.parent_agent_id].call_sign || agent.parent_agent_id) + ')';
                        }
                        titleEl.textContent = typeEmoji + ' Agent ' + (agent.call_sign || agent.id) + parentSuffix;
                        buildPanelChainNav(agent);
                        populateLeftDetailPanel(agentId);
                        populateRightOutputPanel(agentId);

                        // Show/hide left actions based on status
                        var actionsEl = document.getElementById('panel-left-actions');
                        actionsEl.style.display = '';
                        var followupBtn = document.getElementById('panel-followup-btn');
                        var rerunLink = document.getElementById('panel-rerun-link');
                        if (agent.status === 'completed' && !agent.error) {
                            followupBtn.textContent = 'Follow-up Command';
                            rerunLink.style.display = 'block';
                        } else if (agent.status === 'running') {
                            actionsEl.style.display = 'none';
                        } else {
                            followupBtn.textContent = 'Retry Task';
                            rerunLink.style.display = 'none';
                        }
                    }
                }
            }
        }

        function openAgentPanel(mode, agentId) {
            document.body.classList.add('modal-open');
            document.getElementById('agent-panel').classList.add('active');
            document.addEventListener('keydown', _panelEscHandler);

            if (mode === 'create') {
                // Reset form fields
                var taskInput = document.getElementById('agent-task-input');
                if (taskInput) { taskInput.value = ''; }
                var contextInput = document.getElementById('agent-context-input');
                if (contextInput) { contextInput.value = ''; }
                // Reset role selector
                document.querySelectorAll('#panel-role-selector .role-option').forEach(function(el) { el.classList.remove('selected'); });
                var defaultRole = document.querySelector('#panel-role-selector .role-option[data-role="worker"]');
                if (defaultRole) defaultRole.classList.add('selected');
                selectedAgentRole = 'worker';
                // Reset to single mode
                setSpawnMode('single');
                // Reset timeout
                agentTimeout = 3600;
                document.querySelectorAll('#agent-timeout-selector .timeout-btn').forEach(function(btn) {
                    btn.classList.toggle('active', parseInt(btn.dataset.timeout) === 3600);
                });
                // Reset advanced
                var advOpts = document.getElementById('advanced-options');
                if (advOpts) advOpts.classList.add('hidden');
                var advArrow = document.getElementById('advanced-arrow');
                if (advArrow) advArrow.textContent = '\u25B6';

                setAgentPanelState('create');
                setTimeout(function() { var ti = document.getElementById('agent-task-input'); if (ti) ti.focus(); }, 100);
            } else if (mode === 'detail') {
                currentDetailAgentId = agentId;
                _lastStreamedOutputLen = 0;
                // Mark as viewed
                fetch(API_URL + '/agents/' + agentId + '/view', {
                    method: 'POST',
                    headers: { 'Authorization': 'Bearer ' + token }
                }).catch(console.error);

                var agent = agents[agentId];
                if (agent && (agent.status === 'running' || agent.status === 'cycling')) {
                    setAgentPanelState('running', agentId);
                } else {
                    setAgentPanelState('detail', agentId);
                }
            }
        }

        function closeAgentPanel() {
            document.body.classList.remove('modal-open');
            document.getElementById('agent-panel').classList.remove('active');
            var chainNavClose = document.getElementById('panel-chain-nav');
            if (chainNavClose) chainNavClose.style.display = 'none';
            if (_panelElapsedTimer) { clearInterval(_panelElapsedTimer); _panelElapsedTimer = null; }
            if (_specopsElapsedTimer) { clearInterval(_specopsElapsedTimer); _specopsElapsedTimer = null; }
            stopSpecopsCountdown();
            agentPanelState = null;
            agentPanelAgentId = null;
            currentDetailAgentId = null;
            document.removeEventListener('keydown', _panelEscHandler);
        }

        function _panelEscHandler(e) {
            if (e.key === 'Escape' && agentPanelState) closeAgentPanel();
        }

        function populateLeftDetailPanel(agentId) {
            var agent = agents[agentId];
            if (!agent) return;
            var agentType = agent.type || 'worker';
            var duration = agent.completed_at && agent.started_at ?
                formatDuration(new Date(agent.completed_at) - new Date(agent.started_at)) :
                (agent.started_at ? 'Running...' : 'Queued');
            var toolsHtml = agent.tools_used && agent.tools_used.length > 0 ?
                agent.tools_used.map(function(t) { return '<span class="agent-tool-badge">' + t + '</span>'; }).join('') :
                '<span style="color: var(--text-muted);">No tools used yet</span>';

            // Build project dropdown
            var projectOptions = Object.keys(agentProjects).map(function(pid) {
                var pName = agentProjects[pid].name || pid;
                var selected = agent.project_id === pid ? 'selected' : '';
                return '<option value="' + escapeHtml(pid) + '" ' + selected + '>' + escapeHtml(pName) + '</option>';
            }).join('');

            var infoHtml = '<div class="agent-info-card">'
                + '<div class="agent-info-row">'
                + '<div class="agent-info-item"><span class="label">Type:</span><span class="value">' + agentType + '</span></div>'
                + '<div class="agent-info-item"><span class="label">Duration:</span><span class="value">' + duration + '</span></div>'
                + '<div class="agent-info-item"><span class="label">Model:</span><span class="value">' + ((agent.model || 'sonnet').charAt(0).toUpperCase() + (agent.model || 'sonnet').slice(1)) + '</span></div>'
                + '<div class="agent-info-item"><span class="label">Created:</span><span class="value">' + new Date(agent.created_at).toLocaleString() + '</span></div>'
                + '<div class="agent-info-item"><span class="label">Project:</span>'
                + '<select class="agent-project-select" onchange="assignAgentProject(\'' + agent.id + '\', this.value)">'
                + '<option value=""' + (!agent.project_id ? ' selected' : '') + '>None</option>'
                + projectOptions
                + '</select></div>'
                + '</div>'
                + '<div class="agent-task-box" onclick="this.classList.toggle(\'expanded\');var t=this.nextElementSibling;if(t&&t.classList.contains(\'agent-task-toggle\'))t.textContent=this.classList.contains(\'expanded\')?\'Show less\':\'Show full task\'">'
                + escapeHtml(agent.task)
                + '</div>'
                + (agent.task.length > 150 ? '<div class="agent-task-toggle" onclick="var box=this.previousElementSibling;box.classList.toggle(\'expanded\');this.textContent=box.classList.contains(\'expanded\')?\'Show less\':\'Show full task\'">Show full task</div>' : '')
                + '</div>'
                + '<div class="agent-section">'
                + '<div class="agent-section-title">Tools Used (' + (agent.tools_used ? agent.tools_used.length : 0) + ')</div>'
                + '<div class="agent-tools-list">' + toolsHtml + '</div>'
                + '</div>';

            // Add specops controls if applicable
            if (agent.is_specops || (agent.type && agent.type.startsWith('specops_'))) {
                var autoContinueOn = agent.auto_continue !== false;
                var specopsHtml = '<div class="specops-controls">'
                    + '<label style="font-size:0.75rem;color:var(--specops-pink-light);font-weight:600;">Work Style:</label>'
                    + '<select onchange="updateSpecopsField(\'' + agent.id + '\',\'work_style\',this.value)">'
                    + '<option value="continuous"' + (agent.work_style === 'continuous' ? ' selected' : '') + '>Continuous</option>'
                    + '<option value="cycle"' + (agent.work_style === 'cycle' ? ' selected' : '') + '>Cycle-Based</option>'
                    + '<option value="hybrid"' + (agent.work_style === 'hybrid' ? ' selected' : '') + '>Agent Decides</option>'
                    + '</select>'
                    + '<label style="font-size:0.75rem;color:var(--specops-pink-light);font-weight:600;">Cycle:</label>'
                    + '<select onchange="updateSpecopsField(\'' + agent.id + '\',\'cycle_interval\',parseInt(this.value))">'
                    + '<option value="900"' + (agent.cycle_interval === 900 ? ' selected' : '') + '>15m</option>'
                    + '<option value="1800"' + (agent.cycle_interval === 1800 ? ' selected' : '') + '>30m</option>'
                    + '<option value="3600"' + (agent.cycle_interval === 3600 ? ' selected' : '') + '>1hr</option>'
                    + '<option value="14400"' + (agent.cycle_interval === 14400 ? ' selected' : '') + '>4hr</option>'
                    + '<option value="43200"' + (agent.cycle_interval === 43200 ? ' selected' : '') + '>12hr</option>'
                    + '</select>'
                    + '<button class="toggle-btn ' + (autoContinueOn ? 'on' : 'off') + '" onclick="toggleSpecopsAutoContinue(\'' + agent.id + '\')">'
                    + 'Auto-Continue: ' + (autoContinueOn ? 'ON' : 'OFF')
                    + '</button>'
                    + '</div>';

                // Mission journal
                var journalEntries = agent.mission_journal || [];
                if (journalEntries.length > 0) {
                    specopsHtml += '<div class="specops-journal"><div class="agent-section-title" style="color:var(--specops-pink-light);">Mission Journal (' + journalEntries.length + ' cycles)</div>';
                    journalEntries.slice().reverse().forEach(function(entry) {
                        var assessmentHtml = entry.cycle_assessment ? '<div><strong>Assessment:</strong> ' + escapeHtml(entry.cycle_assessment) + '</div>' : '';
                        var contextHtml = entry.context_carry ? '<div><strong>Context:</strong> ' + escapeHtml(entry.context_carry) + '</div>' : '';
                        specopsHtml += '<div class="specops-journal-entry">'
                            + '<div class="specops-journal-entry-header"><span>Cycle #' + (entry.cycle || '?') + '</span><span>' + (entry.timestamp ? new Date(entry.timestamp).toLocaleString() : '') + '</span></div>'
                            + '<div class="specops-journal-entry-body">'
                            + '<div><strong>Progress:</strong> ' + escapeHtml(entry.mission_progress || entry.progress || 'N/A') + '</div>'
                            + assessmentHtml
                            + '<div><strong>Completed:</strong> ' + escapeHtml(entry.completed || 'N/A') + '</div>'
                            + '<div><strong>Next Directive:</strong> ' + escapeHtml(entry.next_directive || entry.next || 'N/A') + '</div>'
                            + contextHtml
                            + '<div><strong>Blockers:</strong> ' + escapeHtml(entry.blockers || 'None') + '</div>'
                            + '</div></div>';
                    });
                    specopsHtml += '</div>';
                }

                infoHtml += specopsHtml;
            }

            document.getElementById('panel-detail-info').innerHTML = infoHtml;
        }

        function populateRightOutputPanel(agentId) {
            _panelThreadStack = [];
            var agent = agents[agentId];
            if (!agent) return;

            // SpecOps agents get their own tabbed completed panel
            if (agent.is_specops || (agent.type && agent.type.startsWith('specops_'))) {
                populateSpecopsCompletedPanel(agentId);
                return;
            }

            var outputText = agent.output || 'No output captured yet.';
            var renderedOutput = safeAgentOutput(outputText);

            // Extract recommendations
            var recommendations = extractRecommendations(outputText);
            var recommendationsHtml = '';
            if (recommendations.length > 0) {
                var recsItems = recommendations.map(function(rec, i) {
                    return '<div class="recommendation-item">'
                        + '<div class="recommendation-text">' + escapeHtml(rec) + '</div>'
                        + '<button class="recommendation-btn" onclick="executeRecommendation(' + i + ')">Execute</button>'
                        + '</div>';
                }).join('');
                recommendationsHtml = '<div class="recommendations-section">'
                    + '<div class="recommendations-title">Recommended Actions</div>'
                    + recsItems + '</div>';
            }

            // Sub-agents
            var subAgentsHtml = '';
            var childAgents = Object.values(agents).filter(function(a) {
                return a.parent_agent_id === agentId && isCurrentRunSubAgent(a, agent);
            });
            if (childAgents.length > 0) {
                childAgents.sort(function(a, b) { return new Date(a.created_at) - new Date(b.created_at); });
                var subAgentCards = childAgents.map(function(child) {
                    var childStatusIcon = child.status === 'running' ? '...' : child.status === 'completed' ? 'OK' : child.status === 'failed' ? 'ERR' : '...';
                    var childName = child.call_sign || child.id;
                    return '<div class="sub-agent-nav-card ' + child.status + '" onclick="openAgentPanel(\'detail\',\'' + child.id + '\')">'
                        + '<div class="sub-agent-nav-name">' + escapeHtml(childName) + '</div>'
                        + '<div class="sub-agent-nav-task">' + escapeHtml(child.task.slice(0, 80)) + (child.task.length > 80 ? '...' : '') + '</div>'
                        + '<span class="sub-agent-nav-status ' + child.status + '">' + childStatusIcon + ' ' + child.status.toUpperCase() + '</span>'
                        + '</div>';
                }).join('');
                subAgentsHtml = '<div class="agent-section">'
                    + '<div class="agent-section-title">Sub-Agents (' + childAgents.length + ')</div>'
                    + '<div class="sub-agents-nav">' + subAgentCards + '</div></div>';
            }

            // Error section
            var errorHtml = agent.error ? '<div class="agent-section">'
                + '<div class="agent-section-title" style="color: var(--red);">Error</div>'
                + '<div style="background: rgba(239,68,68,0.1); border: 1px solid var(--red); border-radius: 12px; padding: 14px; color: var(--red);">'
                + escapeHtml(agent.error) + '</div></div>' : '';

            // Threads
            var threadsHtml = '';
            var threadTree = buildThreadTree(agent.conversation || []);
            if (threadTree.length > 0) {
                threadsHtml = '<div class="agent-section" style="margin-top: 24px;">'
                    + '<div class="agent-section-title">Conversations (' + threadTree.length + ')</div>'
                    + '<div id="panel-threads-list">' + renderPanelThreadCards(threadTree) + '</div></div>';
            }

            document.getElementById('panel-output-area').innerHTML =
                recommendationsHtml + subAgentsHtml + errorHtml
                + '<div class="agent-section"><div class="agent-section-title">Output</div>'
                + '<div class="agent-output-rendered">' + renderedOutput + '</div></div>'
                + threadsHtml;
        }

        function panelSpawnFollowUp() {
            if (!agentPanelAgentId) return;
            var agent = agents[agentPanelAgentId];
            if (!agent) return;
            var instructions = (document.getElementById('panel-followup-instructions') || {}).value;
            instructions = instructions ? instructions.trim() : '';
            if (!instructions) {
                showToast('Enter a command for the follow-up agent', 'warning');
                var el = document.getElementById('panel-followup-instructions');
                if (el) el.focus();
                return;
            }
            // Link to parent (spawnAgent reads this and passes parent_agent_id)
            window.pendingFollowUpParent = agent;
            closeAgentPanel();
            showToast('Spawning follow-up agent linked to ' + (agent.call_sign || agent.id) + '...', 'info');
            spawnAgent(instructions, agent.type || 'worker', agent.model || 'sonnet');
        }

        function panelRerunAgent() {
            if (!agentPanelAgentId) return;
            var agent = agents[agentPanelAgentId];
            if (!agent) return;
            spawnAgentEnhanced(agent.task, agent.type || 'worker', null, null, 'normal', null, 3600, agent.model || 'sonnet');
            closeAgentPanel();
        }

        var _panelAskCounter = 0;

        function panelSubmitAsk() {
            if (!agentPanelAgentId) return;
            var input = document.getElementById('panel-ask-input');
            var question = input.value.trim();
            if (!question) return;
            input.value = '';

            // Generate unique thinking ID
            var thinkingId = 'panel-thinking-' + (++_panelAskCounter) + '-' + Date.now();

            // Append thinking indicator to output area using safe DOM methods
            var outputArea = document.getElementById('panel-output-area');
            if (outputArea) {
                var thinkDiv = document.createElement('div');
                thinkDiv.className = 'panel-thinking-indicator';
                thinkDiv.id = thinkingId;
                thinkDiv.setAttribute('data-agent-id', agentPanelAgentId);

                var dotsDiv = document.createElement('div');
                dotsDiv.className = 'thinking-dots';
                dotsDiv.appendChild(document.createElement('span'));
                dotsDiv.appendChild(document.createElement('span'));
                dotsDiv.appendChild(document.createElement('span'));
                thinkDiv.appendChild(dotsDiv);

                var textDiv = document.createElement('div');
                textDiv.className = 'thinking-text';
                var qLine = document.createElement('div');
                qLine.className = 'thinking-question';
                qLine.textContent = question;
                var subLine = document.createElement('div');
                subLine.className = 'thinking-subtext';
                subLine.textContent = 'Thinking...';
                textDiv.appendChild(qLine);
                textDiv.appendChild(subLine);
                thinkDiv.appendChild(textDiv);

                outputArea.appendChild(thinkDiv);
                thinkDiv.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }

            // Change badge to THINKING
            var badge = document.getElementById('panel-status-badge');
            if (badge) {
                badge.textContent = 'THINKING';
                badge.className = 'agent-status-badge thinking';
            }

            // Send request (background: true so Socket.IO delivers answer)
            fetch(API_URL + '/agents/' + agentPanelAgentId + '/ask', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': 'Bearer ' + token },
                body: JSON.stringify({ question: question, background: true })
            }).then(function(resp) { return resp.json(); }).then(function(data) {
                // Store question_id on thinking div so handleAskResponseReady can find it
                var thinkEl = document.getElementById(thinkingId);
                if (thinkEl && data.question_id) {
                    thinkEl.setAttribute('data-question-id', data.question_id);
                }
            }).catch(function(err) {
                console.error(err);
                // Show error in thinking indicator
                var thinkEl = document.getElementById(thinkingId);
                if (thinkEl) {
                    thinkEl.querySelector('.thinking-dots').style.display = 'none';
                    var sub = thinkEl.querySelector('.thinking-subtext');
                    if (sub) {
                        sub.textContent = 'Error: ' + (err.message || 'Request failed');
                        sub.style.color = 'var(--red)';
                    }
                }
                // Restore badge
                if (badge) {
                    badge.textContent = 'COMPLETED';
                    badge.className = 'agent-status-badge completed';
                }
            });
        }

        // ==================== PANEL THREAD NAVIGATION ====================
        var _panelThreadStack = [];

        function panelNavigateToThread(threadId) {
            _panelThreadStack.push({ type: 'thread', threadId: threadId });
            _panelTransitionTo(function() { panelRenderThreadView(threadId); }, 'forward');
        }

        function panelNavigateBack() {
            if (_panelThreadStack.length <= 1) {
                // Back to output view
                _panelThreadStack = [];
                _panelTransitionTo(function() {
                    populateRightOutputPanel(agentPanelAgentId);
                    // Restore main ask area, hide thread reply area
                    var mainAsk = document.getElementById('panel-ask-area-main');
                    var threadReply = document.getElementById('panel-thread-reply-area');
                    if (mainAsk) mainAsk.style.display = '';
                    if (threadReply) threadReply.style.display = 'none';
                }, 'back');
                return;
            }
            _panelThreadStack.pop();
            var prev = _panelThreadStack[_panelThreadStack.length - 1];
            if (prev.type === 'thread') {
                _panelTransitionTo(function() { panelRenderThreadView(prev.threadId); }, 'back');
            } else {
                _panelThreadStack = [];
                _panelTransitionTo(function() {
                    populateRightOutputPanel(agentPanelAgentId);
                    var mainAsk = document.getElementById('panel-ask-area-main');
                    var threadReply = document.getElementById('panel-thread-reply-area');
                    if (mainAsk) mainAsk.style.display = '';
                    if (threadReply) threadReply.style.display = 'none';
                }, 'back');
            }
        }

        function _panelTransitionTo(renderFn, direction) {
            var outputArea = document.getElementById('panel-output-area');
            if (!outputArea) { renderFn(); return; }

            // Fade out
            outputArea.classList.add('panel-thread-transitioning');
            setTimeout(function() {
                renderFn();
                outputArea.classList.remove('panel-thread-transitioning');
                // Apply fade-in animation
                var animName = direction === 'back' ? 'panelContentFadeBack' : 'panelContentFadeIn';
                outputArea.style.animation = animName + ' 0.25s ease forwards';
                setTimeout(function() {
                    outputArea.style.animation = '';
                }, 260);
            }, 200);
        }

        function panelRenderThreadView(threadId) {
            var agent = agents[agentPanelAgentId];
            if (!agent) return;

            var tree = buildThreadTree(agent.conversation || []);
            var thread = findThreadById(tree, threadId);
            if (!thread) return;

            // Build answer HTML
            var answerContent = thread.answer ? safeAgentOutput(thread.answer) : escapeHtml('Waiting for response...');

            // Build child threads HTML
            var childThreadsHtml = '';
            if (thread.children.length > 0) {
                childThreadsHtml = '<div class="agent-section" style="margin-top: 24px;">'
                    + '<div class="agent-section-title">Replies (' + thread.children.length + ')</div>'
                    + renderPanelThreadCards(thread.children)
                    + '</div>';
            }

            var outputArea = document.getElementById('panel-output-area');
            outputArea.textContent = '';

            // Back button
            var backBtn = document.createElement('div');
            backBtn.style.cssText = 'cursor:pointer;font-size:0.85rem;color:var(--accent);margin-bottom:12px;display:inline-flex;align-items:center;gap:4px;';
            backBtn.textContent = '\u2190 Back';
            backBtn.onclick = panelNavigateBack;
            outputArea.appendChild(backBtn);

            // Thread exchange
            var exchangeDiv = document.createElement('div');
            exchangeDiv.className = 'thread-exchange';

            var userBubble = document.createElement('div');
            userBubble.className = 'thread-bubble user';
            var userLabel = document.createElement('div');
            userLabel.className = 'chat-label';
            userLabel.textContent = 'You';
            var userContentDiv = document.createElement('div');
            userContentDiv.className = 'chat-content';
            userContentDiv.textContent = thread.question;
            userBubble.appendChild(userLabel);
            userBubble.appendChild(userContentDiv);

            var assistantBubble = document.createElement('div');
            assistantBubble.className = 'thread-bubble assistant';
            var assistantLabel = document.createElement('div');
            assistantLabel.className = 'chat-label';
            assistantLabel.textContent = 'Agent';
            var assistantContentDiv = document.createElement('div');
            assistantContentDiv.className = 'chat-content';
            // Use innerHTML for markdown-rendered content (same trusted-backend pattern as rest of codebase)
            assistantContentDiv.innerHTML = answerContent;
            assistantBubble.appendChild(assistantLabel);
            assistantBubble.appendChild(assistantContentDiv);

            exchangeDiv.appendChild(userBubble);
            exchangeDiv.appendChild(assistantBubble);
            outputArea.appendChild(exchangeDiv);

            // Append child threads
            if (childThreadsHtml) {
                var childDiv = document.createElement('div');
                childDiv.innerHTML = childThreadsHtml;
                while (childDiv.firstChild) outputArea.appendChild(childDiv.firstChild);
            }

            // Switch bottom area: hide main ask, show thread reply
            var mainAsk = document.getElementById('panel-ask-area-main');
            var threadReply = document.getElementById('panel-thread-reply-area');
            if (mainAsk) mainAsk.style.display = 'none';
            if (threadReply) {
                threadReply.style.display = '';
                var replyInput = document.getElementById('panel-thread-reply-input');
                if (replyInput) {
                    replyInput.setAttribute('data-parent-thread-id', threadId);
                    setTimeout(function() { replyInput.focus(); }, 100);
                }
            }
        }

        function renderPanelThreadCards(threads) {
            if (!threads || threads.length === 0) return '';
            return threads.map(function(t) {
                var qPreview = escapeHtml((t.question || '').slice(0, 120)) + (t.question && t.question.length > 120 ? '...' : '');
                var aPreview = escapeHtml((t.answer || '').slice(0, 150)) + (t.answer && t.answer.length > 150 ? '...' : '');
                var timeStr = t.timestamp ? formatTimeAgo(new Date(t.timestamp)) : '';
                var replyCount = t.children.length;
                return '<div class="thread-card" onclick="panelNavigateToThread(\'' + t.thread_id + '\')">'
                    + '<div class="thread-question">' + qPreview + '</div>'
                    + '<div class="thread-preview">' + aPreview + '</div>'
                    + '<div class="thread-meta">'
                    + '<span>' + timeStr + '</span>'
                    + (replyCount > 0 ? '<span class="reply-count">' + replyCount + ' repl' + (replyCount === 1 ? 'y' : 'ies') + '</span>' : '')
                    + '</div></div>';
            }).join('');
        }

        function panelSubmitThreadReply() {
            if (!agentPanelAgentId) return;
            var input = document.getElementById('panel-thread-reply-input');
            if (!input) return;
            var question = input.value.trim();
            if (!question) return;
            var parentThreadId = input.getAttribute('data-parent-thread-id');
            if (!parentThreadId) return;
            input.value = '';

            // Synchronous call (no background flag)
            fetch(API_URL + '/agents/' + agentPanelAgentId + '/ask', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': 'Bearer ' + token },
                body: JSON.stringify({ question: question, parent_thread_id: parentThreadId })
            }).then(function(resp) { return resp.json(); }).then(function(data) {
                if (data.answer || data.thread_id) {
                    // Update conversation data
                    var agent = agents[agentPanelAgentId];
                    if (agent) {
                        if (!agent.conversation) agent.conversation = [];
                        agent.conversation.push({
                            role: 'user',
                            content: question,
                            thread_id: data.thread_id || (parentThreadId + '-reply-' + Date.now()),
                            parent_thread_id: parentThreadId,
                            timestamp: new Date().toISOString()
                        });
                        agent.conversation.push({
                            role: 'assistant',
                            content: data.answer || '',
                            thread_id: data.thread_id || (parentThreadId + '-reply-' + Date.now()),
                            parent_thread_id: parentThreadId,
                            timestamp: new Date().toISOString()
                        });
                    }
                    // Re-render current thread view
                    panelRenderThreadView(parentThreadId);
                }
            }).catch(function(err) {
                console.error('Thread reply error:', err);
            });
        }

        // ==================== PROMPT TEMPLATES ====================
        var DEFAULT_TEMPLATES = [
            { id: 'default-code-review', name: 'Code Review', desc: 'Thorough code review with suggestions', role: 'coder', task: 'Review the following code for bugs, security issues, performance problems, and code quality. Provide specific suggestions for improvement with code examples.', context: '', outputFormat: 'detailed' },
            { id: 'default-research', name: 'Research Task', desc: 'Deep research on any topic', role: 'researcher', task: 'Research the following topic thoroughly. Provide a comprehensive summary with key findings, sources, and actionable recommendations.', context: '', outputFormat: 'detailed' },
            { id: 'default-data-analysis', name: 'Data Analysis', desc: 'Analyze data and extract insights', role: 'analyst', task: 'Analyze the provided data. Identify key patterns, trends, outliers, and actionable insights. Present findings with clear visualizations described in text.', context: '', outputFormat: 'list' }
        ];

        function getPromptTemplates() {
            try {
                var stored = localStorage.getItem('cerebro_agent_templates');
                if (stored) return JSON.parse(stored);
            } catch (e) {}
            // Seed defaults on first load
            savePromptTemplates(DEFAULT_TEMPLATES);
            return DEFAULT_TEMPLATES;
        }

        function savePromptTemplates(templates) {
            localStorage.setItem('cerebro_agent_templates', JSON.stringify(templates));
            syncTemplatesToBackend(templates);
        }

        var _activeTemplateMenu = null;

        function renderTemplateGallery() {
            var templates = getPromptTemplates();
            var listEl = document.getElementById('template-list');
            if (!listEl) return;

            if (templates.length === 0) {
                listEl.textContent = '';
                var empty = document.createElement('div');
                empty.className = 'template-empty';
                empty.textContent = 'No templates yet. Click "+ Create Template" to get started!';
                listEl.appendChild(empty);
                return;
            }

            listEl.textContent = '';
            templates.forEach(function(t) {
                var card = document.createElement('div');
                card.className = 'template-card';
                card.onclick = function() { applyTemplate(t.id); };
                card.oncontextmenu = function(e) { showTemplateContextMenu(e, t.id, card); };

                var nameDiv = document.createElement('div');
                nameDiv.className = 'template-name';
                nameDiv.textContent = t.name;

                var descDiv = document.createElement('div');
                descDiv.className = 'template-desc';
                descDiv.textContent = t.desc;

                card.appendChild(nameDiv);
                card.appendChild(descDiv);
                listEl.appendChild(card);
            });
        }

        function applyTemplate(id) {
            var templates = getPromptTemplates();
            var tmpl = templates.find(function(t) { return t.id === id; });
            if (!tmpl) return;

            var taskInput = document.getElementById('agent-task-input');
            if (taskInput) taskInput.value = tmpl.task || '';

            var contextInput = document.getElementById('agent-context-input');
            if (contextInput) contextInput.value = tmpl.context || '';

            var outputFormat = document.getElementById('agent-output-format');
            if (outputFormat) outputFormat.value = tmpl.outputFormat || '';

            // Select role
            if (tmpl.role) {
                document.querySelectorAll('#panel-role-selector .role-option').forEach(function(el) {
                    el.classList.toggle('selected', el.dataset.role === tmpl.role);
                });
                selectedAgentRole = tmpl.role;
            }

            // Show advanced if context or output format set
            if (tmpl.context || tmpl.outputFormat) {
                var advOpts = document.getElementById('advanced-options');
                if (advOpts) advOpts.classList.remove('hidden');
                var advArrow = document.getElementById('advanced-arrow');
                if (advArrow) advArrow.textContent = '\u25BC';
            }
        }

        function showTemplateContextMenu(event, templateId, card) {
            event.preventDefault();
            event.stopPropagation();
            hideTemplateContextMenu();

            var menu = document.createElement('div');
            menu.className = 'template-context-menu';

            var items = [
                { icon: '\u270F\uFE0F', label: 'Edit', action: function() { hideTemplateContextMenu(); openTemplateEditor(templateId); } },
                { icon: '\uD83D\uDDD1\uFE0F', label: 'Delete', action: function() { hideTemplateContextMenu(); deleteTemplate(templateId); } }
            ];

            items.forEach(function(item) {
                var row = document.createElement('div');
                row.className = 'template-context-menu-item';
                var iconSpan = document.createElement('span');
                iconSpan.className = 'popup-icon';
                iconSpan.textContent = item.icon;
                var labelSpan = document.createElement('span');
                labelSpan.textContent = item.label;
                row.appendChild(iconSpan);
                row.appendChild(labelSpan);
                row.onclick = function(e) { e.stopPropagation(); item.action(); };
                menu.appendChild(row);
            });

            card.style.position = 'relative';
            menu.style.position = 'absolute';
            menu.style.top = '8px';
            menu.style.right = '8px';
            card.appendChild(menu);
            _activeTemplateMenu = menu;

            var dismissHandler = function(e) {
                if (!menu.contains(e.target)) {
                    hideTemplateContextMenu();
                    document.removeEventListener('click', dismissHandler);
                }
            };
            var escHandler = function(e) {
                if (e.key === 'Escape') {
                    hideTemplateContextMenu();
                    document.removeEventListener('keydown', escHandler);
                }
            };
            setTimeout(function() {
                document.addEventListener('click', dismissHandler);
                document.addEventListener('keydown', escHandler);
            }, 0);
        }

        function hideTemplateContextMenu() {
            if (_activeTemplateMenu) {
                _activeTemplateMenu.remove();
                _activeTemplateMenu = null;
            }
        }

        function openTemplateEditor(templateId) {
            var listEl = document.getElementById('template-list');
            if (!listEl) return;

            var tmpl = null;
            if (templateId) {
                var templates = getPromptTemplates();
                tmpl = templates.find(function(t) { return t.id === templateId; });
            }

            var isEdit = !!tmpl;

            // Build form with safe DOM methods
            listEl.textContent = '';

            var editor = document.createElement('div');
            editor.className = 'template-editor';

            var titleDiv = document.createElement('div');
            titleDiv.className = 'editor-title';
            titleDiv.textContent = isEdit ? 'Edit Template' : 'Create Template';
            editor.appendChild(titleDiv);

            // Name
            var nameLabel = document.createElement('label');
            nameLabel.textContent = 'Template Name';
            editor.appendChild(nameLabel);
            var nameInput = document.createElement('input');
            nameInput.type = 'text';
            nameInput.id = 'tmpl-edit-name';
            nameInput.placeholder = 'My Template';
            nameInput.value = tmpl ? tmpl.name : '';
            editor.appendChild(nameInput);

            // Role
            var roleLabel = document.createElement('label');
            roleLabel.textContent = 'Role';
            editor.appendChild(roleLabel);
            var roleSelect = document.createElement('select');
            roleSelect.id = 'tmpl-edit-role';
            [['worker','Worker'],['researcher','Researcher'],['coder','Coder'],['analyst','Analyst']].forEach(function(r) {
                var opt = document.createElement('option');
                opt.value = r[0];
                opt.textContent = r[1];
                if (tmpl && tmpl.role === r[0]) opt.selected = true;
                roleSelect.appendChild(opt);
            });
            editor.appendChild(roleSelect);

            // Task
            var taskLabel = document.createElement('label');
            taskLabel.textContent = 'Task Description';
            editor.appendChild(taskLabel);
            var taskArea = document.createElement('textarea');
            taskArea.id = 'tmpl-edit-task';
            taskArea.rows = 3;
            taskArea.placeholder = 'Describe what this template does...';
            taskArea.value = tmpl ? (tmpl.task || '') : '';
            editor.appendChild(taskArea);

            // Context
            var ctxLabel = document.createElement('label');
            ctxLabel.textContent = 'Context';
            editor.appendChild(ctxLabel);
            var ctxArea = document.createElement('textarea');
            ctxArea.id = 'tmpl-edit-context';
            ctxArea.rows = 2;
            ctxArea.placeholder = 'Optional context...';
            ctxArea.value = tmpl ? (tmpl.context || '') : '';
            editor.appendChild(ctxArea);

            // Output format
            var outLabel = document.createElement('label');
            outLabel.textContent = 'Output Format';
            editor.appendChild(outLabel);
            var outSelect = document.createElement('select');
            outSelect.id = 'tmpl-edit-output';
            [['','Any format'],['summary','Brief Summary'],['detailed','Detailed Report'],['code','Code Only'],['list','Bullet Points'],['json','JSON Data']].forEach(function(o) {
                var opt = document.createElement('option');
                opt.value = o[0];
                opt.textContent = o[1];
                if (tmpl && tmpl.outputFormat === o[0]) opt.selected = true;
                outSelect.appendChild(opt);
            });
            editor.appendChild(outSelect);

            // Hidden ID
            var hiddenId = document.createElement('input');
            hiddenId.type = 'hidden';
            hiddenId.id = 'tmpl-edit-id';
            hiddenId.value = tmpl ? tmpl.id : '';
            editor.appendChild(hiddenId);

            // Actions
            var actions = document.createElement('div');
            actions.className = 'template-editor-actions';
            var cancelBtn = document.createElement('button');
            cancelBtn.className = 'editor-cancel';
            cancelBtn.textContent = 'Cancel';
            cancelBtn.onclick = function() { closeTemplateEditor(); };
            var saveBtn = document.createElement('button');
            saveBtn.className = 'editor-save';
            saveBtn.textContent = 'Save';
            saveBtn.onclick = function() { saveTemplateFromEditor(); };
            actions.appendChild(cancelBtn);
            actions.appendChild(saveBtn);
            editor.appendChild(actions);

            listEl.appendChild(editor);
            nameInput.focus();
        }

        function closeTemplateEditor() {
            renderTemplateGallery();
        }

        function saveTemplateFromEditor() {
            var name = (document.getElementById('tmpl-edit-name') || {}).value;
            var task = (document.getElementById('tmpl-edit-task') || {}).value;
            name = name ? name.trim() : '';
            task = task ? task.trim() : '';

            if (!name) { cerebroAlert('Template name is required.', { title: 'Missing Field' }); return; }
            if (!task) { cerebroAlert('Task description is required.', { title: 'Missing Field' }); return; }

            var role = (document.getElementById('tmpl-edit-role') || {}).value || 'worker';
            var context = ((document.getElementById('tmpl-edit-context') || {}).value || '').trim();
            var outputFormat = (document.getElementById('tmpl-edit-output') || {}).value || '';
            var editId = (document.getElementById('tmpl-edit-id') || {}).value;

            var templates = getPromptTemplates();

            if (editId) {
                for (var i = 0; i < templates.length; i++) {
                    if (templates[i].id === editId) {
                        templates[i].name = name;
                        templates[i].desc = task.slice(0, 60) + (task.length > 60 ? '...' : '');
                        templates[i].role = role;
                        templates[i].task = task;
                        templates[i].context = context;
                        templates[i].outputFormat = outputFormat;
                        break;
                    }
                }
            } else {
                templates.push({
                    id: 'custom-' + Date.now(),
                    name: name,
                    desc: task.slice(0, 60) + (task.length > 60 ? '...' : ''),
                    role: role,
                    task: task,
                    context: context,
                    outputFormat: outputFormat
                });
            }

            savePromptTemplates(templates);
            closeTemplateEditor();
        }

        function deleteTemplate(id) {
            var templates = getPromptTemplates();
            templates = templates.filter(function(t) { return t.id !== id; });
            savePromptTemplates(templates);
            renderTemplateGallery();
        }

        function syncTemplatesToBackend(templates) {
            fetch(API_URL + '/agent-templates', {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json', 'Authorization': 'Bearer ' + token },
                body: JSON.stringify({ templates: templates })
            }).catch(function() { /* silent sync */ });
        }

        function loadTemplatesFromBackend() {
            fetch(API_URL + '/agent-templates', {
                headers: { 'Authorization': 'Bearer ' + token }
            }).then(function(resp) {
                if (resp.ok) return resp.json();
                return null;
            }).then(function(data) {
                if (data && data.templates && data.templates.length > 0) {
                    var local = getPromptTemplates();
                    var merged = data.templates.slice();
                    local.filter(function(t) {
                        return t.id.startsWith('custom-') && !data.templates.find(function(bt) { return bt.id === t.id; });
                    }).forEach(function(t) { merged.push(t); });
                    localStorage.setItem('cerebro_agent_templates', JSON.stringify(merged));
                }
            }).catch(function() { /* silent */ });
        }

        // Compatibility alias - old code calls openAgentModal() with a pre-filled task
        function openAgentModal(prefill) {
            openAgentPanel('create');
            if (prefill) {
                setTimeout(function() {
                    var taskInput = document.getElementById('agent-task-input');
                    if (taskInput) taskInput.value = prefill;
                }, 50);
            }
        }

        // Legacy redirect
        function showSpawnAgentDialog() {
            openAgentPanel('create');
        }

        function closeAgentModal() {
            closeAgentPanel();
        }

        function selectRole(element) {
            document.querySelectorAll('.role-option').forEach(el => el.classList.remove('selected'));
            element.classList.add('selected');
            selectedAgentRole = element.dataset.role;
        }

        // ==================== AGENT SELECT MODE (Context Fusion) ====================

        function toggleAgentSelectMode() {
            agentSelectMode = !agentSelectMode;
            const btn = document.getElementById('agent-select-toggle-btn');
            const container = document.getElementById('agents-container');
            const archivedContainer = document.getElementById('archived-agents-container');

            if (agentSelectMode) {
                btn.textContent = 'Cancel';
                btn.classList.remove('btn-secondary');
                btn.classList.add('btn-danger');
                container.classList.add('select-mode');
                if (archivedContainer) archivedContainer.classList.add('select-mode');
            } else {
                btn.textContent = 'Select';
                btn.classList.remove('btn-danger');
                btn.classList.add('btn-secondary');
                container.classList.remove('select-mode');
                if (archivedContainer) archivedContainer.classList.remove('select-mode');
                clearAgentSelection();
            }
        }

        function handleAgentCardClick(agentId, event) {
            if (agentSelectMode) {
                toggleAgentSelection(agentId, event);
            } else {
                showAgentDetail(agentId);
            }
        }

        function toggleAgentSelection(agentId, event) {
            if (event) event.stopPropagation();
            if (!agentSelectMode) return;

            if (selectedAgentIds.has(agentId)) {
                selectedAgentIds.delete(agentId);
            } else {
                selectedAgentIds.add(agentId);
            }
            updateAgentSelectionUI();
        }

        function updateAgentSelectionUI() {
            // Update card visual states
            document.querySelectorAll('.agent-card[data-agent-id], .agent-card-compact[data-agent-id]').forEach(card => {
                const id = card.dataset.agentId;
                const checkbox = card.querySelector('.agent-select-checkbox');
                if (selectedAgentIds.has(id)) {
                    card.classList.add('selected');
                    if (checkbox) checkbox.classList.add('checked');
                } else {
                    card.classList.remove('selected');
                    if (checkbox) checkbox.classList.remove('checked');
                }
            });

            // Show/hide selection action bar
            const bar = document.getElementById('selection-action-bar');
            const count = selectedAgentIds.size;
            if (count > 0) {
                bar.style.display = 'flex';
                document.getElementById('selection-count').textContent = `${count} agent${count > 1 ? 's' : ''} selected`;
            } else {
                bar.style.display = 'none';
            }
        }

        function clearAgentSelection() {
            selectedAgentIds.clear();
            updateAgentSelectionUI();
        }

        async function deleteSelectedAgents() {
            var count = selectedAgentIds.size;
            if (count === 0) return;
            var names = Array.from(selectedAgentIds).map(function(id) {
                return agents[id] ? (agents[id].call_sign || id) : id;
            }).join(', ');
            if (!(await cerebroConfirm('Delete ' + count + ' agent(s)?\n\n' + names + '\n\nThis cannot be undone.', { title: 'Delete Agents', confirmText: 'Delete', danger: true }))) return;

            var deleted = 0;
            for (var agentId of selectedAgentIds) {
                // Try to stop/delete on backend (best-effort)
                try {
                    await fetch(API_URL + '/agents/' + agentId, {
                        method: 'DELETE',
                        headers: { 'Authorization': 'Bearer ' + token }
                    });
                } catch (e) {
                    console.warn('Backend delete failed for ' + agentId + ':', e);
                }
                // Always remove locally and persist the deletion
                delete agents[agentId];
                deletedAgentIds.add(agentId);
                deleted++;
            }
            localStorage.setItem('cerebro_deleted_agents', JSON.stringify(Array.from(deletedAgentIds)));
            selectedAgentIds.clear();
            agentSelectMode = false;
            updateAgentSelectionUI();
            renderAgentsList();
            showToast('Deleted ' + deleted + ' agent(s)', 'success');
        }

        function showMergeSpawnModal() {
            // Populate the selected agents list using safe DOM methods
            const listEl = document.getElementById('merge-agent-list');
            listEl.textContent = ''; // Clear safely
            for (const agentId of selectedAgentIds) {
                const agent = agents[agentId];
                if (agent) {
                    const item = document.createElement('div');
                    item.className = 'merge-agent-item';

                    const callsign = document.createElement('span');
                    callsign.className = 'agent-callsign';
                    callsign.textContent = agent.call_sign || agent.id;

                    const badge = document.createElement('span');
                    badge.className = 'agent-type-badge';
                    badge.textContent = agent.type || 'worker';

                    const preview = document.createElement('span');
                    preview.className = 'agent-task-preview';
                    preview.textContent = agent.task.slice(0, 100);

                    item.appendChild(callsign);
                    item.appendChild(badge);
                    item.appendChild(preview);
                    listEl.appendChild(item);
                }
            }

            // Reset form
            document.getElementById('merge-task-input').value = '';
            mergeSelectedRole = 'worker';
            mergeTimeout = 3600;
            document.querySelectorAll('#merge-role-selector .role-option').forEach(el => {
                el.classList.toggle('selected', el.dataset.role === 'worker');
            });
            document.querySelectorAll('#merge-timeout-selector .timeout-btn').forEach(btn => {
                btn.classList.toggle('active', parseInt(btn.dataset.timeout) === 3600);
            });

            // Show modal
            document.body.classList.add('modal-open');
            document.getElementById('merge-spawn-modal').classList.add('active');
            setTimeout(() => document.getElementById('merge-task-input').focus(), 100);
        }

        function closeMergeSpawnModal() {
            document.body.classList.remove('modal-open');
            document.getElementById('merge-spawn-modal').classList.remove('active');
        }

        function selectMergeRole(element) {
            document.querySelectorAll('#merge-role-selector .role-option').forEach(el => el.classList.remove('selected'));
            element.classList.add('selected');
            mergeSelectedRole = element.dataset.role;
        }

        function selectMergeTimeout(btn) {
            document.querySelectorAll('#merge-timeout-selector .timeout-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            mergeTimeout = parseInt(btn.dataset.timeout);
        }

        async function submitMergeSpawn() {
            const task = document.getElementById('merge-task-input').value.trim();
            if (!task) {
                cerebroAlert('Please enter a task description.', { title: 'Missing Field' });
                return;
            }
            if (selectedAgentIds.size === 0) {
                cerebroAlert('No agents selected.', { title: 'Missing Selection' });
                return;
            }

            try {
                const response = await fetch(`${API_URL}/agents`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        task,
                        agent_type: mergeSelectedRole,
                        source_agents: Array.from(selectedAgentIds),
                        timeout: mergeTimeout
                    })
                });

                const data = await response.json();
                console.log('Merged agent spawned:', data);

                // Close modal and exit select mode
                closeMergeSpawnModal();
                agentSelectMode = true; // force toggle off
                toggleAgentSelectMode();

                switchView('agents');
            } catch (e) {
                console.error('Failed to spawn merged agent:', e);
                cerebroAlert('Failed to spawn merged agent', { title: 'Error', danger: true });
            }
        }

        // ==================== END AGENT SELECT MODE ====================

        // ==================== GROUP EDITOR ====================

        // Starred/protected agents - persisted in localStorage
        var starredAgentIds = new Set(JSON.parse(localStorage.getItem('cerebro_starred_agents') || '[]'));

        function saveStarredAgents() {
            localStorage.setItem('cerebro_starred_agents', JSON.stringify(Array.from(starredAgentIds)));
        }

        function toggleAgentStar(agentId) {
            if (starredAgentIds.has(agentId)) {
                starredAgentIds.delete(agentId);
            } else {
                starredAgentIds.add(agentId);
            }
            saveStarredAgents();
            renderGroupEditorContent();
        }

        function openGroupEditor() {
            renderGroupEditorContent();
            document.getElementById('group-editor-overlay').classList.add('active');
        }

        function closeGroupEditor() {
            document.getElementById('group-editor-overlay').classList.remove('active');
            renderAgents();
            loadAgentProjects();
        }

        function renderGroupEditorContent() {
            const body = document.getElementById('group-editor-body');
            const allAgents = Object.values(agents).filter(function(a) { return !a.archived; });

            // Group agents by project_id
            var groups = {};
            for (var i = 0; i < allAgents.length; i++) {
                var pid = allAgents[i].project_id || 'uncategorized';
                if (!groups[pid]) groups[pid] = [];
                groups[pid].push(allAgents[i]);
            }

            // Sort groups: named first alphabetically, uncategorized last
            var sortedKeys = Object.keys(groups).sort(function(a, b) {
                if (a === 'uncategorized') return 1;
                if (b === 'uncategorized') return -1;
                var nameA = (agentProjects[a] && agentProjects[a].name) || a;
                var nameB = (agentProjects[b] && agentProjects[b].name) || b;
                return nameA.localeCompare(nameB);
            });

            // Add empty groups from agentProjects that have no agents
            for (var pid in agentProjects) {
                if (!groups[pid]) {
                    groups[pid] = [];
                    sortedKeys.splice(sortedKeys.length - (groups['uncategorized'] ? 1 : 0), 0, pid);
                }
            }

            // Build DOM safely
            body.textContent = '';
            var fragment = document.createDocumentFragment();

            for (var k = 0; k < sortedKeys.length; k++) {
                var projKey = sortedKeys[k];
                var projAgents = groups[projKey] || [];
                var projInfo = agentProjects[projKey] || {};
                var projName = projKey === 'uncategorized' ? 'Uncategorized' : (projInfo.name || projKey);
                var isUncategorized = projKey === 'uncategorized';

                var zone = document.createElement('div');
                zone.className = 'group-zone';
                zone.setAttribute('data-project-id', projKey);
                zone.setAttribute('ondragover', 'onGroupEditorDragOver(event)');
                zone.setAttribute('ondragleave', 'onGroupEditorDragLeave(event)');
                zone.setAttribute('ondrop', "onGroupEditorDrop(event, '" + projKey + "')");

                // Zone header
                var zHeader = document.createElement('div');
                zHeader.className = 'group-zone-header';

                var zName = document.createElement('span');
                zName.className = 'group-zone-name';
                zName.id = 'group-name-' + projKey;
                zName.textContent = projName;
                zHeader.appendChild(zName);

                var zCount = document.createElement('span');
                zCount.className = 'group-zone-count';
                zCount.textContent = projAgents.length + ' agent' + (projAgents.length !== 1 ? 's' : '');
                zHeader.appendChild(zCount);

                if (!isUncategorized) {
                    var zActions = document.createElement('div');
                    zActions.className = 'group-zone-actions';

                    var renameBtn = document.createElement('button');
                    renameBtn.className = 'group-zone-action-btn';
                    renameBtn.textContent = 'Rename';
                    renameBtn.setAttribute('onclick', "renameGroupFromEditor('" + projKey + "')");
                    zActions.appendChild(renameBtn);

                    var deleteBtn = document.createElement('button');
                    deleteBtn.className = 'group-zone-action-btn danger';
                    deleteBtn.textContent = 'Delete';
                    deleteBtn.setAttribute('onclick', "deleteGroupFromEditor('" + projKey + "')");
                    zActions.appendChild(deleteBtn);

                    zHeader.appendChild(zActions);
                }

                zone.appendChild(zHeader);

                // Zone agents
                var zAgents = document.createElement('div');
                zAgents.className = 'group-zone-agents';

                if (projAgents.length === 0) {
                    var emptyDiv = document.createElement('div');
                    emptyDiv.className = 'group-zone-empty';
                    emptyDiv.textContent = 'Drop agents here';
                    zAgents.appendChild(emptyDiv);
                } else {
                    for (var j = 0; j < projAgents.length; j++) {
                        var agent = projAgents[j];
                        var pill = document.createElement('div');
                        pill.className = 'group-agent-pill';
                        pill.draggable = true;
                        pill.setAttribute('data-agent-id', agent.id);
                        pill.setAttribute('ondragstart', "onGroupEditorDragStart(event, '" + agent.id + "')");
                        pill.setAttribute('ondragend', 'onGroupEditorDragEnd(event)');

                        var statusDot = document.createElement('span');
                        statusDot.className = 'pill-status ' + agent.status;
                        pill.appendChild(statusDot);

                        var nameSpan = document.createElement('span');
                        nameSpan.textContent = agent.call_sign || agent.id;
                        pill.appendChild(nameSpan);

                        var star = document.createElement('span');
                        star.className = 'pill-star' + (starredAgentIds.has(agent.id) ? ' starred' : '');
                        star.textContent = '\u2605';
                        star.setAttribute('onclick', "event.stopPropagation(); toggleAgentStar('" + agent.id + "')");
                        star.title = starredAgentIds.has(agent.id) ? 'Protected from clearing' : 'Star to protect from clearing';
                        pill.appendChild(star);

                        zAgents.appendChild(pill);
                    }
                }

                zone.appendChild(zAgents);
                fragment.appendChild(zone);
            }

            body.appendChild(fragment);
        }

        function onGroupEditorDragStart(e, agentId) {
            e.dataTransfer.setData('text/plain', agentId);
            e.dataTransfer.effectAllowed = 'move';
            e.target.classList.add('dragging');
        }

        function onGroupEditorDragEnd(e) {
            e.target.classList.remove('dragging');
        }

        function onGroupEditorDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            var zone = e.target.closest('.group-zone');
            if (zone) zone.classList.add('drag-over');
        }

        function onGroupEditorDragLeave(e) {
            var zone = e.target.closest('.group-zone');
            if (zone && !zone.contains(e.relatedTarget)) {
                zone.classList.remove('drag-over');
            }
        }

        async function onGroupEditorDrop(e, projectId) {
            e.preventDefault();
            var zone = e.target.closest('.group-zone');
            if (zone) zone.classList.remove('drag-over');

            var agentId = e.dataTransfer.getData('text/plain');
            if (!agentId) return;

            var agent = agents[agentId];
            if (!agent) return;

            var targetProject = projectId === 'uncategorized' ? '' : projectId;
            if ((agent.project_id || '') === targetProject) return;

            try {
                await fetch(API_URL + '/agents/' + agentId + '/project', {
                    method: 'POST',
                    headers: { 'Authorization': 'Bearer ' + token, 'Content-Type': 'application/json' },
                    body: JSON.stringify({ project_id: targetProject })
                });

                agents[agentId].project_id = targetProject;
                renderGroupEditorContent();
                showToast('Moved ' + (agent.call_sign || agent.id) + ' to ' + (projectId === 'uncategorized' ? 'Uncategorized' : projectId), 'success');
            } catch (err) {
                console.error('Failed to move agent:', err);
                showToast('Failed to move agent', 'error');
            }
        }

        async function createGroupFromEditor() {
            var name = await cerebroPrompt('Enter a name for the new group:', '', { title: 'New Group', confirmText: 'Create', placeholder: 'Group name' });
            if (!name || !name.trim()) return;
            name = name.trim();

            try {
                var response = await fetch(API_URL + '/agents/projects/create', {
                    method: 'POST',
                    headers: { 'Authorization': 'Bearer ' + token, 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name: name })
                });
                var data = await response.json();
                if (data.status === 'error') {
                    showToast(data.error || 'Failed to create group', 'error');
                    return;
                }

                agentProjects[data.project_id] = { id: data.project_id, name: data.name, tech_tags: [] };
                renderGroupEditorContent();
                showToast('Created group: ' + name, 'success');
            } catch (err) {
                console.error('Failed to create group:', err);
                showToast('Failed to create group', 'error');
            }
        }

        async function renameGroupFromEditor(projectId) {
            var currentName = (agentProjects[projectId] && agentProjects[projectId].name) || projectId;
            var newName = await cerebroPrompt('Enter new name for this group:', currentName, { title: 'Rename Group', confirmText: 'Rename' });
            if (!newName || !newName.trim() || newName.trim() === currentName) return;
            newName = newName.trim();

            try {
                var response = await fetch(API_URL + '/agents/projects/' + encodeURIComponent(projectId) + '/rename', {
                    method: 'POST',
                    headers: { 'Authorization': 'Bearer ' + token, 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name: newName })
                });
                var data = await response.json();
                if (data.status === 'error') {
                    showToast(data.error || 'Failed to rename', 'error');
                    return;
                }

                if (agentProjects[projectId]) {
                    agentProjects[projectId].name = newName;
                } else {
                    agentProjects[projectId] = { id: projectId, name: newName, tech_tags: [] };
                }
                renderGroupEditorContent();
                showToast('Renamed to: ' + newName, 'success');
            } catch (err) {
                console.error('Failed to rename group:', err);
                showToast('Failed to rename group', 'error');
            }
        }

        async function deleteGroupFromEditor(projectId) {
            var projName = (agentProjects[projectId] && agentProjects[projectId].name) || projectId;
            var agentCount = Object.values(agents).filter(function(a) { return a.project_id === projectId; }).length;
            var msg = 'Delete group "' + projName + '"?';
            if (agentCount > 0) msg += '\n\n' + agentCount + ' agent(s) will be moved to Uncategorized.';
            if (!(await cerebroConfirm(msg, { title: 'Delete Group', confirmText: 'Delete', danger: true }))) return;

            try {
                var response = await fetch(API_URL + '/agents/projects/' + encodeURIComponent(projectId), {
                    method: 'DELETE',
                    headers: { 'Authorization': 'Bearer ' + token }
                });
                var data = await response.json();
                if (data.status === 'error') {
                    showToast(data.error || 'Failed to delete', 'error');
                    return;
                }

                delete agentProjects[projectId];
                for (var aid in agents) {
                    if (agents[aid].project_id === projectId) {
                        agents[aid].project_id = '';
                    }
                }
                renderGroupEditorContent();
                showToast('Deleted group: ' + projName, 'success');
            } catch (err) {
                console.error('Failed to delete group:', err);
                showToast('Failed to delete group', 'error');
            }
        }

        function showBulkAssignGroupModal() {
            if (selectedAgentIds.size === 0) {
                showToast('No agents selected', 'warning');
                return;
            }

            var body = document.getElementById('bulk-assign-body');
            body.textContent = '';
            var projectList = Object.keys(agentProjects);

            var container = document.createElement('div');
            container.style.cssText = 'display: flex; flex-direction: column; gap: 8px;';

            var countDiv = document.createElement('div');
            countDiv.style.cssText = 'margin-bottom: 8px; color: var(--text-muted); font-size: 0.85rem;';
            countDiv.textContent = selectedAgentIds.size + ' agent(s) selected';
            container.appendChild(countDiv);

            for (var i = 0; i < projectList.length; i++) {
                var pid = projectList[i];
                var pname = (agentProjects[pid] && agentProjects[pid].name) || pid;
                var btn = document.createElement('button');
                btn.className = 'group-agent-pill';
                btn.style.cssText = 'cursor: pointer; width: 100%; justify-content: center;';
                btn.textContent = pname;
                btn.setAttribute('onclick', "bulkAssignToGroup('" + pid + "')");
                container.appendChild(btn);
            }

            var uncatBtn = document.createElement('button');
            uncatBtn.className = 'group-agent-pill';
            uncatBtn.style.cssText = 'cursor: pointer; width: 100%; justify-content: center;';
            uncatBtn.textContent = 'Uncategorized';
            uncatBtn.setAttribute('onclick', "bulkAssignToGroup('')");
            container.appendChild(uncatBtn);

            var divider = document.createElement('div');
            divider.style.cssText = 'margin-top: 8px; border-top: 1px solid var(--border); padding-top: 8px;';
            var newBtn = document.createElement('button');
            newBtn.className = 'group-new-btn';
            newBtn.style.cssText = 'width: 100%; justify-content: center;';
            newBtn.textContent = '+ Create New Group';
            newBtn.setAttribute('onclick', 'bulkAssignNewGroup()');
            divider.appendChild(newBtn);
            container.appendChild(divider);

            body.appendChild(container);
            document.getElementById('bulk-assign-overlay').classList.add('active');
        }

        function closeBulkAssignModal() {
            document.getElementById('bulk-assign-overlay').classList.remove('active');
        }

        async function bulkAssignToGroup(projectId) {
            var count = 0;
            var promises = [];
            for (var agentId of selectedAgentIds) {
                (function(aid) {
                    promises.push(
                        fetch(API_URL + '/agents/' + aid + '/project', {
                            method: 'POST',
                            headers: { 'Authorization': 'Bearer ' + token, 'Content-Type': 'application/json' },
                            body: JSON.stringify({ project_id: projectId })
                        }).then(function() {
                            agents[aid].project_id = projectId;
                            count++;
                        })
                    );
                })(agentId);
            }

            try {
                await Promise.all(promises);
                showToast('Moved ' + count + ' agent(s) to ' + (projectId || 'Uncategorized'), 'success');
            } catch (err) {
                showToast('Some moves failed', 'error');
            }

            closeBulkAssignModal();
            agentSelectMode = true;
            toggleAgentSelectMode();
            renderAgents();
        }

        async function bulkAssignNewGroup() {
            var name = await cerebroPrompt('Enter a name for the new group:', '', { title: 'New Group', confirmText: 'Create', placeholder: 'Group name' });
            if (!name || !name.trim()) return;
            name = name.trim();

            try {
                var response = await fetch(API_URL + '/agents/projects/create', {
                    method: 'POST',
                    headers: { 'Authorization': 'Bearer ' + token, 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name: name })
                });
                var data = await response.json();
                if (data.status === 'error') {
                    showToast(data.error || 'Failed to create group', 'error');
                    return;
                }
                agentProjects[data.project_id] = { id: data.project_id, name: data.name, tech_tags: [] };
                await bulkAssignToGroup(data.project_id);
            } catch (err) {
                showToast('Failed to create group', 'error');
            }
        }

        async function clearAgentsForTheDay() {
            var totalAgents = Object.keys(agents).length;
            var protectedCount = 0;
            for (var aid in agents) {
                if (starredAgentIds.has(aid)) protectedCount++;
            }
            var toDelete = totalAgents - protectedCount;

            if (toDelete === 0) {
                showToast('All agents are starred - nothing to clear', 'info');
                return;
            }

            var msg = 'Clear ' + toDelete + ' agent(s)?';
            if (protectedCount > 0) {
                msg += '\n\n' + protectedCount + ' starred agent(s) will be preserved.';
            }
            if (!(await cerebroConfirm(msg, { title: 'Clear Agents', confirmText: 'Clear', danger: true }))) return;

            try {
                var response = await fetch(API_URL + '/agents/clear', {
                    method: 'POST',
                    headers: { 'Authorization': 'Bearer ' + token, 'Content-Type': 'application/json' },
                    body: JSON.stringify({ exclude_ids: Array.from(starredAgentIds) })
                });
                var data = await response.json();
                if (data.status === 'error') {
                    showToast(data.error || 'Failed to clear agents', 'error');
                    return;
                }

                // Update local cache - remove non-starred agents
                for (var aid in agents) {
                    if (!starredAgentIds.has(aid)) {
                        delete agents[aid];
                    }
                }

                renderGroupEditorContent();
                showToast('Cleared ' + data.deleted + ' agents (' + data.preserved + ' preserved)', 'success');
            } catch (err) {
                console.error('Failed to clear agents:', err);
                showToast('Failed to clear agents', 'error');
            }
        }

        // ==================== END GROUP EDITOR ====================

        function setSpawnMode(mode) {
            currentSpawnMode = mode;
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.mode === mode);
            });
            // Toggle form visibility in unified panel
            var singleForm = document.getElementById('panel-single-agent-form');
            var workflowForm = document.getElementById('workflow-form');
            var specopsForm = document.getElementById('specops-form');
            if (singleForm) singleForm.classList.toggle('hidden', mode !== 'single');
            if (workflowForm) workflowForm.classList.toggle('hidden', mode !== 'workflow');
            if (specopsForm) specopsForm.classList.toggle('hidden', mode !== 'specops');

            // Populate project dropdown for specops
            if (mode === 'specops') {
                var projSelect = document.getElementById('specops-project-select');
                if (projSelect && typeof agentProjects === 'object') {
                    projSelect.textContent = '';
                    var defaultOpt = document.createElement('option');
                    defaultOpt.value = '';
                    defaultOpt.textContent = 'No Project';
                    projSelect.appendChild(defaultOpt);
                    Object.keys(agentProjects).forEach(function(pid) {
                        var proj = agentProjects[pid];
                        var opt = document.createElement('option');
                        opt.value = pid;
                        opt.textContent = proj.name || pid;
                        projSelect.appendChild(opt);
                    });
                    var createOpt = document.createElement('option');
                    createOpt.value = '__create_new__';
                    createOpt.textContent = '+ Create New Project';
                    projSelect.appendChild(createOpt);
                }
            }

            // Update launch button text
            var launchBtn = document.getElementById('panel-launch-btn');
            if (launchBtn) {
                if (mode === 'specops') launchBtn.textContent = 'Deploy Mission';
                else if (mode === 'workflow') launchBtn.textContent = 'Deploy Workflow';
                else launchBtn.textContent = 'Launch Agent';
            }
        }

        function selectWorkflowType(element) {
            document.querySelectorAll('.workflow-type').forEach(el => el.classList.remove('selected'));
            element.classList.add('selected');
            selectedWorkflowType = element.dataset.type;
        }

        // =====================================================
        // SPECIAL OPS FUNCTIONS
        // =====================================================

        function selectSpecopsRole(el) {
            document.querySelectorAll('#specops-role-selector .specops-role-btn').forEach(function(b) { b.classList.remove('active'); });
            el.classList.add('active');
            selectedSpecopsRole = el.dataset.role;
        }

        function selectWorkStyle(btn) {
            document.querySelectorAll('#specops-work-style-selector .sel-btn').forEach(function(b) { b.classList.remove('active'); });
            btn.classList.add('active');
            specopsWorkStyle = btn.dataset.value;
            var cycleGroup = document.getElementById('specops-cycle-interval-group');
            if (cycleGroup) {
                cycleGroup.style.display = (specopsWorkStyle === 'continuous') ? 'none' : 'block';
            }
        }

        function selectCycleInterval(btn) {
            document.querySelectorAll('#specops-cycle-selector .sel-btn').forEach(function(b) { b.classList.remove('active'); });
            btn.classList.add('active');
            specopsCycleInterval = parseInt(btn.dataset.value) || 3600;
        }

        function selectMissionDuration(btn) {
            document.querySelectorAll('#specops-duration-selector .sel-btn').forEach(function(b) { b.classList.remove('active'); });
            btn.classList.add('active');
            specopsMissionDuration = parseInt(btn.dataset.value) || 0;
        }

        async function onSpecopsProjectChange(sel) {
            if (sel.value !== '__create_new__') return;
            var name = await cerebroPrompt('Enter a name for the new project:', '', { title: 'New Project', confirmText: 'Create', placeholder: 'Project name' });
            if (!name || !name.trim()) {
                sel.value = '';
                return;
            }
            name = name.trim();
            try {
                var t = localStorage.getItem('cerebro_token');
                var resp = await fetch(API_URL + '/agents/projects/create', {
                    method: 'POST',
                    headers: { 'Authorization': 'Bearer ' + t, 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name: name })
                });
                var data = await resp.json();
                if (data.status === 'error') {
                    showToast(data.error || 'Failed to create project', 'error');
                    sel.value = '';
                    return;
                }
                agentProjects[data.project_id] = { id: data.project_id, name: data.name, tech_tags: [] };
                var newOpt = document.createElement('option');
                newOpt.value = data.project_id;
                newOpt.textContent = data.name;
                var createOpt = sel.querySelector('option[value="__create_new__"]');
                sel.insertBefore(newOpt, createOpt);
                sel.value = data.project_id;
                showToast('Created project: ' + name, 'success');
            } catch (err) {
                console.error('Failed to create project:', err);
                showToast('Failed to create project', 'error');
                sel.value = '';
            }
        }

        async function submitSpecopsMission() {
            var taskEl = document.getElementById('specops-task-input');
            var task = taskEl ? taskEl.value.trim() : '';
            if (!task) {
                if (taskEl) taskEl.focus();
                return;
            }
            var missionName = (document.getElementById('specops-mission-name')?.value || '').trim() || 'Unnamed Mission';
            var model = document.getElementById('specops-model-select')?.value || 'sonnet';
            var context = document.getElementById('specops-context-input')?.value?.trim() || null;

            var body = {
                task: task,
                agent_type: 'specops_' + selectedSpecopsRole,
                timeout: 0,
                model: model,
                context: context,
                project_id: (function(){ var v = document.getElementById('specops-project-select')?.value; return (v && v !== '__create_new__') ? v : null; })(),
                specops_config: {
                    mission_name: missionName,
                    work_style: specopsWorkStyle,
                    cycle_interval: specopsCycleInterval,
                    mission_duration: specopsMissionDuration,
                    sub_role: selectedSpecopsRole,
                    success_criteria: (document.getElementById('specops-success-criteria')?.value || '').trim() || null
                }
            };

            try {
                var token = localStorage.getItem('cerebro_token');
                var resp = await fetch(API_URL + '/agents', {
                    method: 'POST',
                    headers: { 'Authorization': 'Bearer ' + token, 'Content-Type': 'application/json' },
                    body: JSON.stringify(body)
                });
                var data = await resp.json();
                console.log('[SpecOps] Mission deployed:', data);
                closeAgentPanel();
                if (taskEl) taskEl.value = '';
                var nameEl = document.getElementById('specops-mission-name');
                if (nameEl) nameEl.value = '';
            } catch (e) {
                console.error('[SpecOps] Deploy failed:', e);
            }
        }

        // ==================== SPECOPS TABBED PANEL ====================

        var _specopsCountdownTimer = null;

        function switchSpecopsTab(tabEl) {
            var tabName = tabEl.dataset.tab;
            // Scope to parent container to avoid conflicts between running and completed panels
            var container = tabEl.parentElement ? tabEl.parentElement.parentElement : document;
            container.querySelectorAll('.specops-tab').forEach(function(t) { t.classList.remove('active'); });
            container.querySelectorAll('.specops-tab-content').forEach(function(c) { c.classList.remove('active'); });
            tabEl.classList.add('active');
            var content = container.querySelector('#specops-tab-' + tabName) ||
                          container.querySelector('[data-specops-tab="' + tabName + '"]');
            if (content) content.classList.add('active');
        }

        // Extract a specific cycle's output from accumulated_output text
        function getCycleOutput(text, cycleNum) {
            if (!text) return '';
            var pattern = new RegExp('---\\s*CYCLE\\s+' + cycleNum + '\\s*---\\s*\\n?');
            var match = pattern.exec(text);
            if (!match) return '';
            var startIdx = match.index + match[0].length;
            var nextPattern = /---\s*CYCLE\s+\d+\s*---/;
            var nextMatch = nextPattern.exec(text.substring(startIdx));
            var endIdx = nextMatch ? startIdx + nextMatch.index : text.length;
            return text.substring(startIdx, endIdx).trim();
        }

        // Render accumulated_output with per-cycle headers and rendered markdown
        function renderAccumulatedOutput(container, text) {
            container.textContent = '';
            if (!text || !text.trim()) {
                var emptyMsg = document.createElement('div');
                emptyMsg.style.cssText = 'color:var(--text-muted);font-size:0.8rem;padding:20px;text-align:center;';
                emptyMsg.textContent = 'Output will appear after first cycle completes';
                container.appendChild(emptyMsg);
                return;
            }
            // Split by cycle separators  captures cycle number as group
            var parts = text.split(/---\s*CYCLE\s+(\d+)\s*---/);
            // parts[0] = text before first separator (usually empty)
            // parts[1] = cycle number, parts[2] = cycle content, etc.
            if (parts.length <= 1) {
                // No cycle separators found  render as single block
                var block = document.createElement('div');
                block.className = 'agent-output-rendered';
                block.innerHTML = safeAgentOutput(text);
                container.appendChild(block);
                return;
            }
            // If there's content before the first separator
            if (parts[0].trim()) {
                var preBlock = document.createElement('div');
                preBlock.className = 'agent-output-rendered';
                preBlock.innerHTML = safeAgentOutput(parts[0].trim());
                container.appendChild(preBlock);
            }
            // Iterate cycle pairs
            for (var i = 1; i < parts.length; i += 2) {
                var cycleNum = parts[i];
                var cycleContent = (parts[i + 1] || '').trim();
                var header = document.createElement('div');
                header.className = 'specops-cycle-header';
                header.textContent = 'Cycle #' + cycleNum;
                container.appendChild(header);
                if (cycleContent) {
                    var contentDiv = document.createElement('div');
                    contentDiv.className = 'agent-output-rendered';
                    contentDiv.innerHTML = safeAgentOutput(cycleContent);
                    container.appendChild(contentDiv);
                } else {
                    var emptyDiv = document.createElement('div');
                    emptyDiv.style.cssText = 'color:var(--text-muted);font-size:0.75rem;padding:8px 12px;font-style:italic;';
                    emptyDiv.textContent = 'No output recorded for this cycle';
                    container.appendChild(emptyDiv);
                }
            }
        }

        // Store accumulated output for cycle detail navigation
        var _specopsAccumulatedOutput = '';
        var _specopsAgentOutput = '';

        function renderSpecopsJournalTab(agent) {
            var panel = document.getElementById('specops-journal-panel');
            if (!panel) return;
            var journal = agent.mission_journal || [];
            _specopsAccumulatedOutput = agent.accumulated_output || '';
            _specopsAgentOutput = agent.output || '';
            if (journal.length === 0) {
                panel.textContent = '';
                var emptyMsg = document.createElement('div');
                emptyMsg.style.cssText = 'color:var(--text-muted);font-size:0.8rem;padding:20px;text-align:center;';
                emptyMsg.textContent = 'No journal entries yet \u2014 first cycle in progress';
                panel.appendChild(emptyMsg);
                return;
            }
            panel.textContent = '';
            var sorted = journal.slice().reverse();
            sorted.forEach(function(entry) {
                var entryDiv = document.createElement('div');
                entryDiv.className = 'specops-journal-entry';
                var headerDiv = document.createElement('div');
                headerDiv.className = 'specops-journal-entry-header';
                var cycleSpan = document.createElement('span');
                cycleSpan.textContent = 'CYCLE #' + (entry.cycle || '?');
                var timeSpan = document.createElement('span');
                timeSpan.textContent = entry.timestamp ? new Date(entry.timestamp).toLocaleString() : '';
                headerDiv.appendChild(cycleSpan);
                headerDiv.appendChild(timeSpan);
                var bodyDiv = document.createElement('div');
                bodyDiv.className = 'specops-journal-entry-body';
                var fields = [
                    { label: 'Progress', value: entry.mission_progress || entry.progress || 'N/A' },
                    { label: 'Assessment', value: entry.cycle_assessment || '' },
                    { label: 'Completed', value: entry.completed || 'N/A' },
                    { label: 'Next Directive', value: entry.next_directive || entry.next || 'N/A' },
                    { label: 'Context', value: entry.context_carry || '' },
                    { label: 'Blockers', value: entry.blockers || 'None' }
                ].filter(function(f) { return f.value && f.value !== ''; });
                fields.forEach(function(f) {
                    var row = document.createElement('div');
                    var strong = document.createElement('strong');
                    strong.textContent = f.label + ': ';
                    row.appendChild(strong);
                    row.appendChild(document.createTextNode(f.value));
                    bodyDiv.appendChild(row);
                });
                // Click hint
                var hintDiv = document.createElement('div');
                hintDiv.className = 'specops-journal-expand-hint';
                hintDiv.textContent = '\u25B6 View full output';
                // Click handler  navigate to cycle detail view
                (function(cycleN) {
                    entryDiv.addEventListener('click', function() {
                        openCycleDetailView(cycleN);
                    });
                })(entry.cycle || 0);
                entryDiv.appendChild(headerDiv);
                entryDiv.appendChild(bodyDiv);
                entryDiv.appendChild(hintDiv);
                panel.appendChild(entryDiv);
            });
        }

        function openCycleDetailView(cycleNum) {
            // Hide the journal panel
            var journalPanel = document.getElementById('specops-journal-panel');
            if (journalPanel) journalPanel.style.display = 'none';

            // Show the cycle detail view
            var detailView = document.getElementById('specops-cycle-detail');
            var titleEl = document.getElementById('specops-cycle-detail-title');
            var bodyEl = document.getElementById('specops-cycle-detail-body');
            if (!detailView || !bodyEl) return;

            titleEl.textContent = 'CYCLE #' + cycleNum + ' \u2014 Full Output';
            bodyEl.textContent = '';

            // Get cycle output from accumulated_output, fallback to agent.output for cycle 1
            var cycleText = getCycleOutput(_specopsAccumulatedOutput, cycleNum);
            if (!cycleText && cycleNum === 1 && _specopsAgentOutput) {
                cycleText = _specopsAgentOutput;
            }

            if (cycleText) {
                var liveText = cycleText.replace(/([.!?])([A-Z])/g, '$1\n\n$2');
                var wrapper = document.createElement('div');
                wrapper.className = 'agent-output-rendered';
                // safeAgentOutput uses DOMPurify for sanitization
                wrapper.innerHTML = safeAgentOutput(liveText);
                bodyEl.appendChild(wrapper);
            } else {
                var noData = document.createElement('div');
                noData.style.cssText = 'color:var(--text-muted);font-size:0.85rem;padding:20px;text-align:center;font-style:italic;';
                noData.textContent = 'Output not yet available for this cycle';
                bodyEl.appendChild(noData);
            }

            detailView.style.display = 'block';
        }

        function exitCycleDetailView() {
            // Hide cycle detail
            var detailView = document.getElementById('specops-cycle-detail');
            if (detailView) detailView.style.display = 'none';

            // Restore journal panel
            var journalPanel = document.getElementById('specops-journal-panel');
            if (journalPanel) journalPanel.style.display = '';
        }

        function updateSpecopsRunningPanel(agent) {
            if (!agent || !agent.is_specops) return;

            // Update mission name
            var nameEl = document.getElementById('specops-panel-mission-name');
            if (nameEl) nameEl.textContent = agent.mission_name || 'Unnamed Mission';

            // Update status text
            var statusEl = document.getElementById('specops-panel-status');
            if (statusEl) {
                var cycleNum = (agent.cycle_count || 0) + 1;
                if (agent.status === 'cycling') {
                    statusEl.textContent = 'Completed ' + agent.cycle_count + ' cycle(s) \u2014 Standing by';
                } else {
                    statusEl.textContent = 'Cycle #' + cycleNum + ' \u2014 Operating';
                }
            }

            // Show/hide pending directive badge
            var existingDirectiveBadge = document.getElementById('specops-pending-directive');
            if (existingDirectiveBadge) existingDirectiveBadge.remove();
            if (agent.user_directive) {
                var directiveDiv = document.createElement('div');
                directiveDiv.id = 'specops-pending-directive';
                directiveDiv.className = 'specops-pending-directive';
                var truncated = agent.user_directive.length > 120 ? agent.user_directive.substring(0, 120) + '...' : agent.user_directive;
                directiveDiv.innerHTML = '<span class="directive-badge">PENDING DIRECTIVE</span> "' +
                    truncated.replace(/</g, '&lt;').replace(/>/g, '&gt;') + '"';
                var statusContainer = document.getElementById('specops-panel-status');
                if (statusContainer && statusContainer.parentNode) {
                    statusContainer.parentNode.insertBefore(directiveDiv, statusContainer.nextSibling);
                }
            }

            // Update cycle elapsed timer from started_at
            var specopsElapsedEl = document.getElementById('specops-panel-elapsed');
            if (specopsElapsedEl && agent.status === 'running' && agent.started_at) {
                var cycleStart = new Date(agent.started_at).getTime();
                if (!_specopsElapsedTimer) {
                    var updateFn = function() {
                        var secs = Math.max(0, Math.floor((Date.now() - cycleStart) / 1000));
                        var m = Math.floor(secs / 60);
                        var s = secs % 60;
                        specopsElapsedEl.textContent = m + ':' + s.toString().padStart(2, '0');
                    };
                    updateFn();
                    _specopsElapsedTimer = setInterval(updateFn, 1000);
                }
            } else if (specopsElapsedEl && agent.status === 'cycling') {
                // During cycling, stop the cycle timer and show total mission elapsed instead
                if (_specopsElapsedTimer) { clearInterval(_specopsElapsedTimer); _specopsElapsedTimer = null; }
                specopsElapsedEl.textContent = formatDurationShort(agent.mission_elapsed || 0);
            }

            // Update stats
            var cyclesEl = document.getElementById('specops-stat-cycles');
            if (cyclesEl) cyclesEl.textContent = agent.cycle_count || 0;

            var elapsedEl = document.getElementById('specops-stat-elapsed');
            if (elapsedEl) elapsedEl.textContent = formatDurationShort(agent.mission_elapsed || 0);

            var progressEl = document.getElementById('specops-stat-progress');
            if (progressEl) {
                var journal = agent.mission_journal || [];
                var lastEntry = journal.length > 0 ? journal[journal.length - 1] : null;
                progressEl.textContent = lastEntry ? ((lastEntry.mission_progress || lastEntry.progress || '\u2014').substring(0, 20)) : '\u2014';
            }

            var outputEl = document.getElementById('specops-stat-output');
            if (outputEl) {
                var outLen = (agent.accumulated_output || agent.output || '').length;
                outputEl.textContent = outLen > 1000 ? Math.round(outLen / 1000) + 'K' : outLen;
            }

            // Show/hide countdown area based on status
            var countdownArea = document.getElementById('specops-countdown-area');
            if (countdownArea) {
                countdownArea.style.display = (agent.status === 'cycling') ? 'block' : 'none';
            }

            // Update countdown timer
            if (agent.status === 'cycling' && agent.next_checkin) {
                startSpecopsCountdown(agent.next_checkin);
            } else {
                stopSpecopsCountdown();
            }

            // Render journal tab
            renderSpecopsJournalTab(agent);

            // Render debrief tab
            renderSpecopsDebriefTab(agent);

            // Render full output tab
            var fullOutputPanel = document.getElementById('specops-fulloutput-panel');
            if (fullOutputPanel) {
                renderAccumulatedOutput(fullOutputPanel, agent.accumulated_output || '');
            }
        }

        function renderSpecopsDebriefTab(agent) {
            var panel = document.getElementById('specops-debrief-panel');
            if (!panel) return;
            panel.textContent = '';

            var debrief = agent.mission_debrief || '';
            var cycleCount = agent.cycle_count || 0;

            // Stats row
            var statsDiv = document.createElement('div');
            statsDiv.className = 'specops-debrief-stats';
            var stats = [
                { label: 'Cycles', value: cycleCount },
                { label: 'Elapsed', value: formatDurationShort(agent.mission_elapsed || 0) },
                { label: 'Progress', value: (function() {
                    var j = agent.mission_journal || [];
                    var last = j.length > 0 ? j[j.length - 1] : null;
                    return last ? (last.mission_progress || last.progress || '\u2014').substring(0, 20) : '\u2014';
                })() },
                { label: 'Output', value: (function() {
                    var len = (agent.accumulated_output || agent.output || '').length;
                    return len > 1000 ? Math.round(len / 1000) + 'K' : String(len);
                })() }
            ];
            stats.forEach(function(s) {
                var statDiv = document.createElement('div');
                statDiv.className = 'specops-debrief-stat';
                var valDiv = document.createElement('div');
                valDiv.className = 'specops-debrief-stat-value';
                valDiv.textContent = s.value;
                var lblDiv = document.createElement('div');
                lblDiv.className = 'specops-debrief-stat-label';
                lblDiv.textContent = s.label;
                statDiv.appendChild(valDiv);
                statDiv.appendChild(lblDiv);
                statsDiv.appendChild(statDiv);
            });
            panel.appendChild(statsDiv);

            // Debrief content
            if (!debrief && cycleCount > 0) {
                var genDiv = document.createElement('div');
                genDiv.className = 'specops-debrief-generating';
                var spinner = document.createElement('div');
                spinner.className = 'agent-spinner';
                genDiv.appendChild(spinner);
                genDiv.appendChild(document.createTextNode('Generating mission debrief\u2026'));
                panel.appendChild(genDiv);
            } else if (debrief) {
                var contentDiv = document.createElement('div');
                contentDiv.className = 'specops-debrief-content';
                // safeAgentOutput uses DOMPurify for XSS-safe rendering
                contentDiv.innerHTML = safeAgentOutput(debrief);
                panel.appendChild(contentDiv);
            } else {
                var emptyDiv = document.createElement('div');
                emptyDiv.style.cssText = 'color:var(--text-muted);font-size:0.8rem;padding:20px;text-align:center;';
                emptyDiv.textContent = 'Debrief will be generated after the first cycle completes';
                panel.appendChild(emptyDiv);
            }
        }

        function populateSpecopsCompletedPanel(agentId) {
            var agent = agents[agentId];
            if (!agent) return;

            var outputArea = document.getElementById('panel-output-area');
            if (!outputArea) return;
            outputArea.textContent = '';

            // Tab bar
            var tabBar = document.createElement('div');
            tabBar.className = 'specops-tabs';
            var tabs = [
                { name: 'debrief', label: 'Debrief', active: true },
                { name: 'cycles', label: 'Cycles', active: false },
                { name: 'fulloutput', label: 'Full Output', active: false }
            ];
            tabs.forEach(function(tab) {
                var tabDiv = document.createElement('div');
                tabDiv.className = 'specops-tab' + (tab.active ? ' active' : '');
                tabDiv.dataset.tab = tab.name;
                tabDiv.textContent = tab.label;
                tabDiv.addEventListener('click', function() {
                    switchCompletedSpecopsTab(this);
                });
                tabBar.appendChild(tabDiv);
            });
            outputArea.appendChild(tabBar);

            // === DEBRIEF TAB ===
            var debriefTab = document.createElement('div');
            debriefTab.className = 'specops-tab-content active';
            debriefTab.setAttribute('data-specops-tab', 'debrief');

            // Stats row
            var statsDiv = document.createElement('div');
            statsDiv.className = 'specops-debrief-stats';
            var debriefStats = [
                { label: 'Cycles', value: agent.cycle_count || 0 },
                { label: 'Elapsed', value: formatDurationShort(agent.mission_elapsed || 0) },
                { label: 'Progress', value: (function() {
                    var j = agent.mission_journal || [];
                    var last = j.length > 0 ? j[j.length - 1] : null;
                    return last ? (last.mission_progress || last.progress || '\u2014').substring(0, 20) : '\u2014';
                })() },
                { label: 'Output', value: (function() {
                    var len = (agent.accumulated_output || agent.output || '').length;
                    return len > 1000 ? Math.round(len / 1000) + 'K' : String(len);
                })() }
            ];
            debriefStats.forEach(function(s) {
                var statDiv = document.createElement('div');
                statDiv.className = 'specops-debrief-stat';
                var valDiv = document.createElement('div');
                valDiv.className = 'specops-debrief-stat-value';
                valDiv.textContent = s.value;
                var lblDiv = document.createElement('div');
                lblDiv.className = 'specops-debrief-stat-label';
                lblDiv.textContent = s.label;
                statDiv.appendChild(valDiv);
                statDiv.appendChild(lblDiv);
                statsDiv.appendChild(statDiv);
            });
            debriefTab.appendChild(statsDiv);

            // Debrief content
            var debrief = agent.mission_debrief || '';
            if (debrief) {
                var contentDiv = document.createElement('div');
                contentDiv.className = 'specops-debrief-content';
                // safeAgentOutput uses DOMPurify for XSS-safe rendering
                contentDiv.innerHTML = safeAgentOutput(debrief);
                debriefTab.appendChild(contentDiv);
            } else {
                var emptyDebrief = document.createElement('div');
                emptyDebrief.style.cssText = 'color:var(--text-muted);font-size:0.8rem;padding:20px;text-align:center;font-style:italic;';
                emptyDebrief.textContent = 'No debrief generated for this mission';
                debriefTab.appendChild(emptyDebrief);
            }

            // Error section (if agent had errors)
            if (agent.error) {
                var errorDiv = document.createElement('div');
                errorDiv.style.cssText = 'margin-top:16px;padding:12px;background:rgba(255,50,50,0.08);border:1px solid rgba(255,50,50,0.2);border-radius:8px;';
                var errorLabel = document.createElement('div');
                errorLabel.style.cssText = 'font-size:0.7rem;font-weight:700;color:#ff5050;text-transform:uppercase;margin-bottom:4px;';
                errorLabel.textContent = 'Error';
                var errorText = document.createElement('div');
                errorText.style.cssText = 'font-size:0.8rem;color:var(--text-secondary);';
                errorText.textContent = agent.error;
                errorDiv.appendChild(errorLabel);
                errorDiv.appendChild(errorText);
                debriefTab.appendChild(errorDiv);
            }
            outputArea.appendChild(debriefTab);

            // === CYCLES TAB ===
            var cyclesTab = document.createElement('div');
            cyclesTab.className = 'specops-tab-content';
            cyclesTab.setAttribute('data-specops-tab', 'cycles');

            var journal = agent.mission_journal || [];
            if (journal.length === 0) {
                var emptyJ = document.createElement('div');
                emptyJ.style.cssText = 'color:var(--text-muted);font-size:0.8rem;padding:20px;text-align:center;';
                emptyJ.textContent = 'No cycle data available';
                cyclesTab.appendChild(emptyJ);
            } else {
                // Journal entries container
                var journalContainer = document.createElement('div');
                journalContainer.className = 'specops-completed-journal-list';

                var sorted = journal.slice().reverse();
                sorted.forEach(function(entry) {
                    var entryDiv = document.createElement('div');
                    entryDiv.className = 'specops-journal-entry';
                    var headerDiv = document.createElement('div');
                    headerDiv.className = 'specops-journal-entry-header';
                    var cycleSpan = document.createElement('span');
                    cycleSpan.textContent = 'CYCLE #' + (entry.cycle || '?');
                    var timeSpan = document.createElement('span');
                    timeSpan.textContent = entry.timestamp ? new Date(entry.timestamp).toLocaleString() : '';
                    headerDiv.appendChild(cycleSpan);
                    headerDiv.appendChild(timeSpan);
                    var bodyDiv = document.createElement('div');
                    bodyDiv.className = 'specops-journal-entry-body';
                    var fields = [
                        { label: 'Progress', value: entry.mission_progress || entry.progress || 'N/A' },
                        { label: 'Assessment', value: entry.cycle_assessment || '' },
                        { label: 'Completed', value: entry.completed || 'N/A' },
                        { label: 'Next Directive', value: entry.next_directive || entry.next || 'N/A' },
                        { label: 'Context', value: entry.context_carry || '' },
                        { label: 'Blockers', value: entry.blockers || 'None' }
                    ].filter(function(f) { return f.value && f.value !== ''; });
                    fields.forEach(function(f) {
                        var row = document.createElement('div');
                        var strong = document.createElement('strong');
                        strong.textContent = f.label + ': ';
                        row.appendChild(strong);
                        row.appendChild(document.createTextNode(f.value));
                        bodyDiv.appendChild(row);
                    });
                    var hintDiv = document.createElement('div');
                    hintDiv.className = 'specops-journal-expand-hint';
                    hintDiv.textContent = '\u25B6 View full output';
                    (function(cycleN, cTab) {
                        entryDiv.addEventListener('click', function() {
                            openCompletedCycleDetailView(cycleN, cTab);
                        });
                    })(entry.cycle || 0, cyclesTab);
                    entryDiv.appendChild(headerDiv);
                    entryDiv.appendChild(bodyDiv);
                    entryDiv.appendChild(hintDiv);
                    journalContainer.appendChild(entryDiv);
                });
                cyclesTab.appendChild(journalContainer);

                // Cycle detail view (hidden initially)
                var cycleDetail = document.createElement('div');
                cycleDetail.className = 'specops-completed-cycle-detail';
                cycleDetail.style.display = 'none';
                cycleDetail.setAttribute('data-role', 'completed-cycle-detail');

                var detailHeader = document.createElement('div');
                detailHeader.style.cssText = 'display:flex;align-items:center;gap:10px;margin-bottom:12px;';
                var backBtn = document.createElement('button');
                backBtn.style.cssText = 'background:none;border:1px solid var(--border);color:var(--text-secondary);border-radius:6px;padding:4px 12px;cursor:pointer;font-size:0.75rem;transition:all 0.2s ease;';
                backBtn.textContent = 'Back';
                backBtn.addEventListener('click', function() {
                    cycleDetail.style.display = 'none';
                    journalContainer.style.display = '';
                });
                backBtn.addEventListener('mouseover', function() {
                    this.style.background = 'rgba(255, 45, 120, 0.1)';
                    this.style.borderColor = 'var(--specops-pink)';
                    this.style.color = 'var(--specops-pink)';
                });
                backBtn.addEventListener('mouseout', function() {
                    this.style.background = 'none';
                    this.style.borderColor = 'var(--border)';
                    this.style.color = 'var(--text-secondary)';
                });
                var detailTitle = document.createElement('span');
                detailTitle.style.cssText = 'font-family:var(--font-mono);font-size:0.85rem;color:var(--specops-pink);font-weight:600;';
                detailTitle.setAttribute('data-role', 'cycle-title');
                detailHeader.appendChild(backBtn);
                detailHeader.appendChild(detailTitle);
                cycleDetail.appendChild(detailHeader);

                var detailBody = document.createElement('div');
                detailBody.className = 'specops-live-output';
                detailBody.style.minHeight = '200px';
                detailBody.setAttribute('data-role', 'cycle-body');
                cycleDetail.appendChild(detailBody);
                cyclesTab.appendChild(cycleDetail);
            }
            outputArea.appendChild(cyclesTab);

            // === FULL OUTPUT TAB ===
            var fullTab = document.createElement('div');
            fullTab.className = 'specops-tab-content';
            fullTab.setAttribute('data-specops-tab', 'fulloutput');
            var fullContainer = document.createElement('div');
            fullContainer.className = 'specops-live-output';
            fullContainer.style.minHeight = '200px';
            renderAccumulatedOutput(fullContainer, agent.accumulated_output || agent.output || '');
            fullTab.appendChild(fullContainer);
            outputArea.appendChild(fullTab);
        }

        function switchCompletedSpecopsTab(tabEl) {
            var tabName = tabEl.dataset.tab;
            var outputArea = document.getElementById('panel-output-area');
            if (!outputArea) return;
            outputArea.querySelectorAll('.specops-tab').forEach(function(t) { t.classList.remove('active'); });
            outputArea.querySelectorAll('.specops-tab-content').forEach(function(c) { c.classList.remove('active'); });
            tabEl.classList.add('active');
            var content = outputArea.querySelector('[data-specops-tab="' + tabName + '"]');
            if (content) content.classList.add('active');
        }

        function openCompletedCycleDetailView(cycleNum, container) {
            // Hide journal list
            var journalList = container.querySelector('.specops-completed-journal-list');
            if (journalList) journalList.style.display = 'none';

            // Show cycle detail
            var detailView = container.querySelector('[data-role="completed-cycle-detail"]');
            if (!detailView) return;

            var titleEl = detailView.querySelector('[data-role="cycle-title"]');
            var bodyEl = detailView.querySelector('[data-role="cycle-body"]');
            if (titleEl) titleEl.textContent = 'CYCLE #' + cycleNum + ' \u2014 Full Output';
            if (bodyEl) {
                bodyEl.textContent = '';
                var agent = agents[agentPanelAgentId];
                var accOutput = agent ? (agent.accumulated_output || '') : '';
                var cycleText = getCycleOutput(accOutput, cycleNum);
                if (!cycleText && cycleNum === 1 && agent) {
                    cycleText = agent.output || '';
                }
                if (cycleText) {
                    var wrapper = document.createElement('div');
                    wrapper.className = 'agent-output-rendered';
                    // safeAgentOutput uses DOMPurify for XSS-safe rendering
                    wrapper.innerHTML = safeAgentOutput(cycleText);
                    bodyEl.appendChild(wrapper);
                } else {
                    var noData = document.createElement('div');
                    noData.style.cssText = 'color:var(--text-muted);font-size:0.85rem;padding:20px;text-align:center;font-style:italic;';
                    noData.textContent = 'Output not available for this cycle';
                    bodyEl.appendChild(noData);
                }
            }
            detailView.style.display = 'block';
        }

        function startSpecopsCountdown(nextCheckin) {
            stopSpecopsCountdown();
            var timerEl = document.getElementById('specops-countdown-timer');
            if (!timerEl) return;

            var targetTime = new Date(nextCheckin).getTime();

            _specopsCountdownTimer = setInterval(function() {
                var now = Date.now();
                var diff = Math.max(0, Math.floor((targetTime - now) / 1000));
                var m = Math.floor(diff / 60);
                var s = diff % 60;
                timerEl.textContent = m + ':' + s.toString().padStart(2, '0');
                if (diff <= 0) {
                    timerEl.textContent = 'STARTING...';
                    stopSpecopsCountdown();
                }
            }, 1000);
        }

        function stopSpecopsCountdown() {
            if (_specopsCountdownTimer) {
                clearInterval(_specopsCountdownTimer);
                _specopsCountdownTimer = null;
            }
        }

        async function forceNextCycle(agentId) {
            if (!agentId) return;
            var confirmed = await cerebroConfirm('Force the next cycle to start immediately?', { title: 'Force Cycle', confirmText: 'Force It', danger: false });
            if (!confirmed) return;
            try {
                var token = localStorage.getItem('cerebro_token');
                await fetch(API_URL + '/agents/' + agentId + '/specops/force-cycle', {
                    method: 'POST',
                    headers: { 'Authorization': 'Bearer ' + token }
                });
                showToast('Force cycle requested', 'success');
            } catch (e) {
                console.error('Force cycle failed:', e);
                showToast('Failed to force cycle', 'error');
            }
        }

        async function pauseSpecopsMission(agentId) {
            if (!agentId) return;
            var confirmed = await cerebroConfirm('Pause this mission? The agent will stop after the current cycle completes.', { title: 'Pause Mission', confirmText: 'Pause', danger: true });
            if (!confirmed) return;
            try {
                var token = localStorage.getItem('cerebro_token');
                await fetch(API_URL + '/agents/' + agentId + '/specops', {
                    method: 'PATCH',
                    headers: { 'Authorization': 'Bearer ' + token, 'Content-Type': 'application/json' },
                    body: JSON.stringify({ auto_continue: false })
                });
                showToast('Mission will pause after current cycle', 'success');
            } catch (e) {
                console.error('Pause failed:', e);
                showToast('Failed to pause mission', 'error');
            }
        }

        function formatDurationShort(seconds) {
            if (!seconds || seconds <= 0) return '0s';
            var d = Math.floor(seconds / 86400);
            var h = Math.floor((seconds % 86400) / 3600);
            var m = Math.floor((seconds % 3600) / 60);
            if (d > 0) return d + 'd ' + (h > 0 ? h + 'h' : '');
            if (h > 0) return h + 'h ' + (m > 0 ? m + 'm' : '');
            return m + 'm';
        }

        function getTimeUntil(isoString) {
            if (!isoString) return '--';
            try {
                var target = new Date(isoString).getTime();
                var now = Date.now();
                var diff = Math.max(0, Math.floor((target - now) / 1000));
                if (diff <= 0) return 'now';
                if (diff < 60) return diff + 's';
                if (diff < 3600) return Math.floor(diff / 60) + 'm';
                return Math.floor(diff / 3600) + 'h ' + Math.floor((diff % 3600) / 60) + 'm';
            } catch(e) { return '--'; }
        }

        function renderSpecopsCard(agent, isArchived) {
            var displayName = escapeHtml(agent.call_sign || agent.id);
            var missionName = escapeHtml(agent.mission_name || 'Unnamed Mission');
            var status = agent.status || 'queued';
            var statusLabel = status === 'cycling' ? 'STANDBY' : status.toUpperCase();
            var cycleCount = agent.cycle_count || 0;
            var elapsed = formatDurationShort(agent.mission_elapsed || 0);
            var nextCheckin = agent.next_checkin ? getTimeUntil(agent.next_checkin) : '--';
            var workStyle = agent.work_style || 'continuous';

            var card = document.createElement('div');
            card.className = 'agent-card specops ' + status + (isArchived ? ' archived' : '');
            card.setAttribute('data-agent-id', agent.id);
            card.setAttribute('onclick', "handleAgentCardClick('" + agent.id + "', event)");

            // Header
            var header = document.createElement('div');
            header.className = 'agent-header';
            var headerLeft = document.createElement('div');
            headerLeft.style.cssText = 'display:flex;align-items:center;gap:8px;';
            var badge = document.createElement('span');
            badge.className = 'specops-badge';
            badge.textContent = 'SPEC OPS';
            var nameEl = document.createElement('span');
            nameEl.style.cssText = 'font-weight:600;color:var(--text-primary);';
            nameEl.textContent = agent.call_sign || agent.id;
            var statusEl = document.createElement('span');
            statusEl.className = 'agent-status ' + status;
            statusEl.textContent = statusLabel;
            headerLeft.appendChild(badge);
            headerLeft.appendChild(nameEl);
            headerLeft.appendChild(statusEl);
            var timeEl = document.createElement('span');
            timeEl.className = 'agent-time';
            timeEl.textContent = getTimeAgo(agent.created_at);
            header.appendChild(headerLeft);
            header.appendChild(timeEl);
            card.appendChild(header);

            // Mission name
            var missionEl = document.createElement('div');
            missionEl.className = 'specops-mission-name';
            missionEl.textContent = agent.mission_name || 'Unnamed Mission';
            card.appendChild(missionEl);

            // Task
            var taskEl = document.createElement('div');
            taskEl.className = 'agent-task';
            taskEl.textContent = (agent.task || '').slice(0, 150);
            card.appendChild(taskEl);

            // Metrics row
            var metrics = document.createElement('div');
            metrics.className = 'specops-metrics';
            var metricData = [
                { value: String(cycleCount), label: 'Cycles' },
                { value: elapsed, label: 'Elapsed' },
                { value: nextCheckin, label: 'Next Check-in' },
                { value: workStyle, label: 'Work Style' }
            ];
            metricData.forEach(function(m) {
                var metric = document.createElement('div');
                metric.className = 'specops-metric';
                var val = document.createElement('span');
                val.className = 'specops-metric-value';
                val.textContent = m.value;
                var lbl = document.createElement('span');
                lbl.className = 'specops-metric-label';
                lbl.textContent = m.label;
                metric.appendChild(val);
                metric.appendChild(lbl);
                metrics.appendChild(metric);
            });
            card.appendChild(metrics);

            // Journal preview (last entry)
            var journal = agent.mission_journal || [];
            if (journal.length > 0) {
                var last = journal[journal.length - 1];
                var preview = document.createElement('div');
                preview.className = 'specops-journal-preview';
                var strong = document.createElement('strong');
                strong.textContent = 'Cycle ' + (last.cycle || '?') + ': ';
                preview.appendChild(strong);
                preview.appendChild(document.createTextNode((last.completed || last.progress || 'No data').substring(0, 150)));
                card.appendChild(preview);
            }

            return card.outerHTML;
        }

        function renderCompactSpecopsCard(agent, isArchived) {
            var status = agent.status || 'queued';
            var statusLabel = status === 'cycling' ? 'STANDBY' : status.toUpperCase();
            var cycleCount = agent.cycle_count || 0;

            var card = document.createElement('div');
            card.className = 'agent-card-compact specops ' + status + (isArchived ? ' archived' : '') + (selectedAgentIds.has(agent.id) ? ' selected' : '');
            card.setAttribute('data-agent-id', agent.id);
            card.setAttribute('onclick', "handleAgentCardClick('" + agent.id + "', event)");

            var header = document.createElement('div');
            header.className = 'compact-header';
            var nameSpan = document.createElement('span');
            nameSpan.className = 'compact-name';
            nameSpan.textContent = agent.call_sign || agent.id;
            var badgeSpan = document.createElement('span');
            badgeSpan.className = 'compact-specops-badge';
            badgeSpan.textContent = 'SPEC OPS';
            nameSpan.appendChild(badgeSpan);
            var statusSpan = document.createElement('span');
            statusSpan.className = 'compact-status ' + status;
            statusSpan.textContent = statusLabel;
            header.appendChild(nameSpan);
            header.appendChild(statusSpan);

            var taskDiv = document.createElement('div');
            taskDiv.className = 'compact-task';
            taskDiv.textContent = (agent.mission_name || agent.task || '').slice(0, 80);

            var footer = document.createElement('div');
            footer.className = 'compact-footer';
            var timeSpan = document.createElement('span');
            timeSpan.className = 'compact-time';
            timeSpan.textContent = cycleCount > 0 ? cycleCount + ' cycles' : getTimeAgo(agent.created_at);
            footer.appendChild(timeSpan);

            card.appendChild(header);
            card.appendChild(taskDiv);
            card.appendChild(footer);
            return card.outerHTML;
        }

        async function updateSpecopsField(agentId, field, value) {
            try {
                var token = localStorage.getItem('cerebro_token');
                var body = {};
                body[field] = value;
                await fetch(API_URL + '/agents/' + agentId + '/specops', {
                    method: 'PATCH',
                    headers: { 'Authorization': 'Bearer ' + token, 'Content-Type': 'application/json' },
                    body: JSON.stringify(body)
                });
            } catch(e) {
                console.error('[SpecOps] Update failed:', e);
            }
        }

        function toggleSpecopsAutoContinue(agentId) {
            var agent = agents[agentId];
            if (!agent) return;
            var newVal = !agent.auto_continue;
            agent.auto_continue = newVal;
            updateSpecopsField(agentId, 'auto_continue', newVal);
            renderAgents();
        }

        function toggleAdvancedOptions() {
            const options = document.getElementById('advanced-options');
            const arrow = document.getElementById('advanced-arrow');
            if (options.classList.contains('hidden')) {
                options.classList.remove('hidden');
                arrow.textContent = '';
                // Load project folders when offload is active
                loadProjectFolders();
                // Load eligible devices for offload selector
                loadAgentOffloadDevices();
            } else {
                options.classList.add('hidden');
                arrow.textContent = '';
            }
        }

        async function loadAgentOffloadDevices() {
            var select = document.getElementById('agent-offload-device');
            if (!select) return;
            try {
                var resp = await fetch(API_URL + '/api/offload/eligible-devices', {
                    headers: { 'Authorization': 'Bearer ' + localStorage.getItem('cerebro_token') }
                });
                if (!resp.ok) throw new Error('HTTP ' + resp.status);
                var data = await resp.json();
                var devices = data.devices || [];

                // Reset options  keep the "Local" default
                select.length = 1;

                devices.forEach(function(dev) {
                    var opt = document.createElement('option');
                    opt.value = dev.id;
                    var name = dev.friendly_name || dev.device_name || dev.id;
                    var detail = dev.device_type || 'device';
                    if (dev.ram_gb) detail += ' \u00B7 ' + dev.ram_gb + 'GB RAM';
                    opt.textContent = name + '  (' + detail + ')';
                    select.appendChild(opt);
                });

                // Show project folder group if a remote device is selected
                select.onchange = function() {
                    var folderGroup = document.getElementById('project-folder-group');
                    if (folderGroup) {
                        folderGroup.style.display = select.value ? '' : 'none';
                    }
                    if (select.value) loadProjectFolders();
                };
            } catch (e) {
                console.warn('[Agent Offload] Failed to load devices:', e.message);
            }
        }

        function adjustAgentQty(agentType, delta) {
            const input = document.getElementById('qty-' + agentType);
            const newVal = Math.max(0, Math.min(5, parseInt(input.value || 0) + delta));
            input.value = newVal;
            updateTeamPreview();
        }

        function updateTeamPreview() {
            const preview = document.getElementById('team-preview');
            const icons = {
                'researcher': '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/></svg>',
                'coder': '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="16 18 22 12 16 6"/><polyline points="8 6 2 12 8 18"/></svg>',
                'worker': '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/></svg>',
                'analyst': '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="20" x2="18" y2="10"/><line x1="12" y1="20" x2="12" y2="4"/><line x1="6" y1="20" x2="6" y2="14"/></svg>'
            };
            const names = {
                'researcher': 'Researcher',
                'coder': 'Coder',
                'worker': 'Worker',
                'analyst': 'Analyst'
            };

            let html = '';
            ['researcher', 'coder', 'worker', 'analyst'].forEach(agent => {
                const qty = parseInt(document.getElementById('qty-' + agent)?.value || 0);
                for (let i = 0; i < qty; i++) {
                    const suffix = qty > 1 ? ` #${i + 1}` : '';
                    html += `<div class="team-node"><span>${icons[agent]}</span> ${names[agent]}${suffix}</div>`;
                }
            });

            preview.innerHTML = html || '<div class="team-node" style="opacity: 0.5">No agents selected</div>';
        }

        function getTeamComposition() {
            const team = [];
            ['researcher', 'coder', 'worker', 'analyst'].forEach(agent => {
                const qty = parseInt(document.getElementById('qty-' + agent)?.value || 0);
                for (let i = 0; i < qty; i++) {
                    team.push(agent);
                }
            });
            return team;
        }

        // Update preview on page load
        document.addEventListener('DOMContentLoaded', () => {
            updateTeamPreview();
        });

        function submitAgent() {
            if (currentSpawnMode === 'workflow') {
                submitWorkflow();
                return;
            }
            if (currentSpawnMode === 'specops') {
                submitSpecopsMission();
                return;
            }

            const task = document.getElementById('agent-task-input').value.trim();
            if (!task) {
                document.getElementById('agent-task-input').focus();
                return;
            }

            // Gather advanced options
            const context = document.getElementById('agent-context-input')?.value.trim() || null;
            const expectedOutputFormat = document.getElementById('agent-output-format')?.value || null;
            const priority = document.getElementById('agent-priority')?.value || 'normal';
            const resourcesRaw = document.getElementById('agent-resources-input')?.value.trim() || '';
            const resources = resourcesRaw ? resourcesRaw.split(',').map(r => r.trim()).filter(r => r) : null;

            // Build expected output description based on selection
            let expectedOutput = null;
            if (expectedOutputFormat) {
                const formatDescriptions = {
                    'summary': 'Provide a brief summary (2-3 paragraphs maximum)',
                    'detailed': 'Provide a comprehensive detailed report with sections',
                    'code': 'Output code only with minimal explanation',
                    'list': 'Format output as bullet points',
                    'json': 'Output structured JSON data'
                };
                expectedOutput = formatDescriptions[expectedOutputFormat];
            }

            const model = document.getElementById('agent-model-select')?.value || 'sonnet';
            const projectFolder = document.getElementById('agent-project-folder')?.value || null;
            const offloadDeviceId = document.getElementById('agent-offload-device')?.value || null;
            spawnAgentEnhanced(task, selectedAgentRole, context, expectedOutput, priority, resources, agentTimeout, model, projectFolder, offloadDeviceId);
            closeAgentPanel();
        }

        async function spawnAgentEnhanced(task, agentType, context, expectedOutput, priority, resources, timeout = 3600, model = 'sonnet', projectFolder = null, offloadDeviceId = null) {
            try {
                var payload = {
                    task,
                    agent_type: agentType,
                    context,
                    expected_output: expectedOutput,
                    priority,
                    resources,
                    timeout,
                    model
                };
                if (projectFolder) payload.project_folder = projectFolder;
                if (offloadDeviceId) payload.offload_device_id = offloadDeviceId;
                const response = await fetch(`${API_URL}/agents`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(payload)
                });

                const data = await response.json();
                console.log('Agent spawned:', data);
                // Add agent to local state immediately so it shows in the list
                const agentId = data.agent_id || data.id;
                if (agentId) {
                    agents[agentId] = {
                        id: agentId,
                        task: task,
                        status: data.status || 'queued',
                        call_sign: data.call_sign || data.name || agentId,
                        type: agentType,
                        created_at: new Date().toISOString(),
                        tools_used: [],
                        output: '',
                        source: 'user'
                    };
                }
                switchView('agents');
            } catch (e) {
                console.error('Failed to spawn agent:', e);
                cerebroAlert('Failed to spawn agent', { title: 'Error', danger: true });
            }
        }

        async function submitWorkflow() {
            const task = document.getElementById('workflow-task-input').value.trim();
            if (!task) {
                document.getElementById('workflow-task-input').focus();
                return;
            }

            // Get team composition with quantities
            const agentComposition = getTeamComposition();

            if (agentComposition.length === 0) {
                cerebroAlert('Please select at least one team member', { title: 'Missing Selection' });
                return;
            }

            try {
                const response = await fetch(`${API_URL}/workflows`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        task,
                        workflow_type: selectedWorkflowType,
                        agent_composition: agentComposition
                    })
                });

                const data = await response.json();
                console.log('Workflow deployed:', data);
                closeAgentPanel();
                switchView('agents');
            } catch (e) {
                console.error('Failed to deploy workflow:', e);
                cerebroAlert('Failed to deploy workflow', { title: 'Error', danger: true });
            }
        }

        // Handle agent updates from WebSocket
        // Debounced render for agent updates  prevents multiple full re-renders per second
        let _agentRenderPending = false;
        function _debouncedAgentRender() {
            if (_agentRenderPending) return;
            _agentRenderPending = true;
            requestAnimationFrame(() => {
                _agentRenderPending = false;
                renderAgents();
                updateCerebroStatus();
                if (_currentMindTab === 'agents') renderMindAgents();
                updateAgentsTabBadge();
            });
        }

        function handleAgentUpdate(agent) {
            agents[agent.id] = agent;

            // Link agent to directive chat message (agent link bar)
            if (agent.directive_id) {
                if (!_directiveAgentMap[agent.directive_id]) {
                    _directiveAgentMap[agent.directive_id] = {
                        agentId: agent.id,
                        callSign: agent.call_sign || agent.id
                    };
                    // Find and update the "Working on it..." message
                    const msg = cerebroChat.find(m => m.directiveId === agent.directive_id);
                    if (msg) {
                        msg.agentId = agent.id;
                        msg.agentCallSign = agent.call_sign || agent.id;
                        msg.agentStatus = agent.status;
                        renderChatMessages();
                        renderMindChat();
                    }
                }
                // Update agent link on status change (running  completed/failed)
                const linkedMsg = cerebroChat.find(m => m.directiveId === agent.directive_id);
                if (linkedMsg) {
                    linkedMsg.agentStatus = agent.status;
                    renderChatMessages();
                    renderMindChat();
                }
            }

            // Debounced render  coalesce rapid updates into one frame
            _debouncedAgentRender();

            // Live-stream to detail view if open for this agent
            if (currentDetailAgentId === agent.id) {
                updateAgentDetailStreaming(agent);
            }

            // Update unified panel if it's open for this agent
            if (agentPanelAgentId === agent.id && (agentPanelState === 'running')) {
                var runTaskEl = document.getElementById('panel-running-task');
                if (runTaskEl) runTaskEl.textContent = agent.task.slice(0, 120) + (agent.task.length > 120 ? '...' : '');

                // SpecOps panel updates
                if (agent.is_specops) {
                    updateSpecopsRunningPanel(agent);
                }
            }

            // Start polling fallback when agents are running (catches missed WebSocket events)
            if (agent.status === 'running' || agent.status === 'queued' || agent.status === 'cycling') {
                startAgentPolling();
            }
        }

        // Lightweight partial update for agent detail view (avoids full re-render)
        // Note: innerHTML usage here is safe - output comes from our own backend (Claude CLI)
        // and is rendered through marked.js (same as showAgentDetail). This is an internal tool,
        // not a public-facing app.
        let _lastStreamedOutputLen = 0;
        function updateAgentDetailStreaming(agent) {
            const outputDiv = document.querySelector('.agent-output-rendered');
            if (!outputDiv) return;

            const outputText = agent.output || 'No output captured yet.';

            // Only update if output actually changed
            if (outputText.length === _lastStreamedOutputLen) return;
            _lastStreamedOutputLen = outputText.length;

            // Update rendered output  sanitized via DOMPurify to prevent raw HTML injection from agent code
            try {
                outputDiv.innerHTML = safeAgentOutput(outputText);
            } catch (e) {
                outputDiv.textContent = outputText;
            }

            // Auto-scroll to bottom
            outputDiv.scrollTop = outputDiv.scrollHeight;

            // Update tools count and badges
            const toolsTitle = document.querySelector('.agent-section-title');
            if (toolsTitle && toolsTitle.textContent.includes('Tools Used')) {
                toolsTitle.textContent = '';
                toolsTitle.appendChild(document.createTextNode(' Tools Used (' + agent.tools_used.length + ')'));
            }
            const toolsList = document.querySelector('.agent-tools-list');
            if (toolsList && agent.tools_used.length > 0) {
                toolsList.textContent = '';
                agent.tools_used.forEach(t => {
                    const badge = document.createElement('span');
                    badge.className = 'agent-tool-badge';
                    badge.textContent = t;
                    toolsList.appendChild(badge);
                });
            }

            // Update status badge
            const statusBadge = document.getElementById('agent-page-status');
            if (statusBadge) {
                statusBadge.textContent = agent.status.toUpperCase();
                statusBadge.className = 'agent-status-badge ' + agent.status;
            }

            // Update duration display
            if (agent.started_at && !agent.completed_at) {
                const infoItems = document.querySelectorAll('.agent-info-item');
                infoItems.forEach(item => {
                    const label = item.querySelector('.label');
                    if (label && label.textContent === 'Duration:') {
                        const val = item.querySelector('.value');
                        if (val) val.textContent = formatDuration(new Date() - new Date(agent.started_at));
                    }
                });
            }
        }

        function handleAgentCompleted(agent) {
            agents[agent.id] = agent;

            // Update agent link bar status on completion
            if (agent.directive_id && _directiveAgentMap[agent.directive_id]) {
                const msg = cerebroChat.find(m => m.directiveId === agent.directive_id);
                if (msg) {
                    msg.agentStatus = agent.status || 'completed';
                    renderChatMessages();
                    renderMindChat();
                }
            }

            renderAgents();
            updateCerebroStatus();  // Update presence card
            if (_currentMindTab === 'agents') renderMindAgents();
            updateAgentsTabBadge();

            // Transition unified panel from running to detail if open for this agent
            if (agentPanelAgentId === agent.id && (agentPanelState === 'running' || agentPanelState === 'detail')) {
                setAgentPanelState('detail', agent.id);
            } else if (currentDetailAgentId === agent.id) {
                // Legacy detail page fallback
                showAgentDetail(agent.id);
            }

            // Show notification (skip in standalone  libnotify freezes renderer on Hyprland/Wayland)
            if (!window.__STANDALONE && Notification.permission === 'granted') {
                try {
                    new Notification('Agent Completed', {
                        body: agent.task.slice(0, 50) + '...'
                    });
                } catch (e) { /* notification daemon not available */ }
            }
        }

        // ==================== AGENT STATUS POLLING (WebSocket fallback) ====================
        // Polls running agents every 5s to catch completion events missed by WebSocket
        let _agentPollInterval = null;

        function startAgentPolling() {
            if (_agentPollInterval) return; // Already polling
            _agentPollInterval = setInterval(pollRunningAgents, 5000);
        }

        function stopAgentPolling() {
            if (_agentPollInterval) {
                clearInterval(_agentPollInterval);
                _agentPollInterval = null;
            }
        }

        async function pollRunningAgents() {
            const runningIds = Object.values(agents)
                .filter(a => a.status === 'running' || a.status === 'queued' || a.status === 'cycling')
                .map(a => a.id);

            if (runningIds.length === 0) {
                stopAgentPolling();
                return;
            }

            try {
                const response = await fetch(`${API_URL}/agents`, {
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                if (!response.ok) return;
                const data = await response.json();
                let changed = false;
                let specopsPanelNeedsUpdate = false;

                for (const serverAgent of data.agents) {
                    const local = agents[serverAgent.id];
                    if (!local) continue;
                    const isActive = local.status === 'running' || local.status === 'queued' || local.status === 'cycling';
                    if (!isActive) continue;

                    if (serverAgent.status !== local.status) {
                        // Status changed on server but we missed the WebSocket event
                        console.log(`[Poll] Agent ${serverAgent.id} status: ${local.status}  ${serverAgent.status}`);
                        agents[serverAgent.id] = serverAgent;
                        changed = true;

                        if (serverAgent.status === 'completed' || serverAgent.status === 'failed') {
                            // For SpecOps agents with auto_continue, don't trigger completion handler
                            // during inter-cycle transitions (status briefly hits 'completed' between cycles)
                            if (serverAgent.is_specops && serverAgent.auto_continue && serverAgent.status === 'completed') {
                                console.log(`[Poll] SpecOps agent ${serverAgent.id} completed a cycle  skipping handleAgentCompleted (auto_continue active)`);
                                // Update panel instead
                                if (agentPanelAgentId === serverAgent.id && agentPanelState === 'running') {
                                    specopsPanelNeedsUpdate = true;
                                }
                            } else {
                                handleAgentCompleted(serverAgent);
                            }
                        }
                    } else if (local.is_specops) {
                        // For SpecOps agents, sync data even when status hasn't changed
                        // (cycle completions update journal/output without changing status)
                        var dataChanged = false;
                        if (serverAgent.cycle_count !== local.cycle_count) dataChanged = true;
                        if ((serverAgent.mission_journal || []).length !== (local.mission_journal || []).length) dataChanged = true;
                        if ((serverAgent.accumulated_output || '').length !== (local.accumulated_output || '').length) dataChanged = true;
                        if ((serverAgent.output || '').length !== (local.output || '').length) dataChanged = true;

                        if (dataChanged) {
                            console.log(`[Poll] SpecOps agent ${serverAgent.id} data updated (cycle: ${local.cycle_count}  ${serverAgent.cycle_count})`);
                            agents[serverAgent.id] = serverAgent;
                            changed = true;
                            if (agentPanelAgentId === serverAgent.id && agentPanelState === 'running') {
                                specopsPanelNeedsUpdate = true;
                            }
                        }
                    }
                }

                if (changed) {
                    renderAgents();
                    updateCerebroStatus();
                    if (_currentMindTab === 'agents') renderMindAgents();
                    updateAgentsTabBadge();
                }
                if (specopsPanelNeedsUpdate) {
                    var panelAgent = agents[agentPanelAgentId];
                    if (panelAgent && panelAgent.is_specops) {
                        updateSpecopsRunningPanel(panelAgent);
                    }
                }
            } catch (e) {
                // Silent fail  WebSocket is primary, this is just fallback
            }
        }

        // ==================== AGENT DETAIL PAGE ====================
        let currentDetailAgentId = null;

        function showAgentDetail(agentId) {
            const agent = agents[agentId];
            if (!agent) {
                console.error('Agent not found:', agentId);
                return;
            }

            // Redirect to unified panel
            openAgentPanel('detail', agentId);
            return;

            // --- Legacy code below (kept for reference, unreachable) ---
            currentDetailAgentId = agentId;
            _lastStreamedOutputLen = 0;  // Reset streaming tracker for new agent

            // Initialize navigation stack (click funnel)
            if (!_skipNavStackReset) {
                _detailNavStack = [{ type: 'detail', agentId: agentId }];
            }

            // Mark agent as viewed
            fetch(`${API_URL}/agents/${agentId}/view`, {
                method: 'POST',
                headers: { 'Authorization': `Bearer ${token}` }
            }).catch(console.error);

            // Update header - use call sign if available, otherwise ID
            const agentType = agent.type || 'worker';
            const typeEmoji = agentType === 'researcher' ? '' :
                              agentType === 'coder' ? '' :
                              agentType === 'analyst' ? '' : '';

            const displayName = agent.call_sign || agent.id;
            let titleText = `${typeEmoji} Agent ${displayName}`;

            // Show continuation count if this agent has been continued
            if (agent.continuation_count && agent.continuation_count > 0) {
                titleText += ` [Run #${agent.continuation_count + 1}]`;
            }

            // Show parent relationship if this is a follow-up
            if (agent.parent_agent_id) {
                const parentAgent = agents[agent.parent_agent_id];
                const parentName = parentAgent ? (parentAgent.call_sign || parentAgent.id) : agent.parent_agent_id;
                titleText += ` ( from ${parentName})`;
            }

            document.getElementById('agent-page-title').textContent = titleText;

            // Clear chat messages and hide ask input
            document.getElementById('agent-chat-messages').innerHTML = '';
            document.getElementById('agent-ask-area').style.display = 'none';
            // Hide inline chat container  threads replace it
            document.getElementById('agent-chat-container').style.display = 'none';

            // Reset footer to agent detail mode
            document.getElementById('agent-detail-footer-actions').style.display = '';
            document.getElementById('thread-reply-footer-actions').style.display = 'none';

            const statusBadge = document.getElementById('agent-page-status');
            statusBadge.textContent = agent.status.toUpperCase();
            statusBadge.className = `agent-status-badge ${agent.status}`;

            // Calculate duration
            const duration = agent.completed_at && agent.started_at ?
                formatDuration(new Date(agent.completed_at) - new Date(agent.started_at)) :
                (agent.started_at ? 'Running...' : 'Queued');

            // Build tools HTML
            const toolsHtml = agent.tools_used.length > 0 ?
                agent.tools_used.map(t => `<span class="agent-tool-badge">${t}</span>`).join('') :
                '<span style="color: var(--text-muted);">No tools used yet</span>';

            // Get output and render as markdown (sanitized to prevent raw HTML injection)
            const outputText = agent.output || 'No output captured yet.';
            let renderedOutput = safeAgentOutput(outputText);

            // Extract recommendations from output
            const recommendations = extractRecommendations(outputText);

            // Build recommendations section
            let recommendationsHtml = '';
            if (recommendations.length > 0) {
                const recsItems = recommendations.map((rec, i) => `
                    <div class="recommendation-item">
                        <div class="recommendation-text">${escapeHtml(rec)}</div>
                        <button class="recommendation-btn" onclick="executeRecommendation(${i})">
                            Execute
                        </button>
                    </div>
                `).join('');

                recommendationsHtml = `
                    <div class="recommendations-section">
                        <div class="recommendations-title">
                             Recommended Actions
                        </div>
                        ${recsItems}
                    </div>
                `;
            }

            // Build sub-agents section (if this is a parent agent)
            // Filter to only show sub-agents from the CURRENT run (not previous tasks)
            let subAgentsHtml = '';
            const childAgents = Object.values(agents).filter(a =>
                a.parent_agent_id === agent.id && isCurrentRunSubAgent(a, agent)
            );
            if (childAgents.length > 0) {
                // Sort by created_at
                childAgents.sort((a, b) => new Date(a.created_at) - new Date(b.created_at));

                const subAgentCards = childAgents.map(child => {
                    const childStatusIcon = child.status === 'running' ? '' :
                                           child.status === 'completed' ? '' :
                                           child.status === 'failed' ? '' : '';
                    const childName = child.call_sign || child.id;

                    return `
                        <div class="sub-agent-nav-card ${child.status}" onclick="showAgentDetail('${child.id}')">
                            <div class="sub-agent-nav-name"> ${escapeHtml(childName)}</div>
                            <div class="sub-agent-nav-task">${escapeHtml(child.task.slice(0, 80))}${child.task.length > 80 ? '...' : ''}</div>
                            <span class="sub-agent-nav-status ${child.status}">${childStatusIcon} ${child.status.toUpperCase()}</span>
                        </div>
                    `;
                }).join('');

                subAgentsHtml = `
                    <div class="agent-section">
                        <div class="agent-section-title">
                             Sub-Agents (${childAgents.length})
                        </div>
                        <div class="sub-agents-nav">
                            ${subAgentCards}
                        </div>
                    </div>
                `;
            }

            // Build project dropdown options
            const projectOptions = Object.keys(agentProjects).map(pid => {
                const pName = agentProjects[pid].name || pid;
                const selected = agent.project_id === pid ? 'selected' : '';
                return '<option value="' + escapeHtml(pid) + '" ' + selected + '>' + escapeHtml(pName) + '</option>';
            }).join('');

            // Build the page content - render into output area (NOT page-content, to preserve chat)
            document.getElementById('agent-output-area').innerHTML = `
                <div class="agent-info-card">
                    <div class="agent-info-row">
                        <div class="agent-info-item">
                            <span class="label">Type:</span>
                            <span class="value">${agentType}</span>
                        </div>
                        <div class="agent-info-item">
                            <span class="label">Duration:</span>
                            <span class="value">${duration}</span>
                        </div>
                        <div class="agent-info-item">
                            <span class="label">Model:</span>
                            <span class="value">${(agent.model || 'sonnet').charAt(0).toUpperCase() + (agent.model || 'sonnet').slice(1)}</span>
                        </div>
                        <div class="agent-info-item">
                            <span class="label">Created:</span>
                            <span class="value">${new Date(agent.created_at).toLocaleString()}</span>
                        </div>
                        <div class="agent-info-item">
                            <span class="label">Project:</span>
                            <select class="agent-project-select" onchange="assignAgentProject('${agent.id}', this.value)">
                                <option value="" ${!agent.project_id ? 'selected' : ''}>None</option>
                                ${projectOptions}
                            </select>
                        </div>
                    </div>
                    <div class="agent-task-box">${escapeHtml(agent.task)}</div>
                </div>

                <div class="agent-section">
                    <div class="agent-section-title">
                         Tools Used (${agent.tools_used.length})
                    </div>
                    <div class="agent-tools-list">${toolsHtml}</div>
                </div>

                ${subAgentsHtml}

                ${agent.error ? `
                <div class="agent-section">
                    <div class="agent-section-title" style="color: var(--red);"> Error</div>
                    <div style="background: rgba(239,68,68,0.1); border: 1px solid var(--red); border-radius: 12px; padding: 14px; color: var(--red);">
                        ${escapeHtml(agent.error)}
                    </div>
                </div>
                ` : ''}

                ${recommendationsHtml}

                <div class="agent-section">
                    <div class="agent-section-title">
                         Output
                    </div>
                    <div class="agent-output-rendered">
                        ${renderedOutput}
                    </div>
                    <div style="display: flex; justify-content: flex-end; margin-top: 10px;">
                        <button class="chat-speak-btn" id="agent-output-speak-btn" title="Read output aloud" onclick="speakAgentOutput(this)">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/>
                                <path d="M15.54 8.46a5 5 0 0 1 0 7.07"/>
                                <path d="M19.07 4.93a10 10 0 0 1 0 14.14"/>
                            </svg>
                        </button>
                    </div>
                </div>
            `;

            // === Build threaded conversation cards ===
            const threadTree = buildThreadTree(agent.conversation || []);
            if (threadTree.length > 0) {
                const threadsSection = document.createElement('div');
                threadsSection.className = 'agent-section';
                threadsSection.style.marginTop = '24px';

                const threadsTitle = document.createElement('div');
                threadsTitle.className = 'agent-section-title';
                threadsTitle.textContent = 'Conversations (' + threadTree.length + ')';
                threadsSection.appendChild(threadsTitle);

                const threadsList = document.createElement('div');
                threadsList.id = 'agent-threads-list';
                threadsList.innerHTML = renderThreadCards(threadTree);
                threadsSection.appendChild(threadsList);

                document.getElementById('agent-output-area').appendChild(threadsSection);
            } else {
                // Empty threads container for new threads to appear in
                const emptyThreads = document.createElement('div');
                emptyThreads.id = 'agent-threads-list';
                document.getElementById('agent-output-area').appendChild(emptyThreads);
            }

            // === Build chain navigation ===
            buildAgentChainNav(agent);

            // === Update follow-up button and instructions textarea based on status ===
            const followupBtn = document.getElementById('followup-agent-btn');
            const rerunLink = document.getElementById('rerun-link');
            const instructionsContainer = document.getElementById('followup-instructions-container');
            const instructionsInput = document.getElementById('followup-instructions');

            // Ask input visibility
            const askThreadInput = document.getElementById('agent-ask-thread-input');
            if (askThreadInput) {
                askThreadInput.parentElement.style.display = (agent.status === 'running') ? 'none' : 'flex';
            }

            if (agent.status === 'completed' && !agent.error) {
                followupBtn.style.display = 'flex';
                followupBtn.textContent = ' Follow-up Command';
                followupBtn.onclick = spawnFollowUpAgent;
                rerunLink.style.display = 'block';
                instructionsContainer.style.display = 'block';
                instructionsInput.value = '';
                instructionsInput.placeholder = 'Enter a command for the new linked agent (e.g., "Now implement option 1" or "Execute the recommendations")...';
            } else if (agent.status === 'running') {
                followupBtn.style.display = 'none';
                rerunLink.style.display = 'none';
                instructionsContainer.style.display = 'none';
            } else {
                // Failed/error state - primary action is retry (re-run same agent)
                followupBtn.style.display = 'flex';
                followupBtn.textContent = ' Retry Task';
                followupBtn.onclick = executeAgentFollowUp;
                rerunLink.style.display = 'none';
                instructionsContainer.style.display = 'block';
                instructionsInput.value = '';
                instructionsInput.placeholder = 'Add instructions for the retry (e.g., "Try a different approach" or "Skip the failing step")...';
            }

            // Show the modal
            document.getElementById('agent-detail-page').classList.add('active');
            // Escape key to close
            document.addEventListener('keydown', _agentModalEscHandler);
        }

        function _agentModalEscHandler(e) {
            if (e.key === 'Escape') navigateBack();
        }

        function closeAgentDetailPage() {
            // Close unified panel (also closes old modal for safety)
            closeAgentPanel();
            document.getElementById('agent-detail-page').classList.remove('active');
            document.removeEventListener('keydown', _agentModalEscHandler);
            currentDetailAgentId = null;
            _detailNavStack = [];
        }

        // Legacy alias for compatibility
        function closeAgentDetailModal() {
            closeAgentDetailPage();
        }

        // Show agent detail from Recent Activity in Auto view
        async function showExecutionAgentDetail(agentId) {
            // Check if agent is already loaded
            if (!agents[agentId]) {
                // Try history first (for completed agents), then active agents
                let loaded = false;

                // Try history endpoint first
                try {
                    const historyResponse = await fetch(`${API_URL}/agents/history/${agentId}`, {
                        headers: { 'Authorization': `Bearer ${token}` }
                    });
                    if (historyResponse.ok) {
                        const agent = await historyResponse.json();
                        agent.tools_used = agent.tools_used || [];
                        agents[agentId] = agent;
                        loaded = true;
                    }
                } catch (e) {
                    console.log('History lookup failed, trying active agents');
                }

                // Try active agents endpoint if history failed
                if (!loaded) {
                    try {
                        const activeResponse = await fetch(`${API_URL}/agents/${agentId}`, {
                            headers: { 'Authorization': `Bearer ${token}` }
                        });
                        if (activeResponse.ok) {
                            const agent = await activeResponse.json();
                            agent.tools_used = agent.tools_used || [];
                            agents[agentId] = agent;
                            loaded = true;
                        }
                    } catch (e) {
                        console.log('Active agents lookup failed');
                    }
                }

                if (!loaded) {
                    showToast('Agent data no longer available. This is an older execution.', 'warning');
                    return;
                }
            }

            // Ensure tools_used exists before showing detail
            if (!agents[agentId].tools_used) {
                agents[agentId].tools_used = [];
            }

            // Show the agent detail page
            showAgentDetail(agentId);
        }

        // ==================== AGENT CHAT PAGE ====================
        let currentAgentChatId = null;
        let contextCollapsed = false;

        async function openAgentChatPage(agentId) {
            if (!agentId) return;

            currentAgentChatId = agentId;

            // Try to get agent from cache or load it
            let agent = agents[agentId];
            if (!agent) {
                try {
                    const response = await fetch(`${API_URL}/agents/history/${agentId}`, {
                        headers: { 'Authorization': `Bearer ${token}` }
                    });
                    if (response.ok) {
                        agent = await response.json();
                    }
                } catch (e) {
                    console.error('Failed to load agent:', e);
                }
            }

            if (!agent) {
                cerebroAlert('Agent not found', { title: 'Error', danger: true });
                return;
            }

            // Mark as viewed
            fetch(`${API_URL}/agents/${agentId}/view`, {
                method: 'POST',
                headers: { 'Authorization': `Bearer ${token}` }
            }).catch(console.error);

            // Update header
            const displayName = agent.call_sign || agent.id;
            const typeEmoji = agent.type === 'researcher' ? '' :
                              agent.type === 'coder' ? '' :
                              agent.type === 'analyst' ? '' : '';
            document.getElementById('agent-chat-page-title').textContent = `${typeEmoji} Agent ${displayName}`;

            const statusBadge = document.getElementById('agent-chat-page-status');
            statusBadge.textContent = agent.status.toUpperCase();
            statusBadge.className = `agent-status-badge ${agent.status}`;

            // Populate context summary
            document.getElementById('context-task').textContent = agent.task || 'No task';
            document.getElementById('context-output-preview').textContent =
                (agent.output || 'No output').slice(0, 300) + '...';

            // Reset context state
            contextCollapsed = false;
            document.getElementById('context-toggle-icon').classList.remove('collapsed');
            document.getElementById('context-details').classList.remove('collapsed');

            // Clear and load chat messages
            const messagesArea = document.getElementById('agent-chat-messages-area');
            messagesArea.innerHTML = '';

            // Load existing conversation
            try {
                const convResponse = await fetch(`${API_URL}/agents/${agentId}/conversation`, {
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                if (convResponse.ok) {
                    const convData = await convResponse.json();
                    const conversation = convData.conversation || [];
                    conversation.forEach(msg => {
                        addAgentChatPageMessage(msg.role, msg.content);
                    });
                }
            } catch (e) {
                console.error('Failed to load conversation:', e);
            }

            // Show the page
            document.getElementById('agent-chat-page').classList.add('active');

            // Focus input
            setTimeout(() => {
                document.getElementById('agent-chat-page-input').focus();
            }, 100);
        }

        function closeAgentChatPage() {
            document.getElementById('agent-chat-page').classList.remove('active');
            currentAgentChatId = null;
        }

        function toggleContextSummary() {
            contextCollapsed = !contextCollapsed;
            const icon = document.getElementById('context-toggle-icon');
            const details = document.getElementById('context-details');

            if (contextCollapsed) {
                icon.classList.add('collapsed');
                details.classList.add('collapsed');
            } else {
                icon.classList.remove('collapsed');
                details.classList.remove('collapsed');
            }
        }

        async function submitAgentChatQuestion() {
            const input = document.getElementById('agent-chat-page-input');
            const question = input.value.trim();

            if (!question || !currentAgentChatId) return;

            // Clear input
            input.value = '';

            // Get attached context refs
            const contextRefs = getContextRefsForSend();

            // Add user message
            addAgentChatPageMessage('user', question);

            // Add thinking indicator
            const thinkingId = addAgentChatPageMessage('assistant', ' Processing...', true);

            try {
                // Use background processing by default
                const response = await fetch(`${API_URL}/agents/${currentAgentChatId}/ask`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${token}`
                    },
                    body: JSON.stringify({
                        question: question,
                        background: false,  // Use synchronous for now - we handle via Socket.IO too
                        context_refs: contextRefs
                    })
                });

                const data = await response.json();

                // Remove thinking message
                const thinkingMsg = document.getElementById(thinkingId);
                if (thinkingMsg) thinkingMsg.remove();

                if (data.answer) {
                    addAgentChatPageMessage('assistant', data.answer);
                } else if (data.error) {
                    addAgentChatPageMessage('assistant', `Error: ${data.error}`);
                } else if (data.status === 'processing') {
                    addAgentChatPageMessage('assistant', 'Processing in background... You\'ll be notified when ready.');
                }

            } catch (e) {
                console.error('Submit error:', e);
                const thinkingMsg = document.getElementById(thinkingId);
                if (thinkingMsg) thinkingMsg.remove();
                addAgentChatPageMessage('assistant', 'Failed to send question. Please try again.');
            }
        }

        function addAgentChatPageMessage(role, content, isThinking = false) {
            const container = document.getElementById('agent-chat-messages-area');
            const msgId = `msg-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
            const label = role === 'user' ? 'You' : 'Claude';

            const msgEl = document.createElement('div');
            msgEl.id = msgId;
            msgEl.setAttribute('data-message-id', msgId);
            msgEl.setAttribute('data-text', content);
            msgEl.className = `agent-chat-page-message ${role}${isThinking ? ' thinking' : ''}`;
            const renderedContent = (role === 'assistant')
                ? safeAgentOutput(content)
                : escapeHtml(content);
            msgEl.innerHTML = `
                <div class="chat-label">${label}</div>
                <div class="chat-content">${renderedContent}</div>
            `;

            // Store in session for chunk mapping and add context menu
            if (!isThinking) {
                window.messageChunkMap[msgId] = {
                    content: content,
                    type: role,
                    timestamp: new Date().toISOString(),
                    chunk_id: null,
                    conversation_id: null
                };
                msgEl.classList.add('attachable');
            }

            container.appendChild(msgEl);
            container.scrollTop = container.scrollHeight;

            return msgId;
        }

        function extractRecommendations(text) {
            const recommendations = [];

            // Look for common recommendation patterns
            const patterns = [
                /(?:recommend|suggest|should|consider|try|install|add|create|implement)[:\s]+([^\n.!?]+[.!?]?)/gi,
                /\*\*(?:HIGH|MEDIUM|LOW)\*\*\s*[-]\s*([^\n]+)/gi,
                /(?:Priority|Action):\s*([^\n]+)/gi,
                /(?:Next steps?|To do|TODO)[:\s]*([^\n]+)/gi,
            ];

            for (const pattern of patterns) {
                let match;
                while ((match = pattern.exec(text)) !== null) {
                    const rec = match[1].trim();
                    if (rec.length > 10 && rec.length < 200 && !recommendations.includes(rec)) {
                        recommendations.push(rec);
                    }
                    if (recommendations.length >= 5) break;
                }
                if (recommendations.length >= 5) break;
            }

            // Also look for bullet points with action verbs
            const bulletPattern = /^[\s]*[-*]\s*((?:Add|Create|Install|Implement|Set up|Configure|Enable|Update|Fix|Build)[^.\n]+)/gim;
            let match;
            while ((match = bulletPattern.exec(text)) !== null && recommendations.length < 5) {
                const rec = match[1].trim();
                if (rec.length > 10 && !recommendations.includes(rec)) {
                    recommendations.push(rec);
                }
            }

            return recommendations.slice(0, 5);
        }

        function executeRecommendation(index) {
            const agent = agents[currentDetailAgentId];
            if (!agent) return;

            const recommendations = extractRecommendations(agent.output || '');
            if (index >= recommendations.length) return;

            const rec = recommendations[index];

            // Create a follow-up task based on the recommendation
            const followUpTask = `Based on the previous research (Agent #${agent.id}), execute this recommendation: ${rec}

Context from previous agent:
- Original task: ${agent.task}
- Tools used: ${agent.tools_used.join(', ')}

Please proceed with implementing this recommendation. You have full permissions.`;

            closeAgentDetailPage();
            spawnAgent(followUpTask, 'worker');
        }

        // Toggle the ask question input
        function toggleAgentAsk() {
            const askArea = document.getElementById('agent-ask-area');
            if (askArea.style.display === 'none') {
                askArea.style.display = 'flex';
                document.getElementById('agent-ask-input').focus();
            } else {
                askArea.style.display = 'none';
            }
        }

        // Submit a question about the agent's output
        async function submitAgentQuestion() {
            const input = document.getElementById('agent-ask-input');
            const question = input.value.trim();

            if (!question || !currentDetailAgentId) return;

            // Clear input
            input.value = '';

            // Add user message to chat
            addAgentChatMessage('user', question);

            // Show loading
            addAgentChatMessage('assistant', ' Thinking...');

            try {
                const response = await fetch(`${API_URL}/agents/${currentDetailAgentId}/ask`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${token}`
                    },
                    body: JSON.stringify({ question })
                });

                const data = await response.json();

                // Remove loading message
                const messages = document.getElementById('agent-chat-messages');
                const loadingMsg = messages.lastChild;
                if (loadingMsg && loadingMsg.textContent.includes('Thinking')) {
                    loadingMsg.remove();
                }

                if (data.answer) {
                    addAgentChatMessage('assistant', data.answer);
                } else if (data.error) {
                    addAgentChatMessage('assistant', `Error: ${data.error}`);
                }

            } catch (e) {
                console.error('Ask error:', e);
                const messages = document.getElementById('agent-chat-messages');
                const loadingMsg = messages.lastChild;
                if (loadingMsg) loadingMsg.remove();
                addAgentChatMessage('assistant', 'Failed to get response. Please try again.');
            }
        }

        // Add a message to the agent chat
        function addAgentChatMessage(role, content) {
            const container = document.getElementById('agent-chat-messages');
            const label = role === 'user' ? 'You' : 'Claude';
            const msgId = `msg-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;

            const msgDiv = document.createElement('div');
            msgDiv.className = `agent-chat-message ${role}`;
            msgDiv.setAttribute('data-message-id', msgId);
            msgDiv.setAttribute('data-text', content);
            msgDiv.innerHTML = `
                <div class="chat-label">${label}</div>
                <div class="chat-content">${role === 'assistant' ? safeAgentOutput(content) : escapeHtml(content)}</div>
            `;

            // Store in session for chunk mapping and add context menu
            window.messageChunkMap[msgId] = {
                content: content,
                type: role,
                timestamp: new Date().toISOString(),
                chunk_id: null,
                conversation_id: null
            };
            msgDiv.classList.add('attachable');

            container.appendChild(msgDiv);

            // Scroll to bottom
            const pageContent = document.getElementById('agent-page-content');
            pageContent.scrollTop = pageContent.scrollHeight;
        }

        // Render existing conversation
        function renderAgentConversation(conversation) {
            conversation.forEach(msg => {
                addAgentChatMessage(msg.role, msg.content);
            });
        }

        // ========== THREADED CONVERSATIONS (Click Funnel) ==========

        let _detailNavStack = []; // [{type:'detail', agentId}, {type:'thread', threadId}]
        let _skipNavStackReset = false;

        // Build a tree of Q&A threads from a flat conversation array
        function buildThreadTree(conversation) {
            if (!conversation || conversation.length === 0) return [];

            const threadMap = {};
            let legacyIndex = 0;

            for (const msg of conversation) {
                let tid = msg.thread_id;
                if (!tid) {
                    // Legacy messages without thread_id: pair user+assistant
                    if (msg.role === 'user') {
                        tid = 'legacy-' + legacyIndex;
                        legacyIndex++;
                    } else if (msg.role === 'assistant') {
                        tid = 'legacy-' + (legacyIndex > 0 ? legacyIndex - 1 : 0);
                    }
                }

                if (!threadMap[tid]) {
                    threadMap[tid] = {
                        thread_id: tid,
                        parent_thread_id: msg.parent_thread_id || null,
                        question: '',
                        answer: '',
                        timestamp: msg.timestamp || null,
                        children: []
                    };
                }

                if (msg.role === 'user') {
                    threadMap[tid].question = msg.content;
                    if (!threadMap[tid].timestamp) threadMap[tid].timestamp = msg.timestamp;
                } else if (msg.role === 'assistant') {
                    threadMap[tid].answer = msg.content;
                }
            }

            // Build tree from flat map
            const roots = [];
            for (const t of Object.values(threadMap)) {
                if (t.parent_thread_id && threadMap[t.parent_thread_id]) {
                    threadMap[t.parent_thread_id].children.push(t);
                } else {
                    roots.push(t);
                }
            }

            // Sort by timestamp
            const sortFn = (a, b) => (a.timestamp || '').localeCompare(b.timestamp || '');
            roots.sort(sortFn);
            for (const t of Object.values(threadMap)) {
                t.children.sort(sortFn);
            }

            return roots;
        }

        // Recursive search for a thread by ID
        function findThreadById(threads, threadId) {
            for (const t of threads) {
                if (t.thread_id === threadId) return t;
                const found = findThreadById(t.children, threadId);
                if (found) return found;
            }
            return null;
        }

        // Render thread cards HTML for a list of threads
        function renderThreadCards(threads) {
            if (!threads || threads.length === 0) return '';
            return threads.map(t => {
                const qPreview = escapeHtml((t.question || '').slice(0, 120)) + (t.question && t.question.length > 120 ? '...' : '');
                const aPreview = escapeHtml((t.answer || '').slice(0, 150)) + (t.answer && t.answer.length > 150 ? '...' : '');
                const timeStr = t.timestamp ? formatTimeAgo(new Date(t.timestamp)) : '';
                const replyCount = t.children.length;
                return '<div class="thread-card" onclick="navigateToThread(\'' + t.thread_id + '\')">'
                    + '<div class="thread-question">' + qPreview + '</div>'
                    + '<div class="thread-preview">' + aPreview + '</div>'
                    + '<div class="thread-meta">'
                    + '<span>' + timeStr + '</span>'
                    + (replyCount > 0 ? '<span class="reply-count">' + replyCount + ' repl' + (replyCount === 1 ? 'y' : 'ies') + '</span>' : '')
                    + '</div></div>';
            }).join('');
        }

        // Navigate into a thread (push onto stack)
        function navigateToThread(threadId) {
            _detailNavStack.push({ type: 'thread', threadId });
            _renderThreadView(threadId);
        }

        // Navigate back (pop from stack)
        function navigateBack() {
            if (_detailNavStack.length > 1) {
                _detailNavStack.pop();
                const view = _detailNavStack[_detailNavStack.length - 1];
                if (view.type === 'detail') {
                    _skipNavStackReset = true;
                    showAgentDetail(view.agentId);
                    _skipNavStackReset = false;
                } else if (view.type === 'thread') {
                    _renderThreadView(view.threadId);
                }
            } else {
                closeAgentDetailPage();
            }
        }

        // Render thread view inside the agent detail modal
        function _renderThreadView(threadId) {
            const agent = agents[currentDetailAgentId];
            if (!agent) return;

            const tree = buildThreadTree(agent.conversation || []);
            const thread = findThreadById(tree, threadId);
            if (!thread) return;

            // Update header with back button
            const titleEl = document.getElementById('agent-page-title');
            titleEl.textContent = '';
            const backSpan = document.createElement('span');
            backSpan.className = 'thread-back-btn';
            backSpan.textContent = '\u2190';
            backSpan.onclick = navigateBack;
            titleEl.appendChild(backSpan);
            titleEl.appendChild(document.createTextNode(' Thread'));
            document.getElementById('agent-page-status').textContent = '';

            // Build answer HTML (markdown-rendered, sanitized)
            let answerContent = thread.answer ? safeAgentOutput(thread.answer) : escapeHtml('Waiting for response...');

            // Build child threads HTML
            let childThreadsHtml = '';
            if (thread.children.length > 0) {
                childThreadsHtml = '<div class="agent-section" style="margin-top: 24px;">'
                    + '<div class="agent-section-title">Replies (' + thread.children.length + ')</div>'
                    + renderThreadCards(thread.children)
                    + '</div>';
            }

            // Build exchange HTML
            const outputArea = document.getElementById('agent-output-area');
            outputArea.textContent = ''; // Clear safely

            const exchangeDiv = document.createElement('div');
            exchangeDiv.className = 'thread-exchange';

            const userBubble = document.createElement('div');
            userBubble.className = 'thread-bubble user';
            const userLabel = document.createElement('div');
            userLabel.className = 'chat-label';
            userLabel.textContent = 'You';
            const userContent = document.createElement('div');
            userContent.className = 'chat-content';
            userContent.textContent = thread.question;
            userBubble.appendChild(userLabel);
            userBubble.appendChild(userContent);

            const assistantBubble = document.createElement('div');
            assistantBubble.className = 'thread-bubble assistant';
            const assistantLabel = document.createElement('div');
            assistantLabel.className = 'chat-label';
            assistantLabel.textContent = 'Agent';
            const assistantContent = document.createElement('div');
            assistantContent.className = 'chat-content';
            // Use innerHTML for markdown-rendered content (same pattern as rest of codebase)
            assistantContent.innerHTML = answerContent;
            assistantBubble.appendChild(assistantLabel);
            assistantBubble.appendChild(assistantContent);

            exchangeDiv.appendChild(userBubble);
            exchangeDiv.appendChild(assistantBubble);
            outputArea.appendChild(exchangeDiv);

            // Append child threads
            if (childThreadsHtml) {
                const childDiv = document.createElement('div');
                childDiv.innerHTML = childThreadsHtml;
                while (childDiv.firstChild) outputArea.appendChild(childDiv.firstChild);
            }

            // Switch footer to thread reply mode
            document.getElementById('agent-detail-footer-actions').style.display = 'none';
            const replyActions = document.getElementById('thread-reply-footer-actions');
            replyActions.style.display = 'flex';
            const replyInput = document.getElementById('thread-reply-input');
            replyInput.setAttribute('data-parent-thread-id', threadId);
            setTimeout(function() { replyInput.focus(); }, 100);

            // Hide chain nav and inline chat container
            document.getElementById('agent-chain-nav').style.display = 'none';
            document.getElementById('agent-chat-container').style.display = 'none';

            // Scroll to top
            document.getElementById('agent-page-content').scrollTop = 0;
        }

        // Submit a new top-level thread (ask question from agent detail)
        async function submitNewThread() {
            const input = document.getElementById('agent-ask-thread-input');
            const question = input.value.trim();
            if (!question || !currentDetailAgentId) return;

            input.value = '';

            // Show loading card in threads area
            const threadsContainer = document.getElementById('agent-threads-list');
            let loadingCard;
            if (threadsContainer) {
                loadingCard = document.createElement('div');
                loadingCard.className = 'thread-card loading';
                loadingCard.textContent = question + '  Processing...';
                threadsContainer.appendChild(loadingCard);
            }

            try {
                const response = await fetch(API_URL + '/agents/' + currentDetailAgentId + '/ask', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': 'Bearer ' + token
                    },
                    body: JSON.stringify({
                        question: question,
                        parent_thread_id: null,
                        context_refs: getContextRefsForSend()
                    })
                });

                const data = await response.json();
                if (loadingCard) loadingCard.remove();

                if (data.answer) {
                    const agent = agents[currentDetailAgentId];
                    if (agent) {
                        if (!agent.conversation) agent.conversation = [];
                        const threadId = data.thread_id || ('thread-' + Date.now());
                        const nowTs = new Date().toISOString();
                        agent.conversation.push({
                            role: 'user', content: question, timestamp: nowTs,
                            thread_id: threadId, parent_thread_id: null
                        });
                        agent.conversation.push({
                            role: 'assistant', content: data.answer, timestamp: nowTs,
                            thread_id: threadId, parent_thread_id: null
                        });
                    }
                    // Re-render agent detail to show new thread card
                    _skipNavStackReset = true;
                    showAgentDetail(currentDetailAgentId);
                    _skipNavStackReset = false;
                } else if (data.error) {
                    showToast('Error: ' + data.error, 'error');
                } else if (data.status === 'processing') {
                    showToast('Processing in background...', 'info');
                }
            } catch (e) {
                if (loadingCard) loadingCard.remove();
                showToast('Failed: ' + e.message, 'error');
            }
        }

        // Submit a reply within a thread (creates child thread)
        async function submitThreadReply() {
            const input = document.getElementById('thread-reply-input');
            const question = input.value.trim();
            const parentThreadId = input.getAttribute('data-parent-thread-id');
            if (!question || !currentDetailAgentId || !parentThreadId) return;

            input.value = '';

            // Show loading in content area
            const loadingEl = document.createElement('div');
            loadingEl.className = 'thread-card loading';
            loadingEl.textContent = question + '  Processing...';
            document.getElementById('agent-output-area').appendChild(loadingEl);

            try {
                const response = await fetch(API_URL + '/agents/' + currentDetailAgentId + '/ask', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': 'Bearer ' + token
                    },
                    body: JSON.stringify({
                        question: question,
                        parent_thread_id: parentThreadId,
                        context_refs: getContextRefsForSend()
                    })
                });

                const data = await response.json();
                loadingEl.remove();

                if (data.answer) {
                    const agent = agents[currentDetailAgentId];
                    if (agent) {
                        if (!agent.conversation) agent.conversation = [];
                        const threadId = data.thread_id || ('thread-' + Date.now());
                        const nowTs = new Date().toISOString();
                        agent.conversation.push({
                            role: 'user', content: question, timestamp: nowTs,
                            thread_id: threadId, parent_thread_id: parentThreadId
                        });
                        agent.conversation.push({
                            role: 'assistant', content: data.answer, timestamp: nowTs,
                            thread_id: threadId, parent_thread_id: parentThreadId
                        });
                    }
                    // Re-render current thread view to show new reply
                    _renderThreadView(parentThreadId);
                } else if (data.error) {
                    showToast('Error: ' + data.error, 'error');
                }
            } catch (e) {
                loadingEl.remove();
                showToast('Failed: ' + e.message, 'error');
            }
        }

        // Execute Task - continue work on existing agent (preserves identity)
        async function executeAgentFollowUp() {
            const agent = agents[currentDetailAgentId];
            if (!agent) {
                showToast('Agent not found', 'error');
                return;
            }

            const displayName = agent.call_sign || agent.id;

            // Get custom instructions from textarea
            const customInstructions = document.getElementById('followup-instructions')?.value?.trim() || '';

            // Build continuation instructions based on agent state + custom input
            let instructions = '';
            if (agent.error || agent.status === 'failed') {
                instructions = `The previous attempt failed with error: ${agent.error || 'Unknown error'}. Please retry with a different approach.`;
                if (customInstructions) {
                    instructions += `\n\nUser's specific instructions: ${customInstructions}`;
                }
            } else if (customInstructions) {
                // User provided specific instructions - use those
                instructions = customInstructions;
            } else {
                // Default instructions
                instructions = 'Continue from where you left off. Review your previous work and proceed with any remaining tasks. If you completed research, now take ACTION on the recommendations.';
            }

            try {
                // Show loading state on re-run link
                const rerunEl = document.getElementById('rerun-link');
                if (rerunEl) {
                    rerunEl.style.pointerEvents = 'none';
                    rerunEl.textContent = 'Re-running...';
                }

                // Call the continue endpoint (NOT spawning new agent!)
                const response = await fetch(`${API_URL}/agents/${agent.id}/continue`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ instructions })
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.detail || 'Failed to continue agent');
                }

                const result = await response.json();

                // Update UI - agent keeps SAME identity
                showToast(`Agent ${result.call_sign} is continuing (run #${result.continuation_count})...`, 'success');

                // Update agent status in local cache
                if (agents[result.agent_id]) {
                    agents[result.agent_id].status = 'running';
                    agents[result.agent_id].continuation_count = result.continuation_count;
                }

                // Close detail page and switch to agents view
                closeAgentDetailPage();
                switchView('agents');

                // Reload agents list to show updated status
                await loadAgents();

            } catch (error) {
                console.error('Follow-up error:', error);
                showToast(`Failed to continue agent: ${error.message}`, 'error');

                const rerunEl2 = document.getElementById('rerun-link');
                if (rerunEl2) {
                    rerunEl2.style.pointerEvents = '';
                    rerunEl2.textContent = 'Re-run same agent';
                }
            }
        }

        // Spawn a new agent linked to the current one (follow-up command)
        function spawnFollowUpAgent() {
            const agent = agents[currentDetailAgentId];
            if (!agent) {
                showToast('Agent not found', 'error');
                return;
            }

            const instructions = document.getElementById('followup-instructions')?.value?.trim() || '';
            if (!instructions) {
                showToast('Enter a command for the new agent', 'warning');
                document.getElementById('followup-instructions')?.focus();
                return;
            }

            const displayName = agent.call_sign || agent.id;

            // Set the parent linkage (existing mechanism used by spawnAgent)
            window.pendingFollowUpParent = agent;

            // Close modal and spawn
            closeAgentDetailPage();
            showToast('Spawning follow-up agent linked to ' + displayName + '...', 'info');
            spawnAgent(instructions, 'worker');
        }

        // Build chain navigation bar for agent detail view
        function buildAgentChainNav(agent) {
            const chainNav = document.getElementById('agent-chain-nav');
            if (!chainNav) return;

            // Clear existing
            chainNav.textContent = '';
            let hasChain = false;

            // Walk up the full parent chain
            const ancestors = [];
            let current = agent;
            while (current.parent_agent_id && agents[current.parent_agent_id]) {
                ancestors.unshift(agents[current.parent_agent_id]);
                current = agents[current.parent_agent_id];
                if (ancestors.length > 10) break; // safety
            }

            // Render ancestors
            ancestors.forEach(function(ancestor) {
                const item = document.createElement('span');
                item.className = 'chain-nav-item';
                item.textContent = ancestor.call_sign || ancestor.id;
                item.onclick = function() { showAgentDetail(ancestor.id); };
                chainNav.appendChild(item);

                const sep = document.createElement('span');
                sep.className = 'chain-nav-separator';
                sep.textContent = '';
                chainNav.appendChild(sep);
                hasChain = true;
            });

            // Current agent (not clickable)
            const currentItem = document.createElement('span');
            currentItem.className = 'chain-nav-item current';
            currentItem.textContent = agent.call_sign || agent.id;
            chainNav.appendChild(currentItem);

            // Child agents
            const children = Object.values(agents).filter(function(a) {
                return a.parent_agent_id === agent.id;
            });
            if (children.length > 0) {
                children.sort(function(a, b) { return new Date(a.created_at) - new Date(b.created_at); });
                children.forEach(function(child) {
                    const sep = document.createElement('span');
                    sep.className = 'chain-nav-separator';
                    sep.textContent = '';
                    chainNav.appendChild(sep);

                    const childItem = document.createElement('span');
                    childItem.className = 'chain-nav-item';
                    childItem.textContent = child.call_sign || child.id;
                    childItem.onclick = function() { showAgentDetail(child.id); };
                    chainNav.appendChild(childItem);
                    hasChain = true;
                });
            }

            chainNav.style.display = hasChain ? 'flex' : 'none';
        }

        function buildPanelChainNav(agent) {
            var chainNav = document.getElementById('panel-chain-nav');
            if (!chainNav) return;
            chainNav.textContent = '';
            var hasChain = false;

            // Walk up parent chain
            var ancestors = [];
            var current = agent;
            while (current.parent_agent_id && agents[current.parent_agent_id]) {
                ancestors.unshift(agents[current.parent_agent_id]);
                current = agents[current.parent_agent_id];
                if (ancestors.length > 10) break;
            }

            ancestors.forEach(function(ancestor) {
                var item = document.createElement('span');
                item.className = 'chain-nav-item';
                item.textContent = ancestor.call_sign || ancestor.id;
                item.onclick = function() { openAgentPanel('detail', ancestor.id); };
                chainNav.appendChild(item);
                var sep = document.createElement('span');
                sep.className = 'chain-nav-separator';
                sep.textContent = '\u203A';
                chainNav.appendChild(sep);
                hasChain = true;
            });

            // Current agent
            var currentItem = document.createElement('span');
            currentItem.className = 'chain-nav-item current';
            currentItem.textContent = agent.call_sign || agent.id;
            chainNav.appendChild(currentItem);

            // Children
            var children = Object.values(agents).filter(function(a) {
                return a.parent_agent_id === agent.id;
            });
            if (children.length > 0) {
                children.sort(function(a, b) { return new Date(a.created_at) - new Date(b.created_at); });
                children.forEach(function(child) {
                    var sep = document.createElement('span');
                    sep.className = 'chain-nav-separator';
                    sep.textContent = '\u203A';
                    chainNav.appendChild(sep);
                    var childItem = document.createElement('span');
                    childItem.className = 'chain-nav-item';
                    childItem.textContent = child.call_sign || child.id;
                    childItem.onclick = function() { openAgentPanel('detail', child.id); };
                    chainNav.appendChild(childItem);
                    hasChain = true;
                });
            }

            chainNav.style.display = hasChain ? 'flex' : 'none';
        }

        function formatDuration(ms) {
            const seconds = Math.floor(ms / 1000);
            if (seconds < 60) return `${seconds}s`;
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = seconds % 60;
            if (minutes < 60) return `${minutes}m ${remainingSeconds}s`;
            const hours = Math.floor(minutes / 60);
            const remainingMinutes = minutes % 60;
            return `${hours}h ${remainingMinutes}m`;
        }

        function speakAgentOutput(btnElement) {
            var agent = agents[currentDetailAgentId];
            if (!agent || !agent.output) {
                showToast('No output to read', 'warning');
                return;
            }
            speakText(agent.output, btnElement);
        }

        function copyAgentOutput() {
            const agent = agents[currentDetailAgentId];
            if (!agent || !agent.output) {
                cerebroAlert('No output to copy', { title: 'Nothing to Copy' });
                return;
            }

            navigator.clipboard.writeText(agent.output).then(() => {
                // Find the copy button (could be in footer)
                const btns = document.querySelectorAll('.agent-action-btn.secondary');
                btns.forEach(btn => {
                    if (btn.textContent.includes('Copy')) {
                        btn.innerHTML = ' Copied!';
                        setTimeout(() => {
                            btn.innerHTML = ' Copy';
                        }, 2000);
                    }
                });
            }).catch(err => {
                console.error('Copy failed:', err);
                // Fallback
                const textarea = document.createElement('textarea');
                textarea.value = agent.output;
                document.body.appendChild(textarea);
                textarea.select();
                document.execCommand('copy');
                document.body.removeChild(textarea);
            });
        }

        // ==================== NAVIGATION ====================
        let currentView = 'home';
        const VIEW_ORDER = { home: 0, chat: 1, agents: 2, autonomy: 3, automation: 4, settings: 5 };

        function _switchViewCore(viewName) {
            currentView = viewName;
            // Close any open slide panels when switching views
            closeSlidePanel();

            document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
            document.querySelectorAll('.nav-item').forEach(n => n.classList.remove('active'));

            const view = document.getElementById(`view-${viewName}`);
            if (view) view.classList.add('active');

            const nav = document.querySelector(`.nav-item[data-view="${viewName}"]`);
            if (nav) nav.classList.add('active');

            // Lock main-content scroll when in chat (messages-container handles its own scroll)
            const mainContent = document.querySelector('.main-content');
            if (mainContent) {
                mainContent.style.overflowY = (viewName === 'chat') ? 'hidden' : '';
            }
            // Scroll main content to top when switching views (except chat)
            if (mainContent && viewName !== 'chat') {
                mainContent.scrollTo({ top: 0, behavior: 'instant' });
            }

            // Show/hide chat input and FAB menu based on view
            const chatInput = document.querySelector('.chat-input-area');
            const chatFab = document.getElementById('chat-fab-container');
            if (viewName === 'chat') {
                if (chatInput) {
                    chatInput.style.opacity = '0';
                    chatInput.style.display = 'block';
                    requestAnimationFrame(function() {
                        chatInput.style.opacity = '1';
                    });
                }
                if (chatFab) chatFab.classList.add('visible');
                // Scroll to latest message when entering chat
                setTimeout(function() { scrollMessagesToBottom(); }, 50);
            } else {
                if (chatInput) { chatInput.style.display = 'none'; chatInput.style.opacity = ''; }
                if (chatFab) { chatFab.classList.remove('visible'); closeChatFab(); }
            }

            // Refresh homepage stats when switching to home view
            if (viewName === 'home') {
                loadHomepage();
            }

            // Load agents when switching to agents view
            if (viewName === 'agents') {
                loadAgents();
            }

            // Load autonomy status when switching to autonomy view
            if (viewName === 'autonomy') {
                loadAutonomyStatus();
            }

            // Load schedules when switching to automation view
            if (viewName === 'automation') {
                loadSchedules();
                loadExecutionHistory();
            }

            // Initialize settings sidebar when switching to settings view
            if (viewName === 'settings') {
                restoreSettingsSidebarState();
                updateSettingsProfileCard();
                switchSettingsSection('general');
            }
        }

        function switchView(viewName, instant) {
            if (instant || isViewTransitioning || viewName === currentView) {
                _switchViewCore(viewName);
                if (viewName === 'chat') {
                    setTimeout(function() { scrollMessagesToBottom(true); }, 50);
                }
                return;
            }

            isViewTransitioning = true;

            // Step 1: Fade in translucent overlay (hides everything briefly)
            var overlay = document.createElement('div');
            overlay.className = 'view-transition-overlay';
            document.body.appendChild(overlay);
            overlay.offsetHeight; // force reflow
            overlay.classList.add('active');

            // Step 2: After overlay is opaque, switch view underneath
            setTimeout(function() {
                _switchViewCore(viewName);

                var newViewEl = document.getElementById('view-' + viewName);
                if (newViewEl) {
                    // Hide content while it loads behind overlay
                    newViewEl.classList.add('view-entering');
                    newViewEl.classList.remove('view-entered');
                }

                // Step 3: Wait for content to render, then reveal
                setTimeout(function() {
                    // For chat view: scroll to bottom BEFORE revealing (so it's already at bottom)
                    if (viewName === 'chat') {
                        scrollMessagesToBottom(true); // instant scroll
                        var chatInputEl = document.getElementById('chat-input');
                        if (chatInputEl) chatInputEl.focus();
                    }

                    // Fade overlay away
                    overlay.classList.remove('active');
                    overlay.classList.add('fade-out');

                    if (newViewEl) {
                        // Reveal content with smooth entrance
                        newViewEl.classList.remove('view-entering');
                        newViewEl.classList.add('view-entered');
                        retriggerStaggerAnimations(newViewEl);

                        // Clean up transition class after animations complete
                        setTimeout(function() {
                            newViewEl.classList.remove('view-entered');
                        }, 500);
                    }

                    // Remove overlay element after it fades out
                    setTimeout(function() {
                        if (overlay.parentNode) overlay.parentNode.removeChild(overlay);
                        isViewTransitioning = false;
                    }, 300);
                }, 120); // brief wait for content to render behind overlay
            }, 160); // wait for overlay fade-in
        }

        function retriggerStaggerAnimations(viewEl) {
            viewEl.querySelectorAll('.stagger-in').forEach(function(el) {
                el.style.animation = 'none';
                el.offsetHeight; // force reflow
                el.style.animation = '';
            });
            // Also retrigger nth-child based staggers (agent-card, interest-card, stat-pill)
            viewEl.querySelectorAll('.agent-card, .interest-card, .stat-pill').forEach(function(el) {
                el.style.animation = 'none';
                el.offsetHeight;
                el.style.animation = '';
            });
        }

        // Chat FAB (floating action button) menu toggle
        function toggleChatFab() {
            const btn = document.getElementById('chat-fab-btn');
            const menu = document.getElementById('chat-fab-menu');
            if (btn && menu) {
                btn.classList.toggle('open');
                menu.classList.toggle('open');
            }
        }

        function closeChatFab() {
            const btn = document.getElementById('chat-fab-btn');
            const menu = document.getElementById('chat-fab-menu');
            if (btn && menu) {
                btn.classList.remove('open');
                menu.classList.remove('open');
            }
        }

        // Close FAB menu when clicking outside
        document.addEventListener('click', (e) => {
            const container = document.getElementById('chat-fab-container');
            if (container && !container.contains(e.target)) {
                closeChatFab();
            }
            // Also close model dropdown when clicking outside
            const modelWrapper = document.querySelector('.model-selector-wrapper');
            if (modelWrapper && !modelWrapper.contains(e.target)) {
                closeModelDropdown();
            }
        });

        // ==================== MODEL SELECTOR ====================
        const MODEL_OPTIONS = {
            'claude-opus-4-6': { label: 'Opus 4.6', fullName: 'Claude Opus 4.6', dotClass: 'opus', desc: 'Most capable' },
            'claude-sonnet-4-6': { label: 'Sonnet 4.6', fullName: 'Claude Sonnet 4.6', dotClass: 'sonnet46', desc: 'Fast & intelligent' },
            'claude-sonnet-4-5-20250929': { label: 'Sonnet 4.5', fullName: 'Claude Sonnet 4.5', dotClass: 'sonnet', desc: 'Balanced' },
            'claude-haiku-4-5-20251001': { label: 'Haiku 4.5', fullName: 'Claude Haiku 4.5', dotClass: 'haiku', desc: 'Fastest' }
        };

        let selectedModel = localStorage.getItem('cerebro_selected_model') || 'claude-sonnet-4-5-20250929';

        function initModelSelector() {
            // Validate stored model
            if (!MODEL_OPTIONS[selectedModel]) {
                selectedModel = 'claude-sonnet-4-5-20250929';
            }
            updateModelSelectorUI();
        }

        function toggleModelDropdown() {
            const btn = document.getElementById('model-selector-btn');
            const dropdown = document.getElementById('model-dropdown');
            if (btn && dropdown) {
                btn.classList.toggle('open');
                dropdown.classList.toggle('open');
            }
        }

        function closeModelDropdown() {
            const btn = document.getElementById('model-selector-btn');
            const dropdown = document.getElementById('model-dropdown');
            if (btn && dropdown) {
                btn.classList.remove('open');
                dropdown.classList.remove('open');
            }
        }

        function selectModel(modelId) {
            if (!MODEL_OPTIONS[modelId]) return;
            selectedModel = modelId;
            localStorage.setItem('cerebro_selected_model', modelId);
            updateModelSelectorUI();
            closeModelDropdown();
            // Sync model selection to server and other devices
            if (socket && socket.connected) {
                socket.emit('change_model', { model: modelId });
            }
        }

        async function fetchModelsFromServer() {
            try {
                const response = await fetch(`${API_URL}/api/models`, {
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                const data = await response.json();
                if (data.models && Array.isArray(data.models)) {
                    console.log('[Model] Loaded models from server:', data.models.length);
                    // Validate current selection against server models
                    const serverModelIds = new Set(data.models.map(m => m.id));
                    if (!serverModelIds.has(selectedModel)) {
                        console.log('[Model] Selected model not available on server, falling back to default');
                        selectedModel = data.default || 'claude-sonnet-4-5-20250929';
                        localStorage.setItem('cerebro_selected_model', selectedModel);
                        updateModelSelectorUI();
                    }
                }
            } catch (e) {
                console.warn('[Model] Failed to fetch models from server:', e.message);
                // Continue with local defaults - non-critical
            }
        }

        function updateModelSelectorUI() {
            const info = MODEL_OPTIONS[selectedModel];
            if (!info) return;

            // Update old selector button (hidden but kept for compat)
            const label = document.getElementById('model-selector-label');
            const dot = document.getElementById('model-dot-indicator');
            if (label) label.textContent = info.label;
            if (dot) dot.className = 'model-dot ' + info.dotClass;

            // Update NEW input bar model selector
            const inputLabel = document.getElementById('input-model-label');
            const inputDot = document.getElementById('input-model-dot');
            if (inputLabel) inputLabel.textContent = info.label;
            if (inputDot) inputDot.className = 'model-dot ' + info.dotClass;

            // Update dropdown selected state (both old and new dropdowns)
            document.querySelectorAll('.model-option').forEach(opt => {
                opt.classList.toggle('selected', opt.dataset.model === selectedModel);
            });

            // Close input dropdown after selection
            closeInputModelDropdown();

            // Update settings view
            const settingsLlm = document.getElementById('settings-llm-model');
            if (settingsLlm) settingsLlm.textContent = info.fullName;

            // Update cost display based on model tier
            const costDisplay = document.getElementById('settings-cost-display');
            if (costDisplay) {
                const tierCost = {
                    'claude-opus-4-6': 'Premium tier (Claude Code sub)',
                    'claude-sonnet-4-6': 'Standard tier (Claude Code sub)',
                    'claude-sonnet-4-5-20250929': 'Standard tier (Claude Code sub)',
                    'claude-haiku-4-5-20251001': 'Fast tier (Claude Code sub)'
                };
                costDisplay.textContent = tierCost[selectedModel] || 'Included (Claude Code subscription)';
            }
        }

        // === INPUT BAR MODEL SELECTOR ===
        function toggleInputModelDropdown() {
            const btn = document.getElementById('input-model-btn');
            const dropdown = document.getElementById('input-model-dropdown');
            if (btn && dropdown) {
                btn.classList.toggle('open');
                dropdown.classList.toggle('open');
            }
        }

        function closeInputModelDropdown() {
            const btn = document.getElementById('input-model-btn');
            const dropdown = document.getElementById('input-model-dropdown');
            if (btn) btn.classList.remove('open');
            if (dropdown) dropdown.classList.remove('open');
        }

        // Close input model dropdown when clicking outside
        document.addEventListener('click', function(e) {
            if (!e.target.closest('.input-model-selector')) {
                closeInputModelDropdown();
            }
            if (!e.target.closest('.chat-offload-selector')) {
                closeChatOffloadDropdown();
            }
        });

        function sendQuickAction(text) {
            const input = document.getElementById('chat-input');
            if (input) {
                input.value = text;
                sendMessage();
            }
        }

        // ===== IMAGE UPLOAD UTILITY =====
        const ImageUpload = {
            pending: {},
            async uploadFromFile(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = async () => {
                        try {
                            const base64 = reader.result;
                            const resp = await fetch(API_URL + '/api/upload/image', {
                                method: 'POST',
                                headers: { 'Authorization': 'Bearer ' + token, 'Content-Type': 'application/json' },
                                body: JSON.stringify({ image_base64: base64, filename: file.name })
                            });
                            const data = await resp.json();
                            if (data.success) {
                                resolve({ path: data.path, url: API_URL + data.url, previewDataUrl: base64 });
                            } else reject(new Error(data.detail || 'Upload failed'));
                        } catch(e) { reject(e); }
                    };
                    reader.readAsDataURL(file);
                });
            },
            uploadFromClipboard(clipboardData) {
                const items = clipboardData?.items;
                if (!items) return null;
                for (const item of items) {
                    if (item.type.startsWith('image/')) {
                        const file = item.getAsFile();
                        if (file) return this.uploadFromFile(file);
                    }
                }
                return null;
            },
            showPreview(containerId, imageData) {
                const container = document.getElementById(containerId);
                if (!container) return;
                this.pending[containerId] = imageData;
                container.textContent = '';
                const thumb = document.createElement('img');
                thumb.className = 'upload-thumb';
                thumb.src = imageData.previewDataUrl;
                const nameSpan = document.createElement('span');
                nameSpan.style.cssText = 'color:rgba(255,255,255,0.5);font-size:12px;';
                nameSpan.textContent = imageData.path?.split('/').pop() || 'image';
                const removeBtn = document.createElement('button');
                removeBtn.className = 'upload-remove-btn';
                removeBtn.textContent = '\u00D7';
                removeBtn.onclick = () => ImageUpload.clearPreview(containerId);
                container.appendChild(thumb);
                container.appendChild(nameSpan);
                container.appendChild(removeBtn);
                container.classList.add('has-image');
            },
            clearPreview(containerId) {
                const container = document.getElementById(containerId);
                if (!container) return;
                delete this.pending[containerId];
                container.textContent = '';
                container.classList.remove('has-image');
            }
        };

        function openImageModal(src) {
            const overlay = document.createElement('div');
            overlay.className = 'image-modal-overlay';
            const img = document.createElement('img');
            img.src = src;
            overlay.appendChild(img);
            overlay.onclick = () => overlay.remove();
            document.addEventListener('keydown', function handler(e) {
                if (e.key === 'Escape') { overlay.remove(); document.removeEventListener('keydown', handler); }
            });
            document.body.appendChild(overlay);
        }

        function triggerFileAttach() {
            const fileInput = document.createElement('input');
            fileInput.type = 'file';
            fileInput.accept = 'image/*';
            fileInput.style.display = 'none';
            fileInput.onchange = async function() {
                if (fileInput.files && fileInput.files[0]) {
                    try {
                        const result = await ImageUpload.uploadFromFile(fileInput.files[0]);
                        ImageUpload.showPreview('chat-image-preview', result);
                    } catch(e) { showToast('Upload failed: ' + e.message, 'error'); }
                }
                fileInput.remove();
            };
            document.body.appendChild(fileInput);
            fileInput.click();
        }

        function triggerMindFileAttach() {
            const fileInput = document.createElement('input');
            fileInput.type = 'file';
            fileInput.accept = 'image/*';
            fileInput.style.display = 'none';
            fileInput.onchange = async function() {
                if (fileInput.files && fileInput.files[0]) {
                    try {
                        const result = await ImageUpload.uploadFromFile(fileInput.files[0]);
                        ImageUpload.showPreview('mind-image-preview', result);
                    } catch(e) { showToast('Upload failed: ' + e.message, 'error'); }
                }
                fileInput.remove();
            };
            document.body.appendChild(fileInput);
            fileInput.click();
        }

        // Paste listeners for image upload
        document.getElementById('chat-input')?.addEventListener('paste', async (e) => {
            const result = ImageUpload.uploadFromClipboard(e.clipboardData);
            if (result) { e.preventDefault(); const data = await result; ImageUpload.showPreview('chat-image-preview', data); }
        });
        document.getElementById('mind-chat-field')?.addEventListener('paste', async (e) => {
            const result = ImageUpload.uploadFromClipboard(e.clipboardData);
            if (result) { e.preventDefault(); const data = await result; ImageUpload.showPreview('mind-image-preview', data); }
        });

        // Drag-and-drop listeners for image upload
        ['dragover','dragleave','drop'].forEach(evt => {
            document.querySelector('.chat-input-wrapper')?.addEventListener(evt, async (e) => {
                e.preventDefault();
                if (evt === 'dragover') e.currentTarget.classList.add('drag-over');
                else if (evt === 'dragleave') e.currentTarget.classList.remove('drag-over');
                else if (evt === 'drop') {
                    e.currentTarget.classList.remove('drag-over');
                    const file = e.dataTransfer?.files?.[0];
                    if (file && file.type.startsWith('image/')) {
                        try { const data = await ImageUpload.uploadFromFile(file); ImageUpload.showPreview('chat-image-preview', data); }
                        catch(err) { showToast('Upload failed: ' + err.message, 'error'); }
                    }
                }
            });
        });
        ['dragover','dragleave','drop'].forEach(evt => {
            document.querySelector('.mind-chat-input-bar')?.addEventListener(evt, async (e) => {
                e.preventDefault();
                if (evt === 'dragover') e.currentTarget.classList.add('drag-over');
                else if (evt === 'dragleave') e.currentTarget.classList.remove('drag-over');
                else if (evt === 'drop') {
                    e.currentTarget.classList.remove('drag-over');
                    const file = e.dataTransfer?.files?.[0];
                    if (file && file.type.startsWith('image/')) {
                        try { const data = await ImageUpload.uploadFromFile(file); ImageUpload.showPreview('mind-image-preview', data); }
                        catch(err) { showToast('Upload failed: ' + err.message, 'error'); }
                    }
                }
            });
        });

        function getSelectedModel() {
            return selectedModel;
        }

        function getModelDisplayName(modelId) {
            const info = MODEL_OPTIONS[modelId];
            return info ? info.label : modelId;
        }

        // Initialize on load
        initModelSelector();

        function scrollMessagesToBottom() {
            var container = document.getElementById('messages');
            if (!container) return;

            // Reset user-scrolled-up flag so auto-scroll resumes
            _userScrolledUp[container.id || 'messages'] = false;

            // Scroll the messages container to bottom
            container._setProgrammaticScroll?.();
            container.scrollTop = container.scrollHeight;

            // Also ensure main-content is scrolled to top (chat-view should handle its own scroll)
            var mainContent = document.querySelector('.main-content');
            if (mainContent) mainContent.scrollTop = 0;
        }

        // Handle mobile keyboard - adjust layout when keyboard opens
        function handleMobileKeyboard() {
            if (_chatSplitMode) return; // Split mode handles its own layout via CSS Grid
            const chatInput = document.querySelector('.chat-input-area');
            const bottomNav = document.querySelector('.bottom-nav');
            const messagesContainer = document.getElementById('messages');
            const visualViewport = window.visualViewport;

            if (visualViewport && chatInput) {
                visualViewport.addEventListener('resize', () => {
                    // Check if keyboard is likely open (viewport height reduced)
                    const keyboardHeight = window.innerHeight - visualViewport.height;
                    if (keyboardHeight > 100) {
                        // Keyboard is open - hide bottom nav and adjust input position
                        document.body.classList.add('keyboard-open');
                        if (bottomNav) bottomNav.style.display = 'none';
                        chatInput.style.bottom = `0px`;
                        // Adjust messages padding so it doesn't hide behind input
                        if (messagesContainer) {
                            messagesContainer.style.paddingBottom = '100px';
                        }
                    } else {
                        // Keyboard closed - show bottom nav and reset input
                        document.body.classList.remove('keyboard-open');
                        if (bottomNav) bottomNav.style.display = 'flex';
                        chatInput.style.bottom = '';
                        chatInput.style.left = '';
                        chatInput.style.right = '';
                        chatInput.style.width = '';
                        chatInput.style.maxWidth = '';
                        chatInput.style.margin = '';
                        chatInput.style.borderRadius = '';
                        // Reset messages padding
                        if (messagesContainer) {
                            messagesContainer.style.paddingBottom = '';
                        }
                    }
                    // Don't auto-scroll here - it fires too often on mobile and causes jitter
                });
            }
        }

        // Refresh chat - reload chat history from server without clearing messages
        async function refreshChat() {
            const refreshBtn = event?.target?.closest('.chat-action-btn');
            if (refreshBtn) {
                refreshBtn.style.animation = 'spin 0.5s linear';
                setTimeout(() => refreshBtn.style.animation = '', 500);
            }

            try {
                await loadChatHistory();
                scrollMessagesToBottom();
                console.log('Chat refreshed');
            } catch (e) {
                console.error('Failed to refresh chat:', e);
            }
        }

        // ==================== AUTONOMY SYSTEM ====================
        let autonomyState = {
            status: 'stopped',
            level: 2,
            cycles: 0,
            phase: 'idle'
        };
        let thoughtStream = [];

        async function loadAutonomyStatus() {
            try {
                const response = await fetch(`${API_URL}/api/autonomy/status`, {
                    headers: { 'Authorization': `Bearer ${localStorage.getItem('cerebro_token')}` }
                });
                const data = await response.json();

                if (data.available) {
                    autonomyState = {
                        status: data.status || 'stopped',
                        level: data.autonomy_level || 2,
                        cycles: data.cycles_completed || 0,
                        phase: data.current_phase || 'idle',
                        // NEW: Include actions and pending from status response
                        actions: data.actions_completed || 0,
                        pending: data.pending_count || 0,
                        fullAutonomy: data.full_autonomy_enabled || false
                    };
                    updateAutonomyUI();

                    // Load recent thoughts and populate activity log
                    loadRecentThoughts();
                    loadPendingApprovals();
                    loadProactiveQuestions();
                    loadCerebroChat();  // Load conversation history
                    loadStoredItems();  // Load stored items for Stored tab
                    loadHeartbeatConfig();  // Load heartbeat monitor config
                } else {
                    showToast('Autonomy system not available', 'warning');
                }
            } catch (e) {
                console.error('Failed to load autonomy status:', e);
            }
        }

        async function loadRecentThoughts() {
            try {
                const response = await fetch(`${API_URL}/api/autonomy/thoughts?limit=30`, {
                    headers: { 'Authorization': `Bearer ${localStorage.getItem('cerebro_token')}` }
                });
                const data = await response.json();

                if (data.thoughts) {
                    thoughtStream = data.thoughts;
                    renderThoughtStream();

                    // Populate cycle-based activity from thoughts (all phases)
                    data.thoughts.slice().reverse().forEach(function(thought) {
                        if (thought && thought.phase && thought.content) {
                            addThoughtToCycle(thought);
                        }
                    });
                }
            } catch (e) {
                console.error('Failed to load thoughts:', e);
            }
        }

        // Load proactive questions from backend
        async function loadProactiveQuestions() {
            try {
                const response = await fetch(`${API_URL}/api/autonomy/questions`, {
                    headers: { 'Authorization': `Bearer ${localStorage.getItem('cerebro_token')}` }
                });
                const data = await response.json();

                // Clear and repopulate proactiveQuestions array
                proactiveQuestions.length = 0;
                if (data.questions && data.questions.length > 0) {
                    data.questions.forEach(q => {
                        if (!q.answered) {
                            proactiveQuestions.push({
                                id: q.id,
                                question: q.question,
                                type: q.type || 'general',
                                options: q.options || [],
                                paths: q.paths || [],
                                timestamp: q.timestamp
                            });
                        }
                    });
                }
                // Update the questions badge
                updateQuestionsBadge();
            } catch (e) {
                console.error('Failed to load proactive questions:', e);
            }
        }

        async function loadPendingApprovals() {
            try {
                const response = await fetch(`${API_URL}/api/autonomy/pending`, {
                    headers: { 'Authorization': `Bearer ${localStorage.getItem('cerebro_token')}` }
                });
                const data = await response.json();

                const statPendingEl = document.getElementById('stat-pending');
                const pendingApprovalsEl = document.getElementById('pending-approvals');

                if (data.pending && data.pending.length > 0) {
                    renderPendingApprovals(data.pending);
                    if (statPendingEl) statPendingEl.textContent = data.pending.length;
                } else {
                    if (pendingApprovalsEl) pendingApprovalsEl.style.display = 'none';
                    if (statPendingEl) statPendingEl.textContent = '0';
                }
            } catch (e) {
                console.error('Failed to load pending approvals:', e);
            }
        }

        // ===== CEREBRO'S VOICE - Dynamic conversational updates =====
        let currentVoiceTimeout = null;
        let voiceQueue = [];
        let currentActiveDirective = null;

        function updateCerebroVoice(type, data = {}) {
            const voiceContent = document.getElementById('voice-content');
            const voiceLabel = document.querySelector('.voice-label span:last-child');
            if (!voiceContent) return;

            let message = '';
            let label = 'Cerebro';

            switch (type) {
                case 'acknowledge':
                    const taskPreview = data.task?.substring(0, 50) || 'your request';
                    currentActiveDirective = data.task;
                    message = `Got it! I'm diving into "${taskPreview}${data.task?.length > 50 ? '...' : ''}"  let me see what I can find for you.`;
                    label = 'Cerebro  Starting';
                    break;

                case 'working':
                    message = `Still exploring ${data.task || 'this'}... I'm pulling together some interesting information for you.`;
                    label = 'Cerebro  Researching';
                    break;

                case 'finding':
                    const findingType = data.type || 'something';
                    const preview = data.preview?.replace(/\*\*/g, '').substring(0, 80) || '';
                    const count = data.count || 1;

                    if (findingType === 'web_search') {
                        message = `Found something interesting! "${preview}${preview.length >= 80 ? '...' : ''}"  I've gathered ${count} findings so far.`;
                    } else if (findingType === 'insight') {
                        message = `Aha! Here's an insight: "${preview}${preview.length >= 80 ? '...' : ''}"`;
                    } else {
                        message = `Making progress... ${count} findings gathered. Latest: "${preview}${preview.length >= 80 ? '...' : ''}"`;
                    }
                    label = 'Cerebro  Discovering';
                    break;

                case 'completed':
                    const taskName = data.task?.substring(0, 40) || 'the task';
                    if (data.preview) {
                        const cleanPreview = data.preview.replace(/\*\*/g, '').replace(/Task findings.*?:/g, '').trim();
                        message = `Done! Here's what I found: "${cleanPreview.substring(0, 120)}${cleanPreview.length > 120 ? '...' : ''}"  Check the Completed section for the full details!`;
                    } else {
                        message = `All done with "${taskName}"! Check the Completed section to see what I found.`;
                    }
                    label = 'Cerebro  Complete ';
                    currentActiveDirective = null;
                    break;

                case 'thinking':
                    if (data.message) {
                        // Rich message from processThoughtVoice
                        message = data.message;
                        label = data.customLabel || `Cerebro \u2022 ${data.phase?.charAt(0).toUpperCase() + data.phase?.slice(1) || 'Thinking'}`;
                    } else {
                        const phases = {
                            observe: "I'm scanning for patterns and gathering context...",
                            orient: "Processing what I've learned, forming connections...",
                            decide: "Weighing my options, deciding what to do next...",
                            act: "Taking action now \u2014 watch what happens...",
                            reflect: "Reflecting on what just happened, learning from it..."
                        };
                        message = phases[data.phase] || "Thinking...";
                        label = `Cerebro \u2022 ${data.phase?.charAt(0).toUpperCase() + data.phase?.slice(1) || 'Thinking'}`;
                    }
                    break;

                case 'idle':
                    message = "I'm here. Give me something to think about, or ask me anything.";
                    label = 'Cerebro';
                    break;

                case 'dormant':
                    message = "I'm here, waiting in the quiet dark. Touch the orb to awaken me, and tell me what you'd like me to think about.";
                    label = 'Cerebro';
                    break;

                default:
                    message = data.message || "Thinking...";
            }

            // Animate the text change
            voiceContent.style.opacity = '0';
            setTimeout(() => {
                voiceContent.textContent = message;
                voiceContent.dataset.userSet = 'true';
                voiceContent.style.opacity = '1';
            }, 150);

            // Update label if element exists
            if (voiceLabel) {
                voiceLabel.textContent = label;
            }

            // Inject status thoughts into chat feed (skip acknowledge  canned text)
            if (typeof injectStatusToChat === 'function' && type !== 'acknowledge') {
                injectStatusToChat(message, label);
            }

            // For completed messages, revert to idle after a while
            if (type === 'completed') {
                if (currentVoiceTimeout) clearTimeout(currentVoiceTimeout);
                currentVoiceTimeout = setTimeout(() => {
                    if (autonomyState.status === 'running') {
                        updateCerebroVoice('idle');
                    } else {
                        updateCerebroVoice('dormant');
                    }
                }, 15000); // Show completion message for 15 seconds
            }
        }

        function updateAutonomyUI() {
            const orb = document.getElementById('consciousness-orb');
            const statusText = document.getElementById('consciousness-status-text');
            const voiceContent = document.getElementById('voice-content');
            const slider = document.getElementById('autonomy-level-slider');

            // Reset orb classes
            if (orb) {
                orb.className = 'consciousness-orb';

                if (autonomyState.status === 'running') {
                    orb.classList.add('active');

                    // Phase-specific consciousness states
                    const phaseMap = {
                        'observe': { class: 'observing', text: 'perceiving' },
                        'orient': { class: 'thinking', text: 'contemplating' },
                        'decide': { class: 'deciding', text: 'deliberating' },
                        'act': { class: 'acting', text: 'manifesting' },
                        'reflect': { class: 'reflecting', text: 'introspecting' },
                        'idle': { class: 'thinking', text: 'dreaming' }
                    };

                    const phaseInfo = phaseMap[autonomyState.phase] || phaseMap.idle;
                    orb.classList.add(phaseInfo.class);

                    if (statusText) statusText.textContent = phaseInfo.text;

                    // Voice is now handled by updateCerebroVoice() via socket events
                    // Only set idle message if nothing else is happening
                    if (voiceContent && !voiceContent.dataset.userSet && !currentActiveDirective) {
                        updateCerebroVoice('idle');
                    }
                } else {
                    orb.classList.add('dormant');
                    if (statusText) statusText.textContent = 'dormant';
                    if (voiceContent && !voiceContent.dataset.userSet) {
                        updateCerebroVoice('dormant');
                    }
                }
            }

            // Sync autonomy toggle switch
            const toggleInput = document.getElementById('autonomy-toggle-input');
            if (toggleInput) {
                toggleInput.checked = (autonomyState.status === 'running');
            }

            // Update slider
            if (slider) {
                slider.value = autonomyState.level;
                updateLevelLabels(autonomyState.level);
            }

            // Update stats (both tech panel and sidebar)
            const cyclesEl = document.getElementById('stat-cycles');
            const sidebarCyclesEl = document.getElementById('sidebar-stat-cycles');
            const newCycles = autonomyState.cycles || 0;
            if (cyclesEl) cyclesEl.textContent = newCycles;
            if (sidebarCyclesEl) sidebarCyclesEl.textContent = newCycles;

            const actionsEl = document.getElementById('stat-actions');
            const sidebarActionsEl = document.getElementById('sidebar-stat-actions');
            const newActions = autonomyState.actions || 0;
            if (actionsEl) actionsEl.textContent = newActions;
            if (sidebarActionsEl) sidebarActionsEl.textContent = newActions;

            const pendingEl = document.getElementById('stat-pending');
            const sidebarPendingEl = document.getElementById('sidebar-stat-pending');
            const newPending = autonomyState.pending || 0;
            if (pendingEl) pendingEl.textContent = newPending;
            if (sidebarPendingEl) sidebarPendingEl.textContent = newPending;

            // Update sidebar level display
            const sidebarLevelDisplay = document.getElementById('controls-current-level');
            if (sidebarLevelDisplay) sidebarLevelDisplay.textContent = autonomyState.level || 2;

            // Update sidebar slider
            const sidebarSlider = document.getElementById('sidebar-level-slider');
            if (sidebarSlider) sidebarSlider.value = autonomyState.level || 2;

            // Update full autonomy toggle in sidebar
            const sidebarFullAutonomyToggle = document.getElementById('sidebar-full-autonomy-toggle');
            if (sidebarFullAutonomyToggle) {
                sidebarFullAutonomyToggle.checked = autonomyState.fullAutonomy || false;
            }
            const sidebarFullAutonomySection = document.getElementById('controls-full-autonomy');
            if (sidebarFullAutonomySection) {
                if (autonomyState.fullAutonomy) {
                    sidebarFullAutonomySection.classList.add('enabled');
                } else {
                    sidebarFullAutonomySection.classList.remove('enabled');
                }
            }

            // Add/remove autonomy-running class for emergency stop visibility
            const autonomyView = document.getElementById('view-autonomy');
            if (autonomyView) {
                if (autonomyState.status === 'running') {
                    autonomyView.classList.add('autonomy-running');
                } else {
                    autonomyView.classList.remove('autonomy-running');
                }
            }

            // Legacy support - fake these for old code
            const legacyOrb = document.getElementById('autonomy-orb');
            if (legacyOrb) {
                // For old code that might still reference this
            }

            // ===== UPDATE STATUS CARDS =====
            updateStatusCards();

            // ===== SYNC SLIDE PANEL STATS =====
            syncStatEl('sidebar-stat-cycles', 'slide-stat-cycles');
            syncStatEl('sidebar-stat-actions', 'slide-stat-actions');
            syncStatEl('sidebar-stat-pending', 'slide-stat-pending');
            const slideLevelSlider = document.getElementById('slide-level-slider');
            if (slideLevelSlider) slideLevelSlider.value = autonomyState.level || 2;
            const slideLevelValue = document.getElementById('slide-level-value');
            if (slideLevelValue) slideLevelValue.textContent = autonomyState.level || 2;
            const slideFullToggle = document.getElementById('slide-full-autonomy-toggle');
            if (slideFullToggle) slideFullToggle.checked = autonomyState.fullAutonomy || false;

            // Update tamagotchi panel if available
            if (typeof updateTamagotchiUI === 'function') updateTamagotchiUI();
        }

        // ===== STATUS CARDS UPDATE =====
        function updateStatusCards() {
            // Phase card
            const phaseDot = document.getElementById('status-card-phase-dot');
            const phaseValue = document.getElementById('status-card-phase-value');
            const phaseNames = {
                'observe': 'Observing',
                'orient': 'Orienting',
                'decide': 'Deciding',
                'act': 'Acting',
                'reflect': 'Reflecting',
                'idle': 'Idle'
            };

            if (autonomyState.status === 'running') {
                const phase = autonomyState.phase || 'idle';
                if (phaseDot) {
                    phaseDot.className = 'status-card-dot';
                    phaseDot.classList.add('phase-' + phase);
                }
                if (phaseValue) phaseValue.textContent = phaseNames[phase] || 'Active';
            } else {
                if (phaseDot) {
                    phaseDot.className = 'status-card-dot phase-dormant';
                }
                if (phaseValue) phaseValue.textContent = 'Dormant';
            }

            // Actions card
            const actionsValue = document.getElementById('status-card-actions-value');
            if (actionsValue) actionsValue.textContent = autonomyState.actions || 0;

            // Focus card
            const focusValue = document.getElementById('status-card-focus-value');
            const focusCount = document.getElementById('focus-count');
            if (focusValue && focusCount) focusValue.textContent = focusCount.textContent || '0';

            // Autonomy level card
            const autonomyValue = document.getElementById('status-card-autonomy-value');
            if (autonomyValue) autonomyValue.textContent = 'Lv ' + (autonomyState.level || 2);

            // Update status strip
            updateStatusStrip();
        }

        function updateStatusStrip() {
            // Focus text
            const stripFocusText = document.getElementById('strip-focus-text');
            const stripFocusCount = document.getElementById('strip-focus-count');
            const focusCountEl = document.getElementById('focus-count');

            if (currentActiveDirective && stripFocusText) {
                const text = typeof currentActiveDirective === 'string' ? currentActiveDirective : (currentActiveDirective.text || 'Active focus');
                stripFocusText.textContent = text.length > 35 ? text.substring(0, 35) + '...' : text;
            } else if (stripFocusText) {
                stripFocusText.textContent = 'No active focus';
            }
            if (stripFocusCount && focusCountEl) stripFocusCount.textContent = focusCountEl.textContent || '0';

            // Completed count
            const stripCompletedCount = document.getElementById('strip-completed-count');
            const completedCountEl = document.getElementById('completed-count');
            if (stripCompletedCount && completedCountEl) stripCompletedCount.textContent = completedCountEl.textContent || '0';

            // Skills count
            const stripSkillsCount = document.getElementById('strip-skills-count');
            const skillCountEl = document.getElementById('skill-count');
            if (stripSkillsCount && skillCountEl) stripSkillsCount.textContent = skillCountEl.textContent || '0';

            // Sync orb panel badge counts
            const orbFocusCount = document.getElementById('orb-focus-count');
            if (orbFocusCount && focusCountEl) orbFocusCount.textContent = focusCountEl.textContent || '0';
            const orbCompletedCount = document.getElementById('orb-completed-count');
            if (orbCompletedCount && completedCountEl) orbCompletedCount.textContent = completedCountEl.textContent || '0';
            const orbSkillsCount = document.getElementById('orb-skills-count');
            if (orbSkillsCount && skillCountEl) orbSkillsCount.textContent = skillCountEl.textContent || '0';
        }

        // Toggle tech panel visibility
        function toggleTechPanel() {
            const panel = document.getElementById('tech-panel');
            if (panel) {
                panel.classList.toggle('expanded');
            }
        }

        // Add a message to Cerebro's voice stream
        function addVoiceMessage(text, type = 'thought') {
            const history = document.getElementById('message-history');
            if (!history) return;

            const message = document.createElement('div');
            message.className = `voice-message ${type}`;
            message.innerHTML = `
                <div class="message-text">${escapeHtml(text)}</div>
                <div class="message-meta">
                    <span class="message-type">${type}</span>
                    <span>${new Date().toLocaleTimeString()}</span>
                </div>
            `;

            history.insertBefore(message, history.firstChild);

            // Keep only last 20 messages
            while (history.children.length > 20) {
                history.removeChild(history.lastChild);
            }
        }

        // Update directives display in the new format
        function renderDirectivesNew() {
            const container = document.getElementById('active-directives');
            if (!container) return;

            const activeDirectives = (window.directivesList || []).filter(d => d.status === 'active' || d.status === 'pending');

            if (activeDirectives.length === 0) {
                container.innerHTML = '';
                return;
            }

            container.innerHTML = activeDirectives.map(d => `
                <div class="directive-tag">
                    <span class="status-dot"></span>
                    <span>${escapeHtml(d.text.substring(0, 50))}${d.text.length > 50 ? '...' : ''}</span>
                    <span class="remove" onclick="deleteDirective('${d.id}')">&times;</span>
                </div>
            `).join('');
        }

        // Placeholder for legacy - keep functionality working
        function updateAutonomyUILegacy() {
            // Legacy compatibility - old code paths
        }

        function updateLevelLabelsNew(level) {
            document.querySelectorAll('.level-mark').forEach(mark => {
                mark.classList.remove('active');
                if (parseInt(mark.dataset.level) === parseInt(level)) {
                    mark.classList.add('active');
                }
            });
        }

        function updateLevelLabels(level) {
            // Update old-style labels
            document.querySelectorAll('.level-label').forEach(label => {
                label.classList.remove('active');
                if (parseInt(label.dataset.level) === parseInt(level)) {
                    label.classList.add('active');
                }
            });
            // Update new-style marks
            document.querySelectorAll('.level-mark').forEach(mark => {
                mark.classList.remove('active');
                if (parseInt(mark.dataset.level) === parseInt(level)) {
                    mark.classList.add('active');
                }
            });
            // Update compact marks in sidebar
            document.querySelectorAll('.level-mark-compact').forEach(mark => {
                mark.classList.remove('active');
                if (parseInt(mark.dataset.level) === parseInt(level)) {
                    mark.classList.add('active');
                }
            });
            // Update sidebar level display
            const sidebarLevelDisplay = document.getElementById('controls-current-level');
            if (sidebarLevelDisplay) sidebarLevelDisplay.textContent = level;
        }

        // ========================================
        // DIRECTIVES - Give the AI missions/goals
        // ========================================
        let directives = [];

        async function loadDirectives() {
            try {
                const response = await fetch(`${API_URL}/api/directives`, {
                    headers: { 'Authorization': `Bearer ${localStorage.getItem('cerebro_token')}` }
                });
                if (response.ok) {
                    const data = await response.json();
                    directives = data.directives || [];
                    renderDirectives();
                }
            } catch (e) {
                console.error('Failed to load directives:', e);
            }
        }

        // Auto-resize textarea as user types
        function autoResizeDirective(textarea) {
            // Reset height to auto to get the correct scrollHeight
            textarea.style.height = 'auto';
            // Set to scrollHeight but cap at max-height (200px from CSS)
            const newHeight = Math.min(textarea.scrollHeight, 200);
            textarea.style.height = newHeight + 'px';
        }

        // Handle keydown - Enter submits, Shift+Enter adds newline
        function handleDirectiveKeydown(event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                addDirective();
            }
        }

        async function addDirective() {
            const input = document.getElementById('directive-input');
            const text = input.value.trim();
            if (!text) return;

            try {
                const response = await fetch(`${API_URL}/api/directives`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${localStorage.getItem('cerebro_token')}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ text })
                });
                const data = await response.json();
                if (data.success) {
                    directives.unshift(data.directive);
                    input.value = '';
                    // Reset textarea height after clearing
                    input.style.height = 'auto';
                    renderDirectives();
                    showToast('Directive added - AI will work on this', 'success');
                } else {
                    showToast(data.error || 'Failed to add directive', 'error');
                }
            } catch (e) {
                showToast('Failed to add directive', 'error');
            }
        }

        async function completeDirective(id) {
            try {
                const response = await fetch(`${API_URL}/api/directives/${id}/complete`, {
                    method: 'POST',
                    headers: { 'Authorization': `Bearer ${localStorage.getItem('cerebro_token')}` }
                });
                if (response.ok) {
                    directives = directives.filter(d => d.id !== id);
                    renderDirectives();
                    showToast('Directive marked complete', 'info');
                }
            } catch (e) {
                showToast('Failed to complete directive', 'error');
            }
        }

        async function deleteDirective(id) {
            try {
                const response = await fetch(`${API_URL}/api/directives/${id}`, {
                    method: 'DELETE',
                    headers: { 'Authorization': `Bearer ${localStorage.getItem('cerebro_token')}` }
                });
                if (response.ok) {
                    directives = directives.filter(d => d.id !== id);
                    renderDirectives();
                    showToast('Directive removed', 'info');
                }
            } catch (e) {
                showToast('Failed to delete directive', 'error');
            }
        }

        function renderDirectives() {
            // Store for the new UI
            window.directivesList = directives;

            // Render new consciousness-style directive tags
            const newContainer = document.getElementById('active-directives');
            if (newContainer) {
                const activeDirectives = directives.filter(d => d.status !== 'completed');

                if (activeDirectives.length === 0) {
                    newContainer.innerHTML = '';
                } else {
                    newContainer.innerHTML = activeDirectives.map(d => `
                        <div class="directive-tag">
                            <span class="status-dot"></span>
                            <span>${escapeHtml(d.text.substring(0, 50))}${d.text.length > 50 ? '...' : ''}</span>
                            <span class="remove" onclick="deleteDirective('${d.id}')">&times;</span>
                        </div>
                    `).join('');
                }
            }

            // Sync to Current Focus sidebar
            syncDirectivesToFocus();

            // Sync to orb tabbed panel
            if (typeof renderOrbDirectives === 'function') renderOrbDirectives();

            // Legacy container support (hidden)
            const container = document.getElementById('directives-list');
            const countEl = document.getElementById('directives-count');

            if (!container) return;

            const activeDirectives = directives.filter(d => d.status !== 'completed');
            if (countEl) countEl.textContent = `${activeDirectives.length} active`;

            if (activeDirectives.length === 0) {
                container.innerHTML = `
                    <div class="directives-empty">
                        <div class="directives-empty-icon"></div>
                        <div>No active directives</div>
                        <div style="font-size: 0.75rem; margin-top: 4px;">Give the AI something to learn or work on</div>
                    </div>
                `;
                return;
            }

            container.innerHTML = activeDirectives.map(d => `
                <div class="directive-item" data-id="${d.id}">
                    <div class="directive-content">
                        <div class="directive-text">${escapeHtml(d.text)}</div>
                        <div class="directive-meta">
                            <span class="directive-status ${d.status === 'active' ? 'active' : 'pending'}">
                                ${d.status === 'active' ? ' Working on it' : ' Queued'}
                            </span>
                            <span>${formatTimeAgo(new Date(d.created_at))}</span>
                        </div>
                    </div>
                    <div class="directive-actions">
                        <button class="directive-action-btn" onclick="completeDirective('${d.id}')" title="Mark as done"></button>
                        <button class="directive-action-btn delete" onclick="deleteDirective('${d.id}')" title="Remove"></button>
                    </div>
                </div>
            `).join('');
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function formatTimeAgo(date) {
            const seconds = Math.floor((new Date() - date) / 1000);
            if (seconds < 60) return 'just now';
            const minutes = Math.floor(seconds / 60);
            if (minutes < 60) return `${minutes}m ago`;
            const hours = Math.floor(minutes / 60);
            if (hours < 24) return `${hours}h ago`;
            const days = Math.floor(hours / 24);
            return `${days}d ago`;
        }

        // ========================================
        // INSIGHTS - What Cerebro Found
        // ========================================
        let insights = [];

        async function loadInsights() {
            try {
                const response = await fetch(`${API_URL}/api/insights`, {
                    headers: { 'Authorization': `Bearer ${localStorage.getItem('cerebro_token')}` }
                });
                if (response.ok) {
                    const data = await response.json();
                    insights = (data.insights || []).map(i => ({
                        ...i,
                        timestamp: new Date(i.timestamp)
                    }));
                    renderInsights();
                }
            } catch (e) {
                console.error('Failed to load insights:', e);
            }
        }

        function addInsight(suggestion) {
            const insight = {
                id: suggestion.id || `insight_${Date.now()}`,
                title: suggestion.title || 'New Insight',
                content: suggestion.description || suggestion.content || '',
                confidence: suggestion.confidence || 0.7,
                source: suggestion.source || 'cognitive_loop',
                timestamp: new Date()
            };

            insights.unshift(insight);
            if (insights.length > 20) insights.pop();

            renderInsights();

            // Also add to activity feed
            addActivityItem({
                type: 'suggestion',
                text: ` ${insight.title}`,
                timestamp: new Date()
            });
        }

        function dismissInsight(id) {
            insights = insights.filter(i => i.id !== id);
            renderInsights();
        }

        function renderInsights() {
            const container = document.getElementById('insights-list');
            const countEl = document.getElementById('insights-count');

            if (!container) return;

            if (countEl) countEl.textContent = `${insights.length} insight${insights.length !== 1 ? 's' : ''}`;

            if (insights.length === 0) {
                container.innerHTML = `
                    <div class="insights-empty">
                        <div class="insights-empty-icon"></div>
                        <div class="insights-empty-text">No insights yet</div>
                        <div class="insights-empty-hint">Cerebro will share findings and suggestions here as it researches your directives</div>
                    </div>
                `;
                return;
            }

            container.innerHTML = insights.map(i => `
                <div class="insight-card" data-id="${i.id}">
                    <div class="insight-card-header">
                        <div class="insight-card-title">
                            <span></span>
                            ${escapeHtml(i.title)}
                        </div>
                        <span class="insight-card-badge">${i.source === 'cognitive_loop' ? 'AI Generated' : 'Manual'}</span>
                    </div>
                    <div class="insight-card-content">${escapeHtml(i.content)}</div>
                    <div class="insight-card-meta">
                        <div class="insight-confidence">
                            <span>Confidence:</span>
                            <div class="insight-confidence-bar">
                                <div class="insight-confidence-fill" style="width: ${Math.round(i.confidence * 100)}%"></div>
                            </div>
                            <span>${Math.round(i.confidence * 100)}%</span>
                        </div>
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <span>${formatTimeAgo(i.timestamp)}</span>
                            <button class="insight-dismiss" onclick="dismissInsight('${i.id}')">Dismiss</button>
                        </div>
                    </div>
                </div>
            `).join('');
        }

        // Activity feed items
        let activityItems = [];

        function addActivityItem(item) {
            activityItems.unshift({
                ...item,
                id: `activity_${Date.now()}`,
                timestamp: item.timestamp || new Date()
            });
            if (activityItems.length > 50) activityItems.pop();
            renderActivityFeed();
        }

        function renderActivityFeed() {
            const container = document.getElementById('activity-feed');

            if (!container) return;

            if (activityItems.length === 0) {
                container.innerHTML = `
                    <div class="goals-empty" style="padding: 20px;">
                        <div style="font-size: 0.8rem; color: var(--text-muted);">No activity yet</div>
                        <div style="font-size: 0.7rem; color: var(--text-muted); margin-top: 4px;">Memory searches, learnings, and actions will appear here</div>
                    </div>
                `;
                return;
            }

            const icons = {
                'search': '',
                'suggestion': '',
                'learning': '',
                'action': '',
                'error': '',
                'success': ''
            };

            container.innerHTML = activityItems.slice(0, 15).map(item => `
                <div class="activity-item" style="display: flex; align-items: center; gap: 10px; padding: 10px; background: var(--bg-card); border-radius: 8px; margin-bottom: 6px;">
                    <span style="font-size: 1rem;">${icons[item.type] || ''}</span>
                    <div style="flex: 1;">
                        <div style="font-size: 0.85rem; color: var(--text-primary);">${escapeHtml(item.text)}</div>
                        <div style="font-size: 0.7rem; color: var(--text-muted);">${formatTimeAgo(item.timestamp)}</div>
                    </div>
                </div>
            `).join('');
        }

        async function toggleAutonomy() {
            const toggleInput = document.getElementById('autonomy-toggle-input');
            const wantsOn = toggleInput ? toggleInput.checked : (autonomyState.status !== 'running');

            if (!wantsOn) {
                // Stop
                try {
                    const response = await fetch(`${API_URL}/api/autonomy/stop`, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${localStorage.getItem('cerebro_token')}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ reason: 'User disabled' })
                    });
                    const data = await response.json();
                    if (data.success) {
                        autonomyState.status = 'stopped';
                        updateAutonomyUI();
                        showToast('Autonomy disabled', 'info');
                    } else {
                        if (toggleInput) toggleInput.checked = true;
                    }
                } catch (e) {
                    if (toggleInput) toggleInput.checked = true;
                    showToast('Failed to stop autonomy', 'error');
                }
            } else {
                // Start
                try {
                    const level = parseInt(document.getElementById('autonomy-level-slider')?.value || 2);
                    const response = await fetch(`${API_URL}/api/autonomy/start?level=${level}`, {
                        method: 'POST',
                        headers: { 'Authorization': `Bearer ${localStorage.getItem('cerebro_token')}` }
                    });
                    const data = await response.json();
                    if (data.success) {
                        autonomyState.status = 'running';
                        autonomyState.level = level;
                        updateAutonomyUI();
                        showToast(`Autonomy enabled at level ${level}`, 'success');
                    } else {
                        if (toggleInput) toggleInput.checked = false;
                        showToast(data.error || 'Failed to start', 'error');
                    }
                } catch (e) {
                    if (toggleInput) toggleInput.checked = false;
                    showToast('Failed to start autonomy', 'error');
                }
            }
        }

        async function setAutonomyLevel(level) {
            updateLevelLabels(level);
            try {
                const response = await fetch(`${API_URL}/api/autonomy/level?level=${level}`, {
                    method: 'POST',
                    headers: { 'Authorization': `Bearer ${localStorage.getItem('cerebro_token')}` }
                });
                const data = await response.json();
                if (data.success) {
                    autonomyState.level = level;
                    showToast(`Autonomy level set to ${level}`, 'info');
                }
            } catch (e) {
                console.error('Failed to set level:', e);
            }
        }

        async function toggleFullAutonomy(enabled) {
            // Confirm if enabling
            if (enabled) {
                const confirmed = await cerebroConfirm(
                    'When enabled, the AI can spawn Claude Code agents to write files, run commands, and execute real tasks. This uses your Anthropic subscription.',
                    { title: 'Enable Full Autonomy?', confirmText: 'Enable' }
                );
                if (!confirmed) {
                    // Reset all toggles
                    const mainToggle = document.getElementById('full-autonomy-toggle');
                    const sidebarToggle = document.getElementById('sidebar-full-autonomy-toggle');
                    const slideToggle = document.getElementById('slide-full-autonomy-toggle');
                    if (mainToggle) mainToggle.checked = false;
                    if (sidebarToggle) sidebarToggle.checked = false;
                    if (slideToggle) slideToggle.checked = false;
                    return;
                }
            }

            try {
                const response = await fetch(`${API_URL}/api/autonomy/full-autonomy?enabled=${enabled}`, {
                    method: 'POST',
                    headers: { 'Authorization': `Bearer ${localStorage.getItem('cerebro_token')}` }
                });
                const data = await response.json();
                if (data.success) {
                    autonomyState.fullAutonomy = enabled;
                    updateFullAutonomyUI(enabled);
                    showToast(
                        enabled
                            ? ' Full Autonomy ENABLED - Can spawn Claude agents'
                            : ' Full Autonomy DISABLED - Thinking mode only',
                        enabled ? 'warning' : 'info'
                    );
                }
            } catch (e) {
                console.error('Failed to toggle full autonomy:', e);
                // Reset all toggles on failure
                const ft = document.getElementById('full-autonomy-toggle');
                const st = document.getElementById('sidebar-full-autonomy-toggle');
                const slt = document.getElementById('slide-full-autonomy-toggle');
                if (ft) ft.checked = !enabled;
                if (st) st.checked = !enabled;
                if (slt) slt.checked = !enabled;
                showToast('Failed to toggle full autonomy', 'error');
            }
        }

        function updateFullAutonomyUI(enabled) {
            // Update main panel elements
            const section = document.getElementById('full-autonomy-section');
            const warning = document.getElementById('full-autonomy-warning');
            const desc = document.getElementById('full-autonomy-desc');
            const toggle = document.getElementById('full-autonomy-toggle');

            if (toggle) toggle.checked = enabled;

            if (enabled) {
                if (section) section.classList.add('enabled');
                if (warning) warning.style.display = 'block';
                if (desc) {
                    desc.textContent = 'ACTIVE - Claude agents can be spawned';
                    desc.style.color = 'var(--red)';
                }
            } else {
                if (section) section.classList.remove('enabled');
                if (warning) warning.style.display = 'none';
                if (desc) {
                    desc.textContent = 'Can spawn Claude agents (uses subscription)';
                    desc.style.color = 'var(--text-muted)';
                }
            }

            // Update sidebar elements
            const sidebarToggle = document.getElementById('sidebar-full-autonomy-toggle');
            const sidebarSection = document.getElementById('controls-full-autonomy');
            const sidebarDesc = document.getElementById('sidebar-full-autonomy-desc');

            if (sidebarToggle) sidebarToggle.checked = enabled;
            if (sidebarSection) {
                if (enabled) {
                    sidebarSection.classList.add('enabled');
                } else {
                    sidebarSection.classList.remove('enabled');
                }
            }
            if (sidebarDesc) {
                sidebarDesc.textContent = enabled ? 'ACTIVE - Agents can be spawned' : 'Can spawn agents & execute tasks';
                sidebarDesc.style.color = enabled ? 'var(--red, #ef4444)' : '';
            }

            // Update slide panel toggle
            const slideToggle = document.getElementById('slide-full-autonomy-toggle');
            if (slideToggle) slideToggle.checked = enabled;

            // Store in autonomy state
            autonomyState.fullAutonomy = enabled;
        }

        async function emergencyStop() {
            if (!await cerebroConfirm('This will immediately halt the cognitive loop and stop all running agents.', { title: 'Emergency Stop', danger: true, confirmText: 'Stop Everything' })) {
                return;
            }

            try {
                // Stop cognitive loop
                const response = await fetch(`${API_URL}/api/autonomy/emergency-stop`, {
                    method: 'POST',
                    headers: { 'Authorization': `Bearer ${localStorage.getItem('cerebro_token')}` }
                });
                const data = await response.json();

                // Also kill all running agents
                const agentsKilled = await killAllRunningAgents();

                if (data.success) {
                    autonomyState.status = 'stopped';
                    updateAutonomyUI();
                    const agentMsg = agentsKilled > 0 ? ` (${agentsKilled} agents stopped)` : '';
                    showToast(` Emergency stop activated!${agentMsg}`, 'warning');
                }
            } catch (e) {
                showToast('Failed to trigger emergency stop', 'error');
            }
        }

        // Kill all running agents
        async function killAllRunningAgents() {
            try {
                // Get all agents
                const response = await fetch(`${API_URL}/agents`, {
                    headers: { 'Authorization': `Bearer ${localStorage.getItem('cerebro_token')}` }
                });
                const data = await response.json();
                const runningAgents = (data.agents || []).filter(a =>
                    a.status === 'running' || a.status === 'queued'
                );

                // Kill each running agent
                let killed = 0;
                for (const agent of runningAgents) {
                    try {
                        await fetch(`${API_URL}/agents/${agent.id}`, {
                            method: 'DELETE',
                            headers: { 'Authorization': `Bearer ${localStorage.getItem('cerebro_token')}` }
                        });
                        killed++;
                    } catch (e) {
                        console.error(`Failed to kill agent ${agent.id}:`, e);
                    }
                }

                // Refresh agents list
                if (killed > 0) await loadAgents();

                return killed;
            } catch (e) {
                console.error('Failed to get agents:', e);
                return 0;
            }
        }

        // ===== AGENT CONTROL BAR  Graceful Stop =====

        function updateAgentControlBar() {
            const bar = document.getElementById('agent-control-bar');
            const chipsContainer = document.getElementById('running-agent-chips');
            if (!bar || !chipsContainer) return;

            const allAgents = Object.values(agents);
            const running = allAgents.filter(a => a.status === 'running' || a.status === 'queued' || a.status === 'cycling');

            if (running.length === 0) {
                bar.classList.remove('visible');
                return;
            }

            bar.classList.add('visible');
            chipsContainer.innerHTML = running.map(a => {
                const name = a.call_sign || a.id;
                const statusDot = a.status === 'queued' ? 'background:#f59e0b' : a.is_specops ? 'background:#f472b6' : '';
                const chipTitle = escapeHtml((a.task || '').slice(0, 100));
                return `<span class="agent-chip" title="${chipTitle}">
                    <span class="chip-dot" style="${statusDot}"></span>
                    <span style="overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">${escapeHtml(name)}</span>
                    <button class="chip-stop" onclick="event.stopPropagation(); gracefulStopAgent('${a.id}', '${escapeHtml(name)}')" title="Stop ${escapeHtml(name)}">&#x2715;</button>
                </span>`;
            }).join('');
        }

        async function gracefulStopAgent(agentId, name) {
            if (!await cerebroConfirm(`Stop agent ${name || agentId}? Its output so far will be saved.`, {
                title: 'Stop Agent',
                danger: true,
                confirmText: 'Stop'
            })) return;

            try {
                const response = await fetch(`${API_URL}/agents/${agentId}`, {
                    method: 'DELETE',
                    headers: { 'Authorization': `Bearer ${localStorage.getItem('cerebro_token')}` }
                });
                const data = await response.json();
                showToast(`Agent ${name || agentId} stopped${data.output_saved ? ' (output saved)' : ''}`, 'info');
                await loadAgents();
            } catch (e) {
                showToast(`Failed to stop agent ${name || agentId}`, 'error');
            }
        }

        async function gracefulStopAllAgents() {
            const allAgents = Object.values(agents);
            const running = allAgents.filter(a => a.status === 'running' || a.status === 'queued');
            if (running.length === 0) {
                showToast('No running agents to stop', 'info');
                return;
            }

            const names = running.map(a => a.call_sign || a.id).join(', ');
            if (!await cerebroConfirm(`Stop all ${running.length} running agent(s)?\n\n${names}\n\nPartial output will be saved for each.`, {
                title: 'Stop All Agents',
                danger: true,
                confirmText: `Stop All (${running.length})`
            })) return;

            try {
                const response = await fetch(`${API_URL}/agents/stop-all`, {
                    method: 'POST',
                    headers: { 'Authorization': `Bearer ${localStorage.getItem('cerebro_token')}` }
                });
                const data = await response.json();
                showToast(`Stopped ${data.stopped} agent(s)  output saved`, 'info');
                await loadAgents();
            } catch (e) {
                showToast('Failed to stop agents', 'error');
            }
        }

        // ===== FLOATING SIDEBARS - Activity & Questions =====

        // === Cycle-based Activity Data Model ===
        let activityCycles = {};      // { cycleNumber: { number, startTime, endTime, steps:[], status, decision } }
        let activityCycleOrder = [];  // [3, 2, 1] newest first
        let _runningCycleNumber = 0;

        // Legacy compat - still needed by some callers
        let activityLog = [];
        let proactiveQuestions = [];
        let currentQuestion = null;

        // Activity log clear persistence - stores timestamp of when log was cleared
        let activityLogClearedAt = parseInt(localStorage.getItem('cerebro_activity_cleared_at') || '0');

        function toggleSidebar(type) {
            // Legacy compatibility: now opens slide panels instead
            if (type === 'activity') {
                openSlidePanel('activity');
            } else if (type === 'questions') {
                openSlidePanel('skills');
            }
        }

        // Slide-out panel management
        let currentSlidePanel = null;

        function openSlidePanel(panelType) {
            closeSlidePanel(); // Close any open panel first
            const panel = document.getElementById(`slide-panel-${panelType}`);
            const backdrop = document.getElementById('slide-panel-backdrop');
            if (panel) {
                panel.classList.add('open');
                if (backdrop) backdrop.classList.add('visible');
                currentSlidePanel = panelType;
                // Sync content when opening
                if (panelType === 'activity') {
                    syncActivityToSlidePanel();
                } else if (panelType === 'skills') {
                    syncMindDetailsToSlidePanel();
                }
            }
        }

        function closeSlidePanel() {
            document.querySelectorAll('.slide-panel.open').forEach(p => p.classList.remove('open'));
            const backdrop = document.getElementById('slide-panel-backdrop');
            if (backdrop) backdrop.classList.remove('visible');
            currentSlidePanel = null;
        }

        function syncActivityToSlidePanel() {
            // renderCycleList already renders into both containers directly
            renderCycleList();
            // Sync stats
            syncStatEl('sidebar-stat-cycles', 'slide-stat-cycles');
            syncStatEl('sidebar-stat-actions', 'slide-stat-actions');
            syncStatEl('sidebar-stat-pending', 'slide-stat-pending');
        }

        function syncMindDetailsToSlidePanel() {
            // Clone focus, completed, skills content
            syncContentClone('focus-container', 'slide-focus-container');
            syncContentClone('completed-container', 'slide-completed-container');
            syncContentClone('skills-list', 'slide-skills-list');
            // Sync counts
            syncStatEl('focus-count', 'slide-focus-count');
            syncStatEl('completed-count', 'slide-completed-count');
            syncStatEl('skill-count', 'slide-skill-count');
        }

        function syncStatEl(fromId, toId) {
            const from = document.getElementById(fromId);
            const to = document.getElementById(toId);
            if (from && to) to.textContent = from.textContent;
        }

        function syncContentClone(fromId, toId) {
            const from = document.getElementById(fromId);
            const to = document.getElementById(toId);
            if (from && to) {
                to.textContent = '';
                Array.from(from.childNodes).forEach(node => {
                    to.appendChild(node.cloneNode(true));
                });
            }
        }

        // Alive pulse control
        function setAlivePulse(show) {
            const dot = document.getElementById('alive-pulse-dot');
            if (dot) dot.classList.toggle('hidden', !show);
        }

        // Track last activity to avoid duplicates
        let lastActivityPhase = null;
        let lastActivityContent = null;
        let idleCount = 0;

        function addThoughtToCycle(thought) {
            const cycleNum = thought.cycle_number || (thought.metadata && thought.metadata.cycle_number) || _runningCycleNumber || 1;

            // Filter out items older than cleared timestamp
            if (thought.timestamp) {
                const itemTime = new Date(thought.timestamp).getTime();
                if (itemTime < activityLogClearedAt) return;
            }

            if (!activityCycles[cycleNum]) {
                activityCycles[cycleNum] = {
                    number: cycleNum,
                    startTime: thought.timestamp,
                    endTime: thought.timestamp,
                    steps: [],
                    status: 'running',
                    decision: null
                };
                // Insert in order (newest first)
                if (!activityCycleOrder.includes(cycleNum)) {
                    activityCycleOrder.unshift(cycleNum);
                    activityCycleOrder.sort((a, b) => b - a);
                }
            }

            const cycle = activityCycles[cycleNum];
            cycle.endTime = thought.timestamp || cycle.endTime;

            const step = {
                phase: (thought.phase || '').toLowerCase(),
                content: thought.fullContent || thought.content || '',
                reasoning: thought.reasoning || '',
                confidence: thought.confidence || 0,
                timestamp: thought.timestamp,
                metadata: thought.metadata || {},
                isBrowserStep: thought.is_browser_step || (thought.metadata && thought.metadata.is_browser_step) || false,
                browserStepData: thought.browser_step_data || (thought.metadata && thought.metadata.browser_step_data) || null,
                fullThought: thought
            };

            cycle.steps.push(step);

            // Extract decision summary
            if (step.phase === 'decide') {
                const actionType = (thought.metadata && thought.metadata.action_type) || thought.action_type || '';
                cycle.decision = actionType || step.content.substring(0, 60);
            }

            // Mark completed when reflect phase arrives
            if (step.phase === 'reflect') {
                cycle.status = 'completed';
            }

            _runningCycleNumber = cycleNum;
            renderCycleList();
        }

        // Legacy wrapper - redirects old callers to new cycle system
        function addActivityLogItem(phase, content, timestamp, fullThought) {
            const thought = fullThought || { phase: phase, content: content, timestamp: timestamp || new Date().toISOString() };
            if (!thought.phase) thought.phase = phase;
            if (!thought.content) thought.content = content;
            if (!thought.timestamp) thought.timestamp = timestamp || new Date().toISOString();
            addThoughtToCycle(thought);
        }

        function _cycleFmt(d) {
            return String(d.getHours()).padStart(2,'0') + ':' + String(d.getMinutes()).padStart(2,'0');
        }

        function renderCycleList() {
            ['activity-log-container', 'slide-activity-log'].forEach(function(containerId) {
                const container = document.getElementById(containerId);
                if (!container) return;
                const countEl = document.getElementById('activity-count');
                if (countEl) countEl.textContent = activityCycleOrder.length;

                container.textContent = '';

                if (activityCycleOrder.length === 0) {
                    const empty = document.createElement('div');
                    empty.className = 'sidebar-empty';
                    const txt = document.createElement('div');
                    txt.className = 'sidebar-empty-text';
                    txt.style.opacity = '0.4';
                    txt.style.fontSize = '0.72rem';
                    txt.textContent = 'Waiting for activity...';
                    empty.appendChild(txt);
                    container.appendChild(empty);
                    return;
                }

                activityCycleOrder.forEach(function(cycleNum) {
                    const cycle = activityCycles[cycleNum];
                    if (!cycle) return;

                    const row = document.createElement('div');
                    row.className = 'cycle-row' + (cycle.status === 'running' ? ' running' : '');
                    row.onclick = function() { showCycleDetail(cycleNum); };

                    // Cycle number
                    const numEl = document.createElement('span');
                    numEl.className = 'cycle-number';
                    numEl.textContent = '#' + cycleNum;

                    // Time range
                    const timeEl = document.createElement('span');
                    timeEl.className = 'cycle-time';
                    const s = new Date(cycle.startTime);
                    const e = new Date(cycle.endTime);
                    timeEl.textContent = _cycleFmt(s) + '\u2192' + _cycleFmt(e);

                    // Step count
                    const stepsEl = document.createElement('span');
                    stepsEl.className = 'cycle-steps';
                    const mainSteps = cycle.steps.filter(function(s) { return !s.isBrowserStep; }).length;
                    const browserSteps = cycle.steps.filter(function(s) { return s.isBrowserStep; }).length;
                    stepsEl.textContent = '[' + mainSteps + (browserSteps ? '+' + browserSteps : '') + ']';

                    // Decision summary (truncated)
                    const decEl = document.createElement('span');
                    decEl.className = 'cycle-decision';
                    const decText = cycle.decision || '';
                    decEl.textContent = decText.length > 30 ? decText.substring(0,30) + '...' : decText;

                    // Status indicator
                    const statusEl = document.createElement('span');
                    statusEl.className = 'cycle-status ' + cycle.status;
                    statusEl.textContent = cycle.status === 'completed' ? '\u2713' : cycle.status === 'running' ? '\u25C9' : '\u2717';

                    row.appendChild(numEl);
                    row.appendChild(timeEl);
                    row.appendChild(stepsEl);
                    row.appendChild(decEl);
                    row.appendChild(statusEl);
                    container.appendChild(row);
                });
            });
        }

        // Legacy alias
        function renderActivityLog() { renderCycleList(); }

        function clearActivityLog() {
            activityCycles = {};
            activityCycleOrder = [];
            _runningCycleNumber = 0;
            activityLog = [];
            // Persist cleared state - any thoughts before this timestamp will be ignored
            activityLogClearedAt = Date.now();
            localStorage.setItem('cerebro_activity_cleared_at', activityLogClearedAt.toString());
            renderCycleList();
            showToast('Activity log cleared', 'success');
        }

        // Show cycle detail modal with tree/hierarchy view
        function showCycleDetail(cycleNum) {
            const cycle = activityCycles[cycleNum];
            if (!cycle) return;

            // Remove existing modal
            const old = document.getElementById('cycle-modal-overlay');
            if (old) old.remove();

            const overlay = document.createElement('div');
            overlay.id = 'cycle-modal-overlay';
            overlay.className = 'cycle-modal-overlay';
            overlay.addEventListener('click', function(ev) { if (ev.target === overlay) overlay.remove(); });

            const modal = document.createElement('div');
            modal.className = 'cycle-modal';

            // Header
            const header = document.createElement('div');
            header.className = 'cycle-modal-header';
            const titleEl = document.createElement('span');
            titleEl.className = 'cycle-modal-title';
            titleEl.textContent = 'Cycle ' + cycleNum + (cycle.decision ? ' \u2014 ' + cycle.decision : '');
            const closeBtn = document.createElement('button');
            closeBtn.className = 'cycle-modal-close';
            closeBtn.textContent = '\u00D7';
            closeBtn.onclick = function() { overlay.remove(); };
            header.appendChild(titleEl);
            header.appendChild(closeBtn);
            modal.appendChild(header);

            // Meta line
            const metaDiv = document.createElement('div');
            metaDiv.className = 'cycle-modal-meta';
            var _s = new Date(cycle.startTime);
            var _e = new Date(cycle.endTime);
            var _mainSteps = cycle.steps.filter(function(st) { return !st.isBrowserStep; }).length;
            var _browserSteps = cycle.steps.filter(function(st) { return st.isBrowserStep; }).length;
            metaDiv.textContent = _cycleFmt(_s) + ' \u2192 ' + _cycleFmt(_e) + '  \u2022  ' + _mainSteps + ' phases' + (_browserSteps ? ' + ' + _browserSteps + ' browser steps' : '') + '  \u2022  ' + cycle.status;
            modal.appendChild(metaDiv);

            // Build tree: group steps by phase
            var phaseOrder = ['observe', 'orient', 'decide', 'act', 'reflect'];
            var mainStepsList = cycle.steps.filter(function(st) { return !st.isBrowserStep; });
            var browserStepsList = cycle.steps.filter(function(st) { return st.isBrowserStep; });

            phaseOrder.forEach(function(phase) {
                var phaseSteps = mainStepsList.filter(function(st) { return st.phase === phase; });
                if (phaseSteps.length === 0) return;

                var step = phaseSteps[0];
                var phaseDiv = document.createElement('div');
                phaseDiv.className = 'cycle-tree-phase';

                // Phase header (clickable)
                var phaseHeader = document.createElement('div');
                phaseHeader.className = 'cycle-tree-phase-header';

                var chevron = document.createElement('span');
                chevron.className = 'cycle-tree-chevron';
                chevron.textContent = '\u25B8';

                var badge = document.createElement('span');
                badge.className = 'cycle-tree-phase-badge ' + phase;
                badge.textContent = phase.toUpperCase();

                var timeSpan = document.createElement('span');
                timeSpan.className = 'cycle-tree-phase-time';
                if (step.timestamp) {
                    var td = new Date(step.timestamp);
                    timeSpan.textContent = _cycleFmt(td) + ':' + String(td.getSeconds()).padStart(2,'0');
                }

                var summarySpan = document.createElement('span');
                summarySpan.className = 'cycle-tree-phase-summary';
                var summaryText = step.content || '';
                summarySpan.textContent = summaryText.length > 80 ? summaryText.substring(0, 80) + '...' : summaryText;

                phaseHeader.appendChild(chevron);
                phaseHeader.appendChild(badge);
                phaseHeader.appendChild(timeSpan);
                phaseHeader.appendChild(summarySpan);

                // Details panel (hidden by default)
                var details = document.createElement('div');
                details.className = 'cycle-tree-details';

                // Full content
                var contentLabel = document.createElement('div');
                contentLabel.className = 'cycle-tree-detail-label';
                contentLabel.textContent = 'Content';
                var contentDiv = document.createElement('div');
                contentDiv.className = 'cycle-tree-detail-content';
                contentDiv.textContent = step.content;
                details.appendChild(contentLabel);
                details.appendChild(contentDiv);

                // Reasoning
                if (step.reasoning) {
                    var reasonLabel = document.createElement('div');
                    reasonLabel.className = 'cycle-tree-detail-label';
                    reasonLabel.textContent = 'Reasoning';
                    var reasonDiv = document.createElement('div');
                    reasonDiv.className = 'cycle-tree-detail-content';
                    reasonDiv.style.color = 'rgba(255,255,255,0.5)';
                    reasonDiv.textContent = step.reasoning;
                    details.appendChild(reasonLabel);
                    details.appendChild(reasonDiv);
                }

                // Confidence bar
                if (step.confidence > 0) {
                    var confDiv = document.createElement('div');
                    confDiv.className = 'cycle-tree-confidence';
                    var pct = Math.round(step.confidence * 100);
                    var confColor = step.confidence > 0.7 ? '#10b981' : step.confidence > 0.4 ? '#f59e0b' : '#ef4444';
                    var confLabel = document.createElement('span');
                    confLabel.style.cssText = 'font-size:0.68rem;color:var(--text-muted)';
                    confLabel.textContent = 'Confidence: ';
                    var confBarOuter = document.createElement('span');
                    confBarOuter.className = 'cycle-tree-confidence-bar';
                    var confBarInner = document.createElement('span');
                    confBarInner.className = 'cycle-tree-confidence-fill';
                    confBarInner.style.width = pct + '%';
                    confBarInner.style.background = confColor;
                    confBarOuter.appendChild(confBarInner);
                    var confText = document.createElement('span');
                    confText.style.cssText = 'font-size:0.68rem;color:' + confColor;
                    confText.textContent = pct + '%';
                    confDiv.appendChild(confLabel);
                    confDiv.appendChild(confBarOuter);
                    confDiv.appendChild(confText);
                    details.appendChild(confDiv);
                }

                // Browser steps nested under ACT
                if (phase === 'act' && browserStepsList.length > 0) {
                    var bsContainer = document.createElement('div');
                    bsContainer.className = 'cycle-tree-browser-steps';
                    var bsLabel = document.createElement('div');
                    bsLabel.className = 'cycle-tree-detail-label';
                    bsLabel.textContent = 'Browser Steps (' + browserStepsList.length + ')';
                    bsContainer.appendChild(bsLabel);

                    browserStepsList.forEach(function(bs) {
                        var bsData = bs.browserStepData || {};
                        var bsRow = document.createElement('div');
                        bsRow.className = 'cycle-tree-browser-step';

                        var bsNum = document.createElement('span');
                        bsNum.className = 'cycle-tree-browser-step-num';
                        bsNum.textContent = bsData.step_number || '#';

                        var bsAction = document.createElement('span');
                        bsAction.className = 'cycle-tree-browser-step-action';
                        bsAction.textContent = bsData.action || bs.content.substring(0, 40);

                        var bsDetail = document.createElement('span');
                        bsDetail.className = 'cycle-tree-browser-step-detail';
                        bsDetail.textContent = (bsData.reasoning || '').substring(0, 60);

                        bsRow.appendChild(bsNum);
                        bsRow.appendChild(bsAction);
                        bsRow.appendChild(bsDetail);
                        bsContainer.appendChild(bsRow);
                    });
                    details.appendChild(bsContainer);
                }

                // Toggle expand/collapse
                phaseHeader.onclick = function() {
                    details.classList.toggle('open');
                    chevron.classList.toggle('open');
                };

                phaseDiv.appendChild(phaseHeader);
                phaseDiv.appendChild(details);
                modal.appendChild(phaseDiv);
            });

            overlay.appendChild(modal);
            document.body.appendChild(overlay);
        }

        // Legacy compat
        function showThoughtDetail(idx) {
            if (activityCycleOrder.length > 0 && idx < activityCycleOrder.length) {
                showCycleDetail(activityCycleOrder[idx]);
            }
        }

        function closeThoughtDetail() {
            var modal = document.getElementById('thought-detail-modal');
            if (modal) modal.classList.remove('active');
            var overlay = document.getElementById('cycle-modal-overlay');
            if (overlay) overlay.remove();
        }

        // ==================== CEREBRO CHAT (Conversational Interface) ====================

        // Store for Cerebro conversation (proper chat history)
        let cerebroChat = [];

        let _cerebroChatLoaded = false;
        async function loadCerebroChat(force = false) {
            // Skip reload if already loaded and not forced - prevents wiping in-flight messages
            if (_cerebroChatLoaded && !force) {
                renderChatMessages();
                return;
            }
            try {
                const response = await fetch(`${API_URL}/api/autonomy/chat`, {
                    headers: { 'Authorization': `Bearer ${localStorage.getItem('cerebro_token')}` }
                });
                const data = await response.json();
                if (data.messages) {
                    // Preserve any in-flight messages (typing indicators, unsaved user msgs)
                    const inFlight = cerebroChat.filter(m => m.typing || (m.id && m.id.startsWith('msg_') && !data.messages.find(s => s.id === m.id)));
                    cerebroChat = [...data.messages, ...inFlight];
                    _cerebroChatLoaded = true;
                    renderChatMessages();
                }
            } catch (e) {
                console.error('Failed to load Cerebro chat:', e);
            }
        }

        async function clearCerebroChat() {
            if (!await cerebroConfirm('Clear conversation with Cerebro?', { title: 'Clear Chat', danger: true, confirmText: 'Clear' })) return;
            try {
                await fetch(`${API_URL}/api/autonomy/chat`, {
                    method: 'DELETE',
                    headers: { 'Authorization': `Bearer ${localStorage.getItem('cerebro_token')}` }
                });
                cerebroChat = [];
                renderChatMessages();
                showToast('Chat cleared', 'success');
            } catch (e) {
                console.error('Failed to clear chat:', e);
            }
        }

        // ===== NEW CHAT SYSTEM =====
        async function sendChatMessage() {
            const input = document.getElementById('cerebro-chat-field');
            const btn = document.querySelector('.chat-send-btn');
            const message = input?.value?.trim();

            if (!message) return;

            // Disable input while processing
            if (input) input.disabled = true;
            if (btn) btn.disabled = true;

            // Add user message immediately
            cerebroChat.push({
                id: 'msg_' + Date.now(),
                role: 'user',
                content: message,
                timestamp: new Date().toISOString()
            });
            renderChatMessages();

            // Clear input
            if (input) input.value = '';

            // Add typing indicator
            const typingId = 'typing_' + Date.now();
            cerebroChat.push({
                id: typingId,
                role: 'assistant',
                typing: true,
                timestamp: new Date().toISOString()
            });
            renderChatMessages();

            try {
                const response = await fetch(`${API_URL}/api/autonomy/ask`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${localStorage.getItem('cerebro_token')}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ question: message })
                });

                const data = await response.json();

                // Remove typing and add real response
                cerebroChat = cerebroChat.filter(m => m.id !== typingId);
                cerebroChat.push({
                    id: 'msg_' + (Date.now() + 1),
                    role: 'assistant',
                    content: data.answer || 'I couldn\'t formulate a response.',
                    timestamp: new Date().toISOString()
                });
                renderChatMessages();

            } catch (e) {
                console.error('Failed to message Cerebro:', e);
                cerebroChat = cerebroChat.filter(m => m.id !== typingId);
                cerebroChat.push({
                    id: 'msg_' + (Date.now() + 1),
                    role: 'assistant',
                    content: 'Sorry, I couldn\'t process that right now.',
                    timestamp: new Date().toISOString()
                });
                renderChatMessages();
            }

            // Re-enable input
            if (input) input.disabled = false;
            if (btn) btn.disabled = false;
            if (input) input.focus();
        }

        // Track whether user has manually scrolled up in each chat container
        const _userScrolledUp = {};

        function _trackUserScroll(container, key) {
            if (!container || container._scrollTracked) return;
            container._scrollTracked = true;
            var ignoreUntil = 0;
            container._setProgrammaticScroll = function() { ignoreUntil = Date.now() + 300; };
            container.addEventListener('scroll', function() {
                if (Date.now() < ignoreUntil) return;
                var distFromBottom = container.scrollHeight - container.scrollTop - container.clientHeight;
                _userScrolledUp[key] = distFromBottom > 80;
            }, { passive: true });
        }

        function smartAutoScroll(container, force) {
            if (!container) return;
            var key = container.id || 'unknown';
            _trackUserScroll(container, key);

            // If forced (new message just added by us), always scroll instantly
            if (force) {
                _userScrolledUp[key] = false;
                requestAnimationFrame(function() {
                    container._setProgrammaticScroll?.();
                    container.scrollTop = container.scrollHeight;
                });
                return;
            }

            // Otherwise, only scroll if user hasn't scrolled up
            if (_userScrolledUp[key]) return;

            var threshold = 600;
            var isNearBottom = (container.scrollHeight - container.scrollTop - container.clientHeight) < threshold;
            if (isNearBottom) {
                requestAnimationFrame(function() {
                    container._setProgrammaticScroll?.();
                    container.scrollTo({ top: container.scrollHeight, behavior: 'smooth' });
                });
            }
        }

        function renderChatMessages() {
            const container = document.getElementById('cerebro-chat-area');
            if (!container) return;

            if (cerebroChat.length === 0) {
                container.innerHTML = `
                    <div class="chat-welcome">
                        <div class="chat-welcome-icon"></div>
                        <div class="chat-welcome-text">Chat with Cerebro</div>
                        <div class="chat-welcome-hint">Ask anything or give me a task</div>
                    </div>
                `;
                return;
            }

            let html = '';
            cerebroChat.forEach((msg, idx) => {
                if (msg.typing) {
                    html += `
                        <div class="chat-message cerebro typing">
                            <div class="typing-indicator">
                                <span></span><span></span><span></span>
                            </div>
                        </div>
                    `;
                } else if (msg.isNarration || msg.isIdleNarration) {
                    const label = msg.isIdleNarration ? 'IDLE' : 'LIVE';
                    const narrationHtml = safeMarkdown(msg.content);
                    html += `
                        <div class="chat-message cerebro narration" data-msg-idx="${idx}">
                            <div class="narration-label"><span class="narration-dot"></span>${label}</div>
                            <div class="chat-message-content narration-content">${narrationHtml}</div>
                        </div>
                    `;
                } else if (msg.isQuestion) {
                    html += `
                        <div class="chat-message cerebro narration" data-msg-idx="${idx}" style="border-color: rgba(234,179,8,0.35); background: rgba(234,179,8,0.04);">
                            <div class="narration-label" style="color: #facc15;"><span class="narration-dot" style="background: #facc15;"></span>INPUT NEEDED</div>
                            <div class="chat-message-content">${escapeHtml(msg.content)}</div>
                        </div>
                    `;
                } else if (msg.isObservation) {
                    const obsScreenshot = msg.screenshotPath
                        ? `<img class="observation-screenshot" src="${API_URL}/api/screenshot/file?path=${encodeURIComponent(msg.screenshotPath)}" onclick="openImageModal(this.src)" title="${escapeHtml(msg.windowTitle || 'Screenshot')}" />`
                        : '';
                    html += `
                        <div class="chat-message cerebro narration" data-msg-idx="${idx}" style="border-color: rgba(251,191,36,0.35); background: rgba(251,191,36,0.04);">
                            <div class="narration-label" style="color: #fbbf24;"><span class="narration-dot" style="background: #fbbf24;"></span>OBSERVATION</div>
                            <div class="chat-message-content">${safeMarkdown(msg.content)}</div>
                            ${obsScreenshot}
                        </div>
                    `;
                } else if (msg.type === 'browser_step') {
                    const screenshotHtml = msg.screenshot
                        ? `<img src="data:image/png;base64,${msg.screenshot}" style="max-width:100%;border-radius:8px;margin-top:8px;cursor:pointer;" onclick="window.open(this.src,'_blank')" />`
                        : '';
                    html += `
                        <div class="chat-message cerebro narration" data-msg-idx="${idx}" style="border-color: rgba(96,165,250,0.35); background: rgba(96,165,250,0.04);">
                            <div class="narration-label" style="color: #60a5fa;"><span class="narration-dot" style="background: #60a5fa;"></span>BROWSER</div>
                            <div class="chat-message-content">${escapeHtml(msg.content)}</div>
                            ${screenshotHtml}
                        </div>
                    `;
                } else if (msg.directiveId) {
                    // Directive message as unified working card
                    const isRunning = !msg.agentStatus || msg.agentStatus === 'running' || msg.agentStatus === 'queued';
                    const isDone = msg.agentStatus === 'completed';
                    const isFailed = msg.agentStatus === 'failed';
                    let agentInfo = '';
                    if (msg.agentCallSign) {
                        agentInfo = '<span class="directive-agent-tag" onclick="event.stopPropagation(); showAgentDetail(\'' + msg.agentId + '\')">' + escapeHtml('Agent ' + msg.agentCallSign) + '</span>';
                    }
                    const displayText = (isDone && msg.summaryContent) ? msg.summaryContent : (msg.content || (isRunning ? 'Starting up...' : ''));
                    const renderedDisplay = isDone ? safeMarkdown(displayText) : escapeHtml(displayText);
                    html += '<div class="chat-message cerebro" data-msg-idx="' + idx + '">' +
                        '<div style="display:flex;align-items:center;gap:6px;margin-bottom:4px;">' +
                        '<span style="font-size:11px;color:' + (isDone ? '#22c55e' : isFailed ? '#ef4444' : '#a78bfa') + ';font-weight:600;">' + (isDone ? '\u2705 COMPLETE' : isFailed ? '\u26A0\uFE0F FAILED' : '\u26A1 WORKING') + '</span>' +
                        agentInfo + '</div>' +
                        '<div class="chat-message-content">' + renderedDisplay + '</div></div>';
                } else {
                    const isUser = msg.role === 'user';
                    const speakerBtn = !isUser ? `
                        <button class="chat-speak-btn" onclick="speakChatMessage(${idx}, this)" title="Listen">
                            <svg viewBox="0 0 24 24" width="14" height="14" fill="currentColor">
                                <path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/>
                            </svg>
                        </button>
                    ` : '';
                    const renderedContent = isUser ? escapeHtml(msg.content) : safeMarkdown(msg.content);
                    html += `
                        <div class="chat-message ${isUser ? 'user' : 'cerebro'}" data-msg-idx="${idx}">
                            <div class="chat-message-content">${renderedContent}</div>
                            ${speakerBtn}
                        </div>
                    `;
                }
            });

            container.innerHTML = html;
            smartAutoScroll(container, true);

            // Update questions badge
            updateQuestionsBadge();
        }

        // ===== MIND CHAT (Centered chat below orb) =====
        // Mirrors the sidebar chat functionality in the new centered layout

        // Track status message in chat
        let currentStatusMsgId = null;

        // Directive  Agent mapping for agent link bars
        let _directiveAgentMap = {}; // directive_id  { agentId, callSign }

        function injectStatusToChat(text, label) {
            if (!text || text.includes('Touch the orb to awaken me')) return;

            // Update the most recent active directive card instead of separate message
            const directiveMsg = cerebroChat.slice().reverse().find(m =>
                m.isDirectiveCard && m.directiveId && (!m.agentStatus || m.agentStatus === 'running' || m.agentStatus === 'queued')
            );
            if (directiveMsg) {
                directiveMsg.content = text;
                directiveMsg.statusLabel = label || 'Cerebro';
                renderChatMessages();
                renderMindChat();
                return;
            }

            // Fallback: no active directive card  create standalone status
            if (currentStatusMsgId) {
                cerebroChat = cerebroChat.filter(m => m.id !== currentStatusMsgId);
            }
            currentStatusMsgId = 'status_' + Date.now();
            cerebroChat.push({
                id: currentStatusMsgId,
                role: 'assistant',
                content: text,
                timestamp: new Date().toISOString(),
                isStatus: true,
                statusLabel: label || 'Cerebro'
            });
            renderChatMessages();
        }

        // Safe markdown rendering helper - sanitized via DOMPurify
        // Shared DOMPurify config  only allow tags that markdown generates
        var _markdownSafeConfig = {
            ALLOWED_TAGS: [
                'p', 'br', 'strong', 'b', 'em', 'i', 'u', 'code', 'pre',
                'ul', 'ol', 'li', 'a', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6',
                'blockquote', 'table', 'thead', 'tbody', 'tr', 'th', 'td',
                'hr', 'img', 'del', 'sup', 'sub', 'span'
            ],
            ALLOWED_ATTR: ['href', 'src', 'alt', 'title', 'class', 'id']
        };

        function safeMarkdown(text) {
            try {
                var raw = typeof marked !== 'undefined' ? marked.parse(text || '') : escapeHtml(text || '');
                return typeof DOMPurify !== 'undefined' ? DOMPurify.sanitize(raw, _markdownSafeConfig) : escapeHtml(text || '');
            } catch(e) {
                return escapeHtml(text || '');
            }
        }

        function safeAgentOutput(text) {
            if (!text) return '';
            try {
                if (typeof marked !== 'undefined') {
                    var raw = marked.parse(text, { breaks: true, gfm: true });
                    if (typeof DOMPurify !== 'undefined') {
                        return DOMPurify.sanitize(raw, _markdownSafeConfig);
                    }
                    return raw;
                }
                return escapeHtml(text);
            } catch(e) {
                return escapeHtml(text);
            }
        }

        // Strip markdown syntax to plain text for card previews
        function stripMarkdown(text) {
            if (!text) return '';
            return text
                .replace(/\*\*(.+?)\*\*/g, '$1')     // **bold**
                .replace(/\*(.+?)\*/g, '$1')           // *italic*
                .replace(/__(.+?)__/g, '$1')           // __bold__
                .replace(/_(.+?)_/g, '$1')             // _italic_
                .replace(/`([^`]+)`/g, '$1')           // `code`
                .replace(/```[\s\S]*?```/g, '')        // ```code blocks```
                .replace(/^#{1,6}\s+/gm, '')           // ## headers
                .replace(/\[([^\]]+)\]\([^)]+\)/g, '$1') // [links](url)
                .replace(/!\[([^\]]*)\]\([^)]+\)/g, '$1') // ![images](url)
                .replace(/^[>\-*+]\s+/gm, '')          // > quotes, - lists
                .replace(/\n{2,}/g, ' ')               // collapse newlines
                .trim();
        }

        // Determine card phase from message data
        function getCardPhase(msg) {
            if (msg.isObservation) return 'observation';
            if (msg.isSummary) return 'summary';
            if (msg.isQuestion) return 'question';
            const validTypes = ['thought', 'action', 'message', 'alert', 'summary', 'question', 'system', 'progress', 'observation'];
            if (msg.message_type && validTypes.includes(msg.message_type)) {
                return msg.message_type;
            }
            if (msg.isIdleNarration || msg.isIdle) return 'idle';
            if (msg.phases && msg.phases.length > 0) {
                const p = msg.phases[msg.phases.length - 1];
                if (['observe', 'orient', 'decide', 'act', 'reflect', 'idle'].includes(p)) return p;
            }
            if (msg.isNarration) return 'observe';
            return '';
        }

        const MSG_TYPE_BADGES = {
            observation: { icon: '\u{1F441}\uFE0F', label: 'OBSERVATION' },
            thought:  { icon: '\u{1F9E0}', label: 'THOUGHT' },
            action:   { icon: '\u26A1',    label: 'ACTION' },
            message:  { icon: '\u{1F4AC}', label: 'SPEECH' },
            alert:    { icon: '\u26A0\uFE0F', label: 'ALERT' },
            summary:  { icon: '\u2705',    label: 'SUMMARY' },
            question: { icon: '\u2753',    label: 'QUESTION' },
            system:   { icon: '\u2699\uFE0F', label: 'SYSTEM' },
            progress: { icon: '\u23F3',    label: 'PROGRESS' },
            idle:     { icon: '\u{1F4AD}', label: 'IDLE' },
            observe:  { icon: '\u{1F441}\uFE0F', label: 'OBSERVE' },
            orient:   { icon: '\u{1F9ED}', label: 'ORIENT' },
            decide:   { icon: '\u{1F914}', label: 'DECIDE' },
            act:      { icon: '\u{1F3AF}', label: 'ACT' },
            reflect:  { icon: '\u{1FA9E}', label: 'REFLECT' },
        };

        // Build a structured card element (all content sanitized via DOMPurify)
        function buildCardElement(msg, phase) {
            const div = document.createElement('div');
            let cardClasses = 'mind-chat-msg card';
            if (msg.isIdleNarration || msg.isIdle) cardClasses += ' idle-card';
            if (phase) cardClasses += ' ' + phase + '-card';
            div.className = cardClasses;

            // Header
            const header = document.createElement('div');
            header.className = 'card-header';
            const headerLeft = document.createElement('div');
            headerLeft.className = 'card-header-left';

            // LIVE dot for active narration
            if (msg.isNarration && !msg.isIdleNarration) {
                const dot = document.createElement('span');
                dot.className = 'card-live-dot';
                headerLeft.appendChild(dot);
            }

            // Phase badge with icon
            if (phase) {
                const badge = document.createElement('span');
                const badgeInfo = MSG_TYPE_BADGES[phase];
                const icon = badgeInfo ? badgeInfo.icon + ' ' : '';
                const label = badgeInfo ? badgeInfo.label : phase.toUpperCase();
                badge.className = 'card-phase ' + phase;
                badge.textContent = icon + label;
                headerLeft.appendChild(badge);
            }

            header.appendChild(headerLeft);

            // Timestamp
            const ts = document.createElement('span');
            ts.className = 'card-timestamp';
            try {
                const d = new Date(msg.timestamp || Date.now());
                ts.textContent = d.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
            } catch(e) { ts.textContent = ''; }
            header.appendChild(ts);
            div.appendChild(header);

            // Body
            const body = document.createElement('div');
            body.className = 'card-body';

            const content = document.createElement('div');
            content.className = 'card-content';
            // Content is sanitized by safeMarkdown (DOMPurify)
            const sanitizedHtml = safeMarkdown(msg.content);
            content.appendChild(document.createRange().createContextualFragment(sanitizedHtml));

            // Collapsible for long content
            if ((msg.content || '').length > 300) {
                content.classList.add('collapsed');
                body.appendChild(content);
                const expandBtn = document.createElement('button');
                expandBtn.className = 'card-expand-btn';
                expandBtn.textContent = '[ expand ]';
                expandBtn.onclick = () => {
                    content.classList.toggle('collapsed');
                    expandBtn.textContent = content.classList.contains('collapsed') ? '[ expand ]' : '[ collapse ]';
                };
                body.appendChild(expandBtn);
            } else {
                body.appendChild(content);
            }

            // Browser step screenshot
            if (msg.type === 'browser_step' && msg.screenshot) {
                const img = document.createElement('img');
                img.src = 'data:image/png;base64,' + msg.screenshot;
                img.style.cssText = 'max-width:100%;border-radius:8px;margin-top:8px;cursor:pointer;';
                img.onclick = () => window.open(img.src, '_blank');
                body.appendChild(img);
            }

            // Question-specific elements
            if (msg.isQuestion) {
                if (msg.context) {
                    const ctx = document.createElement('div');
                    ctx.className = 'question-card-context';
                    ctx.textContent = msg.context;
                    body.appendChild(ctx);
                }
                const replyBtn = document.createElement('button');
                replyBtn.className = 'question-reply-btn';
                replyBtn.textContent = 'Reply to this';
                replyBtn.onclick = () => setReplyContext(msg.questionId, msg.content);
                body.appendChild(replyBtn);
            }

            // Observation-specific elements: screenshot thumbnail
            if (msg.isObservation && msg.screenshotPath) {
                const obsImg = document.createElement('img');
                obsImg.className = 'observation-screenshot';
                obsImg.src = API_URL + '/api/screenshot/file?path=' + encodeURIComponent(msg.screenshotPath);
                obsImg.title = msg.windowTitle || 'Screenshot';
                obsImg.onclick = () => openImageModal(obsImg.src);
                body.appendChild(obsImg);
            }

            div.appendChild(body);
            return div;
        }

        // ===== DIRECTIVE PROGRESS BAR STATE =====
        const _progressState = { active: false, directiveId: null, directiveText: '', stepNumber: 0, estimatedTotal: 8, phase: 'observe', startTime: null, events: [] };
        let _progressModalOpen = false;
        const OODA_PHASES = ['observe', 'orient', 'decide', 'act', 'reflect'];

        function _buildProgressBarDOM() {
            const bar = document.createElement('div');
            bar.id = 'directive-progress-bar';
            bar.className = 'directive-progress-bar';
            bar.onclick = () => openProgressModal();
            const info = document.createElement('div');
            info.className = 'progress-bar-info';
            const dirText = document.createElement('div');
            dirText.className = 'progress-bar-directive';
            // Show agent call sign if one is mapped to this directive
            const _pbAgentInfo = _progressState.directiveId && _directiveAgentMap[_progressState.directiveId];
            const _pbAgentLabel = _pbAgentInfo ? `Agent ${_pbAgentInfo.callSign || _pbAgentInfo.agentId}  ` : '';
            dirText.textContent = _pbAgentLabel + (stripMarkdown(_progressState.directiveText) || 'Working...');
            const stepText = document.createElement('div');
            stepText.className = 'progress-bar-step';
            stepText.textContent = `Step ${_progressState.stepNumber} of ~${_progressState.estimatedTotal}`;
            info.appendChild(dirText); info.appendChild(stepText);
            const dots = document.createElement('div');
            dots.className = 'progress-phase-dots';
            const phaseIdx = OODA_PHASES.indexOf(_progressState.phase);
            OODA_PHASES.forEach((p, i) => {
                const dot = document.createElement('span');
                dot.className = 'progress-phase-dot';
                if (i < phaseIdx) dot.classList.add('done');
                else if (i === phaseIdx) dot.classList.add('active');
                dot.title = p;
                dots.appendChild(dot);
            });
            const track = document.createElement('div');
            track.className = 'progress-bar-track';
            const fill = document.createElement('div');
            fill.className = 'progress-bar-fill';
            const pct = _progressState.estimatedTotal > 0 ? Math.min(100, Math.round((_progressState.stepNumber / _progressState.estimatedTotal) * 100)) : 0;
            fill.style.width = pct + '%';
            track.appendChild(fill);
            bar.appendChild(info); bar.appendChild(dots); bar.appendChild(track);
            return bar;
        }

        function renderProgressBar() {
            // Progress info is now shown in the directive working card
            const bar = document.getElementById('directive-progress-bar');
            if (bar) bar.remove();
        }

        function openProgressModal() {
            if (_progressModalOpen) return;
            _progressModalOpen = true;
            const overlay = document.createElement('div');
            overlay.className = 'progress-modal-overlay';
            overlay.id = 'progress-modal-overlay';
            overlay.onclick = (e) => { if (e.target === overlay) closeProgressModal(); };
            const modal = document.createElement('div');
            modal.className = 'progress-modal';
            const header = document.createElement('div');
            header.className = 'progress-modal-header';
            const title = document.createElement('div');
            title.className = 'progress-modal-title';
            title.textContent = _progressState.directiveText || 'Working...';
            const meta = document.createElement('div');
            meta.className = 'progress-modal-meta';
            const elapsed = _progressState.startTime ? Math.round((Date.now() - _progressState.startTime) / 1000) + 's' : '';
            meta.textContent = `${elapsed} \u2022 Step ${_progressState.stepNumber}/${_progressState.estimatedTotal}`;
            const closeBtn = document.createElement('button');
            closeBtn.className = 'progress-modal-close';
            closeBtn.textContent = '\u00D7';
            closeBtn.onclick = () => closeProgressModal();
            header.appendChild(title); header.appendChild(meta); header.appendChild(closeBtn);
            const body = document.createElement('div');
            body.className = 'progress-modal-body';
            body.id = 'progress-modal-body';
            modal.appendChild(header); modal.appendChild(body);
            overlay.appendChild(modal);
            document.body.appendChild(overlay);
            _progressState.events.forEach(ev => appendProgressModalEntry(body, ev));
            body.scrollTop = body.scrollHeight;
            document.addEventListener('keydown', _progressModalEscHandler);
        }
        function _progressModalEscHandler(e) { if (e.key === 'Escape') closeProgressModal(); }
        function closeProgressModal() {
            _progressModalOpen = false;
            const overlay = document.getElementById('progress-modal-overlay');
            if (overlay) overlay.remove();
            document.removeEventListener('keydown', _progressModalEscHandler);
        }
        function appendProgressModalEntry(body, ev) {
            if (!body) body = document.getElementById('progress-modal-body');
            if (!body) return;
            const entry = document.createElement('div');
            entry.className = 'progress-modal-entry';
            const timeSpan = document.createElement('span');
            timeSpan.className = 'progress-modal-entry-time';
            const d = new Date(ev.timestamp || Date.now());
            timeSpan.textContent = d.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit', second:'2-digit'});
            const badgeSpan = document.createElement('span');
            badgeSpan.className = 'progress-modal-entry-badge';
            const badge = document.createElement('span');
            const badgeInfo = MSG_TYPE_BADGES[ev.type] || { icon: '', label: (ev.type || '').toUpperCase() };
            badge.className = 'card-phase ' + (ev.type || '');
            badge.style.fontSize = '0.55rem'; badge.style.padding = '2px 6px';
            badge.textContent = badgeInfo.icon + ' ' + badgeInfo.label;
            badgeSpan.appendChild(badge);
            const contentSpan = document.createElement('span');
            contentSpan.className = 'progress-modal-entry-content';
            contentSpan.textContent = ev.content || '';
            entry.appendChild(timeSpan); entry.appendChild(badgeSpan); entry.appendChild(contentSpan);
            body.appendChild(entry); body.scrollTop = body.scrollHeight;
        }
        function handleProgressEvent(data) {
            if (!data) return;
            if (!_progressState.active || _progressState.directiveId !== data.directive_id) {
                _progressState.active = true; _progressState.directiveId = data.directive_id || null;
                _progressState.directiveText = data.directive_text || data.status || 'Working...';
                _progressState.stepNumber = 0; _progressState.estimatedTotal = data.estimated_total || 8;
                _progressState.startTime = Date.now(); _progressState.events = [];
            }
            _progressState.stepNumber = data.step_number || (_progressState.stepNumber + 1);
            _progressState.estimatedTotal = data.estimated_total || _progressState.estimatedTotal;
            _progressState.phase = data.current_phase || data.phase || _progressState.phase;
            const ev = { timestamp: data.timestamp || new Date().toISOString(), type: data.event_type || data.message_type || _progressState.phase, content: data.status || data.content || '' };
            _progressState.events.push(ev);
            renderProgressBar();
            if (_progressModalOpen) appendProgressModalEntry(null, ev);
            if (data.is_final) { _progressState.active = false; setTimeout(() => renderProgressBar(), 2000); }
        }

        // ===== BEGINNER GUIDE MODAL =====
        function openGuideModal() {
            if (document.getElementById('guide-modal-overlay')) return;
            const overlay = document.createElement('div');
            overlay.className = 'guide-modal-overlay'; overlay.id = 'guide-modal-overlay';
            overlay.onclick = (e) => { if (e.target === overlay) closeGuideModal(); };
            const modal = document.createElement('div');
            modal.className = 'guide-modal';
            const header = document.createElement('div');
            header.className = 'guide-modal-header';
            const h2 = document.createElement('h2');
            h2.textContent = 'Cerebro Guide';
            const closeBtn = document.createElement('button');
            closeBtn.className = 'guide-modal-close'; closeBtn.textContent = '\u00D7';
            closeBtn.onclick = () => closeGuideModal();
            header.appendChild(h2); header.appendChild(closeBtn);
            const body = document.createElement('div');
            body.className = 'guide-modal-body';
            const nav = document.createElement('div');
            nav.className = 'guide-nav';
            const sections = ['Welcome', 'The Orb', 'Message Types', 'Giving Commands', 'Progress', 'Autonomy Levels', 'Tips', 'Troubleshooting'];
            sections.forEach((s, i) => {
                const btn = document.createElement('button');
                btn.className = 'guide-nav-btn'; btn.textContent = s;
                btn.onclick = () => { const el = body.querySelector('#guide-section-' + i); if (el) el.scrollIntoView({ behavior: 'smooth', block: 'start' }); };
                nav.appendChild(btn);
            });
            body.appendChild(nav);
            const sectionData = [
                { title: 'Welcome to Cerebro', content: 'Cerebro is your autonomous AI assistant. It can think, plan, browse the web, run tools, and complete complex tasks on your behalf. Use the chat to give commands, and the Mind page to watch Cerebro think in real-time.' },
                { title: 'The Consciousness Orb', list: ['Dormant (dim, slow pulse): Cerebro is sleeping. Toggle the switch to wake it up.', 'Active (bright, fast rings): Cerebro is awake and ready for commands.', 'Observing (cyan rings): Gathering information about the environment.', 'Acting (amber rings): Executing a tool or browser action.', 'Thinking (purple rings): Reasoning and planning.', 'Mood states: The orb changes color based on mood \u2014 green (excited), normal (happy), dim (bored), red (frustrated).'] },
                { title: 'Message Types & Colors', colors: [{ color: '#a78bfa', name: 'Thought', desc: 'Internal reasoning during a task' }, { color: '#22d3ee', name: 'Action', desc: 'Tool calls, searches, browser actions' }, { color: '#fb7185', name: 'Speech', desc: 'Cerebro talking directly to you' }, { color: '#34d399', name: 'Summary', desc: 'Task completion summaries' }, { color: '#fbbf24', name: 'Question', desc: 'Cerebro asking you something' }, { color: '#f87171', name: 'Alert', desc: 'Errors, warnings, needs attention' }, { color: '#64748b', name: 'System', desc: 'System messages, status updates' }, { color: '#818cf8', name: 'Progress', desc: 'Step-by-step progress updates' }, { color: '#94a3b8', name: 'Idle', desc: 'Background observations when idle' }] },
                { title: 'Giving Commands', list: ['Type a message in the chat input and press Enter or the send button.', 'Commands become "directives" \u2014 tasks that Cerebro works on autonomously.', 'You can give complex, multi-step instructions. Cerebro will break them down.', 'Ask questions directly \u2014 Cerebro will respond conversationally.', 'Use the Mind page to watch the thinking process in real-time.'] },
                { title: 'Progress & Summaries', list: ['When Cerebro starts a task, a progress bar appears showing the current step.', 'Click the progress bar to open a detailed modal with every step logged.', 'Phase dots (Observe \u2192 Orient \u2192 Decide \u2192 Act \u2192 Reflect) show the thinking stage.', 'When a task completes, a green Summary card appears with the results.', 'The modal can be dismissed with Escape, the X button, or clicking outside.'] },
                { title: 'Autonomy Levels', list: ['Level 1 (Cautious): Asks permission before every action.', 'Level 2 (Guided): Executes safe actions, asks for risky ones.', 'Level 3 (Balanced): Default. Handles most tasks independently.', 'Level 4 (Proactive): Takes initiative, minimal interruptions.', 'Level 5 (Full Auto): Complete autonomy. Use with caution.'] },
                { title: 'Tips & Tricks', list: ['The Orb is clickable \u2014 tap it to toggle autonomy on/off.', 'Check the Info tab next to the orb for Cerebro\'s mood and energy.', 'The Done tab shows completed tasks with results.', 'The Browser tab shows live screenshots during web browsing.', 'Cerebro remembers context across conversations.'] },
                { title: 'Troubleshooting', list: ['Orb stays dormant: Check if the toggle is ON and the backend is running.', 'No responses: Verify the connection indicator in the top bar is green.', 'Stuck on a task: Try the emergency stop button in the Mind page.', 'Repeated messages: This should be handled automatically. Refresh if needed.', 'Chat not loading: Use the hamburger menu \u2192 Refresh chat.'] }
            ];
            sectionData.forEach((sec, i) => {
                const section = document.createElement('div');
                section.className = 'guide-section'; section.id = 'guide-section-' + i;
                const h3 = document.createElement('h3'); h3.textContent = sec.title; section.appendChild(h3);
                if (sec.content) { const p = document.createElement('p'); p.textContent = sec.content; section.appendChild(p); }
                if (sec.list) { const ul = document.createElement('ul'); sec.list.forEach(item => { const li = document.createElement('li'); li.textContent = item; ul.appendChild(li); }); section.appendChild(ul); }
                if (sec.colors) { sec.colors.forEach(c => { const row = document.createElement('div'); row.className = 'guide-color-row'; const swatch = document.createElement('span'); swatch.className = 'guide-color-swatch'; swatch.style.background = c.color; const label = document.createElement('span'); label.className = 'guide-color-label'; label.textContent = c.name; const desc = document.createElement('span'); desc.className = 'guide-color-desc'; desc.textContent = c.desc; row.appendChild(swatch); row.appendChild(label); row.appendChild(desc); section.appendChild(row); }); }
                body.appendChild(section);
            });
            modal.appendChild(header); modal.appendChild(body);
            overlay.appendChild(modal); document.body.appendChild(overlay);
            const escHandler = (e) => { if (e.key === 'Escape') { closeGuideModal(); document.removeEventListener('keydown', escHandler); } };
            document.addEventListener('keydown', escHandler);
        }
        function closeGuideModal() { const overlay = document.getElementById('guide-modal-overlay'); if (overlay) overlay.remove(); }

        function renderMindChat() {
            const container = document.getElementById('mind-chat-messages');
            if (!container) return;

            // Save active thread input state before re-render
            const savedThreadInput = _activeThreadInput ? { msgId: _activeThreadInput.msgId } : null;

            if (cerebroChat.length === 0) {
                container.textContent = '';
                const welcome = document.createElement('div');
                welcome.className = 'mind-chat-welcome';
                welcome.appendChild(Object.assign(document.createElement('div'), { className: 'mind-chat-welcome-icon', textContent: '' }));
                welcome.appendChild(Object.assign(document.createElement('div'), { className: 'mind-chat-welcome-text', textContent: 'Chat with Cerebro' }));
                welcome.appendChild(Object.assign(document.createElement('div'), { className: 'mind-chat-welcome-hint', textContent: 'Ask anything or give me a task' }));
                container.appendChild(welcome);
                return;
            }

            container.textContent = '';

            // Cap rendered messages to last 100 for performance
            const maxRender = 100;
            const startIdx = Math.max(0, cerebroChat.length - maxRender);
            if (startIdx > 0) {
                const loadMore = document.createElement('div');
                loadMore.className = 'mind-chat-load-more';
                loadMore.textContent = `${startIdx} earlier messages...`;
                loadMore.onclick = () => {
                    cerebroChat._renderAll = true;
                    renderMindChat();
                };
                container.appendChild(loadMore);
            }

            const renderFrom = cerebroChat._renderAll ? 0 : startIdx;
            delete cerebroChat._renderAll;

            // === THREAD PRE-PASS: build parent  children map ===
            const threadChildren = {};
            for (let i = renderFrom; i < cerebroChat.length; i++) {
                const msg = cerebroChat[i];
                if (msg.parentId) {
                    if (!threadChildren[msg.parentId]) threadChildren[msg.parentId] = [];
                    threadChildren[msg.parentId].push(i);
                }
            }

            // Helper: render a thread container with child messages
            function renderThreadContainer(parentMsgId, childIndices) {
                const threadDiv = document.createElement('div');
                threadDiv.className = 'thread-container';
                threadDiv.setAttribute('data-thread-parent', parentMsgId);

                const shouldCollapse = childIndices.length >= 3;
                let collapsed = shouldCollapse;

                if (shouldCollapse) {
                    const collapseBtn = document.createElement('button');
                    collapseBtn.className = 'thread-collapse-btn';
                    collapseBtn.textContent = ` ${childIndices.length} replies`;
                    collapseBtn.onclick = () => {
                        collapsed = !collapsed;
                        collapseBtn.textContent = collapsed ? ` ${childIndices.length} replies` : ' Collapse';
                        replyWrapper.style.display = collapsed ? 'none' : 'block';
                    };
                    threadDiv.appendChild(collapseBtn);
                }

                const replyWrapper = document.createElement('div');
                if (shouldCollapse) replyWrapper.style.display = 'none';

                childIndices.forEach(idx => {
                    const child = cerebroChat[idx];
                    const bubble = document.createElement('div');
                    bubble.className = `thread-message ${child.role === 'user' ? 'user' : 'cerebro'}`;
                    if (child.role === 'user') {
                        bubble.appendChild(document.createTextNode(child.content));
                    } else {
                        const sanitized = safeMarkdown(child.content);
                        bubble.appendChild(document.createRange().createContextualFragment(sanitized));
                    }
                    const ts = document.createElement('div');
                    ts.className = 'thread-ts';
                    ts.textContent = formatMsgTime(child.timestamp);
                    bubble.appendChild(ts);
                    replyWrapper.appendChild(bubble);
                });

                threadDiv.appendChild(replyWrapper);
                return threadDiv;
            }

            // Merge consecutive narration messages of the SAME type into a single card
            let lastNarrationCard = null;
            let lastNarrationContentEl = null;
            let lastNarrationMsgType = null;

            for (let i = renderFrom; i < cerebroChat.length; i++) {
                const msg = cerebroChat[i];

                // Skip messages that belong to a thread (rendered under parent)
                if (msg.parentId) continue;

                if (msg.typing) {
                    lastNarrationCard = null;
                    lastNarrationMsgType = null;
                    const div = document.createElement('div');
                    div.className = 'mind-chat-msg cerebro typing';
                    const indicator = document.createElement('div');
                    indicator.className = 'typing-indicator';
                    for (let j = 0; j < 3; j++) indicator.appendChild(document.createElement('span'));
                    div.appendChild(indicator);
                    container.appendChild(div);
                } else if (msg.role === 'user') {
                    lastNarrationCard = null;
                    lastNarrationMsgType = null;
                    const div = document.createElement('div');
                    div.className = 'mind-chat-msg user';
                    // Show reply-to banner if this was a HITL reply
                    if (msg.replyTo) {
                        div.title = 'Reply to question';
                        div.style.borderLeft = '2px solid #facc15';
                    }
                    div.appendChild(document.createTextNode(msg.content));
                    if (msg.imageUrl) {
                        const imgThumb = document.createElement('img');
                        imgThumb.className = 'chat-image-thumb';
                        imgThumb.src = msg.imageUrl;
                        imgThumb.onclick = () => openImageModal(imgThumb.src);
                        div.appendChild(imgThumb);
                    }
                    container.appendChild(div);
                    // Timestamp
                    const tsDiv = document.createElement('div');
                    tsDiv.className = 'msg-timestamp';
                    tsDiv.textContent = formatMsgTime(msg.timestamp);
                    container.appendChild(tsDiv);
                } else if (msg.isStatus) {
                    lastNarrationCard = null;
                    lastNarrationMsgType = null;
                    const div = document.createElement('div');
                    div.className = 'mind-chat-msg status';
                    const labelDiv = document.createElement('div');
                    labelDiv.className = 'status-label';
                    const dot = document.createElement('span');
                    dot.className = 'status-dot';
                    labelDiv.appendChild(dot);
                    labelDiv.appendChild(document.createTextNode(msg.statusLabel || 'Cerebro'));
                    div.appendChild(labelDiv);
                    const contentDiv = document.createElement('div');
                    contentDiv.textContent = msg.content;
                    div.appendChild(contentDiv);
                    container.appendChild(div);
                    const tsDiv = document.createElement('div');
                    tsDiv.className = 'msg-timestamp';
                    tsDiv.textContent = formatMsgTime(msg.timestamp);
                    container.appendChild(tsDiv);
                } else if (msg.directiveId) {
                    // Directive message as unified working card
                    lastNarrationCard = null;
                    lastNarrationMsgType = null;
                    const div = document.createElement('div');
                    const isRunning = !msg.agentStatus || msg.agentStatus === 'running' || msg.agentStatus === 'queued';
                    const isDone = msg.agentStatus === 'completed';
                    const isFailed = msg.agentStatus === 'failed';
                    div.className = 'mind-chat-msg card' + (isDone ? ' summary-card' : isFailed ? ' alert-card' : ' action-card');

                    // Header: LIVE dot + badge + agent tag
                    const header = document.createElement('div');
                    header.className = 'card-header';
                    const headerLeft = document.createElement('div');
                    headerLeft.className = 'card-header-left';
                    if (isRunning) {
                        const dot = document.createElement('span');
                        dot.className = 'card-live-dot';
                        headerLeft.appendChild(dot);
                    }
                    const badge = document.createElement('span');
                    badge.className = 'card-phase ' + (isDone ? 'summary' : isFailed ? 'alert' : 'action');
                    badge.textContent = isDone ? '\u2705 COMPLETE' : isFailed ? '\u26A0\uFE0F FAILED' : '\u26A1 WORKING';
                    headerLeft.appendChild(badge);
                    if (msg.agentCallSign) {
                        const agentTag = document.createElement('span');
                        agentTag.className = 'directive-agent-tag';
                        agentTag.textContent = 'Agent ' + msg.agentCallSign;
                        agentTag.onclick = function(e) { e.stopPropagation(); showAgentDetail(msg.agentId); };
                        headerLeft.appendChild(agentTag);
                    }
                    header.appendChild(headerLeft);
                    const ts = document.createElement('span');
                    ts.className = 'card-timestamp';
                    try { ts.textContent = new Date(msg.timestamp || Date.now()).toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'}); } catch(e) {}
                    header.appendChild(ts);
                    div.appendChild(header);

                    // Body: summary for completed cards, status text for running
                    const body = document.createElement('div');
                    body.className = 'card-body';
                    const content = document.createElement('div');
                    content.className = 'card-content';
                    if (isDone && msg.summaryContent) {
                        content.appendChild(document.createRange().createContextualFragment(safeMarkdown(msg.summaryContent)));
                    } else {
                        const displayText = msg.content || (isRunning ? 'Starting up...' : '');
                        if (displayText) content.appendChild(document.createRange().createContextualFragment(safeMarkdown(displayText)));
                    }
                    body.appendChild(content);
                    div.appendChild(body);

                    // Click to open agent detail
                    if (msg.agentId) {
                        div.style.cursor = 'pointer';
                        div.onclick = function(e) { if (!e.target.closest('.directive-agent-tag')) showAgentDetail(msg.agentId); };
                    }
                    container.appendChild(div);
                    const tsDiv = document.createElement('div');
                    tsDiv.className = 'msg-timestamp';
                    tsDiv.textContent = formatMsgTime(msg.timestamp);
                    container.appendChild(tsDiv);
                } else if (msg.isSummary) {
                    // Summary messages: clean assistant message with special styling
                    lastNarrationCard = null;
                    lastNarrationMsgType = null;
                    const div = document.createElement('div');
                    div.className = 'mind-chat-msg cerebro summary-msg';
                    div.style.position = 'relative';
                    const sanitized = safeMarkdown(msg.content);
                    div.appendChild(document.createRange().createContextualFragment(sanitized));
                    div.onclick = (e) => {
                        if (e.target.closest('a') || e.target.closest('.card-action-popup')) return;
                        showCardActionPopup(div, msg.id, msg.content);
                    };
                    container.appendChild(div);
                    const tsDiv = document.createElement('div');
                    tsDiv.className = 'msg-timestamp';
                    tsDiv.textContent = formatMsgTime(msg.timestamp);
                    container.appendChild(tsDiv);
                } else if (msg.isNarration || msg.isIdleNarration || msg.isQuestion || msg.isObservation) {
                    const curMsgType = msg.message_type || 'narration';
                    // Questions and observations always get their own card
                    if (msg.isQuestion || msg.isObservation) {
                        lastNarrationCard = null;
                        lastNarrationMsgType = null;
                        const phase = getCardPhase(msg);
                        container.appendChild(buildCardElement(msg, phase));
                    } else if (lastNarrationCard && !msg.isQuestion && curMsgType === lastNarrationMsgType) {
                        // Merge into existing narration card of SAME type  append content
                        const newContent = (msg.content || '').trim();
                        if (newContent && lastNarrationContentEl) {
                            const sep = document.createElement('div');
                            sep.style.cssText = 'border-top:1px solid rgba(139,92,246,0.1); margin:6px 0;';
                            lastNarrationContentEl.appendChild(sep);
                            const fragment = document.createRange().createContextualFragment(safeMarkdown(newContent));
                            lastNarrationContentEl.appendChild(fragment);
                        }
                    } else {
                        // New card (first narration, or different message_type)
                        const phase = getCardPhase(msg);
                        const card = buildCardElement(msg, phase);
                        // Click-to-popup on narration cards
                        card.onclick = (e) => {
                            if (e.target.closest('button') || e.target.closest('a') || e.target.closest('.card-action-popup')) return;
                            showCardActionPopup(card, msg.id, msg.content);
                        };
                        container.appendChild(card);
                        lastNarrationCard = card;
                        lastNarrationContentEl = card.querySelector('.card-content');
                        lastNarrationMsgType = curMsgType;
                    }
                } else {
                    lastNarrationCard = null;
                    // Regular assistant message - use card if it has phase info
                    const phase = getCardPhase(msg);
                    if (phase) {
                        const card = buildCardElement(msg, phase);
                        card.onclick = (e) => {
                            if (e.target.closest('button') || e.target.closest('a') || e.target.closest('.card-action-popup')) return;
                            showCardActionPopup(card, msg.id, msg.content);
                        };
                        container.appendChild(card);
                    } else {
                        // Plain assistant message with markdown rendering
                        const div = document.createElement('div');
                        div.className = 'mind-chat-msg cerebro';
                        div.style.position = 'relative';
                        const sanitized = safeMarkdown(msg.content);
                        div.appendChild(document.createRange().createContextualFragment(sanitized));
                        // Click-to-popup
                        div.onclick = (e) => {
                            if (e.target.closest('a') || e.target.closest('.card-action-popup')) return;
                            showCardActionPopup(div, msg.id, msg.content);
                        };
                        container.appendChild(div);
                        // Timestamp
                        const tsDiv = document.createElement('div');
                        tsDiv.className = 'msg-timestamp';
                        tsDiv.textContent = formatMsgTime(msg.timestamp);
                        container.appendChild(tsDiv);
                    }
                }

                // === RENDER THREAD CHILDREN under this top-level message ===
                if (threadChildren[msg.id]) {
                    container.appendChild(renderThreadContainer(msg.id, threadChildren[msg.id]));
                }
            }

            // Restore active thread input if it was open
            if (savedThreadInput) {
                const parentMsg = cerebroChat.find(m => m.id === savedThreadInput.msgId);
                if (parentMsg) {
                    // Find the card/element for this message to re-attach input
                    const threadContainer = container.querySelector(`[data-thread-parent="${savedThreadInput.msgId}"]`);
                    if (threadContainer) {
                        openThreadReplyInput(savedThreadInput.msgId, parentMsg.content, threadContainer.previousElementSibling || threadContainer);
                    }
                }
            }

            smartAutoScroll(container, true);
        }

        // Mind chat FAB functions
        function toggleMindFab() {
            const btn = document.getElementById('mind-fab-btn');
            const menu = document.getElementById('mind-fab-menu');
            if (btn && menu) {
                btn.classList.toggle('open');
                menu.classList.toggle('open');
            }
        }
        function closeMindFab() {
            const btn = document.getElementById('mind-fab-btn');
            const menu = document.getElementById('mind-fab-menu');
            if (btn && menu) {
                btn.classList.remove('open');
                menu.classList.remove('open');
            }
        }
        function scrollMindChatToBottom() {
            const container = document.getElementById('mind-chat-messages');
            if (container) {
                _userScrolledUp[container.id] = false;
                container.scrollTop = container.scrollHeight;
            }
        }
        async function refreshMindChat() {
            await loadCerebroChat(true);  // force reload from server
            renderMindChat();
            showToast('Chat refreshed', 'success');
        }
        // Close mind fab when clicking outside
        document.addEventListener('click', (e) => {
            const container = document.querySelector('.mind-fab-container');
            if (container && !container.contains(e.target)) {
                closeMindFab();
            }
        });

        // Override renderChatMessages to also update mind chat
        const _origRenderChat = renderChatMessages;
        renderChatMessages = function() {
            _origRenderChat();
            renderMindChat();
        };

        // ===== ORB TABBED PANEL =====
        let currentOrbTab = 'info';

        function switchOrbTab(tabName) {
            currentOrbTab = tabName;
            // In vertical layout mode (tall viewport), all panes are visible  skip tab switching
            const isVerticalLayout = window.innerHeight >= 1400 && window.innerWidth >= 1024;
            if (!isVerticalLayout) {
                document.querySelectorAll('.orb-tab').forEach(t => t.classList.remove('active'));
                document.querySelector(`.orb-tab[data-orbtab="${tabName}"]`)?.classList.add('active');
                document.querySelectorAll('.orb-tab-pane').forEach(p => p.classList.remove('active'));
                document.getElementById(`orb-pane-${tabName}`)?.classList.add('active');
            }
            // Always trigger content refresh
            if (tabName === 'info') updateTamagotchiUI();
            if (tabName === 'completed') renderOrbCompleted();
            if (tabName === 'command') renderOrbCommand();
            if (tabName === 'browser') renderOrbBrowser();
        }

        // ===== TAMAGOTCHI HEALTH ENGINE =====
        const tamagotchiState = {
            mood: 'content',
            energy: 0,
            memoryHealth: { nas: false, faiss: false, faiss_mb: 0 },
            xp: 0,
            level: 1,
            levelProgress: 0,
            lastInteraction: Date.now(),
            recentErrors: [],
            actionTimestamps: [],
            hitlPending: false
        };

        function recordAction() {
            tamagotchiState.actionTimestamps.push(Date.now());
            const oneHourAgo = Date.now() - 3600000;
            tamagotchiState.actionTimestamps = tamagotchiState.actionTimestamps.filter(t => t > oneHourAgo);
        }
        function recordError() {
            tamagotchiState.recentErrors.push(Date.now());
            const fiveMinAgo = Date.now() - 300000;
            tamagotchiState.recentErrors = tamagotchiState.recentErrors.filter(t => t > fiveMinAgo);
        }
        function recordInteraction() {
            tamagotchiState.lastInteraction = Date.now();
        }

        function computeEnergy() {
            const oneHourAgo = Date.now() - 3600000;
            const recent = tamagotchiState.actionTimestamps.filter(t => t > oneHourAgo);
            const raw = Math.min(recent.length / 60, 1);
            const lastAction = tamagotchiState.actionTimestamps.length > 0
                ? tamagotchiState.actionTimestamps[tamagotchiState.actionTimestamps.length - 1] : 0;
            const idleMin = (Date.now() - lastAction) / 60000;
            const drain = Math.max(0, idleMin - 2) * 0.02;
            return Math.max(0, Math.min(1, raw - drain));
        }

        function computeMood() {
            const fiveMinAgo = Date.now() - 300000;
            const recentErrors = tamagotchiState.recentErrors.filter(t => t > fiveMinAgo).length;
            const idleMinutes = (Date.now() - tamagotchiState.lastInteraction) / 60000;
            const energy = computeEnergy();
            if (recentErrors >= 3) return 'frustrated';
            if (tamagotchiState.hitlPending) return 'confused';
            if (idleMinutes > 30) return 'lonely';
            if (idleMinutes > 10) return 'bored';
            if (energy > 0.7 && idleMinutes < 2) return 'excited';
            if (energy > 0.3 || idleMinutes < 5) return 'happy';
            return 'content';
        }

        function updateOrbMood(mood) {
            const orb = document.getElementById('consciousness-orb');
            if (!orb) return;
            ['mood-excited','mood-happy','mood-content','mood-bored','mood-lonely','mood-confused','mood-frustrated']
                .forEach(c => orb.classList.remove(c));
            if (mood !== 'content') {
                orb.classList.add('mood-' + mood);
            }
        }

        function updateTamagotchiUI() {
            const energy = computeEnergy();
            const mood = computeMood();
            tamagotchiState.mood = mood;
            tamagotchiState.energy = energy;

            // Mood bar
            const moodFill = document.getElementById('tama-mood-fill');
            const moodLabel = document.getElementById('tama-mood-label');
            const moodLevels = { excited: 95, happy: 75, content: 60, bored: 40, lonely: 20, confused: 50, frustrated: 30 };
            if (moodFill) {
                moodFill.style.width = (moodLevels[mood] || 50) + '%';
                moodFill.className = 'tama-bar-fill mood-fill ' + mood;
            }
            if (moodLabel) moodLabel.textContent = mood.charAt(0).toUpperCase() + mood.slice(1);

            // Energy bar
            const energyFill = document.getElementById('tama-energy-fill');
            const energyValue = document.getElementById('tama-energy-value');
            if (energyFill) energyFill.style.width = Math.round(energy * 100) + '%';
            if (energyValue) energyValue.textContent = Math.round(energy * 100) + '%';

            // Memory health bar
            const memFill = document.getElementById('tama-memory-fill');
            const memValue = document.getElementById('tama-memory-value');
            const mh = tamagotchiState.memoryHealth;
            let memPct = 0;
            let memClass = 'memory-fill';
            let memText = 'Offline';
            if (_IS_STANDALONE) {
                if (mh.nas) {
                    memPct = 100;
                    memClass = 'memory-fill';
                    memText = 'OK (' + (mh.faiss_mb || 0) + 'MB)';
                } else {
                    memClass = 'memory-fill offline';
                    memText = 'Volume missing';
                }
            } else {
                if (mh.nas) {
                    memPct = mh.faiss ? 100 : 50;
                    memClass = mh.faiss ? 'memory-fill' : 'memory-fill degraded';
                    memText = mh.faiss ? ('OK (' + mh.faiss_mb + 'MB)') : 'NAS only';
                } else {
                    memClass = 'memory-fill offline';
                }
            }
            if (memFill) { memFill.style.width = memPct + '%'; memFill.className = 'tama-bar-fill ' + memClass; }
            if (memValue) memValue.textContent = memText;

            // XP bar
            const xpFill = document.getElementById('tama-xp-fill');
            const xpValue = document.getElementById('tama-xp-value');
            if (xpFill) xpFill.style.width = Math.round(tamagotchiState.levelProgress * 100) + '%';
            if (xpValue) xpValue.textContent = 'Lv ' + tamagotchiState.level + ' \u00b7 ' + tamagotchiState.xp + ' XP';

            // Phase indicator
            const phaseDot = document.getElementById('tama-phase-dot');
            const phaseLabel = document.getElementById('tama-phase-label');
            const phaseMap = {
                'observe': { cls: 'observing', label: 'Observing' },
                'orient': { cls: 'running', label: 'Orienting' },
                'decide': { cls: 'running', label: 'Deciding' },
                'act': { cls: 'acting', label: 'Acting' },
                'reflect': { cls: 'running', label: 'Reflecting' },
                'idle': { cls: 'running', label: 'Idle' }
            };
            const phase = (typeof autonomyState !== 'undefined' && autonomyState.status === 'running')
                ? (phaseMap[autonomyState.phase] || { cls: 'running', label: 'Active' })
                : { cls: 'dormant', label: 'Dormant' };
            if (phaseDot) phaseDot.className = 'tama-phase-dot ' + phase.cls;
            if (phaseLabel) phaseLabel.textContent = phase.label;

            // Autonomy pips (clickable)
            const pipsContainer = document.getElementById('tama-autonomy-pips');
            if (pipsContainer) {
                const lvl = (typeof autonomyState !== 'undefined' ? autonomyState.level : 2) || 2;
                pipsContainer.textContent = '';
                for (let i = 1; i <= 5; i++) {
                    const pip = document.createElement('span');
                    pip.className = 'tama-pip' + (i <= lvl ? ' filled' : '');
                    pip.title = 'Level ' + i;
                    pip.dataset.level = i;
                    pip.onclick = function() {
                        const newLevel = parseInt(this.dataset.level);
                        if (typeof setAutonomyLevel === 'function') {
                            setAutonomyLevel(newLevel);
                        }
                        // Immediately update pips visually
                        pipsContainer.querySelectorAll('.tama-pip').forEach(function(p) {
                            if (parseInt(p.dataset.level) <= newLevel) {
                                p.classList.add('filled');
                            } else {
                                p.classList.remove('filled');
                            }
                        });
                    };
                    pipsContainer.appendChild(pip);
                }
            }

            // Mini stat cards
            const sa = document.getElementById('tama-stat-actions');
            const sc = document.getElementById('tama-stat-cycles');
            const sp = document.getElementById('tama-stat-pending');
            if (typeof autonomyState !== 'undefined') {
                if (sa) sa.textContent = autonomyState.actions || 0;
                if (sc) sc.textContent = autonomyState.cycles || 0;
                if (sp) sp.textContent = autonomyState.pending || 0;
            }

            // Apply mood to orb
            updateOrbMood(mood);
        }

        async function fetchTamagotchiBackend() {
            try {
                const resp = await fetch(API_URL + '/api/cerebro/tamagotchi');
                if (resp.ok) {
                    const data = await resp.json();
                    tamagotchiState.xp = data.lifetime_xp || 0;
                    tamagotchiState.level = data.level || 1;
                    tamagotchiState.levelProgress = data.level_progress || 0;
                    tamagotchiState.memoryHealth.nas = data.memory_health?.nas_connected || false;
                    tamagotchiState.memoryHealth.faiss = data.memory_health?.faiss_ok || false;
                    tamagotchiState.memoryHealth.faiss_mb = data.memory_health?.faiss_size_mb || 0;
                }
            } catch (e) { /* Backend unavailable */ }
        }

        // Merged command tab renderer  directives + focus as cards
        function renderOrbCommand() {
            const container = document.getElementById('orb-active-directives');
            if (!container) return;
            const active = (directives || []).filter(d => d.status !== 'completed');
            const focusItems = (typeof currentFocus !== 'undefined' ? currentFocus : []);
            container.textContent = '';

            if (active.length === 0 && focusItems.length === 0) {
                const empty = document.createElement('div');
                empty.className = 'orb-command-empty';
                empty.textContent = 'No active directives. Give Cerebro a task below.';
                container.appendChild(empty);
                return;
            }

            // Only show FOCUS for items Cerebro is actively working on (status === 'active')
            const activeFocusItems = focusItems.filter(item => item.status === 'active');
            const focusIds = new Set(activeFocusItems.map(item => item.id));

            activeFocusItems.forEach(function(item) {
                const card = document.createElement('div');
                card.className = 'directive-card';
                const badge = document.createElement('span');
                badge.className = 'directive-status-badge active';
                badge.textContent = 'Focus';
                const text = document.createElement('span');
                text.className = 'directive-card-text';
                text.textContent = item.text || item.name || 'Task';
                card.appendChild(badge);
                card.appendChild(text);
                container.appendChild(card);
            });

            // Show remaining directives (skip ones already shown as FOCUS)
            active.filter(d => !focusIds.has(d.id)).forEach(function(d) {
                const card = document.createElement('div');
                card.className = 'directive-card';
                const badge = document.createElement('span');
                badge.className = 'directive-status-badge pending';
                badge.textContent = 'Pending';
                const text = document.createElement('span');
                text.className = 'directive-card-text';
                text.textContent = d.text;
                const btn = document.createElement('button');
                btn.className = 'directive-card-btn';
                btn.title = 'Complete';
                btn.onclick = function() { completeDirective(d.id); };
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.setAttribute('viewBox', '0 0 24 24');
                svg.setAttribute('width', '14');
                svg.setAttribute('height', '14');
                svg.setAttribute('fill', 'none');
                svg.setAttribute('stroke', 'currentColor');
                svg.setAttribute('stroke-width', '2');
                const polyline = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
                polyline.setAttribute('points', '20 6 9 17 4 12');
                svg.appendChild(polyline);
                btn.appendChild(svg);
                card.appendChild(badge);
                card.appendChild(text);
                card.appendChild(btn);
                container.appendChild(card);
            });
        }

        // Start tamagotchi timers
        setInterval(updateTamagotchiUI, 30000);
        setInterval(fetchTamagotchiBackend, 120000);
        setTimeout(function() { fetchTamagotchiBackend().then(function() { updateTamagotchiUI(); }); }, 2000);

        async function addOrbDirective() {
            const input = document.getElementById('orb-directive-input');
            const text = input?.value?.trim();
            if (!text) return;
            const autoAwake = document.getElementById('auto-awake-checkbox')?.checked ?? true;
            try {
                const response = await fetch(`${API_URL}/api/directives`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${localStorage.getItem('cerebro_token')}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ text, auto_awake: autoAwake })
                });
                const data = await response.json();
                if (data.success) {
                    directives.unshift(data.directive);
                    input.value = '';
                    renderDirectives();
                    recordInteraction();
                    recordAction();
                    showToast('Directive added', 'success');
                } else {
                    showToast(data.error || 'Failed', 'error');
                }
            } catch (e) {
                showToast('Failed to add directive', 'error');
            }
        }

        function renderOrbDirectives() {
            // Delegate to the new card-based renderer
            if (typeof renderOrbCommand === 'function') return renderOrbCommand();
        }

        function renderOrbFocus() {
            const container = document.getElementById('orb-focus-list');
            const countEl = document.getElementById('orb-focus-count');
            if (!container) return;
            const items = typeof currentFocus !== 'undefined' ? currentFocus : [];
            if (countEl) countEl.textContent = items.length;
            container.textContent = '';
            if (items.length === 0) {
                const empty = document.createElement('div');
                empty.className = 'orb-pane-empty';
                empty.textContent = 'No active focus items';
                container.appendChild(empty);
                return;
            }
            items.forEach(item => {
                const el = document.createElement('div');
                el.className = 'orb-list-item';
                el.onclick = () => { openSlidePanel('skills'); switchToTab('focus'); };
                const dot = document.createElement('span');
                dot.className = 'item-dot active';
                const text = document.createElement('span');
                text.className = 'item-text';
                text.textContent = item.text || item.name || 'Task';
                const meta = document.createElement('span');
                meta.className = 'item-meta';
                meta.textContent = item.status === 'active' ? 'Working' : 'Queued';
                el.appendChild(dot);
                el.appendChild(text);
                el.appendChild(meta);
                container.appendChild(el);
            });
        }

        function renderOrbCompleted() {
            const container = document.getElementById('orb-completed-list');
            const countEl = document.getElementById('orb-completed-count');
            if (!container) return;
            const items = typeof completedTasks !== 'undefined' ? completedTasks : [];
            if (countEl) countEl.textContent = items.length;
            container.textContent = '';
            if (items.length === 0) {
                const empty = document.createElement('div');
                empty.className = 'orb-pane-empty';
                empty.textContent = 'No completed tasks yet';
                container.appendChild(empty);
                return;
            }
            // Clear all button
            const clearRow = document.createElement('div');
            clearRow.style.cssText = 'display:flex;justify-content:flex-end;padding:4px 8px 2px;';
            const clearBtn = document.createElement('button');
            clearBtn.style.cssText = 'background:none;border:none;color:var(--text-muted);cursor:pointer;font-size:0.7rem;display:flex;align-items:center;gap:4px;padding:4px 8px;border-radius:6px;transition:all 0.2s;';
            clearBtn.onmouseenter = () => { clearBtn.style.color = '#f87171'; clearBtn.style.background = 'rgba(248,113,113,0.1)'; };
            clearBtn.onmouseleave = () => { clearBtn.style.color = 'var(--text-muted)'; clearBtn.style.background = 'none'; };
            clearBtn.innerHTML = '<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/></svg> Clear all';
            clearBtn.onclick = () => clearCompletedDirectives();
            clearRow.appendChild(clearBtn);
            container.appendChild(clearRow);

            items.forEach(item => {
                const el = document.createElement('div');
                el.className = 'orb-list-item';
                el.onclick = () => { openSlidePanel('skills'); switchToTab('completed'); };
                const dot = document.createElement('span');
                dot.className = 'item-dot done';
                const text = document.createElement('span');
                text.className = 'item-text';
                text.textContent = item.text || item.name || 'Task';
                const meta = document.createElement('span');
                meta.className = 'item-meta';
                meta.textContent = formatTimeAgo(new Date(item.completed_at || item.created_at));
                el.appendChild(dot);
                el.appendChild(text);
                el.appendChild(meta);
                container.appendChild(el);
            });
        }

        function renderOrbSkills() {
            const container = document.getElementById('orb-skills-list');
            const countEl = document.getElementById('orb-skills-count');
            if (!container) return;
            const items = typeof window.skillsList !== 'undefined' ? window.skillsList : [];
            if (countEl) countEl.textContent = items.length;
            container.textContent = '';
            if (items.length === 0) {
                const empty = document.createElement('div');
                empty.className = 'orb-pane-empty';
                empty.textContent = 'No learned skills yet';
                container.appendChild(empty);
                return;
            }
            items.forEach(s => {
                const el = document.createElement('div');
                el.className = 'orb-list-item';
                const dot = document.createElement('span');
                dot.className = 'item-dot skill';
                const text = document.createElement('span');
                text.className = 'item-text';
                text.textContent = s.name || s.skill_name || 'Skill';
                const meta = document.createElement('span');
                meta.className = 'item-meta';
                meta.textContent = s.success_rate ? Math.round(s.success_rate * 100) + '%' : '';
                el.appendChild(dot);
                el.appendChild(text);
                el.appendChild(meta);
                container.appendChild(el);
            });
        }

        async function sendMindChatMessage() {
            const input = document.getElementById('mind-chat-field');
            const btn = document.querySelector('.mind-chat-send-btn');
            const message = input?.value?.trim();

            if (!message) return;

            // Tamagotchi: record user interaction
            recordInteraction();
            recordAction();

            // === REPLY CONTEXT: Route to HITL response ===
            if (_replyContext) {
                const qId = _replyContext.questionId;

                // Add user reply to chat
                cerebroChat.push({
                    id: 'msg_' + Date.now(),
                    role: 'user',
                    content: message,
                    timestamp: new Date().toISOString(),
                    replyTo: qId
                });
                if (input) input.value = '';
                renderChatMessages();

                // Emit HITL response
                if (socket) {
                    const popup = hitlPopups.find(p => p.id === qId);
                    socket.emit('human_input_response', {
                        request_id: qId,
                        directive_id: popup ? (popup.data.directive_id || '') : '',
                        answer: message,
                        timestamp: new Date().toISOString()
                    });
                }

                // Dismiss the modal popup
                dismissHITLPopup(qId);

                // Clear reply context
                clearReplyContext();

                // Re-enable input
                if (input) input.disabled = false;
                if (btn) btn.disabled = false;

                showToast('Response sent to Cerebro', 'success');
                return;
            }

            // Disable input
            if (input) input.disabled = true;
            if (btn) btn.disabled = true;

            const mindImg = ImageUpload.pending['mind-image-preview'];

            // Add user message
            cerebroChat.push({
                id: 'msg_' + Date.now(),
                role: 'user',
                content: message,
                timestamp: new Date().toISOString(),
                imageUrl: mindImg?.url || null
            });
            ImageUpload.clearPreview('mind-image-preview');
            renderChatMessages();

            // Clear input
            if (input) input.value = '';

            // v2.0: ALL messages route as directives  Claude Code agents
            // Agent narration streams back via cerebro_narration socket events
            const autoAwake = document.getElementById('auto-awake-checkbox')?.checked ?? true;
            try {
                const response = await fetch(`${API_URL}/api/directives`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${localStorage.getItem('cerebro_token')}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        text: message,
                        auto_awake: autoAwake,
                        image_path: mindImg?.path || null
                    })
                });
                const data = await response.json();
                cerebroChat.push({
                    id: 'msg_' + (Date.now() + 1),
                    role: 'assistant',
                    content: '',
                    timestamp: new Date().toISOString(),
                    directiveId: data.directive?.id || data.id || null,
                    isDirectiveCard: true,
                    agentId: null,
                    agentCallSign: null,
                    agentStatus: null
                });
                renderChatMessages();
                renderMindChat();
            } catch (e) {
                console.error('Directive submit error:', e);
                cerebroChat.push({
                    id: 'msg_' + (Date.now() + 1),
                    role: 'assistant',
                    content: 'Failed to submit directive. Try the Command tab instead.',
                    timestamp: new Date().toISOString()
                });
                renderChatMessages();
            }

            // Re-enable
            if (input) input.disabled = false;
            if (btn) btn.disabled = false;
            if (input) input.focus();
        }

        // Text-to-Speech for Cerebro messages
        let currentSpeech = null;
        async function speakText(text, btnElement) {
            // Stop any current speech
            stopSpeaking();

            // If clicking the same button that was playing, just stop
            if (btnElement && (btnElement.classList.contains('speaking') || btnElement.classList.contains('loading'))) {
                btnElement.classList.remove('speaking', 'loading');
                return;
            }

            // Clear all speaking/loading states
            document.querySelectorAll('.chat-speak-btn.speaking, .chat-speak-btn.loading, .voice-speak-btn.speaking, .voice-speak-btn.loading').forEach(function(btn) {
                btn.classList.remove('speaking', 'loading');
            });

            // Strip markdown/HTML for cleaner speech
            var cleanText = text
                .replace(/```[\s\S]*?```/g, ' code block ')
                .replace(/\*\*([^*]+)\*\*/g, '$1')
                .replace(/\*([^*]+)\*/g, '$1')
                .replace(/#{1,6}\s/g, '')
                .replace(/\[([^\]]+)\]\([^)]+\)/g, '$1')
                .replace(/`([^`]+)`/g, '$1')
                .replace(/[\-*]{3,}/g, '')
                .replace(/^[\s]*[\-*+]\s/gm, '')
                .replace(/^[\s]*\d+\.\s/gm, '')
                .replace(/\n{2,}/g, '. ')
                .replace(/\n/g, ' ')
                .trim();

            // Cap at ~500 chars for speed (Kokoro CPU gets slow on long text)
            if (cleanText.length > 500) {
                var cutPoint = cleanText.lastIndexOf('.', 500);
                if (cutPoint < 200) cutPoint = cleanText.lastIndexOf(' ', 500);
                if (cutPoint < 200) cutPoint = 500;
                cleanText = cleanText.substring(0, cutPoint + 1);
            }
            if (!cleanText) return;

            // Immediate loading feedback
            if (btnElement) btnElement.classList.add('loading');
            setSpeakingState(true, 'loading');

            try {
                var response = await fetch(TTS_URL + '/v1/audio/speech', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        model: 'kokoro',
                        input: cleanText,
                        voice: TTS_CONFIG.voice,
                        response_format: 'mp3',
                        speed: TTS_CONFIG.speed
                    })
                });

                if (!response.ok) throw new Error('TTS ' + response.status);

                // Switch loading -> speaking
                if (btnElement) {
                    btnElement.classList.remove('loading');
                    btnElement.classList.add('speaking');
                }
                setSpeakingState(true, 'speaking');

                var audioBlob = await response.blob();
                var audioUrl = URL.createObjectURL(audioBlob);
                currentAudio = new Audio(audioUrl);

                if (selectedSpeakerId && currentAudio.setSinkId) {
                    try { await currentAudio.setSinkId(selectedSpeakerId); } catch(e) {}
                }

                currentAudio.onended = function() {
                    setSpeakingState(false);
                    URL.revokeObjectURL(audioUrl);
                    currentAudio = null;
                    if (btnElement) btnElement.classList.remove('speaking', 'loading');
                };
                currentAudio.onerror = function() {
                    setSpeakingState(false);
                    if (btnElement) btnElement.classList.remove('speaking', 'loading');
                    showToast('Audio playback failed');
                };

                await currentAudio.play();
            } catch (e) {
                console.error('[TTS] speakText error:', e);
                setSpeakingState(false);
                if (btnElement) btnElement.classList.remove('speaking', 'loading');

                // Fallback: browser speech synthesis
                try {
                    if (window.speechSynthesis) {
                        var utterance = new SpeechSynthesisUtterance(cleanText);
                        utterance.rate = TTS_CONFIG.speed;
                        var voices = window.speechSynthesis.getVoices();
                        var femaleVoice = voices.find(function(v) { return /female|zira|hazel|susan|samantha/i.test(v.name); })
                                       || voices.find(function(v) { return v.lang.startsWith('en'); });
                        if (femaleVoice) utterance.voice = femaleVoice;
                        utterance.onend = function() {
                            if (btnElement) btnElement.classList.remove('speaking');
                        };
                        if (btnElement) btnElement.classList.add('speaking');
                        window.speechSynthesis.speak(utterance);
                    } else {
                        showToast('Voice unavailable');
                    }
                } catch (fb) {
                    showToast('Voice unavailable');
                }
            }
        }

        // Speak the main voice content (center bubble)
        function speakVoiceContent() {
            const voiceContent = document.getElementById('voice-content');
            const btn = document.getElementById('voice-speak-btn');
            if (voiceContent) {
                speakText(voiceContent.textContent, btn);
            }
        }

        // Speak a chat message by index (avoids escaping issues)
        function speakChatMessage(msgIdx, btnElement) {
            if (cerebroChat[msgIdx]) {
                speakText(cerebroChat[msgIdx].content, btnElement);
            }
        }

        function updateQuestionsBadge() {
            const badge = document.getElementById('cerebro-questions-badge');
            const countEl = document.getElementById('questions-badge-count');

            if (!badge) return;

            if (proactiveQuestions.length > 0) {
                badge.style.display = 'flex';
                if (countEl) countEl.textContent = proactiveQuestions.length;
            } else {
                badge.style.display = 'none';
            }
        }

        // ===== QUESTIONS WIZARD =====
        let wizardCurrentIndex = 0;

        function openQuestionsWizard() {
            if (proactiveQuestions.length === 0) {
                showToast('No questions from Cerebro', 'info');
                return;
            }

            wizardCurrentIndex = 0;
            const overlay = document.getElementById('questions-wizard-overlay');
            if (overlay) {
                overlay.classList.add('active');
                renderWizardQuestion();
            }
        }

        function closeQuestionsWizard() {
            const overlay = document.getElementById('questions-wizard-overlay');
            if (overlay) overlay.classList.remove('active');
        }

        function closeWizardIfBackground(event) {
            if (event.target.classList.contains('questions-wizard-overlay')) {
                closeQuestionsWizard();
            }
        }

        function renderWizardQuestion() {
            const content = document.getElementById('wizard-content');
            const progressBar = document.getElementById('wizard-progress-bar');
            const progressText = document.getElementById('wizard-progress-text');
            const prevBtn = document.getElementById('wizard-prev-btn');
            const nextBtn = document.getElementById('wizard-next-btn');

            if (!content || proactiveQuestions.length === 0) return;

            const question = proactiveQuestions[wizardCurrentIndex];
            const total = proactiveQuestions.length;
            const progress = ((wizardCurrentIndex + 1) / total) * 100;

            // Update progress
            if (progressBar) progressBar.style.setProperty('--progress', `${progress}%`);
            if (progressText) progressText.textContent = `${wizardCurrentIndex + 1} of ${total}`;

            // Update buttons
            if (prevBtn) prevBtn.disabled = wizardCurrentIndex === 0;
            if (nextBtn) nextBtn.textContent = wizardCurrentIndex === total - 1 ? 'Done ' : 'Next ';

            // Render question
            content.innerHTML = `
                <div class="wizard-question-tag">${question.type || question.tag || 'Question'}</div>
                <div class="wizard-question-text">${escapeHtml(question.question)}</div>
                <textarea class="wizard-answer-input" id="wizard-answer-field" placeholder="Type your answer..."></textarea>
            `;
        }

        function prevWizardQuestion() {
            if (wizardCurrentIndex > 0) {
                wizardCurrentIndex--;
                renderWizardQuestion();
            }
        }

        async function nextWizardQuestion() {
            const answerField = document.getElementById('wizard-answer-field');
            const answer = answerField?.value?.trim();
            const question = proactiveQuestions[wizardCurrentIndex];

            // If there's an answer, submit it
            if (answer && question) {
                try {
                    await fetch(`${API_URL}/api/autonomy/answer`, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${localStorage.getItem('cerebro_token')}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            question_id: question.id,
                            answer: answer
                        })
                    });

                    // Add to chat as a record
                    cerebroChat.push({
                        id: 'msg_' + Date.now(),
                        role: 'user',
                        content: `[Re: ${question.question.substring(0, 30)}...] ${answer}`,
                        timestamp: new Date().toISOString()
                    });

                    // Remove from questions
                    await dismissQuestion(question.id);
                } catch (e) {
                    console.error('Failed to submit answer:', e);
                }
            }

            // Move to next or close
            if (wizardCurrentIndex < proactiveQuestions.length - 1) {
                wizardCurrentIndex++;
                renderWizardQuestion();
            } else {
                closeQuestionsWizard();
                renderChatMessages();
                showToast('All questions answered!', 'success');
            }
        }

        function skipWizardQuestion() {
            const question = proactiveQuestions[wizardCurrentIndex];
            if (question) {
                dismissQuestion(question.id);
            }

            if (proactiveQuestions.length === 0) {
                closeQuestionsWizard();
                showToast('Questions cleared', 'info');
            } else {
                if (wizardCurrentIndex >= proactiveQuestions.length) {
                    wizardCurrentIndex = proactiveQuestions.length - 1;
                }
                renderWizardQuestion();
            }
        }

        // Legacy alias
        async function askCerebro() {
            // Redirect to new system
            const oldInput = document.getElementById('ask-cerebro-field');
            const newInput = document.getElementById('cerebro-chat-field');
            if (oldInput && newInput) {
                newInput.value = oldInput.value;
                oldInput.value = '';
            }
            await sendChatMessage();
        }

        function renderCerebroChat() {
            // Render both chat and update badge
            renderChatMessages();
            updateQuestionsBadge();
        }

        function answerProactiveQuestion(questionId) {
            // Find the question index
            const idx = proactiveQuestions.findIndex(q => q.id === questionId);
            if (idx === -1) return;

            // Open the wizard at this question
            wizardCurrentIndex = idx;
            openQuestionsWizard();
        }

        // Legacy alias for compatibility
        function renderQuestionsWithAnswers() {
            renderCerebroChat();
        }

        function addProactiveQuestion(question, context, tag = 'curious') {
            const item = {
                id: Date.now(),
                question: question,
                context: context,
                tag: tag,
                timestamp: new Date().toISOString()
            };

            proactiveQuestions.unshift(item);
            if (proactiveQuestions.length > 20) proactiveQuestions.pop();

            updateQuestionsBadge();  // Update the questions badge

            // Expand sidebar if collapsed and new question arrives
            const sidebar = document.getElementById('sidebar-questions');
            if (sidebar && sidebar.classList.contains('collapsed')) {
                sidebar.classList.remove('collapsed');
            }
        }

        function renderProactiveQuestions() {
            // Use the combined renderer that shows both answers and questions
            renderQuestionsWithAnswers();
        }

        // Current Focus - what Cerebro is working on
        let currentFocus = [];

        function updateCurrentFocus(focusItems) {
            currentFocus = focusItems || [];
            renderCurrentFocus();
            if (typeof renderOrbFocus === 'function') renderOrbFocus();
        }

        function renderCurrentFocus() {
            const container = document.getElementById('focus-container');
            const countEl = document.getElementById('focus-count');

            if (!container) return;

            if (countEl) countEl.textContent = currentFocus.length;

            if (currentFocus.length === 0) {
                container.innerHTML = `
                    <div class="section-empty">
                        <div class="section-empty-icon"></div>
                        <div class="section-empty-text">No active focus<br>Give Cerebro a directive</div>
                    </div>
                `;
                return;
            }

            container.innerHTML = currentFocus.map(item => {
                const isGoal = item.type === 'goal';
                const typeIcon = isGoal ? '' : '';
                const typeLabel = isGoal ? 'Goal' : 'Task';
                const statusLabel = item.paused ? 'Paused' : (item.status === 'pending' ? 'Queued' : (isGoal ? 'Active' : 'Working'));

                return `
                <div class="focus-item ${item.status || 'active'}${item.paused ? ' paused' : ''}${isGoal ? ' goal-type' : ' task-type'}"
                     data-id="${item.id || ''}"
                     onclick="openFindingsPopup('${item.id || ''}')">
                    <div class="focus-item-status">
                        <div class="focus-status-indicator"></div>
                        <span class="focus-type-badge" title="${typeLabel}">${typeIcon}</span>
                        <span class="focus-status-label">${statusLabel}</span>
                    </div>
                    <div class="focus-item-text">${escapeHtml(item.text || item.directive || item.goal || '')}</div>
                    <div class="focus-item-progress" title="${item.saturation || 0}% ${isGoal ? 'progress' : 'completion'}">
                        <div class="focus-progress-bar ${isGoal ? 'goal-bar' : 'task-bar'}" style="width: ${item.saturation || 0}%"></div>
                    </div>
                    <div class="focus-item-controls" onclick="event.stopPropagation()">
                        <button class="focus-control-btn view" onclick="openFindingsPopup('${item.id || ''}')">View</button>
                        <button class="focus-control-btn pause" onclick="toggleDirectivePauseById('${item.id || ''}')">
                            ${item.paused ? 'Resume' : 'Pause'}
                        </button>
                    </div>
                </div>
            `}).join('');
        }

        // Update focus when directives change
        function syncDirectivesToFocus() {
            const activeItems = directives.filter(d => d.status !== 'completed');
            const focusItems = activeItems.map((d, i) => ({
                id: d.id,
                text: d.text,
                type: d.type || 'task',  // task or goal
                status: d.status === 'active' ? 'active' : 'pending',
                paused: d.paused || false,
                saturation: d.saturation || 0,
                created_at: d.created_at
            }));
            updateCurrentFocus(focusItems);

            // Also update completed tasks
            const completedItems = directives.filter(d => d.status === 'completed');
            updateCompletedTasks(completedItems);
        }

        // ========================================
        // COMPLETED TASKS - Task History
        // ========================================
        let completedTasks = [];

        function updateCompletedTasks(items) {
            completedTasks = items || [];
            renderCompletedTasks();
            if (typeof renderOrbCompleted === 'function') renderOrbCompleted();
        }

        function renderCompletedTasks() {
            const container = document.getElementById('completed-container');
            const countEl = document.getElementById('completed-count');

            if (!container) return;

            if (countEl) countEl.textContent = completedTasks.length;

            if (completedTasks.length === 0) {
                container.innerHTML = `
                    <div class="section-empty">
                        <div class="section-empty-icon"></div>
                        <div class="section-empty-text">No completed tasks yet</div>
                    </div>
                `;
                return;
            }

            // Sort by completion time (most recent first)
            const sorted = [...completedTasks].sort((a, b) => {
                const timeA = a.completed_at ? new Date(a.completed_at) : new Date(a.created_at);
                const timeB = b.completed_at ? new Date(b.completed_at) : new Date(b.created_at);
                return timeB - timeA;
            });

            container.innerHTML = sorted.map(item => {
                const isGoal = item.type === 'goal';
                const typeIcon = isGoal ? '' : '';
                const typeLabel = isGoal ? 'Goal' : 'Task';
                const completedTime = item.completed_at ? formatTimeAgo(new Date(item.completed_at)) : 'Recently';

                return `
                <div class="completed-item" data-id="${item.id || ''}" onclick="openFindingsPopup('${item.id || ''}')">
                    <div class="completed-item-header">
                        <span class="completed-item-icon">${typeIcon}</span>
                        <span class="completed-item-text">${escapeHtml(item.text || '')}</span>
                    </div>
                    <div class="completed-item-meta">
                        <span class="completed-item-time">Completed ${completedTime}</span>
                        <span class="completed-item-type">${typeLabel}</span>
                    </div>
                </div>
            `}).join('');
        }

        async function clearCompletedDirectives() {
            try {
                const response = await fetch(`${API_URL}/api/directives/completed/clear`, {
                    method: 'DELETE',
                    headers: { 'Authorization': `Bearer ${localStorage.getItem('cerebro_token')}` }
                });
                if (response.ok) {
                    directives = directives.filter(d => d.status !== 'completed');
                    completedTasks = [];
                    renderCompletedTasks();
                    if (typeof renderOrbCompleted === 'function') renderOrbCompleted();
                    renderDirectives();
                    showToast('Completed tasks cleared', 'info');
                } else {
                    showToast('Failed to clear completed tasks', 'error');
                }
            } catch (e) {
                showToast('Failed to clear completed tasks', 'error');
            }
        }

        function toggleCompletedSection() {
            const section = document.querySelector('.section-completed');
            if (section) {
                section.classList.toggle('section-collapsed');
            }
        }

        // ========================================
        // FINDINGS POPUP - Research Results
        // ========================================
        let currentFindingsDirective = null;
        let currentFindings = { all: [], observations: [], learnings: [], insights: [] };

        async function openFindingsPopup(directiveId) {
            if (!directiveId) return;

            const directive = directives.find(d => d.id === directiveId);
            if (!directive) return;

            currentFindingsDirective = directive;

            // Update header info
            const directiveText = document.getElementById('findings-directive-text');
            const statusDot = document.getElementById('findings-status-dot');
            const statusText = document.getElementById('findings-status-text');
            const startedText = document.getElementById('findings-started');

            if (directiveText) directiveText.textContent = directive.text;

            const isCompleted = directive.status === 'completed';

            if (statusDot) {
                statusDot.className = 'findings-meta-dot ' + (isCompleted ? 'completed' : directive.paused ? 'paused' : 'active');
            }
            if (statusText) {
                if (isCompleted) {
                    statusText.textContent = 'Completed';
                } else {
                    statusText.textContent = directive.paused ? 'Paused' : 'Actively researching';
                }
            }
            if (startedText && directive.created_at) {
                if (isCompleted && directive.completed_at) {
                    startedText.textContent = `Completed ${formatTimeAgo(new Date(directive.completed_at))}`;
                } else {
                    startedText.textContent = `Started ${formatTimeAgo(new Date(directive.created_at))}`;
                }
            }

            // Update findings count
            const findingsCount = document.getElementById('findings-count');
            if (findingsCount) {
                findingsCount.textContent = `${directive.findings_count || 0} findings`;
            }

            // Update pause button - hide for completed tasks
            const pauseBtn = document.getElementById('findings-pause-btn');
            const completeBtn = document.querySelector('.findings-btn.danger');
            if (pauseBtn) {
                if (isCompleted) {
                    pauseBtn.style.display = 'none';
                } else {
                    pauseBtn.style.display = 'block';
                    pauseBtn.textContent = directive.paused ? 'Resume Research' : 'Pause Research';
                }
            }
            if (completeBtn) {
                completeBtn.style.display = isCompleted ? 'none' : 'block';
            }

            // Show overlay
            const overlay = document.getElementById('findings-overlay');
            if (overlay) overlay.classList.add('active');

            // Load findings from backend
            await loadDirectiveFindings(directiveId);
        }

        function closeFindingsPopup() {
            const overlay = document.getElementById('findings-overlay');
            if (overlay) overlay.classList.remove('active');
            currentFindingsDirective = null;
        }

        function closeFindingsIfBackground(event) {
            if (event.target.classList.contains('findings-overlay')) {
                closeFindingsPopup();
            }
        }

        async function loadDirectiveFindings(directiveId) {
            try {
                const response = await fetch(`${API_URL}/api/directives/${directiveId}/findings`, {
                    headers: { 'Authorization': `Bearer ${localStorage.getItem('cerebro_token')}` }
                });

                if (response.ok) {
                    const data = await response.json();

                    // Organize findings by type
                    currentFindings = {
                        all: data.findings || [],
                        observations: (data.findings || []).filter(f => f.type === 'observation'),
                        learnings: (data.findings || []).filter(f => f.type === 'learning'),
                        insights: (data.findings || []).filter(f => f.type === 'insight')
                    };

                    // Update counts
                    updateFindingsCounts();

                    // Update saturation
                    const saturation = data.saturation || 0;
                    const saturationFill = document.getElementById('saturation-fill');
                    const saturationPercent = document.getElementById('saturation-percent');
                    if (saturationFill) saturationFill.style.width = `${saturation}%`;
                    if (saturationPercent) saturationPercent.textContent = `${saturation}%`;

                    // For completed tasks, show Summary tab first to display final answer
                    const directive = currentFindingsDirective;
                    if (directive && directive.status === 'completed') {
                        switchFindingsTab('summary');
                    } else {
                        // Render current tab
                        renderFindings('all');
                    }
                } else {
                    // No findings endpoint yet, show empty state
                    currentFindings = { all: [], observations: [], learnings: [], insights: [] };
                    updateFindingsCounts();
                    renderFindings('all');
                }
            } catch (e) {
                console.error('Failed to load findings:', e);
                currentFindings = { all: [], observations: [], learnings: [], insights: [] };
                updateFindingsCounts();
                renderFindings('all');
            }
        }

        function updateFindingsCounts() {
            const countAll = document.getElementById('findings-count-all');
            const countObs = document.getElementById('findings-count-observations');
            const countLearn = document.getElementById('findings-count-learnings');
            const countInsight = document.getElementById('findings-count-insights');
            const countHeader = document.getElementById('findings-count');

            if (countAll) countAll.textContent = currentFindings.all.length;
            if (countObs) countObs.textContent = currentFindings.observations.length;
            if (countLearn) countLearn.textContent = currentFindings.learnings.length;
            if (countInsight) countInsight.textContent = currentFindings.insights.length;
            if (countHeader) countHeader.textContent = `${currentFindings.all.length} findings`;
        }

        function switchFindingsTab(tab) {
            // Update active tab
            document.querySelectorAll('.findings-tab').forEach(t => {
                t.classList.toggle('active', t.dataset.tab === tab);
            });

            // Handle Summary tab specially
            if (tab === 'summary') {
                renderSummary();
            } else {
                // Render findings for this tab
                renderFindings(tab);
            }
        }

        let cachedSummary = null;

        async function renderSummary() {
            const container = document.getElementById('findings-content');
            if (!container || !currentFindingsDirective) return;

            const directive = currentFindingsDirective;
            const isCompleted = directive.status === 'completed';

            // For completed tasks with a final_answer, show it immediately
            if (isCompleted && directive.final_answer) {
                const htmlContent = markdownToHtml(directive.final_answer);
                container.innerHTML = `
                    <div class="summary-content active" style="position: relative;">
                        <div class="final-answer-banner">
                            <span class="final-answer-icon"></span>
                            <span class="final-answer-label">Task Completed</span>
                        </div>
                        <div class="summary-report final-answer-content">
                            <h3 style="margin-top: 0; color: #10b981;">Cerebro's Answer</h3>
                            ${htmlContent}
                        </div>
                        <div class="summary-actions">
                            <button class="summary-action-btn secondary" onclick="switchFindingsTab('all')">
                                View All ${currentFindings.all.length} Findings
                            </button>
                        </div>
                    </div>
                `;
                return;
            }

            // Show loading state
            container.innerHTML = `
                <div class="summary-content active" style="position: relative;">
                    <div class="summary-loading">
                        <div class="summary-loading-spinner"></div>
                        <div>Generating summary report...</div>
                        <div style="font-size: 0.8rem; margin-top: 8px; opacity: 0.7;">Cerebro is synthesizing all findings</div>
                    </div>
                </div>
            `;

            try {
                const response = await fetch(`${API_URL}/api/directives/${currentFindingsDirective.id}/summary`, {
                    headers: { 'Authorization': `Bearer ${localStorage.getItem('cerebro_token')}` }
                });
                const data = await response.json();

                if (data.success && data.summary) {
                    // Convert markdown to HTML (basic conversion)
                    const htmlContent = markdownToHtml(data.summary);

                    container.innerHTML = `
                        <div class="summary-content active" style="position: relative;">
                            <button class="summary-refresh-btn" onclick="refreshSummary()"> Refresh</button>
                            <div class="summary-report">
                                ${htmlContent}
                            </div>
                            <div class="summary-actions">
                                ${data.saturation >= 80 && data.directive_type === 'task' ? `
                                    <button class="summary-action-btn primary" onclick="markDirectiveComplete()">
                                         Mark Task Complete
                                    </button>
                                ` : ''}
                                <button class="summary-action-btn secondary" onclick="switchFindingsTab('all')">
                                    View All Findings
                                </button>
                            </div>
                        </div>
                    `;
                    cachedSummary = data.summary;
                } else {
                    container.innerHTML = `
                        <div class="summary-content active">
                            <div class="findings-empty">
                                <div class="findings-empty-icon"></div>
                                <div class="findings-empty-text">Could not generate summary. Try again later.</div>
                            </div>
                        </div>
                    `;
                }
            } catch (e) {
                console.error('Failed to load summary:', e);
                container.innerHTML = `
                    <div class="summary-content active">
                        <div class="findings-empty">
                            <div class="findings-empty-icon"></div>
                            <div class="findings-empty-text">Error loading summary: ${e.message}</div>
                        </div>
                    </div>
                `;
            }
        }

        function refreshSummary() {
            cachedSummary = null;
            renderSummary();
        }

        function markdownToHtml(md) {
            // Basic markdown to HTML conversion
            return md
                // Headers
                .replace(/^### (.*$)/gim, '<h3>$1</h3>')
                .replace(/^## (.*$)/gim, '<h2>$1</h2>')
                .replace(/^# (.*$)/gim, '<h1>$1</h1>')
                // Bold
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                // Italic
                .replace(/\*(.*?)\*/g, '<em>$1</em>')
                // Code
                .replace(/`(.*?)`/g, '<code>$1</code>')
                // Lists
                .replace(/^\- (.*$)/gim, '<li>$1</li>')
                .replace(/^\d+\. (.*$)/gim, '<li>$1</li>')
                // Wrap consecutive li in ul
                .replace(/(<li>.*<\/li>\n?)+/g, '<ul>$&</ul>')
                // Paragraphs (lines not starting with special chars)
                .replace(/^(?!<[hul]|<li)(.*$)/gim, (match) => match.trim() ? `<p>${match}</p>` : '')
                // Clean up empty paragraphs
                .replace(/<p><\/p>/g, '')
                // Line breaks
                .replace(/\n\n/g, '<br>');
        }

        function renderFindings(tab) {
            const container = document.getElementById('findings-content');
            if (!container) return;

            const findings = currentFindings[tab] || [];

            if (findings.length === 0) {
                container.innerHTML = `
                    <div class="findings-empty">
                        <div class="findings-empty-icon"></div>
                        <div class="findings-empty-text">
                            ${tab === 'all'
                                ? 'No findings yet. Cerebro is still researching...'
                                : `No ${tab} found yet.`}
                        </div>
                    </div>
                `;
                return;
            }

            container.innerHTML = findings.map(f => `
                <div class="finding-item ${f.type || 'observation'}">
                    <div class="finding-type">
                        <span class="finding-type-dot"></span>
                        <span>${f.type || 'observation'}</span>
                    </div>
                    <div class="finding-text">${escapeHtml(f.content || f.text || '')}</div>
                    ${f.timestamp ? `<div class="finding-time">${formatTimeAgo(new Date(f.timestamp))}</div>` : ''}
                </div>
            `).join('');
        }

        async function toggleDirectivePause() {
            if (!currentFindingsDirective) return;
            await toggleDirectivePauseById(currentFindingsDirective.id);

            // Update UI
            const directive = directives.find(d => d.id === currentFindingsDirective.id);
            if (directive) {
                currentFindingsDirective = directive;
                const statusDot = document.getElementById('findings-status-dot');
                const statusText = document.getElementById('findings-status-text');
                const pauseBtn = document.getElementById('findings-pause-btn');

                if (statusDot) {
                    statusDot.className = 'findings-meta-dot ' + (directive.paused ? 'paused' : 'active');
                }
                if (statusText) {
                    statusText.textContent = directive.paused ? 'Paused' : 'Actively researching';
                }
                if (pauseBtn) {
                    pauseBtn.textContent = directive.paused ? 'Resume Research' : 'Pause Research';
                }
            }
        }

        async function toggleDirectivePauseById(directiveId) {
            try {
                const response = await fetch(`${API_URL}/api/directives/${directiveId}/toggle-pause`, {
                    method: 'POST',
                    headers: { 'Authorization': `Bearer ${localStorage.getItem('cerebro_token')}` }
                });

                if (response.ok) {
                    const data = await response.json();
                    // Update local directive
                    const directive = directives.find(d => d.id === directiveId);
                    if (directive) {
                        directive.paused = data.paused;
                    }
                    renderDirectives();
                    showToast(data.paused ? 'Research paused' : 'Research resumed', 'info');
                }
            } catch (e) {
                console.error('Failed to toggle pause:', e);
                showToast('Failed to toggle pause', 'error');
            }
        }

        async function markDirectiveComplete() {
            if (!currentFindingsDirective) return;

            await completeDirective(currentFindingsDirective.id);
            closeFindingsPopup();
        }

        function openQuestionInput(questionId) {
            const question = proactiveQuestions.find(q => q.id === questionId);
            if (!question) return;

            currentQuestion = question;

            const inputText = document.getElementById('question-input-text');
            const answerField = document.getElementById('question-answer-field');
            const overlay = document.getElementById('question-input-overlay');

            if (inputText) inputText.textContent = question.question;
            if (answerField) answerField.value = '';
            if (overlay) overlay.classList.add('active');

            // Focus the textarea
            setTimeout(() => {
                const field = document.getElementById('question-answer-field');
                if (field) field.focus();
            }, 100);
        }

        function closeQuestionInput() {
            const overlay = document.getElementById('question-input-overlay');
            if (overlay) overlay.classList.remove('active');
            currentQuestion = null;
        }

        async function submitQuestionAnswer() {
            if (!currentQuestion) return;

            const answerField = document.getElementById('question-answer-field');
            const answer = answerField ? answerField.value.trim() : '';
            if (!answer) {
                showToast('Please provide an answer', 'warning');
                return;
            }

            try {
                // Send answer to backend
                const response = await fetch(`${API_URL}/api/autonomy/answer-question`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${localStorage.getItem('cerebro_token')}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        question_id: currentQuestion.id,
                        question: currentQuestion.question,
                        answer: answer
                    })
                });

                const data = await response.json();
                if (data.success) {
                    showToast('Thank you for sharing!', 'success');

                    // Remove question from list
                    dismissQuestion(currentQuestion.id);
                    closeQuestionInput();

                    // Add to activity log
                    addActivityLogItem('ask', `Answered: "${currentQuestion.question.substring(0, 50)}..."`);
                }
            } catch (e) {
                console.error('Failed to submit answer:', e);
                showToast('Failed to submit answer', 'error');
            }
        }

        async function dismissQuestion(questionId) {
            const idx = proactiveQuestions.findIndex(q => q.id === questionId);
            if (idx !== -1) {
                proactiveQuestions.splice(idx, 1);
                updateQuestionsBadge();
            }

            // Also delete from backend for persistence
            try {
                await fetch(`${API_URL}/api/autonomy/questions/${questionId}`, {
                    method: 'DELETE',
                    headers: { 'Authorization': `Bearer ${localStorage.getItem('cerebro_token')}` }
                });
            } catch (e) {
                console.error('Failed to delete question from backend:', e);
            }
        }

        async function clearAllQuestions() {
            if (!await cerebroConfirm('Clear all questions from Cerebro?', { title: 'Clear Questions', danger: true, confirmText: 'Clear' })) return;

            // Clear local array
            proactiveQuestions.length = 0;
            updateQuestionsBadge();

            // Clear from backend
            try {
                await fetch(`${API_URL}/api/autonomy/questions`, {
                    method: 'DELETE',
                    headers: { 'Authorization': `Bearer ${localStorage.getItem('cerebro_token')}` }
                });
                showToast('Questions cleared', 'success');
            } catch (e) {
                console.error('Failed to clear questions:', e);
                showToast('Failed to clear questions', 'error');
            }
        }

        async function approveAction(actionId) {
            try {
                const response = await fetch(`${API_URL}/api/autonomy/approve/${actionId}`, {
                    method: 'POST',
                    headers: { 'Authorization': `Bearer ${localStorage.getItem('cerebro_token')}` }
                });
                const data = await response.json();
                if (data.success) {
                    showToast('Action approved', 'success');
                    loadPendingApprovals();
                }
            } catch (e) {
                showToast('Failed to approve action', 'error');
            }
        }

        async function rejectAction(actionId) {
            try {
                const response = await fetch(`${API_URL}/api/autonomy/reject/${actionId}`, {
                    method: 'POST',
                    headers: { 'Authorization': `Bearer ${localStorage.getItem('cerebro_token')}` }
                });
                const data = await response.json();
                if (data.success) {
                    showToast('Action rejected', 'info');
                    loadPendingApprovals();
                }
            } catch (e) {
                showToast('Failed to reject action', 'error');
            }
        }

        function renderThoughtStream() {
            const container = document.getElementById('thought-stream');
            const countEl = document.getElementById('thought-count');

            // Phase display names and icons for clarity
            const phaseDisplay = {
                observe: { name: 'OBSERVING', icon: '', color: '#3b82f6' },
                orient: { name: 'ANALYZING', icon: '', color: '#8b5cf6' },
                decide: { name: 'DECIDING', icon: '', color: '#f59e0b' },
                act: { name: 'ACTING', icon: '', color: '#ef4444' },
                reflect: { name: 'REFLECTING', icon: '', color: '#10b981' },
                idle: { name: 'IDLE', icon: '', color: '#6b7280' }
            };

            // Guard against missing elements
            if (!container) return;

            if (thoughtStream.length === 0) {
                const isRunning = autonomyState.status === 'running';
                container.innerHTML = isRunning ? `
                    <div class="goals-empty" style="padding: 30px;">
                        <div style="font-size: 2rem; animation: pulse 1.5s ease-in-out infinite;"></div>
                        <div style="margin-top: 8px; color: var(--accent);">Mind awakening...</div>
                        <div style="font-size: 0.75rem; color: var(--text-muted);">First thoughts coming soon</div>
                    </div>` : `
                    <div class="goals-empty" style="padding: 30px;">
                        <div style="font-size: 2rem; opacity: 0.3;"></div>
                        <div style="margin-top: 8px;">Mind at rest</div>
                        <div style="font-size: 0.75rem; color: var(--text-muted);">Click the orb to awaken</div>
                    </div>`;
                if (countEl) countEl.textContent = isRunning ? 'awakening...' : '0 thoughts';
                return;
            }

            if (countEl) countEl.textContent = `${thoughtStream.length} thoughts`;
            container.innerHTML = thoughtStream.map(thought => {
                const time = new Date(thought.timestamp).toLocaleTimeString();
                const date = new Date(thought.timestamp).toLocaleDateString();
                const confidence = Math.round((thought.confidence || 0.5) * 100);
                const phase = phaseDisplay[thought.phase] || phaseDisplay.idle;

                // Check if this is a session marker
                if (thought.is_session_marker || thought.metadata?.is_session_marker) {
                    const markerType = thought.metadata?.marker_type || (thought.content?.includes('START') ? 'start' : 'end');
                    const levelName = thought.metadata?.level_name || '';
                    const cycles = thought.metadata?.cycles_completed || '';

                    if (markerType === 'start') {
                        return `
                            <div class="session-marker session-start">
                                <div class="session-marker-line"></div>
                                <div class="session-marker-content">
                                    <span class="session-marker-icon"></span>
                                    <span class="session-marker-text">Session Started</span>
                                    ${levelName ? `<span class="session-marker-level">${levelName}</span>` : ''}
                                </div>
                                <div class="session-marker-time">${date} ${time}</div>
                            </div>
                        `;
                    } else {
                        return `
                            <div class="session-marker session-end">
                                <div class="session-marker-line"></div>
                                <div class="session-marker-content">
                                    <span class="session-marker-icon"></span>
                                    <span class="session-marker-text">Session Ended</span>
                                    ${cycles ? `<span class="session-marker-cycles">${cycles} cycles</span>` : ''}
                                </div>
                                <div class="session-marker-time">${date} ${time}</div>
                            </div>
                        `;
                    }
                }

                // Make content more readable
                let content = thought.content || '';
                // Highlight key actions/decisions
                content = content.replace(/Decided:/gi, '<strong>Decision:</strong>');
                content = content.replace(/Observed:/gi, '<strong>Saw:</strong>');
                content = content.replace(/Recorded solution:/gi, '<strong>Learned:</strong>');

                return `
                    <div class="thought-item">
                        <div class="thought-header">
                            <span class="thought-phase" style="background: ${phase.color}20; color: ${phase.color}; border: 1px solid ${phase.color}40;">
                                ${phase.icon} ${phase.name}
                            </span>
                            <span class="thought-time">${time}</span>
                        </div>
                        <div class="thought-content">${escapeHtml(content).replace(/&lt;strong&gt;/g, '<strong>').replace(/&lt;\/strong&gt;/g, '</strong>')}</div>
                        <div class="thought-confidence">
                            <div class="thought-confidence-bar">
                                <div class="thought-confidence-fill" style="width: ${confidence}%; background: ${phase.color}"></div>
                            </div>
                            <span class="thought-confidence-value">${confidence}% confident</span>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function renderPendingApprovals(pending) {
            const container = document.getElementById('pending-approvals');
            const listEl = document.getElementById('pending-approvals-list');

            // Guard against missing elements
            if (!container || !listEl) return;

            if (pending.length === 0) {
                container.style.display = 'none';
                return;
            }

            container.style.display = 'block';
            listEl.innerHTML = pending.map(action => `
                <div class="approval-card">
                    <div class="approval-header">
                        <span class="approval-action">${escapeHtml(action.action_type)}</span>
                        <span class="approval-risk ${action.risk_level}">${action.risk_level}</span>
                    </div>
                    <div class="approval-description">${escapeHtml(action.description)}</div>
                    <div class="approval-buttons">
                        <button class="approval-btn approve" onclick="approveAction('${action.id}')"> Approve</button>
                        <button class="approval-btn reject" onclick="rejectAction('${action.id}')"> Reject</button>
                    </div>
                </div>
            `).join('');
        }

        function addThoughtToStream(thought) {
            // Add new thought at the beginning
            thoughtStream.unshift(thought);
            // Keep only last 50
            if (thoughtStream.length > 50) {
                thoughtStream = thoughtStream.slice(0, 50);
            }
            renderThoughtStream();

            // === NEW: Update Cerebro's voice with the thought ===
            updateCerebroVoice(thought);

            // === ADD TO CYCLE-BASED ACTIVITY LOG (all phases) ===
            if (thought && thought.phase && thought.content) {
                addThoughtToCycle(thought);
                setAlivePulse(false); // OODA is active, hide idle pulse
            }

            // Add to activity feed for notable events
            if (thought.phase === 'act' && thought.content) {
                const actionMatch = thought.content.match(/Executed:\s*(\w+)/);
                if (actionMatch) {
                    addActivityItem({
                        type: 'action',
                        text: `Executed: ${actionMatch[1]}`,
                        timestamp: new Date(thought.timestamp)
                    });
                }
            } else if (thought.phase === 'reflect' && thought.type === 'learning') {
                addActivityItem({
                    type: 'learning',
                    text: thought.content || 'Recorded a learning',
                    timestamp: new Date(thought.timestamp)
                });
            } else if (thought.phase === 'decide' && thought.metadata?.action_type && thought.metadata?.action_type !== 'no_action') {
                addActivityItem({
                    type: 'search',
                    text: `Decided: ${thought.metadata.action_type}`,
                    timestamp: new Date(thought.timestamp)
                });
            }

            // Enhanced highlight for new thought - makes it feel ALIVE
            const firstThought = document.querySelector('.thought-item');
            if (firstThought) {
                firstThought.classList.add('new');
                firstThought.classList.add('typing');
                setTimeout(() => firstThought.classList.remove('typing'), 800);
                setTimeout(() => firstThought.classList.remove('new'), 2500);
            }

            // Flash the consciousness orb
            const orb = document.getElementById('consciousness-orb');
            if (orb) {
                orb.style.transition = 'transform 0.15s ease';
                orb.style.transform = 'scale(1.02)';
                setTimeout(() => orb.style.transform = '', 150);
            }
        }

        // Update Cerebro's voice with a thought (first-person communication)
        // Convert raw thought objects to rich voice messages
        // (Called from thought_stream handler - delegates to main updateCerebroVoice)
        function processThoughtVoice(thought) {
            const content = thought.content || '';
            let voiceText = '';

            switch (thought.phase) {
                case 'observe':
                    if (content.includes('goals')) {
                        voiceText = "I'm scanning your goals and active projects...";
                    } else if (content.includes('memory')) {
                        voiceText = "I'm reaching into the memory banks, gathering context...";
                    } else {
                        voiceText = "I sense " + content.replace(/^(?:I\s+sense\s+)?|^Saw:|^Observed:/i, '').trim().toLowerCase();
                    }
                    break;
                case 'orient':
                    voiceText = thought.reasoning || ("I'm thinking about what this means... " + content.substring(0, 100));
                    break;
                case 'decide':
                    voiceText = (content.includes('no_action') || content.includes('No action'))
                        ? "I've considered my options. For now, I'll continue observing."
                        : "I've decided: " + content.replace(/^Decision:|^Decided:/i, '').trim();
                    break;
                case 'act':
                    voiceText = "I'm taking action now. " + content.replace(/^Executed:|^Action:/i, '').trim();
                    break;
                case 'reflect':
                    if (content.includes('success') || content.includes('Success')) {
                        voiceText = "That worked well. I'm remembering this for next time.";
                    } else if (content.includes('failed') || content.includes('error')) {
                        voiceText = "That didn't go as planned. Let me learn from this...";
                    } else {
                        voiceText = "Reflecting on what just happened... " + content.substring(0, 80);
                    }
                    break;
                default:
                    voiceText = content.substring(0, 150);
            }

            if (voiceText) {
                const label = 'Cerebro \u2022 ' + (thought.phase?.charAt(0).toUpperCase() + thought.phase?.slice(1) || 'Thinking');
                updateCerebroVoice('thinking', { phase: thought.phase, message: voiceText, customLabel: label });
            }
        }

        // Socket.IO listeners for autonomy events
        function setupAutonomySocketListeners() {
            if (!socket) {
                console.log('[Autonomy] Socket not ready, will retry...');
                setTimeout(setupAutonomySocketListeners, 1000);
                return;
            }
            socket.on('autonomy_status', (data) => {
                autonomyState = {
                    status: data.status || 'stopped',
                    level: data.autonomy_level || 2,
                    cycles: data.cycles_completed || 0,
                    phase: data.current_phase || 'idle',
                    fullAutonomy: data.full_autonomy_enabled || false,
                    // Include actions and pending from status
                    actions: data.actions_completed || autonomyState.actions || 0,
                    pending: data.pending_count || autonomyState.pending || 0
                };
                updateAutonomyUI();

                // Show/hide live pulse indicator
                const pulse = document.getElementById('thought-pulse');
                if (pulse) {
                    pulse.style.display = data.status === 'running' ? 'inline-block' : 'none';
                }

                // Reset narration active flag when loop stops
                if (data.status === 'stopped' || data.status === 'error') {
                    window._narrationActive = false;
                    setAlivePulse(false);
                }
            });

            socket.on('thought_stream', (thought) => {
                addThoughtToStream(thought);
                // Track action for tamagotchi energy
                if (typeof recordAction === 'function') recordAction();
                // Update voice with rich thought-specific messages
                if (thought && thought.phase) {
                    processThoughtVoice(thought);
                }
            });

            socket.on('approval_needed', (action) => {
                showToast(` Approval needed: ${action.action_type}`, 'warning');
                loadPendingApprovals();
            });

            socket.on('emergency_stop', () => {
                autonomyState.status = 'stopped';
                updateAutonomyUI();
                showToast(' Emergency stop triggered!', 'error');
            });

            // Proactive questions - Cerebro asking the user meaningful questions
            socket.on('proactive_question', async (data) => {
                console.log('[Autonomy] Received proactive question:', data);
                addProactiveQuestion(
                    data.question || 'What are you thinking about?',
                    data.context || null,
                    data.tag || 'curious'
                );
                showToast(' Cerebro has a question for you', 'info');

                // PERSIST the question to backend for page refresh survival
                try {
                    await fetch(`${API_URL}/api/autonomy/questions`, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${localStorage.getItem('cerebro_token')}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            question: data.question,
                            type: data.type || 'general',
                            options: data.options || [],
                            paths: data.paths || [],
                            directive_id: data.directive_id || ''
                        })
                    });
                } catch (e) {
                    console.error('Failed to persist question:', e);
                }
            });

            // Cognitive suggestions - insights from the AI
            socket.on('cognitive_suggestion', (suggestion) => {
                console.log('[Autonomy] Received suggestion:', suggestion);
                addInsight(suggestion);

                // Also add to voice stream as an insight message
                const voiceContent = document.getElementById('voice-content');
                if (voiceContent) {
                    voiceContent.textContent = suggestion.suggestion || suggestion.content || "I've discovered something interesting...";
                    voiceContent.classList.add('typing');
                    setTimeout(() => voiceContent.classList.remove('typing'), 2000);
                }

                // Add to message history as an insight
                addVoiceMessage(suggestion.suggestion || suggestion.content || "I found something.", 'insight');

                showToast(' Cerebro has a suggestion!', 'info');
            });

            // Debug feed listener - shows raw LLM calls and API activity
            socket.on('debug_feed', (event) => {
                addDebugEvent(event);

                // Handle skill-related debug events (event.type is set by _emit_debug)
                const eventType = event.type || event.event_type;
                if (eventType === 'skill_learned') {
                    console.log('[Skills] Skill learned via debug_feed:', event);
                    addSkillToPanel(event);  // event contains skill data directly
                    showToast(` New skill learned: ${event.name}`, 'success');
                    loadSkills(true);  // Reload skills to sync cache
                } else if (eventType === 'skill_reused') {
                    showToast(` Reused skill: ${event.skill_name}`, 'info');
                } else if (eventType === 'skill_verified') {
                    showToast(` Skill verified: ${event.skill_id}`, 'success');
                    loadSkills(true);
                }
            });

            // Activity backfill on connect - reconstruct cycles from server history
            socket.on('activity_backfill', (data) => {
                if (data && data.activity && data.activity.length > 0) {
                    console.log('[Activity] Backfill received:', data.activity.length, 'entries');
                    // Process oldest first so cycles build chronologically
                    var sorted = data.activity.slice().sort(function(a, b) {
                        return new Date(a.timestamp) - new Date(b.timestamp);
                    });
                    sorted.forEach(function(item) { addThoughtToCycle(item); });
                }
            });

            // Skills events (direct socket events, backup for debug_feed)
            socket.on('skill_learned', (data) => {
                console.log('[Skills] Skill learned (direct):', data);
                addSkillToPanel(data);
                showToast(` New skill learned: ${data.name}`, 'success');
                loadSkills(true);  // Sync cache
            });

            socket.on('skill_reused', (data) => {
                console.log('[Skills] Skill reused:', data);
                showToast(` Reused skill: ${data.skill_name}`, 'info');
                // Highlight the skill in the panel if visible
                const skillCard = document.querySelector(`[data-skill-id="${data.skill_id}"]`);
                if (skillCard) {
                    skillCard.classList.add('skill-active');
                    setTimeout(() => skillCard.classList.remove('skill-active'), 2000);
                }
            });

            socket.on('skill_executed', (data) => {
                console.log('[Skills] Skill executed:', data);
                if (data.success) {
                    showToast(` Skill executed: ${data.skill_name}`, 'success');
                } else {
                    showToast(` Skill failed: ${data.error || 'Unknown error'}`, 'error');
                }
            });

            socket.on('skill_verified', (data) => {
                console.log('[Skills] Skill verified:', data);
                showToast(
                    data.success
                        ? ` Skill verified: ${data.skill_name}`
                        : ` Skill verification failed: ${data.skill_name}`,
                    data.success ? 'success' : 'warning'
                );
                // Reload skills to show updated status
                loadSkills();
            });

            // === STORED ITEMS: Real-time sync ===
            socket.on('cerebro_stored_item_added', (item) => {
                storedItems.unshift(item);
                updateStoredBadge();
                if (_currentMindTab === 'answers') renderAnswerItems();
                else if (_currentMindTab === 'stored') renderStoredItems();
            });
            socket.on('cerebro_stored_item_removed', (data) => {
                storedItems = storedItems.filter(i => i.id !== data.id);
                updateStoredBadge();
                if (_currentMindTab === 'answers') renderAnswerItems();
                else if (_currentMindTab === 'stored') renderStoredItems();
            });

            // === HEARTBEAT: Monitor results ===
            socket.on('cerebro_heartbeat_complete', (data) => {
                const label = data.changed
                    ? `${data.findings_count} finding${data.findings_count > 1 ? 's' : ''}`
                    : 'All clear';
                const color = data.changed ? '#eab308' : 'var(--text-muted)';
                // Update slide panel
                const lastEl = document.getElementById('slide-heartbeat-last');
                if (lastEl) {
                    lastEl.textContent = label;
                    lastEl.style.color = color;
                }
                // Update floating editor status
                const editorStatus = document.getElementById('hb-editor-status');
                if (editorStatus) {
                    editorStatus.textContent = `Last: ${label}`;
                    editorStatus.style.color = color;
                }
                // Pulse heart icon when findings exist
                const heartBtn = document.getElementById('heartbeat-config-btn');
                if (heartBtn) {
                    if (data.changed) heartBtn.classList.add('has-findings');
                    else heartBtn.classList.remove('has-findings');
                }
                // Terminal activity log: add HB line with summary when findings exist
                if (data.changed) {
                    const cnt = data.findings_count || 0;
                    const hasAlert = (data.monitor_names || []).some(m => m.includes('security') || m.includes('alert'));
                    const tag = hasAlert ? 'alert' : 'hb';
                    const summary = data.summary || `${cnt} finding${cnt !== 1 ? 's' : ''} detected`;
                    addActivityLogItem(tag, summary,
                        data.timestamp || new Date().toISOString(), data);
                }
                // Alive pulse: show after heartbeat (idle state)
                setAlivePulse(true);
            });
            socket.on('cerebro_heartbeat_config_updated', (config) => {
                _heartbeatConfig = config;
                renderHeartbeatMonitors();
            });

            // === PROGRESS BAR: Compact progress during active directive work ===
            let _progressTimer = null;
            let _progressStartTime = null;

            function showProgressBar() {
                const bar = document.getElementById('cerebro-progress-bar');
                if (!bar) return;
                bar.classList.add('active');
                if (!_progressStartTime) {
                    _progressStartTime = Date.now();
                    _progressTimer = setInterval(() => {
                        const elapsed = Math.floor((Date.now() - _progressStartTime) / 1000);
                        const mins = Math.floor(elapsed / 60);
                        const secs = elapsed % 60;
                        const el = document.getElementById('progress-elapsed');
                        if (el) el.textContent = mins > 0 ? `${mins}m ${secs}s` : `${secs}s`;
                    }, 1000);
                }
            }

            function hideProgressBar() {
                const bar = document.getElementById('cerebro-progress-bar');
                if (bar) bar.classList.remove('active');
                if (_progressTimer) { clearInterval(_progressTimer); _progressTimer = null; }
                _progressStartTime = null;
                const inner = document.getElementById('progress-bar-inner');
                if (inner) inner.style.width = '20%';
                const statusEl = document.getElementById('progress-status');
                if (statusEl) statusEl.textContent = 'Working...';
                const elapsedEl = document.getElementById('progress-elapsed');
                if (elapsedEl) elapsedEl.textContent = '0s';
                // Clear live output panel
                const liveOutput = document.getElementById('progress-live-output-inner');
                if (liveOutput) liveOutput.textContent = '';
                const livePanel = document.getElementById('progress-live-output');
                if (livePanel) livePanel.classList.remove('visible');
                const expandIcon = document.getElementById('progress-expand-icon');
                if (expandIcon) expandIcon.classList.remove('expanded');
            }

            function toggleProgressOutput() {
                const panel = document.getElementById('progress-live-output');
                const icon = document.getElementById('progress-expand-icon');
                if (!panel) return;
                panel.classList.toggle('visible');
                if (icon) icon.classList.toggle('expanded');
                // Auto-scroll to bottom when expanding
                if (panel.classList.contains('visible')) {
                    panel.scrollTop = panel.scrollHeight;
                }
            }

            // Throttle progress DOM updates  max once per 250ms in standalone mode
            let _lastProgressUpdate = 0;
            let _progressQueue = null;

            socket.on('cerebro_progress', (data) => {
                const now = Date.now();
                const throttleMs = _IS_STANDALONE ? 250 : 50;

                // Always update status text and progress bar (cheap)
                showProgressBar();
                const statusEl = document.getElementById('progress-status');
                if (statusEl && data.status) {
                    statusEl.textContent = stripMarkdown(data.status).substring(0, 120);
                }
                if (data.event_count) {
                    const pct = Math.min(90, 20 + Math.log2(data.event_count + 1) * 12);
                    const inner = document.getElementById('progress-bar-inner');
                    if (inner) inner.style.width = pct + '%';
                }

                // Throttle DOM-heavy content appends
                if (data.content) {
                    if (now - _lastProgressUpdate < throttleMs) {
                        _progressQueue = data; // Keep latest, drop intermediates
                        return;
                    }
                    _lastProgressUpdate = now;
                    _progressQueue = null;

                    const liveInner = document.getElementById('progress-live-output-inner');
                    if (liveInner) {
                        const p = document.createElement('p');
                        if (data.is_tool) p.className = 'tool-line';
                        p.textContent = stripMarkdown(data.content.substring(0, 500));
                        liveInner.appendChild(p);
                        const panel = document.getElementById('progress-live-output');
                        if (panel && panel.classList.contains('visible')) {
                            panel.scrollTop = panel.scrollHeight;
                        }
                    }
                }

                // If this is a final progress event, keep bar visible briefly
                if (data.is_final) {
                    const inner = document.getElementById('progress-bar-inner');
                    if (inner) inner.style.width = '100%';
                }
            });

            // === NARRATION: Live thought narration from Cerebro ===
            socket.on('cerebro_narration', (data) => {
                console.log('[Narration] Received:', data);
                window._narrationActive = true;
                const isIdle = data.is_idle || false;
                const isSummary = data.is_summary || false;
                const content = (data.content || '').trim();

                // Filter: Skip idle narrations entirely (zero idle messages policy)
                if (isIdle || data.isIdleNarration) {
                    console.log('[Narration] Suppressed idle message');
                    return;
                }

                // Filter: Skip repeated "I sense...mission" messages
                if (/^I sense \d+ mission/i.test(content)) {
                    console.log('[Narration] Suppressed "I sense" message');
                    return;
                }

                // Dedup: Skip if last chat message has identical content
                if (content && cerebroChat.length > 0) {
                    const lastMsg = cerebroChat[cerebroChat.length - 1];
                    if (lastMsg && lastMsg.content === content) {
                        console.log('[Narration] Suppressed duplicate message');
                        return;
                    }
                }

                // Suppress ALL non-summary narration when a directive card is active
                const hasActiveDirectiveCard = cerebroChat.some(m =>
                    m.isDirectiveCard && m.directiveId && (!m.agentStatus || m.agentStatus === 'running' || m.agentStatus === 'queued')
                );
                if (hasActiveDirectiveCard && !isSummary) {
                    if (content && _progressState.active) {
                        const ev = { timestamp: data.timestamp || new Date().toISOString(), type: data.message_type || 'thought', content: content };
                        _progressState.events.push(ev);
                        if (_progressModalOpen) appendProgressModalEntry(null, ev);
                    }
                    console.log('[Narration] Suppressed  directive card active');
                    return;
                }

                // Thread tagging: check if this narration belongs to a threaded reply
                const threadParent = data.directive_id ? _threadDirectiveMap[data.directive_id] : null;

                // Summary: embed into directive card if possible, else standalone
                if (isSummary && content) {
                    _progressState.active = false;
                    renderProgressBar();

                    // Find matching directive card
                    const directiveId = data.directive_id || null;
                    const agentId = data.agent_id || null;
                    let targetCard = null;
                    if (directiveId) {
                        targetCard = cerebroChat.find(m => m.isDirectiveCard && m.directiveId === directiveId);
                    }
                    if (!targetCard && agentId) {
                        targetCard = cerebroChat.find(m => m.isDirectiveCard && m.agentId === agentId);
                    }

                    if (targetCard) {
                        targetCard.summaryContent = content;
                        renderChatMessages();
                        renderMindChat();
                        if (content && TTS_CONFIG.autoSpeak) speak(content);
                        if (data.directive_id && _threadDirectiveMap[data.directive_id]) {
                            delete _threadDirectiveMap[data.directive_id];
                        }
                        return;
                    }

                    // Fallback: standalone summary (non-directive summaries)
                    const summaryMsg = {
                        id: data.id || ('summary_' + Date.now()),
                        role: 'assistant',
                        content: content,
                        timestamp: data.timestamp || new Date().toISOString(),
                        isSummary: true,
                        directive: data.directive || '',
                        message_type: 'summary'
                    };
                    if (threadParent) summaryMsg.parentId = threadParent;
                    cerebroChat.push(summaryMsg);
                    if (data.directive_id && _threadDirectiveMap[data.directive_id]) {
                        delete _threadDirectiveMap[data.directive_id];
                    }
                    renderChatMessages();
                    renderMindChat();
                    if (content && TTS_CONFIG.autoSpeak) speak(content);
                    return;
                }

                // Skip empty narration (is_final signals with deduped content)
                if (!content && !data.is_final) return;
                if (content) {
                    const narrMsg = {
                        id: data.id || ('narr_' + Date.now()),
                        role: 'assistant',
                        content: content,
                        timestamp: data.timestamp || new Date().toISOString(),
                        isNarration: true,
                        isIdleNarration: isIdle,
                        isIdle: isIdle,
                        phases: data.phases || [],
                        directive: data.directive || '',
                        message_type: data.message_type || ''
                    };
                    if (threadParent) narrMsg.parentId = threadParent;
                    cerebroChat.push(narrMsg);
                }
                // Feed non-idle narration into progress events
                if (!isIdle && !isSummary && content && _progressState.active) {
                    const ev = { timestamp: data.timestamp || new Date().toISOString(), type: data.message_type || 'thought', content: content };
                    _progressState.events.push(ev);
                    if (_progressModalOpen) appendProgressModalEntry(null, ev);
                }
                // When agent finishes, add step summary
                if (data.is_final && _agentBrowserStepCount > 0) {
                    hideProgressBar();
                    cerebroChat.push({
                        id: 'step_summary_' + Date.now(),
                        role: 'assistant',
                        content: 'Browser task completed  ' + _agentBrowserStepCount + ' steps executed. See Browser tab for details.',
                        timestamp: new Date().toISOString(),
                        isNarration: true,
                        phases: ['act']
                    });
                    _agentBrowserStepCount = 0;
                }
                renderChatMessages();
                renderMindChat();
                // Auto-speak narration content
                if (content && TTS_CONFIG.autoSpeak && !isIdle && data.is_final) {
                    speak(content);
                }
            });

            // === OBSERVATION: Screen monitor observations from Cerebro ===
            socket.on('cerebro_observation', (data) => {
                cerebroChat.push({
                    id: data.id,
                    role: 'assistant',
                    content: data.content,
                    timestamp: data.timestamp,
                    isObservation: true,
                    message_type: 'observation',
                    screenshotPath: data.screenshot_path,
                    windowTitle: data.window_title,
                });
                renderMindChat();
            });

            // === PROGRESS: Step-by-step progress during directives ===
            socket.on('cerebro_progress', (data) => {
                console.log('[Progress] Received:', data);
                handleProgressEvent(data);
            });

            // SimEngine simulation events
            socket.on('simulation_started', (data) => {
                console.log('[SimEngine] Simulation started:', data);
                addMessage(`Running simulation: "${data.query}"...`, 'tool');
            });

            socket.on('simulation_complete', (data) => {
                console.log('[SimEngine] Simulation complete:', data);
                renderSimulationCard(data);
                showSimulationModal(data);
                showToast('Simulation complete! Click to view results.', 'success');
                // Auto-store simulation result
                const simTs = Date.now();
                fetch(`${API_URL}/api/stored-items`, {
                    method: 'POST',
                    headers: { 'Authorization': `Bearer ${localStorage.getItem('cerebro_token')}`, 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        id: 'stored_sim_' + simTs,
                        type: 'simulation',
                        title: data.query || 'Simulation Result',
                        content: [data.expected_value && ('EV: ' + data.expected_value), data.confidence && ('Confidence: ' + data.confidence), data.risk_assessment].filter(Boolean).join(' | ') || 'Completed',
                        metadata: data,
                        status: 'pending',
                        source_id: 'sim_' + simTs
                    })
                }).catch(e => console.error('Failed to store simulation:', e));
            });

            socket.on('simulation_error', (data) => {
                console.log('[SimEngine] Simulation error:', data);
                addMessage(`Simulation failed: ${data.error}`, 'assistant');
            });

            socket.on('simulation_clarification_needed', (data) => {
                console.log('[SimEngine] Clarification needed:', data);
                showSimClarificationModal(data);
            });

            socket.on('simulation_analysis_chat', (data) => {
                console.log('[SimEngine] Analysis chat:', data);
                var msgEl = addMessage(data.message, 'assistant');
                if (msgEl && data.suggestions && data.suggestions.length > 0) {
                    renderSimFollowups(msgEl, data);
                }
                // Also push to cerebro chat sidebar
                cerebroChat.push({
                    id: 'msg_' + Date.now(),
                    role: 'assistant',
                    content: data.message,
                    timestamp: new Date().toISOString()
                });
                renderChatMessages();
            });

            // Human-in-the-loop authentication
            socket.on('auth_needed', (data) => {
                console.log('[Auth] Authentication needed:', data);
                showAuthModal(data);
            });

            socket.on('auth_continued', (data) => {
                console.log('[Auth] Authentication completed:', data);
                hideAuthModal();
                showToast(' Authentication completed, resuming...', 'success');
            });

            console.log('[Autonomy] Socket listeners registered');
        }

        // Initialize autonomy socket listeners when socket is ready
        setTimeout(setupAutonomySocketListeners, 500);

        // ==================== HUMAN-IN-THE-LOOP POPUP SYSTEM ====================
        // NOTE: All dynamic content is sanitized via escapeHtml() before DOM insertion,
        // following the same pattern used throughout this codebase (renderThoughtStream,
        // renderPendingApprovals, formatDebugEvent, etc.)
        let hitlPopups = [];
        let hitlBrowserScreenshot = null;

        // Reply context state for question-in-chat replies
        let _replyContext = null;

        // Thread reply system (iMessage-style)
        let _threadDirectiveMap = {};   // directive_id  parentMessageId
        let _activeCardPopup = null;    // current floating popup element
        let _activeThreadInput = null;  // current inline reply input {msgId, element}

        function formatMsgTime(ts) {
            if (!ts) return '';
            const d = new Date(ts);
            const now = new Date();
            const isToday = d.toDateString() === now.toDateString();
            const time = d.toLocaleTimeString([], {hour: 'numeric', minute: '2-digit'});
            if (isToday) return time;
            return d.toLocaleDateString([], {month: 'short', day: 'numeric'}) + ', ' + time;
        }

        // === CARD ACTION POPUP (iMessage-style) ===
        function showCardActionPopup(cardElement, msgId, msgContent) {
            hideCardActionPopup();
            closeThreadReplyInput();

            const popup = document.createElement('div');
            popup.className = 'card-action-popup';

            const items = [
                { icon: '', label: 'Reply', action: () => { hideCardActionPopup(); openThreadReplyInput(msgId, msgContent, cardElement); } },
                { icon: '', label: 'Attach as Context', action: () => { hideCardActionPopup(); attachAsContext(msgId); } },
                { icon: '', label: 'Copy Text', action: () => { hideCardActionPopup(); copyMessageText(msgId); } }
            ];

            items.forEach(item => {
                const row = document.createElement('div');
                row.className = 'card-action-popup-item';
                const iconSpan = document.createElement('span');
                iconSpan.className = 'popup-icon';
                iconSpan.textContent = item.icon;
                const labelSpan = document.createElement('span');
                labelSpan.textContent = item.label;
                row.appendChild(iconSpan);
                row.appendChild(labelSpan);
                row.onclick = (e) => { e.stopPropagation(); item.action(); };
                popup.appendChild(row);
            });

            // Position relative to card
            cardElement.style.position = 'relative';
            popup.style.position = 'absolute';
            popup.style.top = '8px';
            popup.style.right = '8px';
            cardElement.appendChild(popup);
            _activeCardPopup = popup;

            // Dismiss on outside click or Escape
            const dismissHandler = (e) => {
                if (!popup.contains(e.target) && !cardElement.contains(e.target)) {
                    hideCardActionPopup();
                    document.removeEventListener('click', dismissHandler);
                }
            };
            const escHandler = (e) => {
                if (e.key === 'Escape') {
                    hideCardActionPopup();
                    document.removeEventListener('keydown', escHandler);
                }
            };
            setTimeout(() => {
                document.addEventListener('click', dismissHandler);
                document.addEventListener('keydown', escHandler);
            }, 10);
        }

        function hideCardActionPopup() {
            if (_activeCardPopup) {
                _activeCardPopup.remove();
                _activeCardPopup = null;
            }
        }

        // === INLINE THREAD REPLY INPUT ===
        function openThreadReplyInput(parentMsgId, parentContent, cardElement) {
            closeThreadReplyInput();

            const inputBar = document.createElement('div');
            inputBar.className = 'thread-reply-input';
            inputBar.setAttribute('data-thread-parent', parentMsgId);

            const input = document.createElement('input');
            input.type = 'text';
            input.placeholder = 'Reply...';
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && input.value.trim()) {
                    sendThreadReply(parentMsgId, parentContent, input.value.trim());
                    closeThreadReplyInput();
                } else if (e.key === 'Escape') {
                    closeThreadReplyInput();
                }
            });

            const sendBtn = document.createElement('button');
            sendBtn.className = 'thread-send-btn';
            sendBtn.textContent = '';
            sendBtn.title = 'Send reply';
            sendBtn.onclick = () => {
                if (input.value.trim()) {
                    sendThreadReply(parentMsgId, parentContent, input.value.trim());
                    closeThreadReplyInput();
                }
            };

            const cancelBtn = document.createElement('button');
            cancelBtn.className = 'thread-cancel-btn';
            cancelBtn.textContent = '';
            cancelBtn.title = 'Cancel';
            cancelBtn.onclick = () => closeThreadReplyInput();

            inputBar.appendChild(input);
            inputBar.appendChild(sendBtn);
            inputBar.appendChild(cancelBtn);

            // Insert after the card in DOM
            cardElement.parentNode.insertBefore(inputBar, cardElement.nextSibling);
            _activeThreadInput = { msgId: parentMsgId, element: inputBar };
            input.focus();
        }

        function closeThreadReplyInput() {
            if (_activeThreadInput) {
                _activeThreadInput.element.remove();
                _activeThreadInput = null;
            }
        }

        // === SEND THREAD REPLY ===
        async function sendThreadReply(parentMsgId, parentContent, message) {
            // Tamagotchi interaction
            recordInteraction();
            recordAction();

            // Push user message with parentId
            cerebroChat.push({
                id: 'msg_' + Date.now(),
                role: 'user',
                content: message,
                timestamp: new Date().toISOString(),
                parentId: parentMsgId
            });
            renderChatMessages();
            renderMindChat();

            // Post as directive with reply prefix
            const autoAwake = document.getElementById('auto-awake-checkbox')?.checked ?? true;
            try {
                const response = await fetch(`${API_URL}/api/directives`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${localStorage.getItem('cerebro_token')}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        text: `[Replying to: "${parentContent.substring(0, 200)}"]\n\n${message}`,
                        auto_awake: autoAwake
                    })
                });
                const data = await response.json();
                // Map directive  parent for thread tagging
                if (data.directive && data.directive.id) {
                    _threadDirectiveMap[data.directive.id] = parentMsgId;
                }
                // Placeholder response in thread
                cerebroChat.push({
                    id: 'msg_' + (Date.now() + 1),
                    role: 'assistant',
                    content: 'Working on it...',
                    timestamp: new Date().toISOString(),
                    parentId: parentMsgId
                });
                renderChatMessages();
                renderMindChat();
            } catch (e) {
                console.error('Thread reply error:', e);
                cerebroChat.push({
                    id: 'msg_' + (Date.now() + 1),
                    role: 'assistant',
                    content: 'Failed to submit reply.',
                    timestamp: new Date().toISOString(),
                    parentId: parentMsgId
                });
                renderChatMessages();
                renderMindChat();
            }
        }

        // Tab flash state
        let _tabFlashInterval = null;
        let _originalTitle = document.title;

        function playHITLNotificationSound() {
            try {
                const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                // Two-tone: D5 -> G5
                const osc1 = audioCtx.createOscillator();
                const osc2 = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                gain.gain.setValueAtTime(0.15, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
                osc1.frequency.value = 587; // D5
                osc2.frequency.value = 784; // G5
                osc1.connect(gain);
                osc2.connect(gain);
                gain.connect(audioCtx.destination);
                osc1.start(audioCtx.currentTime);
                osc1.stop(audioCtx.currentTime + 0.25);
                osc2.start(audioCtx.currentTime + 0.25);
                osc2.stop(audioCtx.currentTime + 0.5);
            } catch(e) { console.log('[HITL] Sound failed:', e); }
        }

        function startTabFlash(message) {
            stopTabFlash();
            _originalTitle = document.title;
            let toggle = false;
            _tabFlashInterval = setInterval(() => {
                document.title = toggle ? message : _originalTitle;
                toggle = !toggle;
            }, 1000);
            // Stop on window focus
            window.addEventListener('focus', stopTabFlash, { once: true });
        }

        function stopTabFlash() {
            if (_tabFlashInterval) {
                clearInterval(_tabFlashInterval);
                _tabFlashInterval = null;
                document.title = _originalTitle;
            }
        }

        function setReplyContext(questionId, questionText) {
            _replyContext = { questionId, text: questionText };
            // Show reply bar above input
            const inputArea = document.querySelector('.mind-chat-input-bar');
            if (!inputArea) return;
            // Remove existing bar if any
            clearReplyContext(true);
            const bar = document.createElement('div');
            bar.className = 'reply-context-bar';
            bar.id = 'reply-context-bar';
            const textSpan = document.createElement('span');
            textSpan.className = 'reply-context-text';
            textSpan.textContent = 'Replying to: ' + (questionText || '').substring(0, 80) + ((questionText || '').length > 80 ? '...' : '');
            bar.appendChild(textSpan);
            const closeBtn = document.createElement('button');
            closeBtn.className = 'reply-context-close';
            closeBtn.textContent = '\u00D7';
            closeBtn.onclick = () => clearReplyContext();
            bar.appendChild(closeBtn);
            inputArea.insertBefore(bar, inputArea.firstChild);
            // Focus input
            const input = document.getElementById('mind-chat-field');
            if (input) input.focus();
        }

        function clearReplyContext(skipNull) {
            const existing = document.getElementById('reply-context-bar');
            if (existing) existing.remove();
            if (!skipNull) _replyContext = null;
        }

        const OODA_PHASE_ICONS = {
            observe: { icon: '\uD83D\uDC41\uFE0F', label: 'OBSERVE' },
            orient:  { icon: '\uD83E\uDDED', label: 'ORIENT' },
            decide:  { icon: '\uD83E\uDDE0', label: 'DECIDE' },
            act:     { icon: '\u26A1', label: 'ACT' }
        };

        function showHITLPopup(data) {
            const container = document.getElementById('hitl-popup-container');
            if (!container) return;

            const popupId = data.id || ('hitl-' + Date.now());
            const urgency = escapeHtml(data.urgency || 'medium');
            const isApproval = data.type === 'approval';
            const questionText = escapeHtml(data.question || 'Cerebro needs your input');
            const contextText = data.context ? escapeHtml(data.context) : '';
            const directiveId = escapeHtml(data.directive_id || '');

            // Build popup using DOM methods for safety
            const popup = document.createElement('div');
            popup.className = 'hitl-popup';
            popup.id = popupId;
            popup.dataset.directiveId = directiveId;

            // -- Header --
            const header = document.createElement('div');
            header.className = 'hitl-popup-header';

            const headerLeft = document.createElement('div');
            headerLeft.className = 'hitl-popup-header-left';

            const iconDiv = document.createElement('div');
            iconDiv.className = 'hitl-popup-icon';
            iconDiv.textContent = isApproval ? '\uD83D\uDEE1\uFE0F' : '\uD83E\uDDE0';

            const labelSpan = document.createElement('span');
            labelSpan.className = 'hitl-popup-label';
            labelSpan.textContent = isApproval ? 'Approval Needed' : 'Input Needed';

            headerLeft.appendChild(iconDiv);
            headerLeft.appendChild(labelSpan);

            const urgencySpan = document.createElement('span');
            urgencySpan.className = 'hitl-popup-urgency ' + urgency;
            urgencySpan.textContent = urgency;

            const closeBtn = document.createElement('button');
            closeBtn.className = 'hitl-popup-close';
            closeBtn.textContent = '\u00D7';
            closeBtn.onclick = () => dismissHITLPopup(popupId);

            header.appendChild(headerLeft);
            header.appendChild(urgencySpan);
            header.appendChild(closeBtn);
            popup.appendChild(header);

            // -- Body --
            const body = document.createElement('div');
            body.className = 'hitl-popup-body';

            const questionDiv = document.createElement('div');
            questionDiv.className = 'hitl-popup-question';
            questionDiv.textContent = data.question || 'Cerebro needs your input';

            body.appendChild(questionDiv);

            if (contextText) {
                const ctxDiv = document.createElement('div');
                ctxDiv.className = 'hitl-popup-context';
                ctxDiv.textContent = data.context;
                body.appendChild(ctxDiv);
            }

            // Browser preview
            var rawScreenshot = data.screenshot || hitlBrowserScreenshot;
            var screenshotSrc = rawScreenshot && !rawScreenshot.startsWith('data:') ? 'data:image/png;base64,' + rawScreenshot : rawScreenshot;
            if (screenshotSrc) {
                const previewDiv = document.createElement('div');
                previewDiv.className = 'hitl-browser-preview';
                previewDiv.title = 'Click to view live browser';
                previewDiv.onclick = () => openBrowserView();

                const img = document.createElement('img');
                img.src = screenshotSrc;
                img.alt = 'Browser view';
                img.onerror = function() {
                    this.style.display = 'none';
                };

                const overlay = document.createElement('div');
                overlay.className = 'hitl-browser-preview-overlay';
                const lbl1 = document.createElement('span');
                lbl1.className = 'hitl-browser-preview-label';
                lbl1.textContent = 'Live Browser';
                const lbl2 = document.createElement('span');
                lbl2.className = 'hitl-browser-preview-label';
                lbl2.style.color = 'var(--accent-light)';
                lbl2.textContent = 'Click to open';
                overlay.appendChild(lbl1);
                overlay.appendChild(lbl2);

                previewDiv.appendChild(img);
                previewDiv.appendChild(overlay);
                body.appendChild(previewDiv);
            }

            // Chrome desktop hint when browser is running
            if (data.browser_url || browserState.running) {
                const chromeHint = document.createElement('div');
                chromeHint.className = 'hitl-popup-context';
                chromeHint.style.borderLeftColor = 'var(--accent)';
                chromeHint.textContent = 'Chrome is open on your desktop - switch to the Chrome window to interact.';
                body.appendChild(chromeHint);
            }

            popup.appendChild(body);

            // -- Actions --
            if (isApproval) {
                const actions = document.createElement('div');
                actions.className = 'hitl-popup-actions';

                const approveBtn = document.createElement('button');
                approveBtn.className = 'hitl-action-btn approve';
                approveBtn.textContent = 'Approve';
                approveBtn.onclick = () => submitHITLResponse(popupId, 'approved');

                const rejectBtn = document.createElement('button');
                rejectBtn.className = 'hitl-action-btn reject';
                rejectBtn.textContent = 'Reject';
                rejectBtn.onclick = () => submitHITLResponse(popupId, 'rejected');

                actions.appendChild(approveBtn);
                actions.appendChild(rejectBtn);
                popup.appendChild(actions);
            } else {
                const answerDiv = document.createElement('div');
                answerDiv.className = 'hitl-popup-answer';

                const textarea = document.createElement('textarea');
                textarea.className = 'hitl-answer-input';
                textarea.id = 'hitl-input-' + popupId;
                textarea.rows = 2;
                textarea.placeholder = 'Type your answer...';
                textarea.onkeydown = (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        submitHITLResponse(popupId);
                    }
                };

                answerDiv.appendChild(textarea);
                popup.appendChild(answerDiv);

                const actions = document.createElement('div');
                actions.className = 'hitl-popup-actions';

                const sendBtn = document.createElement('button');
                sendBtn.className = 'hitl-action-btn submit';
                sendBtn.textContent = 'Send';
                sendBtn.onclick = () => submitHITLResponse(popupId);

                const viewBtn = document.createElement('a');
                viewBtn.className = 'hitl-view-browser-btn';
                viewBtn.title = 'View what Cerebro sees';
                if (browserState.running) {
                    viewBtn.textContent = 'Open Chrome';
                    viewBtn.style.background = 'rgba(139, 92, 246, 0.3)';
                    viewBtn.style.borderColor = 'rgba(139, 92, 246, 0.5)';
                } else {
                    viewBtn.textContent = 'View Browser';
                }
                viewBtn.onclick = () => openBrowserView();

                actions.appendChild(sendBtn);
                actions.appendChild(viewBtn);
                popup.appendChild(actions);
            }

            // -- Secondary actions: Skip & Delay --
            const secondary = document.createElement('div');
            secondary.className = 'hitl-secondary-actions';

            const skipBtn = document.createElement('button');
            skipBtn.className = 'hitl-action-btn secondary skip';
            skipBtn.textContent = 'Skip';
            skipBtn.onclick = () => skipHITL(popupId);

            const delayBtn = document.createElement('button');
            delayBtn.className = 'hitl-action-btn secondary delay';
            delayBtn.textContent = 'Delay';
            delayBtn.onclick = () => delayHITL(popupId);

            secondary.appendChild(skipBtn);
            secondary.appendChild(delayBtn);
            popup.appendChild(secondary);

            container.appendChild(popup);

            // Show the overlay
            container.classList.add('visible');

            // Track popup (no timer)
            const popupRecord = {
                id: popupId,
                data: data,
                element: popup,
                createdAt: Date.now()
            };
            hitlPopups.push(popupRecord);

            // Play notification sound (Web Audio API two-tone)
            playHITLNotificationSound();

            // Flash tab title
            startTabFlash('Cerebro needs input');

            // Inject question into Mind chat as question card
            cerebroChat.push({
                id: 'q_' + popupId,
                role: 'assistant',
                content: data.question || 'Cerebro needs your input',
                timestamp: new Date().toISOString(),
                isQuestion: true,
                questionId: popupId,
                context: data.context || '',
                directiveId: data.directive_id || ''
            });
            renderChatMessages();
            renderMindChat();

            // Sidebar pulse indicator
            const sidebar = document.getElementById('sidebar-questions');
            if (sidebar) sidebar.classList.add('has-pending-hitl');

            // Persist as proactive question for page refresh survival
            addProactiveQuestion(
                data.question || 'Cerebro needs your input',
                data.context || null,
                data.type === 'approval' ? 'approval' : 'input-needed'
            );
        }

        function submitHITLResponse(popupId, action) {
            const popup = hitlPopups.find(p => p.id === popupId);
            if (!popup) return;

            let response;
            if (action === 'approved' || action === 'rejected') {
                response = { approved: action === 'approved' };
            } else {
                const input = document.getElementById('hitl-input-' + popupId);
                const answer = input ? input.value.trim() : '';
                if (!answer) {
                    if (input) {
                        input.style.borderColor = 'var(--red)';
                        setTimeout(() => { input.style.borderColor = ''; }, 600);
                    }
                    return;
                }
                response = { answer: answer };
            }

            if (socket) {
                socket.emit('human_input_response', {
                    request_id: popupId,
                    directive_id: popup.data.directive_id || '',
                    ...response,
                    timestamp: new Date().toISOString()
                });
            }

            const el = popup.element;
            if (el) {
                el.style.borderColor = 'var(--green)';
                el.style.boxShadow = '0 0 30px rgba(34, 197, 94, 0.3)';
            }

            showToast(action === 'rejected' ? 'Response sent: Rejected' : 'Response sent to Cerebro', 'success');
            setTimeout(() => dismissHITLPopup(popupId), 500);

            // Remove answered item from Answers tab
            if (popup.data._storedItemId) {
                deleteStoredItem(popup.data._storedItemId);
            }
        }

        function dismissHITLPopup(popupId) {
            const idx = hitlPopups.findIndex(p => p.id === popupId);
            if (idx === -1) return;

            const popup = hitlPopups[idx];

            const el = popup.element;
            if (el) {
                el.classList.add('dismissing');
                setTimeout(() => el.remove(), 300);
            }

            hitlPopups.splice(idx, 1);

            // Update tamagotchi HITL state
            if (typeof tamagotchiState !== 'undefined') {
                tamagotchiState.hitlPending = hitlPopups.length > 0;
            }

            // Hide overlay when no popups remain
            if (hitlPopups.length === 0) {
                const container = document.getElementById('hitl-popup-container');
                if (container) container.classList.remove('visible');

                const sidebar = document.getElementById('sidebar-questions');
                if (sidebar) sidebar.classList.remove('has-pending-hitl');
            }

            // Stop tab flash
            stopTabFlash();
        }

        // ==================== HEARTBEAT MONITOR ====================

        let _heartbeatConfig = null;
        let _hbParsedData = null;
        let _hbOriginalMd = '';
        let _hbDirty = false;

        const MONITOR_LABELS = {
            git_repos: 'Git Repos',
            file_changes: 'File Changes',
            memory_health: 'Memory Health',
            system_health: 'System Health',
            network_devices: 'Network Devices',
            screen_monitor: 'Screen Monitor',
        };

        async function loadHeartbeatConfig() {
            try {
                const resp = await fetch(`${API_URL}/api/heartbeat/config`, {
                    headers: { 'Authorization': `Bearer ${localStorage.getItem('cerebro_token')}` }
                });
                if (resp.ok) {
                    _heartbeatConfig = await resp.json();
                    renderHeartbeatMonitors();
                }
            } catch (e) {
                console.warn('[Heartbeat] Failed to load config:', e);
            }
        }

        function renderHeartbeatMonitors() {
            if (!_heartbeatConfig) return;
            const container = document.getElementById('slide-heartbeat-monitors');
            if (!container) return;

            const slider = document.getElementById('slide-heartbeat-interval');
            const valEl = document.getElementById('slide-heartbeat-interval-value');
            if (slider) slider.value = _heartbeatConfig.interval_minutes || 15;
            if (valEl) valEl.textContent = `${_heartbeatConfig.interval_minutes || 15}m`;

            container.textContent = '';
            const monitors = _heartbeatConfig.monitors || {};
            for (const [key, cfg] of Object.entries(monitors)) {
                const label = document.createElement('label');
                label.style.cssText = 'display:flex; align-items:center; gap:6px; cursor:pointer;';
                const cb = document.createElement('input');
                cb.type = 'checkbox';
                cb.checked = !!cfg.enabled;
                cb.style.cssText = 'accent-color:var(--accent); width:14px; height:14px;';
                cb.addEventListener('change', function() { toggleHeartbeatMonitor(key, this.checked); });
                const span = document.createElement('span');
                span.style.cssText = 'font-size:0.68rem; color:var(--text-secondary);';
                span.textContent = MONITOR_LABELS[key] || key;
                label.appendChild(cb);
                label.appendChild(span);
                container.appendChild(label);
            }
        }

        async function updateHeartbeatInterval(value) {
            const valEl = document.getElementById('slide-heartbeat-interval-value');
            if (valEl) valEl.textContent = `${value}m`;
            try {
                await fetch(`${API_URL}/api/heartbeat/config`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${localStorage.getItem('cerebro_token')}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ interval_minutes: parseInt(value) })
                });
            } catch (e) {
                console.warn('[Heartbeat] Failed to update interval:', e);
            }
        }

        async function toggleHeartbeatMonitor(name, enabled) {
            try {
                await fetch(`${API_URL}/api/heartbeat/config`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${localStorage.getItem('cerebro_token')}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ monitors: { [name]: { enabled } } })
                });
            } catch (e) {
                console.warn('[Heartbeat] Failed to toggle monitor:', e);
            }
        }

        // ==================== HEARTBEAT SETTINGS MODAL ====================

        function _parseHeartbeatMd(content) {
            const result = {
                focusAreas: [],
                idleTasks: [],
                customMonitors: [],
                dormantInstructions: '',
                rawSettings: { interval: 15, monitors: [] }
            };
            const sections = {};
            let currentSection = '';
            let currentLines = [];
            for (const line of content.split('\n')) {
                if (line.startsWith('## ')) {
                    if (currentSection) sections[currentSection] = currentLines.join('\n');
                    currentSection = line.slice(3).trim().toLowerCase();
                    currentLines = [];
                } else {
                    currentLines.push(line);
                }
            }
            if (currentSection) sections[currentSection] = currentLines.join('\n');

            // Settings
            const settingsText = sections['settings'] || '';
            const intervalMatch = settingsText.match(/\*\*Interval:\*\*\s*(\d+)/);
            if (intervalMatch) result.rawSettings.interval = Math.max(5, Math.min(60, parseInt(intervalMatch[1])));
            const monitorsMatch = settingsText.match(/\*\*Monitors:\*\*\s*(.+)/);
            if (monitorsMatch) result.rawSettings.monitors = monitorsMatch[1].split(',').map(s => s.trim()).filter(Boolean);

            // Focus Areas
            for (const line of (sections['focus areas'] || '').split('\n')) {
                const trimmed = line.trim();
                if (trimmed.startsWith('- ') && trimmed.length > 2) {
                    const item = trimmed.slice(2).trim();
                    if (item) result.focusAreas.push(item);
                }
            }

            // Idle Tasks
            for (const line of (sections['idle tasks'] || '').split('\n')) {
                const trimmed = line.trim();
                if (trimmed.startsWith('- [x] ') || trimmed.startsWith('- [X] ')) {
                    const task = trimmed.slice(6).trim();
                    if (task) result.idleTasks.push({ text: task, done: true });
                } else if (trimmed.startsWith('- [ ] ')) {
                    const task = trimmed.slice(6).trim();
                    if (task) result.idleTasks.push({ text: task, done: false });
                }
            }

            // Custom Monitors
            for (const line of (sections['custom monitors'] || '').split('\n')) {
                const trimmed = line.trim();
                const cmMatch = trimmed.match(/\*\*(.+?)\*\*:\s*`(.+?)`\s*(?:--\s*(.*))?/);
                if (cmMatch) {
                    result.customMonitors.push({
                        name: cmMatch[1].trim(),
                        command: cmMatch[2].trim(),
                        description: (cmMatch[3] || '').trim()
                    });
                }
            }

            // Dormant Instructions
            result.dormantInstructions = (sections['dormant instructions'] || '').trim();

            return result;
        }

        function _buildHeartbeatMd(data, config) {
            const lines = ['# Cerebro Heartbeat Configuration', '', '## Settings', ''];
            const interval = config ? (config.interval_minutes || 15) : (data.rawSettings.interval || 15);
            const enabledMonitors = [];
            if (config && config.monitors) {
                for (const [key, cfg] of Object.entries(config.monitors)) {
                    if (cfg.enabled) enabledMonitors.push(key);
                }
            } else if (data.rawSettings.monitors.length) {
                enabledMonitors.push(...data.rawSettings.monitors);
            }
            lines.push(`- **Interval:** ${interval} minutes`);
            lines.push(`- **Monitors:** ${enabledMonitors.join(', ')}`);

            lines.push('', '## Focus Areas', '');
            if (data.focusAreas.length) {
                for (const item of data.focusAreas) lines.push(`- ${item}`);
            } else {
                lines.push('-');
            }

            lines.push('', '## Idle Tasks', '');
            if (data.idleTasks.length) {
                for (const task of data.idleTasks) {
                    lines.push(`- [${task.done ? 'x' : ' '}] ${task.text}`);
                }
            } else {
                lines.push('- [ ]');
            }

            lines.push('', '## Custom Monitors', '');
            for (const cm of data.customMonitors) {
                let line = `**${cm.name}**: \`${cm.command}\``;
                if (cm.description) line += ` -- ${cm.description}`;
                lines.push(line);
            }

            lines.push('', '## Dormant Instructions', '');
            lines.push(data.dormantInstructions || '');
            lines.push('');

            return lines.join('\n');
        }

        function _renderHbMonitors(config) {
            const grid = document.getElementById('hb-monitor-grid');
            if (!grid) return;
            grid.textContent = '';
            const monitors = config.monitors || {};
            for (const [key, cfg] of Object.entries(monitors)) {
                const item = document.createElement('div');
                item.className = 'hb-monitor-item';

                const label = document.createElement('span');
                label.textContent = MONITOR_LABELS[key] || key;

                const toggle = document.createElement('label');
                toggle.className = 'hb-toggle';
                const input = document.createElement('input');
                input.type = 'checkbox';
                input.checked = !!cfg.enabled;
                input.dataset.monitor = key;
                input.addEventListener('change', function() { _markHbDirty(); });
                const track = document.createElement('span');
                track.className = 'hb-toggle-track';
                const thumb = document.createElement('span');
                thumb.className = 'hb-toggle-thumb';
                track.appendChild(thumb);
                toggle.appendChild(input);
                toggle.appendChild(track);

                item.appendChild(label);
                item.appendChild(toggle);
                grid.appendChild(item);
            }

            // Set interval slider
            const slider = document.getElementById('hb-interval-slider');
            const display = document.getElementById('hb-interval-display');
            if (slider) {
                slider.value = config.interval_minutes || 15;
                slider.addEventListener('input', _markHbDirty);
            }
            if (display) display.textContent = (config.interval_minutes || 15) + 'm';
        }

        let _hbGoals = [];

        async function _loadHbGoals() {
            try {
                const headers = { 'Authorization': `Bearer ${localStorage.getItem('cerebro_token')}` };
                const res = await fetch(`${API_URL}/api/goals`, { headers });
                const data = await res.json();
                _hbGoals = data.goals || [];
            } catch (e) {
                console.error('[Heartbeat] Failed to load goals:', e);
                _hbGoals = [];
            }
        }

        function _renderHbGoals() {
            const list = document.getElementById('hb-goals-list');
            if (!list) return;
            list.textContent = '';
            _hbGoals.forEach(function(entry) {
                const goal = entry.goal || entry;
                const progress = entry.progress || {};
                const item = document.createElement('div');
                item.className = 'hb-goal-item';

                // Header row: checkbox + description + mode badge + delete
                const header = document.createElement('div');
                header.className = 'hb-goal-header';

                const cb = document.createElement('input');
                cb.type = 'checkbox';
                cb.className = 'hb-task-checkbox';
                cb.title = 'Mark complete';
                cb.addEventListener('change', function() { _completeHbGoal(goal.goal_id); });
                header.appendChild(cb);

                const desc = document.createElement('span');
                desc.className = 'hb-goal-desc';
                desc.textContent = goal.description;
                header.appendChild(desc);

                const modeBadge = document.createElement('span');
                modeBadge.className = 'hb-goal-mode ' + (goal.mode || 'monitor');
                modeBadge.textContent = (goal.mode || 'monitor').charAt(0).toUpperCase() + (goal.mode || 'monitor').slice(1);
                header.appendChild(modeBadge);

                const del = document.createElement('button');
                del.className = 'hb-item-delete';
                del.textContent = '\u00d7';
                del.title = 'Delete goal';
                del.addEventListener('click', function() { _deleteHbGoal(goal.goal_id); });
                header.appendChild(del);

                item.appendChild(header);

                // Meta row: progress bar + percentage + deadline
                const meta = document.createElement('div');
                meta.className = 'hb-goal-meta';

                const progressBar = document.createElement('div');
                progressBar.className = 'hb-goal-progress-bar';
                const fill = document.createElement('div');
                fill.className = 'hb-goal-progress-fill';
                const pct = progress.progress_percentage != null
                    ? Math.round(progress.progress_percentage * 100)
                    : Math.round(goal.get_progress_percentage ? goal.get_progress_percentage() * 100 : (goal.target_value > 0 ? Math.min(goal.current_value / goal.target_value, 1.0) * 100 : 0));
                fill.style.width = pct + '%';
                progressBar.appendChild(fill);
                meta.appendChild(progressBar);

                const pctSpan = document.createElement('span');
                pctSpan.className = 'hb-goal-pct';
                pctSpan.textContent = pct + '%';
                meta.appendChild(pctSpan);

                if (goal.deadline) {
                    const deadlineSpan = document.createElement('span');
                    deadlineSpan.className = 'hb-goal-deadline';
                    try {
                        const d = new Date(goal.deadline);
                        deadlineSpan.textContent = 'Due ' + d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                    } catch (_) {
                        deadlineSpan.textContent = 'Due ' + goal.deadline;
                    }
                    meta.appendChild(deadlineSpan);
                }

                item.appendChild(meta);
                list.appendChild(item);
            });
        }

        async function _addHbGoal() {
            const input = document.getElementById('hb-goal-input');
            const modeSelect = document.getElementById('hb-goal-mode-select');
            const deadlineInput = document.getElementById('hb-goal-deadline');
            if (!input) return;
            const desc = input.value.trim();
            if (!desc) return;
            const mode = modeSelect ? modeSelect.value : 'monitor';
            const deadline = deadlineInput && deadlineInput.value ? deadlineInput.value : null;

            try {
                const headers = {
                    'Authorization': `Bearer ${localStorage.getItem('cerebro_token')}`,
                    'Content-Type': 'application/json'
                };
                const body = { description: desc, mode: mode };
                if (deadline) body.deadline = deadline;
                await fetch(`${API_URL}/api/goals`, {
                    method: 'POST', headers, body: JSON.stringify(body)
                });
                input.value = '';
                if (deadlineInput) deadlineInput.value = '';
                await _loadHbGoals();
                _renderHbGoals();
            } catch (e) {
                console.error('[Heartbeat] Failed to add goal:', e);
            }
        }

        async function _completeHbGoal(goalId) {
            try {
                const headers = { 'Authorization': `Bearer ${localStorage.getItem('cerebro_token')}` };
                await fetch(`${API_URL}/api/goals/${goalId}/complete`, { method: 'POST', headers });
                await _loadHbGoals();
                _renderHbGoals();
                if (typeof showToast === 'function') showToast('Goal completed!', 'success');
            } catch (e) {
                console.error('[Heartbeat] Failed to complete goal:', e);
            }
        }

        async function _deleteHbGoal(goalId) {
            try {
                const headers = { 'Authorization': `Bearer ${localStorage.getItem('cerebro_token')}` };
                await fetch(`${API_URL}/api/goals/${goalId}`, { method: 'DELETE', headers });
                await _loadHbGoals();
                _renderHbGoals();
            } catch (e) {
                console.error('[Heartbeat] Failed to delete goal:', e);
            }
        }

        function _renderHbFocusAreas(items) {
            // Focus areas still parsed/saved in heartbeat.md for agent context,
            // but no longer rendered in the UI (replaced by Goals section).
        }

        function _renderHbIdleTasks(tasks) {
            const list = document.getElementById('hb-tasks-list');
            if (!list) return;
            list.textContent = '';
            tasks.forEach(function(task, i) {
                const row = document.createElement('div');
                row.className = 'hb-list-item';
                const cb = document.createElement('input');
                cb.type = 'checkbox';
                cb.className = 'hb-task-checkbox';
                cb.checked = task.done;
                cb.addEventListener('change', function() {
                    _hbParsedData.idleTasks[i].done = this.checked;
                    _markHbDirty();
                    _renderHbIdleTasks(_hbParsedData.idleTasks);
                });
                const span = document.createElement('span');
                span.className = 'hb-item-text';
                span.textContent = task.text;
                const del = document.createElement('button');
                del.className = 'hb-item-delete';
                del.textContent = '\u00d7';
                del.addEventListener('click', function() { _removeHbItem('task', i); });
                row.appendChild(cb);
                row.appendChild(span);
                row.appendChild(del);
                list.appendChild(row);
            });
        }

        function _addHbFocusArea() {
            const input = document.getElementById('hb-focus-input');
            if (!input || !_hbParsedData) return;
            const val = input.value.trim();
            if (!val) return;
            _hbParsedData.focusAreas.push(val);
            input.value = '';
            _renderHbFocusAreas(_hbParsedData.focusAreas);
            _markHbDirty();
        }

        function _addHbIdleTask() {
            const input = document.getElementById('hb-task-input');
            if (!input || !_hbParsedData) return;
            const val = input.value.trim();
            if (!val) return;
            _hbParsedData.idleTasks.push({ text: val, done: false });
            input.value = '';
            _renderHbIdleTasks(_hbParsedData.idleTasks);
            _markHbDirty();
        }

        function _removeHbItem(type, index) {
            if (!_hbParsedData) return;
            if (type === 'focus') {
                _hbParsedData.focusAreas.splice(index, 1);
                _renderHbFocusAreas(_hbParsedData.focusAreas);
            } else {
                _hbParsedData.idleTasks.splice(index, 1);
                _renderHbIdleTasks(_hbParsedData.idleTasks);
            }
            _markHbDirty();
        }

        function _markHbDirty() {
            _hbDirty = true;
            const el = document.getElementById('hb-dirty-indicator');
            if (el) el.classList.add('visible');
        }

        function _collectHbConfig() {
            const config = { interval_minutes: 15, monitors: {} };
            const slider = document.getElementById('hb-interval-slider');
            if (slider) config.interval_minutes = parseInt(slider.value);
            const toggles = document.querySelectorAll('#hb-monitor-grid input[type="checkbox"]');
            toggles.forEach(function(cb) {
                config.monitors[cb.dataset.monitor] = { enabled: cb.checked };
            });
            return config;
        }

        async function openHeartbeatModal() {
            const modal = document.getElementById('heartbeat-modal');
            if (!modal) return;
            modal.classList.add('active');
            _hbDirty = false;
            const dirtyEl = document.getElementById('hb-dirty-indicator');
            if (dirtyEl) dirtyEl.classList.remove('visible');
            const statusEl = document.getElementById('hb-status-text');
            if (statusEl) statusEl.textContent = 'Loading...';

            const headers = { 'Authorization': `Bearer ${localStorage.getItem('cerebro_token')}` };

            try {
                const [configRes, mdRes] = await Promise.all([
                    fetch(`${API_URL}/api/heartbeat/config`, { headers }),
                    fetch(`${API_URL}/api/heartbeat/md`, { headers })
                ]);
                const config = await configRes.json();
                const mdData = await mdRes.json();
                const mdContent = mdData.content || '';
                _hbOriginalMd = mdContent;
                _heartbeatConfig = config;

                // Parse markdown into structured data
                _hbParsedData = _parseHeartbeatMd(mdContent);

                // Populate all sections
                _renderHbMonitors(config);
                _renderHbIdleTasks(_hbParsedData.idleTasks);

                // Load and render goals from API (independent of heartbeat.md)
                await _loadHbGoals();
                _renderHbGoals();

                // Dormant instructions
                const dormantEl = document.getElementById('hb-dormant-textarea');
                if (dormantEl) {
                    dormantEl.value = _hbParsedData.dormantInstructions;
                    dormantEl.addEventListener('input', _markHbDirty);
                }

                // Raw editor
                const rawEl = document.getElementById('hb-raw-textarea');
                if (rawEl) rawEl.value = mdContent;
            } catch (e) {
                console.error('[Heartbeat] Failed to load:', e);
                if (statusEl) statusEl.textContent = 'Failed to load';
                return;
            }

            // Fetch status
            try {
                const statusRes = await fetch(`${API_URL}/api/heartbeat/status`, { headers });
                const status = await statusRes.json();
                if (statusEl) {
                    if (status.last_heartbeat) {
                        const ago = _timeAgo(new Date(status.last_heartbeat));
                        const summary = status.summary || 'All clear';
                        statusEl.textContent = `Last heartbeat: ${ago} \u2014 ${summary}`;
                    } else {
                        statusEl.textContent = 'No heartbeat recorded yet';
                    }
                }
            } catch (e) {
                if (statusEl) statusEl.textContent = 'Status unavailable';
            }
        }

        function _timeAgo(date) {
            const seconds = Math.floor((Date.now() - date.getTime()) / 1000);
            if (seconds < 60) return 'just now';
            const minutes = Math.floor(seconds / 60);
            if (minutes < 60) return minutes + ' min ago';
            const hours = Math.floor(minutes / 60);
            if (hours < 24) return hours + 'h ago';
            return Math.floor(hours / 24) + 'd ago';
        }

        async function closeHeartbeatModal() {
            const modal = document.getElementById('heartbeat-modal');
            if (!modal) return;
            if (_hbDirty) {
                if (!(await cerebroConfirm('You have unsaved changes. Discard?', { title: 'Unsaved Changes', confirmText: 'Discard', danger: true }))) return;
            }
            modal.classList.remove('active');
            // Collapse raw editor
            const rawWrap = document.getElementById('hb-raw-wrap');
            const rawBtn = document.getElementById('hb-raw-toggle-btn');
            if (rawWrap) rawWrap.classList.remove('visible');
            if (rawBtn) rawBtn.classList.remove('expanded');
        }

        async function saveHeartbeatSettings() {
            const saveBtn = document.getElementById('hb-save-btn');
            const dirtyEl = document.getElementById('hb-dirty-indicator');
            const statusEl = document.getElementById('hb-status-text');
            if (saveBtn) { saveBtn.disabled = true; saveBtn.textContent = 'Saving...'; }

            // Collect dormant instructions from textarea
            const dormantEl = document.getElementById('hb-dormant-textarea');
            if (dormantEl && _hbParsedData) _hbParsedData.dormantInstructions = dormantEl.value;

            // Collect config from UI
            const config = _collectHbConfig();

            // Build markdown
            const mdContent = _buildHeartbeatMd(_hbParsedData, config);

            const headers = {
                'Authorization': `Bearer ${localStorage.getItem('cerebro_token')}`,
                'Content-Type': 'application/json'
            };

            try {
                const [configRes, mdRes] = await Promise.all([
                    fetch(`${API_URL}/api/heartbeat/config`, {
                        method: 'POST', headers,
                        body: JSON.stringify(config)
                    }),
                    fetch(`${API_URL}/api/heartbeat/md`, {
                        method: 'POST', headers,
                        body: JSON.stringify({ content: mdContent })
                    })
                ]);
                const configData = await configRes.json();
                const mdData = await mdRes.json();

                if (configData.success && mdData.success) {
                    _hbOriginalMd = mdContent;
                    _hbDirty = false;
                    if (dirtyEl) dirtyEl.classList.remove('visible');
                    if (statusEl) statusEl.textContent = 'Saved just now';
                    // Update raw editor
                    const rawEl = document.getElementById('hb-raw-textarea');
                    if (rawEl) rawEl.value = mdContent;
                    // Sync slide panel
                    _heartbeatConfig = configData.config || config;
                    renderHeartbeatMonitors();
                    if (typeof showToast === 'function') showToast('Heartbeat settings saved', 'success');
                } else {
                    if (statusEl) statusEl.textContent = 'Save failed';
                }
            } catch (e) {
                console.error('[Heartbeat] Save error:', e);
                if (statusEl) statusEl.textContent = 'Save failed';
            }
            if (saveBtn) { saveBtn.disabled = false; saveBtn.textContent = 'Save'; }
        }

        function toggleRawEditor() {
            const wrap = document.getElementById('hb-raw-wrap');
            const btn = document.getElementById('hb-raw-toggle-btn');
            if (!wrap || !btn) return;
            const isOpen = wrap.classList.toggle('visible');
            btn.classList.toggle('expanded', isOpen);
            if (isOpen) {
                // Rebuild markdown from current UI state and show in raw editor
                const dormantEl = document.getElementById('hb-dormant-textarea');
                if (dormantEl && _hbParsedData) _hbParsedData.dormantInstructions = dormantEl.value;
                const config = _collectHbConfig();
                const rawEl = document.getElementById('hb-raw-textarea');
                if (rawEl && _hbParsedData) rawEl.value = _buildHeartbeatMd(_hbParsedData, config);
            }
        }

        // ==================== STORED ITEMS (Delayed questions, sims, agent results) ====================

        let storedItems = [];
        let _currentMindTab = 'chat';

        function switchMindTab(tab) {
            _currentMindTab = tab;
            const chatMsgs = document.getElementById('mind-chat-messages');
            const answersDiv = document.getElementById('mind-answers-items');
            const storedDiv = document.getElementById('mind-stored-items');
            const agentsDiv = document.getElementById('mind-agents-items');
            const walletDiv = document.getElementById('mind-wallet-items');
            const inputBar = document.querySelector('.mind-chat-input-bar');
            const fabContainer = document.querySelector('.mind-fab-container');
            document.querySelectorAll('.mind-chat-tab').forEach(t => {
                t.classList.toggle('active', t.dataset.tab === tab);
            });
            // Hide all panes
            if (chatMsgs) chatMsgs.style.display = 'none';
            if (answersDiv) answersDiv.classList.add('hidden');
            if (storedDiv) storedDiv.classList.add('hidden');
            if (agentsDiv) agentsDiv.classList.add('hidden');
            if (walletDiv) walletDiv.classList.add('hidden');
            if (inputBar) inputBar.style.display = 'none';
            if (fabContainer) fabContainer.style.display = 'none';

            // Stop wallet polling when leaving wallet tab
            if (tab !== 'wallet') stopWalletPolling();

            if (tab === 'chat') {
                if (chatMsgs) chatMsgs.style.display = '';
                if (inputBar) inputBar.style.display = '';
                if (fabContainer) fabContainer.style.display = '';
            } else if (tab === 'answers') {
                if (answersDiv) answersDiv.classList.remove('hidden');
                renderAnswerItems();
            } else if (tab === 'agents') {
                if (agentsDiv) agentsDiv.classList.remove('hidden');
                renderMindAgents();
            } else if (tab === 'wallet') {
                if (walletDiv) walletDiv.classList.remove('hidden');
                fetchWalletData();
                startWalletPolling();
            } else {
                if (storedDiv) storedDiv.classList.remove('hidden');
                renderStoredItems();
            }
        }

        function renderMindAgents() {
            const container = document.getElementById('mind-agents-items');
            if (!container) return;
            container.textContent = '';

            // Filter to only Cerebro-spawned and scheduler agents (not manual user agents)
            const cerebroAgents = Object.values(agents).filter(a =>
                a.source === 'cerebro' || a.source === 'scheduler'
            );

            // Separate running/queued from completed
            const running = cerebroAgents.filter(a => a.status === 'running');
            const queued = cerebroAgents.filter(a => a.status === 'queued');
            const recent = cerebroAgents.filter(a => a.status === 'completed' || a.status === 'failed')
                .sort((a, b) => (b.completed_at || '').localeCompare(a.completed_at || ''))
                .slice(0, 5);

            if (running.length === 0 && queued.length === 0 && recent.length === 0) {
                const emptyDiv = document.createElement('div');
                emptyDiv.className = 'mind-agents-empty';
                const iconDiv = document.createElement('div');
                iconDiv.className = 'empty-icon';
                iconDiv.textContent = '\u{1F916}';
                const textDiv = document.createElement('div');
                textDiv.textContent = 'No Cerebro agents active';
                const hintDiv = document.createElement('div');
                hintDiv.style.cssText = 'font-size:0.72rem;margin-top:4px;color:rgba(255,255,255,0.2)';
                hintDiv.textContent = 'Agents spawned by directives and automations appear here';
                emptyDiv.append(iconDiv, textDiv, hintDiv);
                container.appendChild(emptyDiv);
                return;
            }

            // Queue header
            const header = document.createElement('div');
            header.className = 'mind-agents-queue-header';
            const stats = document.createElement('div');
            stats.className = 'queue-stats';
            const runSpan = document.createElement('span');
            runSpan.textContent = running.length;
            const queueSpan = document.createElement('span');
            queueSpan.textContent = queued.length;
            stats.append(runSpan, ' running \u00B7 ', queueSpan, ' queued');
            header.appendChild(stats);
            container.appendChild(header);

            // Queued agents first
            for (const a of queued) {
                container.appendChild(buildMindAgentCard(a, 'queued'));
            }
            // Running agents
            for (const a of running) {
                container.appendChild(buildMindAgentCard(a, 'running'));
            }
            // Recent completed (last 5)
            if (recent.length > 0) {
                const recentLabel = document.createElement('div');
                recentLabel.style.cssText = 'font-size:0.7rem;color:rgba(255,255,255,0.25);padding:8px 4px 4px;text-transform:uppercase;letter-spacing:0.5px';
                recentLabel.textContent = 'Recent';
                container.appendChild(recentLabel);
                for (const a of recent) {
                    container.appendChild(buildMindAgentCard(a, a.status));
                }
            }
        }

        function buildMindAgentCard(agent, status) {
            const card = document.createElement('div');
            card.className = 'mind-agent-card';
            card.addEventListener('click', () => showAgentDetail(agent.id));

            const iconDiv = document.createElement('div');
            iconDiv.className = 'agent-icon';
            iconDiv.textContent = agent.role_icon || '\u{1F916}';

            const infoDiv = document.createElement('div');
            infoDiv.className = 'agent-info';
            const callsignDiv = document.createElement('div');
            callsignDiv.className = 'agent-callsign';
            callsignDiv.textContent = agent.call_sign || agent.id;
            const typeSpan = document.createElement('span');
            typeSpan.style.cssText = 'font-size:0.68rem;color:rgba(255,255,255,0.3);font-weight:400;margin-left:6px';
            typeSpan.textContent = agent.type || '';
            callsignDiv.appendChild(typeSpan);
            const taskDiv = document.createElement('div');
            taskDiv.className = 'agent-task-preview';
            taskDiv.textContent = (agent.task || '').substring(0, 80);
            infoDiv.append(callsignDiv, taskDiv);

            const dot = document.createElement('div');
            const statusClass = status === 'running' ? 'running' : status === 'queued' ? 'queued' : (status === 'completed' ? 'completed' : 'failed');
            dot.className = 'agent-status-dot ' + statusClass;
            if (status === 'completed') dot.style.background = 'var(--green)';
            else if (status === 'failed') dot.style.background = 'var(--red)';

            card.append(iconDiv, infoDiv, dot);
            return card;
        }

        function updateAgentsTabBadge() {
            const badge = document.getElementById('agents-tab-badge');
            if (!badge) return;
            const count = Object.values(agents).filter(a =>
                (a.source === 'cerebro' || a.source === 'scheduler') &&
                (a.status === 'running' || a.status === 'queued')
            ).length;
            if (count > 0) {
                badge.textContent = count;
                badge.style.display = '';
            } else {
                badge.style.display = 'none';
            }
        }

        //  Wallet Tab 
        let _walletData = null;
        let _walletPeriod = 'today';
        let _walletPollTimer = null;

        async function fetchWalletData() {
            try {
                const resp = await fetch(`${API_URL}/api/wallet/summary`, {
                    headers: { 'Authorization': `Bearer ${localStorage.getItem('cerebro_token')}` }
                });
                if (resp.ok) {
                    _walletData = await resp.json();
                    updateWalletBadge();
                    if (_currentMindTab === 'wallet') renderWallet();
                }
            } catch (e) {
                console.error('Wallet fetch failed:', e);
            }
        }

        function _walletPnlClass(v) { return v > 0 ? 'positive' : v < 0 ? 'negative' : 'zero'; }
        function _walletSign(v) { return v > 0 ? '+' : ''; }

        function renderWallet() {
            const container = document.getElementById('mind-wallet-items');
            if (!container) return;
            container.textContent = '';

            if (!_walletData) {
                const empty = document.createElement('div');
                empty.className = 'wallet-empty';
                const ico = document.createElement('div');
                ico.className = 'empty-icon';
                ico.textContent = '\u{1F4B0}';
                const txt = document.createElement('div');
                txt.textContent = 'Loading wallet...';
                empty.append(ico, txt);
                container.appendChild(empty);
                return;
            }

            // P&L Header
            const header = document.createElement('div');
            header.className = 'wallet-pnl-header';

            const label = document.createElement('div');
            label.className = 'wallet-pnl-label';
            const periodLabels = { today: "Today's", week: 'This Week', month: 'This Month', all: 'All Time' };
            label.textContent = (periodLabels[_walletPeriod] || "Today's") + ' P&L';
            header.appendChild(label);

            const total = _walletData.totals[_walletPeriod] || 0;
            const amtDiv = document.createElement('div');
            amtDiv.className = 'wallet-pnl-amount ' + _walletPnlClass(total);
            amtDiv.textContent = _walletSign(total) + '$' + total.toFixed(2);
            header.appendChild(amtDiv);

            const unrealized = _walletData.unrealized || 0;
            if (unrealized !== 0) {
                const uDiv = document.createElement('div');
                uDiv.className = 'wallet-pnl-unrealized';
                const posCount = (_walletData.open_positions || []).length;
                uDiv.textContent = 'Unrealized: ' + _walletSign(unrealized) + '$' + unrealized.toFixed(2) + ' (' + posCount + ' position' + (posCount !== 1 ? 's' : '') + ')';
                header.appendChild(uDiv);
            }

            const periodBar = document.createElement('div');
            periodBar.className = 'wallet-period-bar';
            for (const p of ['today', 'week', 'month', 'all']) {
                const btn = document.createElement('button');
                btn.className = 'wallet-period-btn' + (_walletPeriod === p ? ' active' : '');
                btn.textContent = p.charAt(0).toUpperCase() + p.slice(1);
                btn.addEventListener('click', () => setWalletPeriod(p));
                periodBar.appendChild(btn);
            }
            header.appendChild(periodBar);
            container.appendChild(header);

            // Two-column layout: Open | History
            const cols = document.createElement('div');
            cols.className = 'wallet-columns';

            //  Open column 
            const openCol = document.createElement('div');
            openCol.className = 'wallet-col';
            const openHeader = document.createElement('div');
            openHeader.className = 'wallet-col-header';
            openHeader.textContent = 'Open';
            openCol.appendChild(openHeader);
            const openContent = document.createElement('div');
            openContent.className = 'wallet-col-content';

            const positions = _walletData.open_positions || [];
            if (positions.length === 0) {
                const emptyMsg = document.createElement('div');
                emptyMsg.className = 'wallet-col-empty';
                emptyMsg.textContent = 'No open positions';
                openContent.appendChild(emptyMsg);
            } else {
                for (const pos of positions) {
                    openContent.appendChild(buildPositionCard(pos));
                }
            }
            openCol.appendChild(openContent);

            //  History column 
            const histCol = document.createElement('div');
            histCol.className = 'wallet-col';
            const histHeader = document.createElement('div');
            histHeader.className = 'wallet-col-header';
            histHeader.textContent = 'History';
            histCol.appendChild(histHeader);
            const histContent = document.createElement('div');
            histContent.className = 'wallet-col-content';

            const history = _walletData.history || [];
            if (history.length === 0) {
                const emptyMsg = document.createElement('div');
                emptyMsg.className = 'wallet-col-empty';
                emptyMsg.textContent = 'No activity yet';
                histContent.appendChild(emptyMsg);
            } else {
                for (const entry of history) {
                    histContent.appendChild(buildWalletEntryCard(entry));
                }
            }
            histCol.appendChild(histContent);

            cols.append(openCol, histCol);
            container.appendChild(cols);
        }

        function buildPositionCard(pos) {
            const card = document.createElement('div');
            card.className = 'wallet-position-card';

            const infoDiv = document.createElement('div');
            infoDiv.className = 'wallet-entry-info';
            const sym = document.createElement('div');
            sym.className = 'pos-symbol';
            sym.textContent = pos.symbol || '';
            const detail = document.createElement('div');
            detail.className = 'pos-detail';
            const qty = parseFloat(pos.qty) || 0;
            const side = pos.side || (qty > 0 ? 'long' : 'short');
            const price = pos.avg_entry_price ? parseFloat(pos.avg_entry_price).toFixed(2) : '';
            const cur = pos.current_price ? parseFloat(pos.current_price).toFixed(2) : '';
            detail.textContent = side.toUpperCase() + ' ' + Math.abs(qty) + (price ? ' @ $' + price : '') + (cur ? '  $' + cur : '');
            infoDiv.append(sym, detail);

            const pnlDiv = document.createElement('div');
            pnlDiv.className = 'pos-pnl';
            const upl = parseFloat(pos.unrealized_pl) || 0;
            pnlDiv.className = 'pos-pnl ' + _walletPnlClass(upl);
            pnlDiv.textContent = _walletSign(upl) + '$' + upl.toFixed(2);

            card.append(infoDiv, pnlDiv);
            return card;
        }

        function buildWalletEntryCard(entry) {
            const card = document.createElement('div');
            const cat = entry.category || 'other';
            card.className = 'wallet-entry-card cat-' + cat;

            const infoDiv = document.createElement('div');
            infoDiv.className = 'wallet-entry-info';

            const descDiv = document.createElement('div');
            descDiv.className = 'wallet-entry-desc';
            descDiv.textContent = entry.description || 'Activity';

            const metaDiv = document.createElement('div');
            metaDiv.className = 'wallet-entry-meta';
            const catSpan = document.createElement('span');
            catSpan.className = 'wallet-entry-category cat-' + cat;
            catSpan.textContent = cat;
            const timeSpan = document.createElement('span');
            try {
                const d = new Date(entry.timestamp);
                timeSpan.textContent = d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' }) + ' ' + d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            } catch (e) { timeSpan.textContent = ''; }
            metaDiv.append(catSpan, timeSpan);
            if (entry.source && entry.source !== cat) {
                const srcSpan = document.createElement('span');
                srcSpan.textContent = entry.source;
                metaDiv.appendChild(srcSpan);
            }
            infoDiv.append(descDiv, metaDiv);

            const pnlDiv = document.createElement('div');
            const pnl = parseFloat(entry.pnl) || 0;
            pnlDiv.className = 'wallet-entry-pnl ' + _walletPnlClass(pnl);
            pnlDiv.textContent = _walletSign(pnl) + '$' + pnl.toFixed(2);

            card.append(infoDiv, pnlDiv);
            return card;
        }

        function setWalletPeriod(period) {
            _walletPeriod = period;
            renderWallet();
        }

        function startWalletPolling() {
            stopWalletPolling();
            _walletPollTimer = setInterval(() => {
                if (_currentMindTab === 'wallet') fetchWalletData();
            }, 45000);
        }

        function stopWalletPolling() {
            if (_walletPollTimer) {
                clearInterval(_walletPollTimer);
                _walletPollTimer = null;
            }
        }

        function updateWalletBadge() {
            const badge = document.getElementById('wallet-badge');
            if (!badge) return;
            const count = _walletData ? (_walletData.today_count || 0) : 0;
            if (count > 0) {
                badge.textContent = count;
                badge.style.display = '';
            } else {
                badge.style.display = 'none';
            }
        }

        // Initial wallet badge fetch on page load
        setTimeout(() => fetchWalletData(), 3000);

        async function loadStoredItems() {
            try {
                const resp = await fetch(`${API_URL}/api/stored-items`, {
                    headers: { 'Authorization': `Bearer ${localStorage.getItem('cerebro_token')}` }
                });
                if (resp.ok) {
                    const data = await resp.json();
                    storedItems = data.items || [];
                    updateStoredBadge();
                    if (_currentMindTab === 'stored') renderStoredItems();
                    if (_currentMindTab === 'answers') renderAnswerItems();
                }
            } catch (e) {
                console.error('Failed to load stored items:', e);
            }
        }

        function relativeTime(isoStr) {
            const diff = Date.now() - new Date(isoStr).getTime();
            const mins = Math.floor(diff / 60000);
            if (mins < 1) return 'just now';
            if (mins < 60) return mins + ' min ago';
            const hrs = Math.floor(mins / 60);
            if (hrs < 24) return hrs + 'h ago';
            const days = Math.floor(hrs / 24);
            return days + 'd ago';
        }

        function _buildStoredEmptyState() {
            const wrap = document.createElement('div');
            wrap.className = 'mind-stored-items-empty';
            const icon = document.createElement('div');
            icon.className = 'mind-stored-items-empty-icon';
            icon.textContent = '\uD83D\uDCE6';
            const msg = document.createElement('div');
            msg.textContent = 'No stored items yet';
            const hint = document.createElement('div');
            hint.style.fontSize = '0.75rem';
            hint.textContent = 'Delayed questions, simulations, and agent results will appear here';
            wrap.appendChild(icon);
            wrap.appendChild(msg);
            wrap.appendChild(hint);
            return wrap;
        }

        function getAnswerItems() {
            return storedItems.filter(i => i.type === 'question' || i.type === 'approval');
        }
        function getStoredOnlyItems() {
            return storedItems.filter(i => i.type !== 'question' && i.type !== 'approval');
        }

        function _buildAnswersEmptyState() {
            const wrap = document.createElement('div');
            wrap.className = 'mind-stored-items-empty';
            const icon = document.createElement('div');
            icon.className = 'mind-stored-items-empty-icon';
            icon.textContent = '\uD83E\uDDE0';
            const msg = document.createElement('div');
            msg.textContent = 'No questions from Cerebro';
            const hint = document.createElement('div');
            hint.style.fontSize = '0.75rem';
            hint.textContent = 'Questions and approval requests will appear here';
            wrap.appendChild(icon);
            wrap.appendChild(msg);
            wrap.appendChild(hint);
            return wrap;
        }

        function renderAnswerItems() {
            const container = document.getElementById('mind-answers-items');
            if (!container) return;
            container.textContent = '';
            const items = getAnswerItems();
            if (items.length === 0) {
                container.appendChild(_buildAnswersEmptyState());
                return;
            }
            items.forEach(item => {
                const card = document.createElement('div');
                card.className = 'stored-item-card type-' + (item.type || 'question');
                card.onclick = (e) => {
                    if (e.target.closest('.stored-item-delete')) return;
                    onStoredItemClick(item);
                };
                const header = document.createElement('div');
                header.className = 'stored-item-card-header';
                const statusDot = document.createElement('div');
                statusDot.className = 'stored-item-status-dot ' + (item.status || 'pending');
                header.appendChild(statusDot);
                const badge = document.createElement('span');
                badge.className = 'stored-item-badge ' + (item.type || 'question');
                const badgeLabels = { question: 'Input Needed', approval: 'Approval Needed', alert: 'Alert', goal_progress: 'Goal Progress', goal_complete: 'Goal Complete', quick_task: 'Quick Task' };
                badge.textContent = badgeLabels[item.type] || item.type;
                header.appendChild(badge);
                const timeSpan = document.createElement('span');
                timeSpan.className = 'stored-item-time';
                timeSpan.textContent = relativeTime(item.created_at);
                header.appendChild(timeSpan);
                card.appendChild(header);
                const title = document.createElement('div');
                title.className = 'stored-item-title';
                title.textContent = stripMarkdown(item.title) || 'Stored Item';
                card.appendChild(title);
                if (item.content) {
                    const preview = document.createElement('div');
                    preview.className = 'stored-item-content-preview';
                    preview.textContent = stripMarkdown(item.content).substring(0, 200);
                    card.appendChild(preview);
                }
                const delBtn = document.createElement('button');
                delBtn.className = 'stored-item-delete';
                delBtn.textContent = '\u2715';
                delBtn.title = 'Remove';
                delBtn.onclick = (e) => { e.stopPropagation(); deleteStoredItem(item.id); };
                card.appendChild(delBtn);
                container.appendChild(card);
            });
        }

        function renderStoredItems() {
            const container = document.getElementById('mind-stored-items');
            if (!container) return;
            container.textContent = '';
            const items = getStoredOnlyItems();
            if (items.length === 0) {
                container.appendChild(_buildStoredEmptyState());
                return;
            }
            items.forEach(item => {
                const card = document.createElement('div');
                card.className = 'stored-item-card type-' + (item.type || 'question');
                card.onclick = (e) => {
                    if (e.target.closest('.stored-item-delete')) return;
                    onStoredItemClick(item);
                };

                // Header
                const header = document.createElement('div');
                header.className = 'stored-item-card-header';

                const statusDot = document.createElement('div');
                statusDot.className = 'stored-item-status-dot ' + (item.status || 'pending');
                header.appendChild(statusDot);

                const badge = document.createElement('span');
                badge.className = 'stored-item-badge ' + (item.type || 'question');
                const badgeLabels = { question: 'Input Needed', approval: 'Approval Needed', simulation: 'Simulation', agent_result: 'Agent Complete', finding: 'Finding', alert: 'Alert', goal_progress: 'Goal Progress', goal_complete: 'Goal Complete', quick_task: 'Quick Task' };
                badge.textContent = badgeLabels[item.type] || item.type;
                header.appendChild(badge);

                const timeSpan = document.createElement('span');
                timeSpan.className = 'stored-item-time';
                timeSpan.textContent = relativeTime(item.created_at);
                header.appendChild(timeSpan);

                card.appendChild(header);

                // Title
                const title = document.createElement('div');
                title.className = 'stored-item-title';
                title.textContent = stripMarkdown(item.title) || 'Stored Item';
                card.appendChild(title);

                // Content preview
                if (item.content) {
                    const preview = document.createElement('div');
                    preview.className = 'stored-item-content-preview';
                    preview.textContent = stripMarkdown(item.content).substring(0, 200);
                    card.appendChild(preview);
                }

                // Delete button
                const delBtn = document.createElement('button');
                delBtn.className = 'stored-item-delete';
                delBtn.textContent = '\u2715';
                delBtn.title = 'Remove';
                delBtn.onclick = (e) => { e.stopPropagation(); deleteStoredItem(item.id); };
                card.appendChild(delBtn);

                container.appendChild(card);
            });
        }

        function onStoredItemClick(item) {
            if (item.type === 'question' || item.type === 'approval') {
                reopenStoredQuestion(item);
            } else if (item.type === 'simulation') {
                if (item.metadata) showSimulationModal(item.metadata);
                markStoredItemViewed(item.id);
            } else {
                // agent_result / finding / alert: show detail popup
                showStoredItemDetail(item);
                markStoredItemViewed(item.id);
            }
        }

        function parseAlertFields(content) {
            const fields = {};
            if (!content) return fields;
            const regex = /\*\*([^*]+):\*\*\s*(.+)/g;
            let match;
            while ((match = regex.exec(content)) !== null) {
                fields[match[1].trim()] = match[2].trim();
            }
            return fields;
        }

        function showStoredItemDetail(item) {
            // Remove any existing detail overlay
            const existing = document.querySelector('.stored-item-detail-overlay');
            if (existing) existing.remove();

            const type = item.type || 'finding';
            const icons = { alert: '\u26a0\ufe0f', finding: '\ud83d\udd0d', agent_result: '\u2705' };
            const typeLabels = { alert: 'Network Alert', finding: 'Finding', agent_result: 'Agent Result' };

            // Overlay
            const overlay = document.createElement('div');
            overlay.className = 'stored-item-detail-overlay';
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) dismissStoredItemDetail();
            });

            // Popup
            const popup = document.createElement('div');
            popup.className = 'stored-item-detail-popup type-' + type;

            // Header
            const header = document.createElement('div');
            header.className = 'stored-item-detail-header type-' + type;

            const icon = document.createElement('div');
            icon.className = 'stored-item-detail-icon type-' + type;
            icon.textContent = icons[type] || '\ud83d\udccc';
            header.appendChild(icon);

            const headerText = document.createElement('div');
            headerText.className = 'stored-item-detail-header-text';
            const typeLabel = document.createElement('div');
            typeLabel.className = 'stored-item-detail-type-label type-' + type;
            typeLabel.textContent = typeLabels[type] || type;
            headerText.appendChild(typeLabel);
            const titleEl = document.createElement('div');
            titleEl.className = 'stored-item-detail-title';
            titleEl.textContent = item.title || 'Stored Item';
            headerText.appendChild(titleEl);
            header.appendChild(headerText);

            const closeBtn = document.createElement('button');
            closeBtn.className = 'stored-item-detail-close';
            closeBtn.innerHTML = '&times;';
            closeBtn.onclick = dismissStoredItemDetail;
            header.appendChild(closeBtn);
            popup.appendChild(header);

            // Body
            const body = document.createElement('div');
            body.className = 'stored-item-detail-body';

            if (type === 'alert') {
                const fields = parseAlertFields(item.content);
                if (Object.keys(fields).length > 0) {
                    const grid = document.createElement('div');
                    grid.className = 'stored-item-detail-fields';
                    for (const [key, val] of Object.entries(fields)) {
                        const label = document.createElement('div');
                        label.className = 'stored-item-detail-field-label';
                        label.textContent = key;
                        grid.appendChild(label);
                        const value = document.createElement('div');
                        value.className = 'stored-item-detail-field-value';
                        value.textContent = val;
                        grid.appendChild(value);
                    }
                    body.appendChild(grid);
                } else {
                    const md = document.createElement('div');
                    md.className = 'stored-item-detail-markdown';
                    md.innerHTML = typeof safeMarkdown === 'function' ? safeMarkdown(item.content || '') : (item.content || '');
                    body.appendChild(md);
                }
            } else {
                const md = document.createElement('div');
                md.className = 'stored-item-detail-markdown';
                md.innerHTML = typeof safeMarkdown === 'function' ? safeMarkdown(item.content || '') : (item.content || '');
                body.appendChild(md);
            }

            // Metadata section
            if (item.metadata && Object.keys(item.metadata).length > 0) {
                const metaDiv = document.createElement('div');
                metaDiv.className = 'stored-item-detail-meta';
                const metaKeys = ['source', 'directive_id', 'agent_type', 'category'];
                for (const k of metaKeys) {
                    if (item.metadata[k]) {
                        const row = document.createElement('div');
                        row.className = 'stored-item-detail-meta-row';
                        row.innerHTML = '<span>' + k.replace(/_/g, ' ') + '</span><span>' + item.metadata[k] + '</span>';
                        metaDiv.appendChild(row);
                    }
                }
                if (metaDiv.children.length > 0) body.appendChild(metaDiv);
            }

            // Timestamp
            if (item.created_at) {
                const ts = document.createElement('div');
                ts.className = 'stored-item-detail-timestamp';
                try {
                    ts.textContent = new Date(item.created_at).toLocaleString();
                } catch(e) { ts.textContent = item.created_at; }
                body.appendChild(ts);
            }

            popup.appendChild(body);

            // Actions
            const actions = document.createElement('div');
            actions.className = 'stored-item-detail-actions';

            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'stored-item-detail-btn delete';
            deleteBtn.textContent = 'Delete';
            deleteBtn.onclick = () => {
                deleteStoredItem(item.id);
                dismissStoredItemDetail();
            };
            actions.appendChild(deleteBtn);

            const investBtn = document.createElement('button');
            investBtn.className = 'stored-item-detail-btn investigate type-' + type;
            investBtn.textContent = 'Investigate';
            investBtn.onclick = () => investigateStoredItem(item);
            actions.appendChild(investBtn);

            popup.appendChild(actions);
            overlay.appendChild(popup);
            document.body.appendChild(overlay);

            // Escape key handler
            overlay._escHandler = (e) => {
                if (e.key === 'Escape') dismissStoredItemDetail();
            };
            document.addEventListener('keydown', overlay._escHandler);
        }

        function dismissStoredItemDetail() {
            const overlay = document.querySelector('.stored-item-detail-overlay');
            if (!overlay) return;
            const popup = overlay.querySelector('.stored-item-detail-popup');
            if (popup) popup.classList.add('closing');
            overlay.classList.add('closing');
            if (overlay._escHandler) {
                document.removeEventListener('keydown', overlay._escHandler);
            }
            setTimeout(() => overlay.remove(), 200);
        }

        async function investigateStoredItem(item) {
            dismissStoredItemDetail();
            const directiveText = 'Investigate stored ' + (item.type || 'item') + ': ' + (item.title || '') + '. Details: ' + (item.content || '').substring(0, 500);
            try {
                const resp = await fetch(API_URL + '/api/directives', {
                    method: 'POST',
                    headers: { 'Authorization': 'Bearer ' + localStorage.getItem('cerebro_token'), 'Content-Type': 'application/json' },
                    body: JSON.stringify({ text: directiveText, priority: item.type === 'alert' ? 'high' : 'normal' })
                });
                if (resp.ok) {
                    showToast('Investigation directive created', 'success');
                } else {
                    showToast('Failed to create directive', 'error');
                }
            } catch (e) {
                console.error('Failed to create investigation directive:', e);
                showToast('Failed to create directive: ' + e.message, 'error');
            }
        }

        function reopenStoredQuestion(item) {
            const popupData = {
                id: item.source_id || item.id,
                question: item.content || item.title,
                context: item.metadata?.context || '',
                urgency: item.metadata?.urgency || 'medium',
                type: item.type === 'approval' ? 'approval' : 'question',
                directive_id: item.metadata?.directive_id || '',
                options: item.metadata?.options || [],
                _storedItemId: item.id
            };
            showHITLPopup(popupData);
        }

        async function markStoredItemViewed(itemId) {
            const item = storedItems.find(i => i.id === itemId);
            if (item && item.status === 'pending') {
                item.status = 'viewed';
                updateStoredBadge();
                if (_currentMindTab === 'answers') renderAnswerItems();
                else if (_currentMindTab === 'stored') renderStoredItems();
                try {
                    await fetch(`${API_URL}/api/stored-items/${encodeURIComponent(itemId)}`, {
                        method: 'PATCH',
                        headers: { 'Authorization': `Bearer ${localStorage.getItem('cerebro_token')}`, 'Content-Type': 'application/json' },
                        body: JSON.stringify({ status: 'viewed' })
                    });
                } catch (e) { console.error('Failed to update stored item:', e); }
            }
        }

        async function deleteStoredItem(itemId) {
            storedItems = storedItems.filter(i => i.id !== itemId);
            updateStoredBadge();
            if (_currentMindTab === 'answers') renderAnswerItems();
            else if (_currentMindTab === 'stored') renderStoredItems();
            try {
                await fetch(`${API_URL}/api/stored-items/${encodeURIComponent(itemId)}`, {
                    method: 'DELETE',
                    headers: { 'Authorization': `Bearer ${localStorage.getItem('cerebro_token')}` }
                });
            } catch (e) { console.error('Failed to delete stored item:', e); }
        }

        function updateStoredBadge() {
            // Answers badge - count pending questions/approvals
            const answersBadge = document.getElementById('answers-badge');
            if (answersBadge) {
                const answerCount = storedItems.filter(i =>
                    (i.type === 'question' || i.type === 'approval') && i.status === 'pending'
                ).length;
                answersBadge.textContent = answerCount;
                answersBadge.style.display = answerCount > 0 ? '' : 'none';
            }
            // Stored badge - count pending non-question items
            const storedBadge = document.getElementById('stored-badge');
            if (storedBadge) {
                const storedCount = storedItems.filter(i =>
                    i.type !== 'question' && i.type !== 'approval' && i.status === 'pending'
                ).length;
                storedBadge.textContent = storedCount;
                storedBadge.style.display = storedCount > 0 ? '' : 'none';
            }
        }

        function skipHITL(popupId) {
            if (socket) {
                const popup = hitlPopups.find(p => p.id === popupId);
                socket.emit('human_input_response', {
                    request_id: popupId,
                    directive_id: popup ? (popup.data.directive_id || '') : '',
                    answer: '__SKIPPED__',
                    timestamp: new Date().toISOString()
                });
            }
            dismissHITLPopup(popupId);
        }

        async function delayHITL(popupId) {
            const popup = hitlPopups.find(p => p.id === popupId);
            if (!popup) { dismissHITLPopup(popupId); return; }
            const data = popup.data;
            const item = {
                id: 'stored_' + popupId,
                type: data.type === 'approval' ? 'approval' : 'question',
                title: (data.question || 'Cerebro Question').substring(0, 80),
                content: data.question || '',
                metadata: {
                    request_id: popupId,
                    context: data.context || '',
                    urgency: data.urgency || 'medium',
                    type: data.type || 'question',
                    options: data.options || [],
                    directive_id: data.directive_id || '',
                    chrome_hint: data.browser_url || ''
                },
                created_at: new Date().toISOString(),
                status: 'pending',
                source_id: popupId
            };
            try {
                await fetch(`${API_URL}/api/stored-items`, {
                    method: 'POST',
                    headers: { 'Authorization': `Bearer ${localStorage.getItem('cerebro_token')}`, 'Content-Type': 'application/json' },
                    body: JSON.stringify(item)
                });
            } catch (e) { console.error('Failed to store delayed question:', e); }
            dismissHITLPopup(popupId);
            showToast('Question saved to Answers tab', 'info');
        }

        // ==================== END STORED ITEMS ====================

        function openBrowserView() {
            // Chrome is running on the desktop - show a helpful message
            if (browserState.running) {
                var url = browserState.currentUrl || '';
                showToast('Chrome is open on your desktop - switch to the Chrome window' + (url ? ': ' + url : ''), 'info');
            }
            // Also open CDP inspector as fallback
            window.open(CEREBRO_CDP_URL, '_blank');
        }

        async function fetchBrowserScreenshot() {
            try {
                const response = await fetch(API_URL + '/api/browser/screenshot', {
                    headers: { 'Authorization': 'Bearer ' + localStorage.getItem('cerebro_token') }
                });
                if (response.ok) {
                    const data = await response.json();
                    if (data.screenshot) {
                        var b64src = data.screenshot.startsWith('data:') ? data.screenshot : 'data:image/png;base64,' + data.screenshot;
                        hitlBrowserScreenshot = b64src;
                        document.querySelectorAll('.hitl-browser-preview img').forEach(img => {
                            img.src = b64src;
                        });
                    }
                }
            } catch(e) { /* Screenshot is optional */ }
        }

        function setupHITLSocketListeners() {
            if (!socket) {
                setTimeout(setupHITLSocketListeners, 1000);
                return;
            }

            socket.on('human_input_needed', (data) => {
                console.log('[HITL] Human input needed:', data);
                if (typeof tamagotchiState !== 'undefined') tamagotchiState.hitlPending = true;
                showHITLPopup(data);
            });

            // === BROWSER STEP: Live exploration progress (Browser tab only, no chat clutter) ===
            socket.on('browser_step', (data) => {
                _agentBrowserStepCount++;
                browserStepLog.push({ step: data.step, action: data.action, reasoning: data.reasoning || '', screenshot: data.screenshot || '' });
                if (browserStepLog.length > 100) browserStepLog.shift();
                renderBrowserStepLog();
            });

            socket.on('browser_screenshot', (data) => {
                if (data.screenshot) {
                    var b64src = data.screenshot.startsWith('data:') ? data.screenshot : 'data:image/png;base64,' + data.screenshot;
                    hitlBrowserScreenshot = b64src;
                    document.querySelectorAll('.hitl-browser-preview img').forEach(img => {
                        img.src = b64src;
                    });
                }
            });

            // Voice Screenshot - toast + overlay + chat injection
            socket.on('voice_screenshot', (data) => {
                console.log('[VoiceScreenshot] Received:', data.window_title);
                const imgSrc = data.image_base64.startsWith('data:')
                    ? data.image_base64
                    : 'data:image/jpeg;base64,' + data.image_base64;

                // --- Toast notification (built with safe DOM methods) ---
                const existingToast = document.querySelector('.voice-screenshot-toast');
                if (existingToast) existingToast.remove();

                const toast = document.createElement('div');
                toast.className = 'voice-screenshot-toast';

                const header = document.createElement('div');
                header.className = 'vs-toast-header';

                const label = document.createElement('span');
                label.className = 'vs-toast-label';
                label.textContent = 'Voice Capture';

                const title = document.createElement('span');
                title.className = 'vs-toast-title';
                title.textContent = data.window_title || 'Screenshot';

                const closeBtn = document.createElement('button');
                closeBtn.className = 'vs-toast-close';
                closeBtn.textContent = String.fromCharCode(215);
                closeBtn.onclick = function(e) {
                    e.stopPropagation();
                    toast.remove();
                };

                header.appendChild(label);
                header.appendChild(title);
                header.appendChild(closeBtn);

                const thumb = document.createElement('img');
                thumb.className = 'vs-toast-thumb';
                thumb.src = imgSrc;
                thumb.alt = 'screenshot';

                toast.appendChild(header);
                toast.appendChild(thumb);

                toast.onclick = function() {
                    toast.remove();
                    showVoiceScreenshotOverlay(imgSrc, data.window_title || 'Screenshot');
                };
                document.body.appendChild(toast);

                // Auto-dismiss after 8s
                setTimeout(function() {
                    if (toast.parentNode) {
                        toast.classList.add('dismissing');
                        setTimeout(function() { toast.remove(); }, 300);
                    }
                }, 8000);

                // --- Inject into mind chat ---
                if (typeof cerebroChat !== 'undefined') {
                    cerebroChat.push({
                        id: 'vs_' + Date.now(),
                        role: 'assistant',
                        type: 'browser_step',
                        content: 'Voice capture: ' + (data.window_title || 'Screenshot'),
                        screenshot: data.image_base64,
                        timestamp: data.timestamp || new Date().toISOString(),
                        isNarration: true,
                        phases: ['observe']
                    });
                    if (typeof renderChatMessages === 'function') renderChatMessages();
                    if (typeof renderMindChat === 'function') renderMindChat();
                }
            });


            socket.on('loop_phase_change', (data) => {
                console.log('[HITL] Phase change:', data);
                const phaseInfo = OODA_PHASE_ICONS[data.phase] || { icon: '', label: data.phase };

                const phaseEl = document.getElementById('current-ooda-phase');
                if (phaseEl) {
                    phaseEl.className = 'ooda-phase-indicator ' + (data.phase || '');
                    phaseEl.textContent = phaseInfo.icon + ' ' + phaseInfo.label;
                }

                if (data.summary) {
                    addThoughtToCycle({
                        phase: data.phase || '',
                        content: data.summary,
                        timestamp: data.timestamp || new Date().toISOString(),
                        cycle_number: data.cycle_number || _runningCycleNumber || 0,
                        metadata: data.metadata || {}
                    });
                    setAlivePulse(false);
                }

                // Update status bar phase text
                const phaseBar = document.getElementById('status-card-phase-value');
                if (phaseBar) phaseBar.textContent = (data.phase || 'idle').charAt(0).toUpperCase() + (data.phase || 'idle').slice(1);

                // Push phase changes to mind chat as status messages
                if (data.summary && typeof injectStatusToChat === 'function') {
                    const label = 'Cerebro \u2022 ' + (phaseInfo.label || data.phase);
                    injectStatusToChat(data.summary, label);
                }
            });

            console.log('[HITL] Socket listeners registered');
        }

        setTimeout(setupHITLSocketListeners, 600);

        // Periodic real-time sync: refresh autonomy status + directives every 15s
        setInterval(async () => {
            if (currentView === 'autonomy') {
                try {
                    const response = await fetch(`${API_URL}/api/autonomy/status`, {
                        headers: { 'Authorization': `Bearer ${localStorage.getItem('cerebro_token')}` }
                    });
                    const data = await response.json();
                    if (data.available) {
                        autonomyState = {
                            status: data.status || 'stopped',
                            level: data.autonomy_level || 2,
                            cycles: data.cycles_completed || 0,
                            phase: data.current_phase || 'idle',
                            actions: data.actions_completed || 0,
                            pending: data.pending_count || 0,
                            fullAutonomy: data.full_autonomy_enabled || false
                        };
                        updateAutonomyUI();
                    }
                } catch (e) { /* silent */ }
            }
        }, 15000);

        // Periodic directive sync every 20s when on Mind page
        setInterval(() => {
            if (currentView === 'autonomy' && typeof loadDirectives === 'function') {
                loadDirectives();
            }
        }, 20000);

        // Periodically fetch browser screenshots when autonomy is running AND browser is active
        setInterval(() => {
            if (autonomyState.status === 'running' && browserState.running) {
                fetchBrowserScreenshot();
            }
        }, 10000);

        // ==================== BROWSER CONTROL PANEL ====================
        let browserStepLog = [];
        let _agentBrowserStepCount = 0;

        let browserState = {
            running: false,
            paused: false,
            tabs: [],
            currentUrl: '',
            actionNeeded: false,
            actionDescription: ''
        };
        let browserScreenshotInterval = null;
        let chatBrowserEnabled = false;  // Local toggle: allow browser use from Chat page

        async function launchBrowser() {
            try {
                // If running inside Electron, ask the host to launch Chrome first
                if (window.cerebroDesktop && window.cerebroDesktop.launchChromeCDP) {
                    const cdpResult = await window.cerebroDesktop.launchChromeCDP();
                    if (!cdpResult.success) {
                        showToast('Failed to start Chrome: ' + (cdpResult.error || 'Unknown error'), 'error');
                        return;
                    }
                }

                const resp = await fetch(API_URL + '/api/browser/launch', {
                    method: 'POST',
                    headers: {
                        'Authorization': 'Bearer ' + localStorage.getItem('cerebro_token'),
                        'Content-Type': 'application/json'
                    }
                });
                if (resp.ok) {
                    const data = await resp.json();
                    browserState.running = true;
                    browserState.paused = false;
                    updateBrowserPanel();
                    showToast('Chrome launched', 'success');
                } else {
                    const err = await resp.json().catch(() => ({}));
                    showToast('Failed to launch: ' + (err.detail || 'Unknown error'), 'error');
                }
            } catch(e) {
                showToast('Browser launch failed: ' + e.message, 'error');
            }
        }

        async function stopBrowser() {
            try {
                // 1. Tell backend to disconnect Playwright from Chrome
                const resp = await fetch(API_URL + '/api/browser/shutdown', {
                    method: 'POST',
                    headers: { 'Authorization': 'Bearer ' + localStorage.getItem('cerebro_token') }
                });

                // 2. Tell Electron to kill the Chrome CDP process on the host
                if (window.cerebroDesktop && window.cerebroDesktop.stopChromeCDP) {
                    try {
                        await window.cerebroDesktop.stopChromeCDP();
                    } catch (e) {
                        console.warn('[Browser] Electron stopChromeCDP failed:', e);
                    }
                }

                browserState.running = false;
                browserState.paused = false;
                browserState.tabs = [];
                browserState.currentUrl = '';
                browserState.actionNeeded = false;
                updateBrowserPanel();
                showToast('Chrome stopped', 'success');
            } catch(e) {
                showToast('Failed to stop browser: ' + e.message, 'error');
            }
        }

        async function pauseBrowser() {
            try {
                const resp = await fetch(API_URL + '/api/browser/pause', {
                    method: 'POST',
                    headers: { 'Authorization': 'Bearer ' + localStorage.getItem('cerebro_token') }
                });
                if (resp.ok) {
                    browserState.paused = true;
                    updateBrowserPanel();
                    showToast('You have control - Chrome is on your desktop', 'success');
                }
            } catch(e) {
                showToast('Failed to pause: ' + e.message, 'error');
            }
        }

        async function resumeBrowser() {
            try {
                const resp = await fetch(API_URL + '/api/browser/resume', {
                    method: 'POST',
                    headers: { 'Authorization': 'Bearer ' + localStorage.getItem('cerebro_token') }
                });
                if (resp.ok) {
                    browserState.paused = false;
                    browserState.actionNeeded = false;
                    updateBrowserPanel();
                    showToast('Cerebro has control again', 'success');
                }
            } catch(e) {
                showToast('Failed to resume: ' + e.message, 'error');
            }
        }

        async function signalUserDone() {
            try {
                const resp = await fetch(API_URL + '/api/browser/user-done', {
                    method: 'POST',
                    headers: { 'Authorization': 'Bearer ' + localStorage.getItem('cerebro_token') }
                });
                if (resp.ok) {
                    browserState.paused = false;
                    browserState.actionNeeded = false;
                    updateBrowserPanel();
                    hideUserActionBanner();
                    showToast('Handing back to Cerebro', 'success');
                }
            } catch(e) {
                showToast('Failed to signal done: ' + e.message, 'error');
            }
        }

        async function fetchBrowserStatus() {
            try {
                const resp = await fetch(API_URL + '/api/browser/status', {
                    headers: { 'Authorization': 'Bearer ' + localStorage.getItem('cerebro_token') }
                });
                if (resp.ok) {
                    const data = await resp.json();
                    browserState.running = data.running || false;
                    browserState.paused = data.paused || false;
                    browserState.currentUrl = data.current_url || '';
                    updateBrowserPanel();
                }
            } catch(e) { /* Status check is optional */ }
        }

        async function refreshBrowserScreenshot() {
            try {
                const resp = await fetch(API_URL + '/api/browser/screenshot', {
                    headers: { 'Authorization': 'Bearer ' + localStorage.getItem('cerebro_token') }
                });
                if (resp.ok) {
                    const data = await resp.json();
                    if (data.screenshot) {
                        var b64src = data.screenshot.startsWith('data:') ? data.screenshot : 'data:image/png;base64,' + data.screenshot;
                        hitlBrowserScreenshot = b64src;
                        const previewImg = document.getElementById('browser-preview-img');
                        if (previewImg) previewImg.src = b64src;
                        // Also update HITL popup screenshots
                        document.querySelectorAll('.hitl-browser-preview img').forEach(function(img) {
                            img.src = b64src;
                        });
                    }
                }
            } catch(e) { /* Screenshot optional */ }
        }

        async function fetchBrowserTabs() {
            try {
                const resp = await fetch(API_URL + '/api/browser/tabs', {
                    headers: { 'Authorization': 'Bearer ' + localStorage.getItem('cerebro_token') }
                });
                if (resp.ok) {
                    const data = await resp.json();
                    browserState.tabs = data.tabs || [];
                    updateBrowserTabs(browserState.tabs);
                }
            } catch(e) { /* Tab list optional */ }
        }

        // Chat page browser toggle  actually launch or stop the shared browser
        async function toggleChatBrowser() {
            var btn = document.getElementById('chat-browser-btn');
            if (btn) btn.disabled = true;

            try {
                if (browserState.running) {
                    // Browser is running  shut it down and disable chat browser
                    await stopBrowser();
                    chatBrowserEnabled = false;
                } else {
                    // Browser is not running  launch it and enable chat browser
                    await launchBrowser();
                    chatBrowserEnabled = true;
                }
            } catch (e) {
                console.error('[Chat Browser] Toggle error:', e);
            } finally {
                updateChatBrowserBtn();
                if (btn) btn.disabled = false;
            }
        }

        // Reflect real browser state on the chat browser orb
        function updateChatBrowserBtn() {
            var btn = document.getElementById('chat-browser-btn');
            var dot = document.getElementById('chat-browser-dot');
            if (!btn) return;

            if (browserState.running && !browserState.paused) {
                // Browser is running  orb active + green/purple glow
                btn.classList.add('browser-active');
                btn.title = 'Browser running  Click to stop';
                chatBrowserEnabled = true;
                if (dot) { dot.classList.add('running'); dot.classList.remove('paused'); }
            } else if (browserState.running && browserState.paused) {
                // Browser is paused  orb shows yellow
                btn.classList.add('browser-active');
                btn.title = 'Browser paused  Click to stop';
                chatBrowserEnabled = true;
                if (dot) { dot.classList.remove('running'); dot.classList.add('paused'); }
            } else {
                // Browser is off  orb inactive
                btn.classList.remove('browser-active');
                btn.title = 'Launch browser for chat';
                chatBrowserEnabled = false;
                if (dot) { dot.classList.remove('running', 'paused'); }
            }
        }

        // ==================== CHAT OFFLOAD ROUTING ====================
        let chatOffloadDeviceId = localStorage.getItem('cerebro_chat_offload_device') || '';
        let _chatOffloadDevices = []; // cached eligible devices

        async function loadChatOffloadDevices() {
            try {
                const resp = await fetch(API_URL + '/api/offload/eligible-devices', {
                    headers: { 'Authorization': 'Bearer ' + localStorage.getItem('cerebro_token') }
                });
                if (!resp.ok) throw new Error('HTTP ' + resp.status);
                const data = await resp.json();
                _chatOffloadDevices = data.devices || [];

                // Show the offload selector if there are eligible devices
                var selector = document.getElementById('chat-offload-selector');
                if (selector) {
                    selector.style.display = _chatOffloadDevices.length > 0 ? '' : 'none';
                }

                // Build dropdown options
                var dropdown = document.getElementById('chat-offload-dropdown');
                if (dropdown) {
                    var html = '<button class="offload-option' + (!chatOffloadDeviceId ? ' selected' : '') + '" data-device-id="" onclick="selectChatOffloadDevice(\'\')">'
                        + '<span class="offload-opt-icon">&#x1F4BB;</span>'
                        + '<div class="offload-opt-info"><div class="offload-opt-name">Local</div><div class="offload-opt-detail">Process on this machine</div></div>'
                        + '<svg class="offload-check" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><polyline points="20 6 9 17 4 12"/></svg>'
                        + '</button>';

                    _chatOffloadDevices.forEach(function(dev) {
                        var isSelected = chatOffloadDeviceId === dev.id;
                        var typeIcon = dev.device_type === 'gpu_server' ? '&#x1F5A5;' : dev.device_type === 'sbc' ? '&#x1F4DF;' : '&#x1F5A5;';
                        html += '<button class="offload-option' + (isSelected ? ' selected' : '') + '" data-device-id="' + dev.id + '" onclick="selectChatOffloadDevice(\'' + dev.id + '\')">'
                            + '<span class="offload-opt-icon">' + typeIcon + '</span>'
                            + '<div class="offload-opt-info"><div class="offload-opt-name">' + (dev.friendly_name || dev.device_name || dev.id) + '</div>'
                            + '<div class="offload-opt-detail">' + (dev.device_type || 'device') + (dev.ram_gb ? ' &middot; ' + dev.ram_gb + 'GB RAM' : '') + '</div></div>'
                            + '<svg class="offload-check" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><polyline points="20 6 9 17 4 12"/></svg>'
                            + '</button>';
                    });

                    dropdown.innerHTML = html;
                }

                // Validate current selection still exists
                if (chatOffloadDeviceId && !_chatOffloadDevices.find(d => d.id === chatOffloadDeviceId)) {
                    chatOffloadDeviceId = '';
                    localStorage.removeItem('cerebro_chat_offload_device');
                }

                updateChatOffloadBtn();
            } catch (e) {
                console.warn('[Chat Offload] Failed to load devices:', e.message);
                var selector = document.getElementById('chat-offload-selector');
                if (selector) selector.style.display = 'none';
            }
        }

        function selectChatOffloadDevice(deviceId) {
            chatOffloadDeviceId = deviceId;
            if (deviceId) {
                localStorage.setItem('cerebro_chat_offload_device', deviceId);
            } else {
                localStorage.removeItem('cerebro_chat_offload_device');
            }
            updateChatOffloadBtn();
            closeChatOffloadDropdown();

            var deviceName = 'Local';
            if (deviceId) {
                var dev = _chatOffloadDevices.find(d => d.id === deviceId);
                deviceName = dev ? (dev.friendly_name || dev.device_name || deviceId) : deviceId;
            }
            showToast(deviceId ? 'Chat routed to ' + deviceName : 'Chat set to local processing', deviceId ? 'success' : 'info');
        }

        function updateChatOffloadBtn() {
            var btn = document.getElementById('chat-offload-btn');
            var label = document.getElementById('chat-offload-label');
            if (!btn || !label) return;

            if (chatOffloadDeviceId) {
                var dev = _chatOffloadDevices.find(d => d.id === chatOffloadDeviceId);
                label.textContent = dev ? (dev.friendly_name || dev.device_name || 'Remote') : 'Remote';
                btn.classList.add('offload-active');
            } else {
                label.textContent = 'Local';
                btn.classList.remove('offload-active');
            }

            // Update dropdown selection
            document.querySelectorAll('#chat-offload-dropdown .offload-option').forEach(function(opt) {
                opt.classList.toggle('selected', (opt.dataset.deviceId || '') === chatOffloadDeviceId);
            });
        }

        function toggleChatOffloadDropdown() {
            var dropdown = document.getElementById('chat-offload-dropdown');
            if (dropdown) {
                var isOpen = dropdown.classList.contains('open');
                dropdown.classList.toggle('open');
                // Refresh devices when opening
                if (!isOpen) loadChatOffloadDevices();
            }
        }

        function closeChatOffloadDropdown() {
            var dropdown = document.getElementById('chat-offload-dropdown');
            if (dropdown) dropdown.classList.remove('open');
        }

        // Check real browser status and sync the chat orb.
        // If Chrome CDP is available but backend disconnected (e.g. after restart), auto-reconnect.
        async function checkBrowserStatus() {
            try {
                var resp = await fetch(API_URL + '/api/browser/status', {
                    headers: { 'Authorization': 'Bearer ' + localStorage.getItem('cerebro_token') }
                });
                if (resp.ok) {
                    var data = await resp.json();
                    browserState.running = !!data.running;
                    browserState.paused = !!data.paused;

                    // If backend is disconnected but Chrome CDP is available, auto-reconnect
                    if (!browserState.running && data.cdp_available) {
                        console.log('[Browser] CDP available but disconnected  auto-reconnecting...');
                        try {
                            if (window.cerebroDesktop && window.cerebroDesktop.launchChromeCDP) {
                                await window.cerebroDesktop.launchChromeCDP();
                            }
                            var launchResp = await fetch(API_URL + '/api/browser/launch', {
                                method: 'POST',
                                headers: { 'Authorization': 'Bearer ' + localStorage.getItem('cerebro_token'), 'Content-Type': 'application/json' }
                            });
                            if (launchResp.ok) {
                                var launchData = await launchResp.json();
                                browserState.running = !!launchData.running;
                                browserState.paused = !!launchData.paused;
                                console.log('[Browser] Auto-reconnected successfully');
                            }
                        } catch (e) {
                            console.warn('[Browser] Auto-reconnect failed:', e.message);
                        }
                    }

                    updateChatBrowserBtn();
                    updateBrowserPanel();
                }
            } catch (e) {
                console.warn('[Browser] Status check failed:', e.message);
            }
        }

        function updateBrowserPanel() {
            var dot = document.getElementById('browser-status-dot');
            var statusText = document.getElementById('browser-status-text');
            var launchBtn = document.getElementById('browser-launch-btn');
            var launchLabel = document.getElementById('browser-launch-label');
            var controlToggle = document.getElementById('browser-control-toggle');
            var controlLabel = document.getElementById('browser-control-label');
            var urlInput = document.getElementById('browser-url-input');
            var stoppedView = document.getElementById('browser-tab-stopped');
            var runningView = document.getElementById('browser-tab-running');

            // Status dot
            if (dot) {
                dot.classList.remove('running', 'paused', 'stopped');
                if (browserState.running && !browserState.paused) {
                    dot.classList.add('running');
                } else if (browserState.paused) {
                    dot.classList.add('paused');
                } else {
                    dot.classList.add('stopped');
                }
            }

            // Status text
            if (statusText) {
                statusText.classList.remove('running', 'paused');
                if (browserState.running && !browserState.paused) {
                    statusText.textContent = 'Running';
                    statusText.classList.add('running');
                } else if (browserState.paused) {
                    statusText.textContent = "You're in control";
                    statusText.classList.add('paused');
                } else {
                    statusText.textContent = 'Stopped';
                }
            }

            // Launch/Stop button (compact)
            if (launchBtn && launchLabel) {
                if (browserState.running) {
                    launchBtn.classList.add('stop');
                    launchLabel.textContent = 'Stop';
                } else {
                    launchBtn.classList.remove('stop');
                    launchLabel.textContent = 'Launch';
                }
            }

            // Toggle stopped/running views
            if (stoppedView && runningView) {
                if (browserState.running) {
                    stoppedView.style.display = 'none';
                    runningView.style.display = 'flex';
                } else {
                    stoppedView.style.display = 'flex';
                    runningView.style.display = 'none';
                }
            }

            // Control toggle
            if (controlToggle && controlLabel) {
                if (browserState.paused) {
                    controlToggle.classList.add('give-back');
                    controlLabel.textContent = 'Give Back to Cerebro';
                } else {
                    controlToggle.classList.remove('give-back');
                    controlLabel.textContent = 'Take Control';
                }
            }

            // URL input  only update if not currently focused
            if (urlInput && document.activeElement !== urlInput) {
                urlInput.value = browserState.currentUrl || '';
            }

            // Tab badge sync
            updateBrowserTabBadge();

            // Start/stop screenshot interval (4s)
            if (browserState.running && !browserScreenshotInterval) {
                browserScreenshotInterval = setInterval(function() {
                    refreshBrowserScreenshot();
                    fetchBrowserTabs();
                }, 4000);
                refreshBrowserScreenshot();
                fetchBrowserTabs();
            } else if (!browserState.running && browserScreenshotInterval) {
                clearInterval(browserScreenshotInterval);
                browserScreenshotInterval = null;
            }
        }

        function updateBrowserTabs(tabs) {
            var container = document.getElementById('browser-tab-list');
            if (!container) return;

            // Clear existing tabs
            while (container.firstChild) {
                container.removeChild(container.firstChild);
            }

            if (!tabs || tabs.length === 0) return;

            tabs.forEach(function(tab) {
                var item = document.createElement('div');
                item.className = 'browser-tab-item';
                if (tab.active) item.classList.add('active-tab');

                if (tab.favicon) {
                    var favicon = document.createElement('img');
                    favicon.className = 'browser-tab-favicon';
                    favicon.src = tab.favicon;
                    favicon.alt = '';
                    favicon.onerror = function() { this.style.display = 'none'; };
                    item.appendChild(favicon);
                }

                var title = document.createElement('span');
                title.className = 'browser-tab-title';
                title.textContent = tab.title || tab.url || 'Untitled';
                item.appendChild(title);

                container.appendChild(item);
            });
        }

        function showUserActionBanner(description) {
            browserState.actionNeeded = true;
            browserState.actionDescription = description || 'Please complete an action in the browser.';
            var banner = document.getElementById('browser-action-banner');
            var desc = document.getElementById('browser-action-desc');
            if (banner) banner.classList.add('visible');
            if (desc) desc.textContent = browserState.actionDescription;

            // Play notification sound
            try {
                var audio = new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2teleP//');
                audio.volume = 0.3;
                audio.play().catch(function() {});
            } catch(e) {}
        }

        function hideUserActionBanner() {
            browserState.actionNeeded = false;
            var banner = document.getElementById('browser-action-banner');
            if (banner) banner.classList.remove('visible');
        }

        function toggleBrowserLaunch() {
            if (browserState.running) {
                stopBrowser();
            } else {
                launchBrowser();
            }
        }

        function toggleBrowserControl() {
            if (browserState.paused) {
                resumeBrowser();
            } else {
                pauseBrowser();
            }
        }

        function renderOrbBrowser() {
            var stopped = document.getElementById('browser-tab-stopped');
            var running = document.getElementById('browser-tab-running');
            if (!stopped || !running) return;
            if (browserState.running) {
                stopped.style.display = 'none';
                running.style.display = 'flex';
                renderBrowserStepLog();
                refreshBrowserScreenshot();
            } else {
                stopped.style.display = 'flex';
                running.style.display = 'none';
            }
        }

        function renderBrowserStepLog() {
            var container = document.getElementById('browser-step-log');
            var header = document.getElementById('browser-step-log-header');
            var countEl = document.getElementById('browser-step-count');
            if (!container) return;

            if (browserStepLog.length === 0) {
                if (header) header.style.display = 'none';
                while (container.firstChild) container.removeChild(container.firstChild);
                return;
            }
            if (header) header.style.display = 'flex';
            if (countEl) countEl.textContent = browserStepLog.length;

            while (container.firstChild) container.removeChild(container.firstChild);
            browserStepLog.forEach(function(entry) {
                var el = document.createElement('div');
                el.className = 'browser-step-entry';

                var numEl = document.createElement('span');
                numEl.className = 'step-num';
                numEl.textContent = '#' + entry.step;
                el.appendChild(numEl);

                var bodyEl = document.createElement('div');
                bodyEl.className = 'step-body';
                var actionEl = document.createElement('div');
                actionEl.className = 'step-action';
                actionEl.textContent = entry.action || 'Action';
                bodyEl.appendChild(actionEl);
                if (entry.reasoning) {
                    var reasonEl = document.createElement('div');
                    reasonEl.className = 'step-reasoning';
                    reasonEl.textContent = entry.reasoning.substring(0, 120);
                    bodyEl.appendChild(reasonEl);
                }
                el.appendChild(bodyEl);

                if (entry.screenshot) {
                    var thumb = document.createElement('img');
                    thumb.className = 'step-thumb';
                    thumb.src = entry.screenshot.startsWith('data:') ? entry.screenshot : 'data:image/png;base64,' + entry.screenshot;
                    thumb.alt = '';
                    el.appendChild(thumb);
                }

                container.appendChild(el);
            });
            container.scrollTop = container.scrollHeight;
        }

        async function navigateBrowserUrl(url) {
            if (!url) return;
            if (!/^https?:\/\//i.test(url)) url = 'https://' + url;
            try {
                await fetch(API_URL + '/api/browser/navigate', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': 'Bearer ' + localStorage.getItem('cerebro_token')
                    },
                    body: JSON.stringify({ url: url })
                });
            } catch(e) { console.error('[Browser] Navigate error:', e); }
        }

        function updateBrowserTabBadge() {
            var badge = document.getElementById('orb-browser-badge');
            var indicator = document.getElementById('orb-browser-status-indicator');
            if (!badge || !indicator) return;
            indicator.classList.remove('running', 'paused', 'stopped');
            if (browserState.running) {
                badge.style.display = 'inline-flex';
                indicator.classList.add(browserState.paused ? 'paused' : 'running');
            } else {
                badge.style.display = 'none';
            }
        }

        function setupBrowserSocketListeners() {
            if (!socket) {
                setTimeout(setupBrowserSocketListeners, 1000);
                return;
            }

            socket.on('browser_launched', function(data) {
                console.log('[Browser] Launched:', data);
                browserState.running = true;
                browserState.paused = false;
                updateBrowserPanel();
                updateChatBrowserBtn();
            });

            socket.on('browser_shutdown', function(data) {
                console.log('[Browser] Shutdown:', data);
                browserState.running = false;
                browserState.paused = false;
                browserState.tabs = [];
                browserState.currentUrl = '';
                browserState.actionNeeded = false;
                browserStepLog = [];
                _agentBrowserStepCount = 0;
                hideUserActionBanner();
                updateBrowserPanel();
                updateChatBrowserBtn();
            });

            socket.on('browser_paused', function(data) {
                console.log('[Browser] Paused (user control):', data);
                browserState.paused = true;
                updateBrowserPanel();
                updateChatBrowserBtn();
            });

            socket.on('browser_resumed', function(data) {
                console.log('[Browser] Resumed (Cerebro control):', data);
                browserState.paused = false;
                browserState.actionNeeded = false;
                hideUserActionBanner();
                updateBrowserPanel();
                updateChatBrowserBtn();
            });

            socket.on('browser_navigated', function(data) {
                console.log('[Browser] Navigated:', data);
                if (data.url) {
                    browserState.currentUrl = data.url;
                    var urlInput = document.getElementById('browser-url-input');
                    if (urlInput && document.activeElement !== urlInput) {
                        urlInput.value = data.url;
                    }
                }
            });

            socket.on('browser_tab_opened', function(data) {
                console.log('[Browser] Tab opened:', data);
                fetchBrowserTabs();
            });

            socket.on('browser_tab_closed', function(data) {
                console.log('[Browser] Tab closed:', data);
                fetchBrowserTabs();
            });

            socket.on('browser_user_action_needed', function(data) {
                console.log('[Browser] User action needed:', data);
                browserState.paused = true;
                updateBrowserPanel();
                showUserActionBanner(data.description || data.message || 'Cerebro needs you to take action in Chrome.');
            });

            console.log('[Browser] Socket listeners registered');
        }

        setTimeout(setupBrowserSocketListeners, 700);

        // Fetch initial browser status on load
        setTimeout(fetchBrowserStatus, 1500);

        // Poll browser status every 10s as fallback (in case socket events are missed)
        setInterval(fetchBrowserStatus, 10000);

        // ==================== SKILLS SYSTEM ====================
        let skillsCache = [];
        let currentTab = 'focus'; // 'focus', 'completed', or 'skills'

        // Switch between Focus, Completed, and Skills tabs
        function switchToTab(tabName) {
            currentTab = tabName;

            // Update tab active states (both old sidebar and slide panel)
            ['tab-focus', 'tab-completed', 'tab-skills', 'slide-tab-focus', 'slide-tab-completed', 'slide-tab-skills'].forEach(id => {
                document.getElementById(id)?.classList.remove('active');
            });
            document.getElementById(`tab-${tabName}`)?.classList.add('active');
            document.getElementById(`slide-tab-${tabName}`)?.classList.add('active');

            // Show/hide content (old sidebar containers)
            document.getElementById('focus-container')?.classList.add('hidden');
            document.getElementById('completed-container')?.classList.add('hidden');
            document.getElementById('skills-list')?.classList.add('hidden');

            // Show/hide content (slide panel containers)
            document.getElementById('slide-focus-container')?.classList.add('hidden');
            document.getElementById('slide-completed-container')?.classList.add('hidden');
            document.getElementById('slide-skills-list')?.classList.add('hidden');

            if (tabName === 'focus') {
                document.getElementById('focus-container')?.classList.remove('hidden');
                document.getElementById('slide-focus-container')?.classList.remove('hidden');
            } else if (tabName === 'completed') {
                document.getElementById('completed-container')?.classList.remove('hidden');
                document.getElementById('slide-completed-container')?.classList.remove('hidden');
            } else if (tabName === 'skills') {
                document.getElementById('skills-list')?.classList.remove('hidden');
                document.getElementById('slide-skills-list')?.classList.remove('hidden');
                loadSkills(); // Reload skills when viewing
            }

            // Sync content to slide panel
            if (currentSlidePanel === 'skills') {
                syncMindDetailsToSlidePanel();
            }
        }

        // Legacy functions for backwards compatibility
        function switchToCompletedView() { switchToTab('completed'); }
        function switchToSkillsView() { switchToTab('skills'); }

        async function loadSkills(forceReload = true) {
            try {
                // First reload skills from disk to catch newly created ones
                if (forceReload) {
                    console.log('[Skills] Reloading from disk...');
                    const reloadResp = await fetch(`${API_URL}/api/skills/reload`, {
                        method: 'POST',
                        headers: { 'Authorization': `Bearer ${localStorage.getItem('cerebro_token')}` }
                    });
                    if (!reloadResp.ok) {
                        const errText = await reloadResp.text();
                        console.error('[Skills] Reload failed:', reloadResp.status, errText);
                    } else {
                        const reloadData = await reloadResp.json();
                        console.log('[Skills] Reloaded:', reloadData);
                    }
                }

                // Then fetch the skills list
                const response = await fetch(`${API_URL}/api/skills`, {
                    headers: { 'Authorization': `Bearer ${localStorage.getItem('cerebro_token')}` }
                });
                const data = await response.json();
                skillsCache = data.skills || [];
                window.skillsList = skillsCache;
                renderSkillsList(skillsCache);
                const countEl = document.getElementById('skill-count');
                if (countEl) countEl.textContent = data.count || 0;
                if (typeof renderOrbSkills === 'function') renderOrbSkills();
                console.log('[Skills] Loaded', skillsCache.length, 'skills');
            } catch (e) {
                console.error('[Skills] Failed to load:', e);
            }
        }

        function renderSkillsList(skills) {
            const container = document.getElementById('skills-list');
            if (!container) return;

            if (!skills || skills.length === 0) {
                container.innerHTML = `
                    <div class="skills-empty">
                        <div style="font-size: 1.5rem; opacity: 0.4;"></div>
                        <div>No learned skills yet</div>
                        <div style="font-size: 0.75rem; color: var(--text-muted);">
                            Skills are automatically created when Cerebro explores websites
                        </div>
                    </div>`;
                return;
            }

            container.innerHTML = skills.map(skill => {
                const statusClass = skill.status === 'verified' ? 'verified' :
                                   skill.status === 'failed' ? 'failed' : 'unverified';
                const statusLabel = skill.status === 'draft' ? 'new' : skill.status;
                // Clean up auto-generated names
                let displayName = skill.name.replace(/^auto_/, '').replace(/_/g, ' ');
                if (displayName.length > 40) displayName = displayName.substring(0, 40) + '...';
                // Truncate description
                let desc = skill.description || '';
                if (desc.length > 80) desc = desc.substring(0, 80) + '...';
                return `
                    <div class="skill-card" data-skill-id="${skill.id}">
                        <div class="skill-header">
                            <span class="skill-name">${displayName}</span>
                            <span class="skill-status ${statusClass}">${statusLabel}</span>
                        </div>
                        <div class="skill-description">${desc}</div>
                        <div class="skill-meta">
                            <span>${skill.steps?.length || 0} steps</span>
                            <span></span>
                            <span>Used ${skill.success_count || 0}x</span>
                        </div>
                        <div class="skill-actions">
                            <button onclick="executeSkill('${skill.id}')" class="skill-btn primary"> Run</button>
                            <button onclick="verifySkill('${skill.id}')" class="skill-btn secondary"> Verify</button>
                            <button onclick="deleteSkill('${skill.id}')" class="skill-btn danger"></button>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function addSkillToPanel(skill) {
            const container = document.getElementById('skills-list');
            if (!container) return;

            // Remove empty state if present
            const emptyState = container.querySelector('.skills-empty');
            if (emptyState) emptyState.remove();

            // Check if skill already exists
            const existing = container.querySelector(`[data-skill-id="${skill.skill_id || skill.id}"]`);
            if (existing) return;

            const skillId = skill.skill_id || skill.id;
            const card = document.createElement('div');
            card.className = 'skill-card skill-new';
            card.dataset.skillId = skillId;
            card.innerHTML = `
                <div class="skill-header">
                    <span class="skill-name">${skill.name}</span>
                    <span class="skill-status unverified">new</span>
                </div>
                <div class="skill-description">${skill.description || ''}</div>
                <div class="skill-actions">
                    <button onclick="executeSkill('${skillId}')" class="skill-btn primary"> Run</button>
                    <button onclick="verifySkill('${skillId}')" class="skill-btn secondary"> Verify</button>
                </div>
            `;
            container.prepend(card);

            // Update count
            const count = document.getElementById('skill-count');
            if (count) count.textContent = parseInt(count.textContent || '0') + 1;

            // Animate
            setTimeout(() => card.classList.remove('skill-new'), 100);
        }

        async function executeSkill(skillId) {
            console.log('[Skill] Executing:', skillId);
            showToast('Executing skill...', 'info');
            try {
                const response = await fetch(`${API_URL}/api/skills/${skillId}/execute`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${localStorage.getItem('cerebro_token')}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({})
                });
                console.log('[Skill] Response status:', response.status);
                const result = await response.json();
                console.log('[Skill] Result:', result);
                if (result.success) {
                    showToast(' Skill executed successfully', 'success');
                    // Show output in a modal
                    showSkillOutput(skillId, result);
                } else {
                    showToast(` Skill failed: ${result.error || 'Unknown error'}`, 'error');
                }
            } catch (e) {
                console.error('[Skill] Error:', e);
                showToast('Failed to execute skill', 'error');
            }
        }

        function showSkillOutput(skillId, result) {
            // Convert output to markdown format (like agent output)
            const output = result.output;
            let markdownContent = '';

            // Build structured markdown
            markdownContent += `## Skill Execution Complete\n\n`;
            markdownContent += `**Status:** ${result.steps_completed}/${result.total_steps} steps completed in ${(result.duration_ms / 1000).toFixed(1)}s\n\n`;

            if (Array.isArray(output)) {
                // Numbered list (like headlines)
                markdownContent += `### Results (${output.length} items)\n\n`;
                output.forEach((item, i) => {
                    // Handle items that might have titles/urls or just be strings
                    if (typeof item === 'object' && item !== null) {
                        if (item.title && item.url) {
                            markdownContent += `${i + 1}. [${item.title}](${item.url})\n`;
                        } else if (item.title) {
                            markdownContent += `${i + 1}. **${item.title}**\n`;
                        } else {
                            markdownContent += `${i + 1}. ${JSON.stringify(item)}\n`;
                        }
                    } else {
                        markdownContent += `${i + 1}. ${String(item)}\n`;
                    }
                });
            } else if (typeof output === 'string') {
                markdownContent += `### Output\n\n${output}\n`;
            } else if (output && typeof output === 'object') {
                // Object output - format as key-value pairs
                markdownContent += `### Data\n\n`;
                for (const [key, value] of Object.entries(output)) {
                    if (Array.isArray(value)) {
                        markdownContent += `**${key}:**\n`;
                        value.forEach((v, i) => {
                            markdownContent += `  ${i + 1}. ${String(v)}\n`;
                        });
                    } else {
                        markdownContent += `- **${key}:** ${String(value)}\n`;
                    }
                }
            } else {
                markdownContent += `*No output data captured*\n`;
            }

            // Render markdown using marked.js (sanitized)
            let renderedHtml = safeAgentOutput(markdownContent);

            // Create modal with agent-output-rendered styling
            const modal = document.createElement('div');
            modal.className = 'skill-output-modal';
            modal.innerHTML = `
                <div class="skill-output-backdrop" onclick="this.parentElement.remove()"></div>
                <div class="skill-output-content">
                    <div class="skill-output-header">
                        <div class="skill-output-title">
                            <span class="skill-output-icon"></span>
                            <span>OUTPUT</span>
                        </div>
                        <button class="skill-output-close" onclick="this.closest('.skill-output-modal').remove()"></button>
                    </div>
                    <div class="skill-output-body">
                        <div class="agent-output-rendered">
                            ${renderedHtml}
                        </div>
                    </div>
                    <div class="skill-output-actions">
                        <button onclick="copySkillOutput()" class="skill-output-btn"> Copy</button>
                        <button onclick="this.closest('.skill-output-modal').remove()" class="skill-output-btn primary">Done</button>
                    </div>
                </div>
            `;

            // Store output for copy (store markdown for better copy)
            window._lastSkillOutput = output;
            window._lastSkillMarkdown = markdownContent;

            document.body.appendChild(modal);
            setTimeout(() => modal.classList.add('visible'), 10);
        }

        function copySkillOutput() {
            // Use the markdown format for better copying
            let text = window._lastSkillMarkdown || '';
            if (!text && window._lastSkillOutput) {
                const output = window._lastSkillOutput;
                if (Array.isArray(output)) {
                    text = output.map((item, i) => `${i + 1}. ${typeof item === 'object' ? (item.title || JSON.stringify(item)) : item}`).join('\n');
                } else if (typeof output === 'string') {
                    text = output;
                } else {
                    text = JSON.stringify(output, null, 2);
                }
            }
            navigator.clipboard.writeText(text);
            showToast('Copied to clipboard', 'success');
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        async function verifySkill(skillId) {
            showToast('Verifying skill...', 'info');
            try {
                const response = await fetch(`${API_URL}/api/skills/${skillId}/verify`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${localStorage.getItem('cerebro_token')}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ dry_run: true, auto_heal: true })
                });
                const result = await response.json();
                showToast(
                    result.success ? ' Skill verified!' : ' Skill verification failed',
                    result.success ? 'success' : 'warning'
                );
                // Reload skills to show updated status
                loadSkills();
            } catch (e) {
                showToast('Failed to verify skill', 'error');
            }
        }

        async function deleteSkill(skillId) {
            if (!await cerebroConfirm('Delete this skill? This cannot be undone.', { title: 'Delete Skill', danger: true, confirmText: 'Delete' })) return;
            try {
                await fetch(`${API_URL}/api/skills/${skillId}`, {
                    method: 'DELETE',
                    headers: { 'Authorization': `Bearer ${localStorage.getItem('cerebro_token')}` }
                });
                loadSkills();
                showToast('Skill deleted', 'info');
            } catch (e) {
                showToast('Failed to delete skill', 'error');
            }
        }

        function toggleSkillsPanel() {
            const section = document.getElementById('skills-section');
            if (section) section.classList.toggle('collapsed');
        }

        // Load skills on page load
        setTimeout(loadSkills, 1000);

        // ==================== DEBUG FEED SYSTEM ====================
        let debugEvents = [];
        const MAX_DEBUG_EVENTS = 100;

        function toggleDebugFeed() {
            const section = document.getElementById('debug-feed-section');
            section.classList.toggle('collapsed');
        }

        function clearDebugFeed() {
            debugEvents = [];
            const content = document.getElementById('debug-feed-content');
            content.innerHTML = `
                <div class="debug-feed-empty">
                    <div style="font-size: 1.2rem; opacity: 0.4;"></div>
                    <div>Debug feed cleared</div>
                    <div style="font-size: 0.7rem; color: var(--text-muted);">New events will appear here</div>
                </div>`;
            document.getElementById('debug-feed-count').textContent = '0 events';
        }

        function addDebugEvent(event) {
            // Add to array
            debugEvents.unshift(event);
            if (debugEvents.length > MAX_DEBUG_EVENTS) {
                debugEvents.pop();
            }

            // Update count
            const countEl = document.getElementById('debug-feed-count');
            if (countEl) countEl.textContent = `${debugEvents.length} events`;

            // Render event
            const content = document.getElementById('debug-feed-content');
            if (!content) return;

            // Remove empty state if present
            const emptyState = content.querySelector('.debug-feed-empty');
            if (emptyState) {
                emptyState.remove();
            }

            // Create event element
            const eventEl = document.createElement('div');
            eventEl.className = `debug-event ${event.type}`;
            eventEl.innerHTML = formatDebugEvent(event);

            // Prepend to content
            content.insertBefore(eventEl, content.firstChild);

            // Limit DOM elements
            while (content.children.length > MAX_DEBUG_EVENTS) {
                content.removeChild(content.lastChild);
            }
        }

        function formatDebugEvent(event) {
            const time = new Date(event.timestamp).toLocaleTimeString();
            const phase = event.phase ? `<span class="debug-event-phase">${event.phase}</span>` : '';

            let contentHtml = '';

            switch (event.type) {
                case 'llm_prompt':
                    contentHtml = `
                        ${phase}<span class="model"> ${event.model || getModelDisplayName(getSelectedModel())}</span>
                        <pre>${escapeHtml(event.prompt || '')}</pre>
                        <div style="font-size: 0.6rem; color: var(--text-muted); margin-top: 4px;">
                            Full prompt: ${event.full_prompt_length || 0} chars
                        </div>`;
                    break;

                case 'llm_response':
                    contentHtml = `
                        ${phase}<span class="model"> ${event.model || getModelDisplayName(getSelectedModel())}</span>
                        <span class="tokens">${event.tokens || 0} tokens</span>
                        <span class="duration">${event.tokens_per_sec || 0} tok/s  ${event.duration_ms || 0}ms</span>
                        <pre>${escapeHtml(event.content || '')}</pre>
                        ${event.thinking ? `<div class="thinking"> ${escapeHtml(event.thinking)}</div>` : ''}`;
                    break;

                case 'api_call':
                    contentHtml = `
                        ${phase}<span style="color: var(--blue);"> ${event.method || 'GET'}</span>
                        <span style="color: var(--text-primary);">${event.endpoint || ''}</span>`;
                    break;

                case 'api_response':
                    contentHtml = `
                        ${phase}<span style="color: var(--green);"> ${event.status || 200}</span>
                        <span>${event.endpoint || ''}</span>
                        ${event.count !== undefined ? `<span class="tokens">${event.count} items</span>` : ''}`;
                    break;

                case 'api_error':
                    contentHtml = `
                        <span style="color: var(--red);"> ${event.endpoint || ''}</span>
                        <pre style="color: var(--red);">${escapeHtml(event.error || 'Unknown error')}</pre>`;
                    break;

                case 'action_execute':
                    contentHtml = `
                        ${phase}<span style="color: var(--yellow);"> EXECUTING:</span>
                        <span style="color: var(--text-primary);">${event.action_type || ''}</span>
                        ${event.target ? `<span> ${event.target}</span>` : ''}
                        <span class="debug-event-phase" style="background: rgba(234, 179, 8, 0.2); color: var(--yellow);">${event.risk_level || 'LOW'}</span>`;
                    break;

                case 'action_result':
                    const success = event.success ? '' : '';
                    const color = event.success ? 'var(--green)' : 'var(--red)';
                    contentHtml = `
                        ${phase}<span style="color: ${color};">${success} ${event.action_type || ''}</span>
                        ${event.output ? `<pre>${escapeHtml(event.output)}</pre>` : ''}`;
                    break;

                default:
                    contentHtml = `<pre>${JSON.stringify(event, null, 2)}</pre>`;
            }

            return `
                <div class="debug-event-header">
                    <span class="debug-event-type">${event.type.replace('_', ' ')}</span>
                    <span class="debug-event-time">${time}</span>
                </div>
                <div class="debug-event-content">${contentHtml}</div>`;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // ==================== GOALS SYSTEM ====================
        let goals = [];
        let pendingChatMessage = null;

        async function loadGoals() {
            try {
                const response = await fetch(`${API_URL}/api/goals`, {
                    headers: { 'Authorization': `Bearer ${localStorage.getItem('cerebro_token')}` }
                });
                const data = await response.json();

                if (data.success && data.goals) {
                    goals = data.goals;
                    renderGoals();
                }
            } catch (e) {
                console.error('Failed to load goals:', e);
            }
        }

        function renderGoals() {
            const activeContainer = document.getElementById('active-goals');
            const blockedContainer = document.getElementById('blocked-goals');
            const completedContainer = document.getElementById('completed-goals');

            // Filter goals by status
            const active = goals.filter(g => g.status === 'active' && !g.known_blockers?.length);
            const blocked = goals.filter(g => g.status === 'active' && g.known_blockers?.length > 0);
            const completed = goals.filter(g => g.status === 'completed');

            // Render active goals
            if (active.length > 0) {
                activeContainer.innerHTML = active.map(createGoalCard).join('');
            } else {
                activeContainer.innerHTML = `
                    <div class="goals-empty">
                        <div class="goals-empty-icon"></div>
                        <div>No active goals</div>
                        <div style="font-size: 0.8rem; margin-top: 4px;">Create one to get started</div>
                    </div>`;
            }

            // Render blocked goals
            if (blocked.length > 0) {
                blockedContainer.innerHTML = blocked.map(g => createGoalCard(g, 'blocked')).join('');
            } else {
                blockedContainer.innerHTML = `
                    <div class="goals-empty" style="opacity: 0.6;">
                        <div>No blocked goals</div>
                    </div>`;
            }

            // Render completed goals
            if (completed.length > 0) {
                completedContainer.innerHTML = completed.slice(0, 5).map(g => createGoalCard(g, 'completed')).join('');
            } else {
                completedContainer.innerHTML = `
                    <div class="goals-empty" style="opacity: 0.6;">
                        <div>No completed goals</div>
                    </div>`;
            }
        }

        function createGoalCard(goal, status = 'active') {
            const priorityClass = goal.priority || 'medium';
            const blockers = goal.known_blockers || [];
            const subgoals = goal.subgoals || [];

            return `
                <div class="goal-card ${status}" data-id="${goal.goal_id}" onclick="showGoalDetail('${goal.goal_id}')">
                    <div class="goal-header">
                        <span class="goal-priority ${priorityClass}">${priorityClass}</span>
                        ${goal.progress_history ? `<span class="goal-progress">${goal.progress_history.length} updates</span>` : ''}
                    </div>
                    <h4 class="goal-title">${escapeHtml(goal.description.slice(0, 100))}${goal.description.length > 100 ? '...' : ''}</h4>
                    ${subgoals.length > 0 ? `
                        <div class="goal-subtasks">
                            ${subgoals.slice(0, 3).map((s, i) => `
                                <div class="subtask">
                                    <span class="subtask-check"></span>
                                    ${escapeHtml(s.slice(0, 50))}
                                </div>
                            `).join('')}
                            ${subgoals.length > 3 ? `<div class="subtask" style="opacity: 0.6;">+${subgoals.length - 3} more</div>` : ''}
                        </div>
                    ` : ''}
                    ${blockers.length > 0 ? `
                        <div class="goal-blockers">
                            ${blockers.slice(0, 2).map(b => `
                                <span class="blocker-tag"> ${escapeHtml(b.slice(0, 30))}${b.length > 30 ? '...' : ''}</span>
                            `).join('')}
                        </div>
                    ` : ''}
                    <div class="goal-actions" onclick="event.stopPropagation()">
                        <button onclick="pursueGoal('${goal.goal_id}')"> Pursue</button>
                        ${status !== 'completed' ? `<button onclick="completeGoal('${goal.goal_id}')"> Complete</button>` : ''}
                    </div>
                </div>
            `;
        }

        function openGoalModal() {
            const modalHtml = `
                <div class="modal-overlay active" id="goal-modal" onclick="if(event.target === this) closeGoalModal()">
                    <div class="modal prediction-modal">
                        <div class="modal-header">
                            <span class="modal-icon"></span>
                            <h3>Create New Goal</h3>
                        </div>
                        <div class="modal-body">
                            <div class="goal-form-group">
                                <label class="goal-form-label">What do you want to accomplish?</label>
                                <textarea class="goal-form-input" id="goal-description" placeholder="e.g., Set up automated backup system for NAS" style="height: 80px;"></textarea>
                            </div>
                            <div class="goal-form-group">
                                <label class="goal-form-label">Priority</label>
                                <select class="goal-form-input" id="goal-priority">
                                    <option value="low">Low</option>
                                    <option value="medium" selected>Medium</option>
                                    <option value="high">High</option>
                                </select>
                            </div>
                        </div>
                        <div class="modal-actions">
                            <button class="btn-secondary" onclick="closeGoalModal()">Cancel</button>
                            <button class="btn-primary" onclick="createGoal()">Create Goal</button>
                        </div>
                    </div>
                </div>
            `;
            document.body.insertAdjacentHTML('beforeend', modalHtml);
            document.getElementById('goal-description').focus();
        }

        function closeGoalModal() {
            const modal = document.getElementById('goal-modal');
            if (modal) modal.remove();
        }

        async function createGoal() {
            const description = document.getElementById('goal-description').value.trim();
            const priority = document.getElementById('goal-priority').value;

            if (!description) {
                showToast('Please enter a goal description', 'error');
                return;
            }

            try {
                const response = await fetch(`${API_URL}/api/goals`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${localStorage.getItem('cerebro_token')}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ description, priority })
                });

                if (response.ok) {
                    showToast('Goal created!', 'success');
                    closeGoalModal();
                    await loadGoals();
                } else {
                    showToast('Failed to create goal', 'error');
                }
            } catch (e) {
                console.error('Error creating goal:', e);
                showToast('Error creating goal', 'error');
            }
        }

        async function completeGoal(goalId) {
            try {
                const response = await fetch(`${API_URL}/api/goals/${goalId}/complete`, {
                    method: 'POST',
                    headers: { 'Authorization': `Bearer ${localStorage.getItem('cerebro_token')}` }
                });

                if (response.ok) {
                    showToast('Goal completed! ', 'success');
                    await loadGoals();
                }
            } catch (e) {
                console.error('Error completing goal:', e);
            }
        }

        async function pursueGoal(goalId) {
            const goal = goals.find(g => g.goal_id === goalId);
            if (!goal) return;

            showToast('Spawning agent to pursue goal...', 'info');

            try {
                // Create an agent to pursue this goal
                const response = await fetch(`${API_URL}/agents`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${localStorage.getItem('cerebro_token')}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        task: `Work on achieving this goal: ${goal.description}\n\nBreak it down into actionable steps and start executing.`,
                        agent_type: 'worker',
                        context: `Goal ID: ${goalId}, Priority: ${goal.priority}`
                    })
                });

                if (response.ok) {
                    const data = await response.json();
                    showToast('Agent spawned to pursue goal!', 'success');
                    switchView('agents');
                }
            } catch (e) {
                console.error('Error pursuing goal:', e);
                showToast('Failed to spawn agent', 'error');
            }
        }

        function showGoalDetail(goalId) {
            // For now, just show the pursue/edit options
            const goal = goals.find(g => g.goal_id === goalId);
            if (!goal) return;
            // Could expand to a full detail view later
        }

        // ==================== PREDICTIVE INTERRUPTS ====================
        async function analyzeMessageBeforeSending(message) {
            try {
                const response = await fetch(`${API_URL}/api/chat/analyze`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${localStorage.getItem('cerebro_token')}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ message })
                });

                const data = await response.json();

                if (data.warnings && data.warnings.length > 0) {
                    // Show warning modal
                    pendingChatMessage = message;
                    showPredictionWarningModal(data.warnings, data.suggestions || []);
                    return false; // Don't send yet
                }

                return true; // OK to send
            } catch (e) {
                console.error('Error analyzing message:', e);
                return true; // On error, let it through
            }
        }

        function showPredictionWarningModal(warnings, suggestions) {
            const warningsHtml = warnings.map(w => `
                <div class="warning-item">
                    <span class="confidence">${Math.round((w.confidence || 0.7) * 100)}%</span>
                    <span class="text">${escapeHtml(w.warning || w.pattern)}</span>
                </div>
            `).join('');

            const alternativesHtml = suggestions.length > 0 ? `
                <div class="prediction-alternatives">
                    <h4>Suggestions:</h4>
                    <ul>
                        ${suggestions.map((s, i) => `
                            <li onclick="useSuggestion('${escapeHtml(s.message || s)}')">${escapeHtml(s.message || s)}</li>
                        `).join('')}
                    </ul>
                </div>
            ` : '';

            const modalHtml = `
                <div class="modal-overlay" id="prediction-modal" onclick="if(event.target === this) closePredictionModal()">
                    <div class="modal prediction-modal">
                        <div class="modal-header">
                            <span class="modal-icon"></span>
                            <h3>Cerebro Detected a Potential Issue</h3>
                        </div>
                        <div class="modal-body">
                            <div class="prediction-warnings">
                                ${warningsHtml}
                            </div>
                            ${alternativesHtml}
                        </div>
                        <div class="modal-actions">
                            <button class="btn-secondary" onclick="cancelPredictedAction()">Cancel</button>
                            <button class="btn-primary" onclick="proceedAnyway()">Proceed Anyway</button>
                        </div>
                    </div>
                </div>
            `;

            document.body.insertAdjacentHTML('beforeend', modalHtml);
        }

        function closePredictionModal() {
            const modal = document.getElementById('prediction-modal');
            if (modal) modal.remove();
            pendingChatMessage = null;
        }

        function cancelPredictedAction() {
            closePredictionModal();
            showToast('Action cancelled', 'info');
        }

        function proceedAnyway() {
            closePredictionModal();
            if (pendingChatMessage) {
                // Send the message directly without re-analyzing
                sendMessageDirect(pendingChatMessage);
                pendingChatMessage = null;
            }
        }

        function useSuggestion(suggestion) {
            closePredictionModal();
            // Put suggestion in chat input
            const chatInput = document.getElementById('chat-input');
            if (chatInput) {
                chatInput.value = suggestion;
                chatInput.focus();
            }
        }

        // Helper to send message without analysis (after warning accepted)
        function sendMessageDirect(message) {
            if (socket && socket.connected) {
                socket.emit('chat_message', {
                    content: message,
                    session_id: 'default',
                    model: getSelectedModel()
                });

                // Add user message to UI
                addMessage('user', message);
                scrollMessagesToBottom();
            }
        }

        // Escape HTML helper
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // ==================== AUTOMATION SYSTEM ====================
        let schedules = [];
        let currentCalendarDate = new Date();
        let automationAgentType = 'researcher';
        let automationScheduleType = 'once';
        let automationFrequency = 'daily';
        let automationDaysOfWeek = [1, 2, 3, 4, 5]; // Mon-Fri default
        let automationTimeout = 3600; // default 1 hour

        function selectAutomationTimeout(btn) {
            document.querySelectorAll('#automation-timeout-selector .timeout-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            automationTimeout = parseInt(btn.dataset.timeout);
        }

        async function loadSchedules() {
            try {
                const response = await fetch(`${API_URL}/schedules`, {
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                const data = await response.json();
                schedules = data.schedules || [];
            } catch (error) {
                console.error('Failed to load schedules:', error);
                schedules = [];
            }
            // Always render even if API fails
            renderSchedulesList();
            renderCalendar();
        }

        async function loadExecutionHistory() {
            try {
                const response = await fetch(`${API_URL}/schedules/history?limit=10`, {
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                const data = await response.json();
                renderExecutionHistory(data.executions || []);
            } catch (error) {
                console.error('Failed to load history:', error);
            }
        }

        async function clearRecentActivity() {
            if (!await cerebroConfirm('Clear all recent activity? This cannot be undone.', { title: 'Clear Activity', danger: true, confirmText: 'Clear' })) {
                return;
            }

            try {
                const response = await fetch(`${API_URL}/schedules/history`, {
                    method: 'DELETE',
                    headers: { 'Authorization': `Bearer ${token}` }
                });

                if (response.ok) {
                    renderExecutionHistory([]);
                    showToast('Activity cleared', 'success');
                } else {
                    showToast('Failed to clear activity', 'error');
                }
            } catch (error) {
                console.error('Failed to clear activity:', error);
                showToast('Failed to clear activity', 'error');
            }
        }

        function renderCalendar() {
            const grid = document.getElementById('calendar-grid');
            const label = document.getElementById('calendar-month-label');
            if (!grid || !label) return;

            const year = currentCalendarDate.getFullYear();
            const month = currentCalendarDate.getMonth();

            const monthNames = ['January', 'February', 'March', 'April', 'May', 'June',
                               'July', 'August', 'September', 'October', 'November', 'December'];
            label.textContent = `${monthNames[month]} ${year}`;

            // Get first day of month and total days
            const firstDay = new Date(year, month, 1).getDay();
            const daysInMonth = new Date(year, month + 1, 0).getDate();
            const daysInPrevMonth = new Date(year, month, 0).getDate();

            const today = new Date();
            const isCurrentMonth = today.getFullYear() === year && today.getMonth() === month;

            // Get schedules for this month
            const monthSchedules = getSchedulesForMonth(year, month);

            grid.innerHTML = '';

            // Previous month days
            for (let i = firstDay - 1; i >= 0; i--) {
                const day = daysInPrevMonth - i;
                grid.innerHTML += `<div class="calendar-day other-month"><span class="day-number">${day}</span></div>`;
            }

            // Current month days
            for (let day = 1; day <= daysInMonth; day++) {
                const isToday = isCurrentMonth && today.getDate() === day;
                const dateStr = `${year}-${String(month + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
                const daySchedules = monthSchedules.filter(s => s.dates && s.dates.includes(dateStr));

                let eventsHtml = '';
                daySchedules.forEach(s => {
                    eventsHtml += `<div class="event-dot ${s.agent_type}"></div>`;
                });

                grid.innerHTML += `
                    <div class="calendar-day ${isToday ? 'today' : ''}" onclick="showDaySchedules('${dateStr}')">
                        <span class="day-number">${day}</span>
                        <div class="day-events">${eventsHtml}</div>
                    </div>
                `;
            }

            // Next month days to fill grid
            const totalCells = firstDay + daysInMonth;
            const remainingCells = totalCells % 7 === 0 ? 0 : 7 - (totalCells % 7);
            for (let day = 1; day <= remainingCells; day++) {
                grid.innerHTML += `<div class="calendar-day other-month"><span class="day-number">${day}</span></div>`;
            }
        }

        function getSchedulesForMonth(year, month) {
            // Calculate which dates each schedule runs on this month
            return schedules.map(schedule => {
                const dates = [];
                const daysInMonth = new Date(year, month + 1, 0).getDate();

                if (schedule.schedule_type === 'once' && schedule.date) {
                    const schedDate = new Date(schedule.date);
                    if (schedDate.getFullYear() === year && schedDate.getMonth() === month) {
                        dates.push(schedule.date);
                    }
                } else if (schedule.schedule_type === 'recurring') {
                    for (let day = 1; day <= daysInMonth; day++) {
                        const date = new Date(year, month, day);
                        const dayOfWeek = date.getDay();

                        if (schedule.frequency === 'daily') {
                            dates.push(`${year}-${String(month + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`);
                        } else if (schedule.frequency === 'weekly' && schedule.days_of_week && schedule.days_of_week.includes(dayOfWeek)) {
                            dates.push(`${year}-${String(month + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`);
                        } else if (schedule.frequency === 'monthly' && day === 1) {
                            dates.push(`${year}-${String(month + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`);
                        }
                    }
                }

                return { ...schedule, dates };
            });
        }

        function navigateCalendar(direction) {
            currentCalendarDate.setMonth(currentCalendarDate.getMonth() + direction);
            renderCalendar();
        }

        function showDaySchedules(dateStr) {
            // Could show a popup with that day's schedules
            console.log('Day clicked:', dateStr);
        }

        function renderSchedulesList() {
            const list = document.getElementById('schedules-list');
            if (!list) return;

            // Update stats
            updateAutomationStats();

            if (schedules.length === 0) {
                list.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
                        </div>
                        <div class="empty-state-text">No automations yet. Create one to get started!</div>
                    </div>
                `;
                return;
            }

            const agentIcons = {
                'researcher': '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/></svg>',
                'coder': '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="16 18 22 12 16 6"/><polyline points="8 6 2 12 8 18"/></svg>',
                'worker': '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/></svg>',
                'analyst': '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="20" x2="18" y2="10"/><line x1="12" y1="20" x2="12" y2="4"/><line x1="6" y1="20" x2="6" y2="14"/></svg>'
            };
            const defaultIcon = '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="8" r="5"/><path d="M3 21v-2a7 7 0 0 1 7-7h4a7 7 0 0 1 7 7v2"/></svg>';

            list.innerHTML = schedules.map(schedule => {
                const icon = agentIcons[schedule.agent_type] || defaultIcon;
                const timing = schedule.schedule_type === 'once'
                    ? `${schedule.date} at ${schedule.time}`
                    : `${schedule.frequency} at ${schedule.time}`;
                const badge = schedule.schedule_type === 'recurring'
                    ? '<span class="schedule-badge recurring">recurring</span>'
                    : '<span class="schedule-badge">one-time</span>';

                return `
                    <div class="schedule-card" onclick="openEditAutomationModal('${schedule.id}')" style="cursor: pointer;">
                        <div class="schedule-toggle" onclick="event.stopPropagation()">
                            <input type="checkbox" ${schedule.enabled ? 'checked' : ''}
                                   onchange="toggleSchedule('${schedule.id}', this.checked)">
                        </div>
                        <div class="schedule-info">
                            <div class="schedule-name">${icon} ${schedule.name}</div>
                            <div class="schedule-timing">${timing} ${badge}</div>
                        </div>
                        <div class="schedule-actions" onclick="event.stopPropagation()">
                            <button class="run-btn" onclick="runScheduleNow('${schedule.id}')" title="Run now">
                                <svg width="12" height="12" viewBox="0 0 24 24" fill="currentColor"><polygon points="5 3 19 12 5 21 5 3"/></svg>
                            </button>
                            <button class="delete-btn" onclick="deleteSchedule('${schedule.id}')" title="Delete">
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg>
                            </button>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function updateAutomationStats() {
            const totalEl = document.getElementById('auto-stat-total');
            const activeEl = document.getElementById('auto-stat-active');
            const todayEl = document.getElementById('auto-stat-today');
            const countEl = document.getElementById('auto-count');

            if (totalEl) totalEl.textContent = schedules.length;
            if (activeEl) activeEl.textContent = schedules.filter(s => s.enabled).length;
            if (countEl) countEl.textContent = schedules.length;

            // Count schedules that run today
            const today = new Date().toISOString().split('T')[0];
            const todayCount = schedules.filter(s => {
                if (!s.enabled) return false;
                if (s.schedule_type === 'once') return s.date === today;
                if (s.schedule_type === 'recurring') {
                    if (s.frequency === 'daily') return true;
                    if (s.frequency === 'weekly') {
                        const dayOfWeek = new Date().getDay();
                        return s.days_of_week && s.days_of_week.includes(dayOfWeek);
                    }
                }
                return false;
            }).length;
            if (todayEl) todayEl.textContent = todayCount;
        }

        function renderExecutionHistory(executions) {
            const container = document.getElementById('execution-history');
            if (!container) return;

            if (executions.length === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10 9 9 9 8 9"/></svg>
                        </div>
                        <div class="empty-state-text">No executions yet</div>
                    </div>
                `;
                return;
            }

            const statusIcons = {
                'success': '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><polyline points="20 6 9 17 4 12"/></svg>',
                'failed': '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>',
                'running': '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><path d="M12 6v6l4 2"/></svg>'
            };
            const defaultStatusIcon = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><path d="M12 6v6l4 2"/></svg>';

            container.innerHTML = executions.map(exec => {
                const time = new Date(exec.started_at).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                const date = new Date(exec.started_at).toLocaleDateString([], { month: 'short', day: 'numeric' });
                const icon = statusIcons[exec.status] || defaultStatusIcon;

                // Make clickable if agent_id exists
                const clickable = exec.agent_id ? 'clickable' : '';
                const onclick = exec.agent_id ? `onclick="showExecutionAgentDetail('${exec.agent_id}')"` : '';

                return `
                    <div class="execution-item ${clickable}" ${onclick}>
                        <div class="execution-time">${date}<br>${time}</div>
                        <div class="execution-status ${exec.status}">${icon}</div>
                        <div class="execution-info">
                            <div class="execution-name">${exec.schedule_name}</div>
                            <div class="execution-type">${exec.trigger}  ${exec.agent_type}</div>
                        </div>
                        ${exec.agent_id ? '<div class="execution-arrow"><svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="9 18 15 12 9 6"/></svg></div>' : ''}
                    </div>
                `;
            }).join('');
        }

        function openCreateAutomationModal() {
            // Reset edit mode
            editingScheduleId = null;

            // Reset form
            document.getElementById('automation-name').value = '';
            document.getElementById('automation-prompt').value = '';
            document.getElementById('automation-time').value = '09:00';
            document.getElementById('automation-enabled').checked = true;

            // Set default date to tomorrow
            const tomorrow = new Date();
            tomorrow.setDate(tomorrow.getDate() + 1);
            document.getElementById('automation-date').value = tomorrow.toISOString().split('T')[0];

            // Reset toggles
            automationAgentType = 'researcher';
            automationScheduleType = 'once';
            automationFrequency = 'daily';
            automationDaysOfWeek = [1, 2, 3, 4, 5];
            automationTimeout = 3600;

            // Reset UI
            document.querySelectorAll('#automation-agent-selector .role-option').forEach(opt => {
                opt.classList.toggle('selected', opt.dataset.role === 'researcher');
            });
            document.querySelectorAll('.schedule-type-toggle .toggle-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.type === 'once');
            });
            document.querySelectorAll('.day-selector .day-btn').forEach(btn => {
                const day = parseInt(btn.dataset.day);
                btn.classList.toggle('active', automationDaysOfWeek.includes(day));
            });
            document.querySelectorAll('#automation-timeout-selector .timeout-btn').forEach(btn => {
                btn.classList.toggle('active', parseInt(btn.dataset.timeout) === 3600);
            });

            // Hide recurring options
            document.getElementById('recurring-options').classList.add('hidden');
            document.getElementById('weekly-options').classList.add('hidden');
            document.getElementById('cron-options').classList.add('hidden');
            document.getElementById('date-group').style.display = 'block';

            // Reset modal title and button for create mode
            document.querySelector('#automation-modal .modal-title').textContent = ' Create Automation';
            document.querySelector('#automation-modal .modal-footer .btn-primary').textContent = 'Create Automation';
            document.querySelector('#automation-modal .modal-footer .btn-primary').onclick = createAutomation;

            document.body.classList.add('modal-open');
            document.getElementById('automation-modal').classList.add('active');
        }

        function closeAutomationModal() {
            document.body.classList.remove('modal-open');
            document.getElementById('automation-modal').classList.remove('active');
        }

        function selectAutomationAgent(agentType) {
            automationAgentType = agentType;
            document.querySelectorAll('#automation-agent-selector .role-option').forEach(opt => {
                opt.classList.toggle('selected', opt.dataset.role === agentType);
            });
        }

        function selectScheduleType(type) {
            automationScheduleType = type;
            document.querySelectorAll('.schedule-type-toggle .toggle-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.type === type);
            });

            const recurringOptions = document.getElementById('recurring-options');
            const dateGroup = document.getElementById('date-group');

            if (type === 'recurring') {
                recurringOptions.classList.remove('hidden');
                dateGroup.style.display = 'none';
                updateFrequencyOptions();
            } else {
                recurringOptions.classList.add('hidden');
                dateGroup.style.display = 'block';
                document.getElementById('weekly-options').classList.add('hidden');
                document.getElementById('cron-options').classList.add('hidden');
            }
        }

        function updateFrequencyOptions() {
            const frequency = document.getElementById('automation-frequency').value;
            automationFrequency = frequency;

            const weeklyOptions = document.getElementById('weekly-options');
            const cronOptions = document.getElementById('cron-options');

            weeklyOptions.classList.toggle('hidden', frequency !== 'weekly');
            cronOptions.classList.toggle('hidden', frequency !== 'custom');
        }

        function toggleAutomationDay(day) {
            const btn = document.querySelector(`.day-selector .day-btn[data-day="${day}"]`);
            const index = automationDaysOfWeek.indexOf(day);

            if (index > -1) {
                automationDaysOfWeek.splice(index, 1);
                btn.classList.remove('active');
            } else {
                automationDaysOfWeek.push(day);
                automationDaysOfWeek.sort();
                btn.classList.add('active');
            }
        }

        let editingScheduleId = null; // Track if we're editing

        async function createAutomation() {
            const name = document.getElementById('automation-name').value.trim();
            const prompt = document.getElementById('automation-prompt').value.trim();

            if (!name || !prompt) {
                cerebroAlert('Please enter a name and task/prompt', { title: 'Missing Field' });
                return;
            }

            const data = {
                name: name,
                agent_type: automationAgentType,
                prompt: prompt,
                schedule_type: automationScheduleType,
                frequency: automationFrequency,
                date: document.getElementById('automation-date').value,
                time: document.getElementById('automation-time').value,
                days_of_week: automationDaysOfWeek,
                cron: document.getElementById('automation-cron')?.value || null,
                enabled: document.getElementById('automation-enabled').checked,
                timeout: automationTimeout
            };

            try {
                const response = await fetch(`${API_URL}/schedules`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(data)
                });

                if (response.ok) {
                    closeAutomationModal();
                    loadSchedules();
                    loadExecutionHistory();
                } else {
                    const err = await response.json();
                    cerebroAlert('Failed to create automation: ' + (err.detail || 'Unknown error'), { title: 'Error', danger: true });
                }
            } catch (error) {
                console.error('Failed to create automation:', error);
                cerebroAlert('Failed to create automation', { title: 'Error', danger: true });
            }
        }

        async function openEditAutomationModal(scheduleId) {
            // Find the schedule
            const schedule = schedules.find(s => s.id === scheduleId);
            if (!schedule) {
                console.error('Schedule not found:', scheduleId);
                return;
            }

            editingScheduleId = scheduleId;

            // Pre-populate the form
            document.getElementById('automation-name').value = schedule.name || '';
            document.getElementById('automation-prompt').value = schedule.prompt || '';
            document.getElementById('automation-time').value = schedule.time || '09:00';
            document.getElementById('automation-date').value = schedule.date || '';
            document.getElementById('automation-enabled').checked = schedule.enabled !== false;

            // Set agent type
            automationAgentType = schedule.agent_type || 'researcher';
            document.querySelectorAll('#automation-agent-selector .role-option').forEach(opt => {
                opt.classList.toggle('selected', opt.dataset.role === automationAgentType);
            });

            // Set timeout
            automationTimeout = schedule.timeout || 3600;
            document.querySelectorAll('#automation-timeout-selector .timeout-btn').forEach(btn => {
                btn.classList.toggle('active', parseInt(btn.dataset.timeout) === automationTimeout);
            });

            // Set schedule type
            automationScheduleType = schedule.schedule_type || 'once';
            document.querySelectorAll('.schedule-type-toggle .toggle-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.type === automationScheduleType);
            });

            // Set frequency
            automationFrequency = schedule.frequency || 'daily';
            document.getElementById('automation-frequency').value = automationFrequency;

            // Set days of week
            automationDaysOfWeek = schedule.days_of_week || [1, 2, 3, 4, 5];
            document.querySelectorAll('.day-selector .day-btn').forEach(btn => {
                const day = parseInt(btn.dataset.day);
                btn.classList.toggle('active', automationDaysOfWeek.includes(day));
            });

            // Set cron if exists
            if (schedule.cron) {
                document.getElementById('automation-cron').value = schedule.cron;
            }

            // Show/hide appropriate options
            const recurringOptions = document.getElementById('recurring-options');
            const dateGroup = document.getElementById('date-group');
            const weeklyOptions = document.getElementById('weekly-options');
            const cronOptions = document.getElementById('cron-options');

            if (automationScheduleType === 'recurring') {
                recurringOptions.classList.remove('hidden');
                dateGroup.style.display = 'none';
                weeklyOptions.classList.toggle('hidden', automationFrequency !== 'weekly');
                cronOptions.classList.toggle('hidden', automationFrequency !== 'custom');
            } else {
                recurringOptions.classList.add('hidden');
                dateGroup.style.display = 'block';
                weeklyOptions.classList.add('hidden');
                cronOptions.classList.add('hidden');
            }

            // Update modal title and button
            document.querySelector('#automation-modal .modal-title').textContent = ' Edit Automation';
            document.querySelector('#automation-modal .modal-footer .btn-primary').textContent = 'Save Changes';
            document.querySelector('#automation-modal .modal-footer .btn-primary').onclick = updateAutomation;

            document.body.classList.add('modal-open');
            document.getElementById('automation-modal').classList.add('active');
        }

        async function updateAutomation() {
            if (!editingScheduleId) return;

            const name = document.getElementById('automation-name').value.trim();
            const prompt = document.getElementById('automation-prompt').value.trim();

            if (!name || !prompt) {
                cerebroAlert('Please enter a name and task/prompt', { title: 'Missing Field' });
                return;
            }

            const data = {
                name: name,
                agent_type: automationAgentType,
                prompt: prompt,
                schedule_type: automationScheduleType,
                frequency: automationFrequency,
                date: document.getElementById('automation-date').value,
                time: document.getElementById('automation-time').value,
                days_of_week: automationDaysOfWeek,
                cron: document.getElementById('automation-cron')?.value || null,
                enabled: document.getElementById('automation-enabled').checked,
                timeout: automationTimeout
            };

            try {
                const response = await fetch(`${API_URL}/schedules/${editingScheduleId}`, {
                    method: 'PATCH',
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(data)
                });

                if (response.ok) {
                    closeAutomationModal();
                    loadSchedules();
                } else {
                    const err = await response.json();
                    cerebroAlert('Failed to update automation: ' + (err.detail || 'Unknown error'), { title: 'Error', danger: true });
                }
            } catch (error) {
                console.error('Failed to update automation:', error);
                cerebroAlert('Failed to update automation', { title: 'Error', danger: true });
            }
        }

        async function runScheduleNow(scheduleId) {
            try {
                await fetch(`${API_URL}/schedules/${scheduleId}/run`, {
                    method: 'POST',
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                // Refresh history after a short delay
                setTimeout(() => loadExecutionHistory(), 1000);
            } catch (error) {
                console.error('Failed to run schedule:', error);
            }
        }

        async function toggleSchedule(scheduleId, enabled) {
            try {
                await fetch(`${API_URL}/schedules/${scheduleId}`, {
                    method: 'PATCH',
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ enabled })
                });
                loadSchedules();
            } catch (error) {
                console.error('Failed to toggle schedule:', error);
            }
        }

        async function deleteSchedule(scheduleId) {
            if (!await cerebroConfirm('Delete this automation?', { title: 'Delete Automation', danger: true, confirmText: 'Delete' })) return;

            try {
                await fetch(`${API_URL}/schedules/${scheduleId}`, {
                    method: 'DELETE',
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                loadSchedules();
            } catch (error) {
                console.error('Failed to delete schedule:', error);
            }
        }

        // ==================== STANDALONE / ELECTRON DETECTION ====================
        // Standalone mode: running inside Electron or Docker (not the Linux server)
        const _IS_STANDALONE = !!(window.cerebroDesktop) || (window.location.port === '61000' && window.location.hostname === 'localhost');

        // ==================== PARTICLE BACKGROUND ====================
        function initParticleBackground() {
            // Skip particles entirely in standalone/Electron mode  devastating on software rendering
            if (_IS_STANDALONE) {
                console.log('[Perf] Particles disabled in standalone mode');
                return;
            }
            if (typeof tsParticles === 'undefined') return;

            tsParticles.load("particles-bg", {
                particles: {
                    number: { value: 15, density: { enable: true, value_area: 1200 } },
                    color: { value: ["#8b5cf6", "#a78bfa", "#6d28d9"] },
                    opacity: {
                        value: 0.3,
                        animation: { enable: true, speed: 0.5, minimumValue: 0.1, sync: false }
                    },
                    size: {
                        value: { min: 1, max: 3 },
                        animation: { enable: true, speed: 2, minimumValue: 0.5, sync: false }
                    },
                    move: {
                        enable: true,
                        speed: 0.3,
                        direction: "none",
                        random: true,
                        straight: false,
                        outModes: { default: "out" }
                    },
                    links: {
                        enable: true,
                        color: "#8b5cf6",
                        opacity: 0.15,
                        distance: 120,
                        width: 1
                    }
                },
                interactivity: {
                    events: {
                        onHover: { enable: true, mode: "grab" },
                        onClick: { enable: true, mode: "push" }
                    },
                    modes: {
                        grab: { distance: 150, links: { opacity: 0.3 } },
                        push: { quantity: 2 }
                    }
                },
                detectRetina: true,
                fpsLimit: 30
            });
        }

        // ==================== GSAP ANIMATION UTILITIES ====================
        function animateMessageIn(element, isUser = false) {
            // In standalone mode, use simple CSS animation (no blur filter  very expensive on software rendering)
            if (_IS_STANDALONE || typeof gsap === 'undefined') {
                element.style.animation = 'messageIn 0.3s ease forwards';
                return;
            }

            gsap.fromTo(element,
                {
                    opacity: 0,
                    y: 20,
                    scale: 0.95,
                    filter: 'blur(8px)'
                },
                {
                    opacity: 1,
                    y: 0,
                    scale: 1,
                    filter: 'blur(0px)',
                    duration: 0.4,
                    ease: 'power2.out'
                }
            );

            if (!isUser) {
                gsap.fromTo(element,
                    { boxShadow: '0 0 40px rgba(139, 92, 246, 0.4)' },
                    { boxShadow: '0 4px 16px rgba(0, 0, 0, 0.4)', duration: 0.8, delay: 0.2 }
                );
            }
        }

        function initCardHoverEffects() {
            document.querySelectorAll('.agent-card, .suggestion-card').forEach(card => {
                card.addEventListener('mouseenter', () => {
                    if (typeof gsap !== 'undefined') {
                        gsap.to(card, { y: -4, duration: 0.3, ease: 'power2.out' });
                    }
                });

                card.addEventListener('mouseleave', () => {
                    if (typeof gsap !== 'undefined') {
                        gsap.to(card, { y: 0, duration: 0.3, ease: 'power2.out' });
                    }
                });
            });
        }

        function animateListIn(selector) {
            if (typeof gsap === 'undefined') return;

            const elements = document.querySelectorAll(selector);
            gsap.fromTo(elements,
                { opacity: 0, y: 30 },
                {
                    opacity: 1,
                    y: 0,
                    duration: 0.4,
                    stagger: 0.08,
                    ease: 'power2.out'
                }
            );
        }

        function addRippleEffect(button) {
            button.addEventListener('click', function(e) {
                const rect = this.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                const ripple = document.createElement('span');
                ripple.className = 'ripple';
                ripple.style.left = x + 'px';
                ripple.style.top = y + 'px';
                this.appendChild(ripple);

                if (typeof gsap !== 'undefined') {
                    gsap.fromTo(ripple,
                        { scale: 0, opacity: 0.5 },
                        {
                            scale: 4,
                            opacity: 0,
                            duration: 0.6,
                            ease: 'power2.out',
                            onComplete: () => ripple.remove()
                        }
                    );
                } else {
                    setTimeout(() => ripple.remove(), 600);
                }
            });
        }

        // ==================== CINEMATIC ONBOARDING ====================
        const CinOnboard = {
            data: { name: '', password: '', use_cases: [], style: 'balanced', personality_tone: 'professional', experience_level: 'intermediate', work_hours: 'all_hours' },
            SPEED: 18,
            PAUSE_SHORT: 250,
            PAUSE_MED: 500,
            PAUSE_LONG: 900,

            async run() {
                const orb = document.getElementById('cin-orb');
                const conv = document.getElementById('cin-conversation');

                // Phase 0: Cinematic intro
                await this.sleep(1500);
                if (typeof gsap !== 'undefined') {
                    gsap.fromTo(orb, { scale: 0, opacity: 0 }, { scale: 1, opacity: 1, duration: 1.2, ease: 'back.out(1.4)' });
                } else {
                    orb.classList.add('cin-orb-visible');
                }
                await this.sleep(2000);
                orb.classList.add('cin-orb-docked');
                await this.sleep(600);
                conv.classList.add('cin-conv-visible');
                await this.sleep(400);

                // Phase 1: Greeting + Name
                await this.typeText('Systems online.');
                await this.sleep(this.PAUSE_MED);
                await this.typeText("I'm Cerebro \u2014 your personal AI. Built to think, act, and evolve alongside you.");
                await this.sleep(this.PAUSE_MED);
                await this.typeText('But first... what do I call you?');
                await this.sleep(this.PAUSE_SHORT);
                this.data.name = await this.waitForTextInput('text', 'cin-name');
                await this.sleep(this.PAUSE_SHORT);
                await this.typeText(`${this.data.name}. I like that.`);
                await this.sleep(this.PAUSE_MED);
                await this.typeText(`Alright ${this.data.name}, let\u2019s get you set up.`);
                await this.sleep(this.PAUSE_LONG);

                // Phase 2: Use Cases (multi-select chips)
                await this.typeText('So \u2014 what are we going to be working on together?');
                await this.sleep(this.PAUSE_SHORT);
                await this.typeText('Select everything that applies.');
                await this.sleep(this.PAUSE_SHORT);
                this.data.use_cases = await this.showChips(['Coding', 'Research', 'Writing', 'Automation', 'Learning', 'Business']);
                await this.sleep(this.PAUSE_MED);

                // Phase 3: Communication Style (single-select)
                await this.typeText(`How do you want me to talk to you, ${this.data.name}?`);
                await this.sleep(this.PAUSE_SHORT);
                this.data.style = await this.showOptions([
                    { label: 'Short & direct', value: 'concise' },
                    { label: 'Clear with context', value: 'balanced' },
                    { label: 'Thorough explanations', value: 'detailed' }
                ]);
                await this.sleep(this.PAUSE_MED);

                // Phase 4: Personality Tone
                await this.typeText('And what kind of energy should I bring?');
                await this.sleep(this.PAUSE_SHORT);
                this.data.personality_tone = await this.showOptions([
                    { label: 'Professional', value: 'professional' },
                    { label: 'Casual & friendly', value: 'casual' },
                    { label: 'Military operator', value: 'military' },
                    { label: 'Witty & sharp', value: 'witty' }
                ]);
                await this.sleep(this.PAUSE_MED);

                // Phase 5: Experience Level
                await this.typeText(`Between you and me \u2014 how deep do you go with tech?`);
                await this.sleep(this.PAUSE_SHORT);
                this.data.experience_level = await this.showOptions([
                    { label: "I'm not very technical", value: 'beginner' },
                    { label: 'Somewhere in between', value: 'intermediate' },
                    { label: 'I live in the terminal', value: 'technical' }
                ]);
                await this.sleep(this.PAUSE_MED);

                // Phase 6: Work Hours
                await this.typeText("When are you usually in your zone? I'll know when to handle things in the background.");
                await this.sleep(this.PAUSE_SHORT);
                this.data.work_hours = await this.showOptions([
                    { label: 'Early bird', value: 'early_bird' },
                    { label: 'Night owl', value: 'night_owl' },
                    { label: '9 to 5', value: 'nine_to_five' },
                    { label: 'All hours', value: 'all_hours' }
                ]);
                await this.sleep(this.PAUSE_MED);

                // Phase 7: Password
                await this.typeText(`One last thing, ${this.data.name}. Let\u2019s secure this.`);
                await this.sleep(this.PAUSE_SHORT);
                await this.typeText('Choose a password for your neural link.');
                await this.sleep(this.PAUSE_SHORT);
                let passwordSet = false;
                while (!passwordSet) {
                    const pw = await this.waitForTextInput('password', 'cin-pw');
                    if (pw.length < 4) {
                        this.showError('Password must be at least 4 characters.');
                        continue;
                    }
                    await this.sleep(this.PAUSE_SHORT);
                    await this.typeText('Confirm it.');
                    await this.sleep(this.PAUSE_SHORT);
                    const pw2 = await this.waitForTextInput('password', 'cin-pw2');
                    if (pw !== pw2) {
                        this.showError("Passwords don't match. Try again.");
                        await this.sleep(this.PAUSE_MED);
                        await this.typeText('Let\u2019s try that again. Choose your password.');
                        await this.sleep(this.PAUSE_SHORT);
                        continue;
                    }
                    this.data.password = pw;
                    passwordSet = true;
                }
                await this.sleep(this.PAUSE_MED);

                // Phase 8: Completion + Dissolve
                await this.typeText('Neural link established.');
                await this.sleep(this.PAUSE_SHORT);
                await this.typeText(`Welcome aboard, ${this.data.name}. Let\u2019s build something extraordinary.`);
                document.getElementById('cin-orb').classList.add('cin-orb-surge');
                await this.sleep(2000);
                await this.submitSetup();
            },

            typeText(text, speed) {
                speed = speed || this.SPEED;
                return new Promise(resolve => {
                    const conv = document.getElementById('cin-conversation');
                    const line = document.createElement('div');
                    line.className = 'cin-line-cerebro';
                    conv.appendChild(line);
                    this.scrollToBottom();
                    let i = 0;
                    const tick = () => {
                        if (i < text.length) {
                            line.textContent += text[i];
                            i++;
                            this.scrollToBottom();
                            setTimeout(tick, speed);
                        } else {
                            resolve();
                        }
                    };
                    tick();
                });
            },

            showInputBar() {
                document.getElementById('cin-input-bar').classList.add('active');
            },

            hideInputBar() {
                document.getElementById('cin-input-bar').classList.remove('active');
                const content = document.getElementById('cin-input-content');
                content.replaceChildren();
            },

            waitForTextInput(type, id) {
                return new Promise(resolve => {
                    const content = document.getElementById('cin-input-content');
                    content.replaceChildren();
                    const wrap = document.createElement('div');
                    wrap.className = 'cin-bar-input-wrap';
                    const prompt = document.createElement('span');
                    prompt.className = 'cin-prompt';
                    prompt.textContent = '>';
                    const input = document.createElement('input');
                    input.type = type === 'password' ? 'password' : 'text';
                    input.className = 'cin-bar-input';
                    input.id = id;
                    input.autocomplete = 'off';
                    input.placeholder = type === 'password' ? 'Type your password...' : 'Type here...';
                    wrap.appendChild(prompt);
                    wrap.appendChild(input);
                    content.appendChild(wrap);
                    this.showInputBar();
                    setTimeout(() => input.focus(), 100);
                    const submit = () => {
                        const val = input.value.trim();
                        if (!val) return;
                        this.hideError();
                        this.hideInputBar();
                        resolve(val);
                    };
                    input.addEventListener('keydown', e => {
                        if (e.key === 'Enter') submit();
                    });
                });
            },

            showChips(options) {
                return new Promise(resolve => {
                    const content = document.getElementById('cin-input-content');
                    content.replaceChildren();
                    const wrap = document.createElement('div');
                    wrap.className = 'cin-bar-chips';
                    const selected = new Set();
                    options.forEach((opt, i) => {
                        const chip = document.createElement('div');
                        chip.className = 'cin-chip';
                        chip.textContent = opt;
                        chip.style.animationDelay = (i * 0.08) + 's';
                        chip.addEventListener('click', () => {
                            if (selected.has(opt)) {
                                selected.delete(opt);
                                chip.classList.remove('selected');
                            } else {
                                selected.add(opt);
                                chip.classList.add('selected');
                            }
                        });
                        wrap.appendChild(chip);
                    });
                    content.appendChild(wrap);
                    const btn = document.createElement('div');
                    btn.className = 'cin-continue-btn';
                    btn.textContent = 'Continue';
                    btn.style.animationDelay = (options.length * 0.08 + 0.2) + 's';
                    btn.addEventListener('click', () => {
                        if (selected.size === 0) {
                            this.showError('Select at least one option.');
                            return;
                        }
                        this.hideError();
                        this.hideInputBar();
                        resolve(Array.from(selected).map(s => s.toLowerCase()));
                    });
                    content.appendChild(btn);
                    this.showInputBar();
                });
            },

            showOptions(options) {
                return new Promise(resolve => {
                    const content = document.getElementById('cin-input-content');
                    content.replaceChildren();
                    const wrap = document.createElement('div');
                    wrap.className = 'cin-bar-options';
                    options.forEach((opt, i) => {
                        const el = document.createElement('div');
                        el.className = 'cin-option';
                        el.textContent = opt.label;
                        el.style.animationDelay = (i * 0.1) + 's';
                        el.addEventListener('click', () => {
                            el.classList.add('selected');
                            wrap.querySelectorAll('.cin-option').forEach(o => {
                                if (o !== el) o.classList.add('dimmed');
                            });
                            setTimeout(() => {
                                this.hideInputBar();
                                resolve(opt.value);
                            }, 500);
                        });
                        wrap.appendChild(el);
                    });
                    content.appendChild(wrap);
                    this.showInputBar();
                });
            },

            async submitSetup() {
                try {
                    const res = await fetch(`${API_URL}/auth/setup`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(this.data)
                    });
                    if (!res.ok) throw new Error((await res.json()).detail || 'Setup failed');
                    const data = await res.json();
                    token = data.token;
                    if (data.user) CEREBRO_USERNAME = data.user;
                    localStorage.setItem('cerebro_token', token);
                    await this.dissolveToApp();
                } catch (e) {
                    this.showError('Setup failed: ' + e.message);
                }
            },

            async dissolveToApp() {
                const dissolve = document.getElementById('cin-dissolve');
                dissolve.classList.add('active');
                await this.sleep(2000);
                document.getElementById('onboarding-view').classList.add('hidden');
                showApp();
                const mainApp = document.getElementById('main-app');
                mainApp.style.opacity = '0';
                mainApp.style.transition = 'opacity 0.5s ease';
                await this.sleep(50);
                mainApp.style.opacity = '1';
            },

            showError(msg) {
                const err = document.getElementById('cin-error');
                err.textContent = msg;
                err.classList.add('visible');
                setTimeout(() => this.hideError(), 3000);
            },

            hideError() {
                const err = document.getElementById('cin-error');
                if (err) err.classList.remove('visible');
            },

            scrollToBottom() {
                const conv = document.getElementById('cin-conversation');
                if (conv) conv.scrollTop = conv.scrollHeight;
            },

            sleep(ms) {
                return new Promise(r => setTimeout(r, ms));
            }
        };

        function showOnboarding() {
            document.getElementById('login-view').classList.add('hidden');
            document.getElementById('onboarding-view').classList.remove('hidden');
            CinOnboard.run();
        }

        // ==================== STARTUP ====================
        document.addEventListener('DOMContentLoaded', async () => {
            // Populate configurable display values
            const usernameDisplay = document.getElementById('username-display');
            if (usernameDisplay) usernameDisplay.textContent = CEREBRO_USERNAME;
            const presenceGreeting = document.getElementById('presence-greeting');
            if (presenceGreeting && presenceGreeting.textContent === 'Hey') {
                presenceGreeting.textContent = `Hey ${CEREBRO_USERNAME}`;
            }

            // Check if setup is complete
            try {
                const statusRes = await fetch(`${API_URL}/auth/status`);
                if (statusRes.ok) {
                    const status = await statusRes.json();
                    if (status.username) {
                        CEREBRO_USERNAME = status.username;
                    }
                    if (!status.setup_complete) {
                        // First-time user  show onboarding
                        document.getElementById('login-view').classList.add('hidden');
                        showOnboarding();
                        return;
                    }
                }
            } catch (e) {
                console.error('Auth status check failed:', e);
            }

            if (token) {
                // Validate token before showing app
                try {
                    const response = await fetch(`${API_URL}/briefing`, {
                        headers: { 'Authorization': `Bearer ${token}` }
                    });
                    if (response.ok) {
                        showApp();
                    } else {
                        // Token invalid - clear and show login
                        console.log('Token invalid, clearing...');
                        localStorage.removeItem('cerebro_token');
                        token = null;
                    }
                } catch (e) {
                    console.error('Token validation failed:', e);
                    // Don't clear token on network error, might be temporary
                }
            }

            document.getElementById('password-input').addEventListener('keydown', (e) => {
                if (e.key === 'Enter') login();
            });

            // Onboarding Enter key support
            ['onboard-name', 'onboard-password', 'onboard-password-confirm'].forEach(id => {
                const el = document.getElementById(id);
                if (el) el.addEventListener('keydown', (e) => { if (e.key === 'Enter') onboardNext(); });
            });

            // Auto-resize chat input
            const chatInput = document.getElementById('chat-input');
            chatInput.addEventListener('input', () => {
                chatInput.style.height = 'auto';
                chatInput.style.height = Math.min(chatInput.scrollHeight, 120) + 'px';
                // Keep messages visible when input grows
                const sc = document.getElementById('messages');
                if (sc && (sc.scrollHeight - sc.scrollTop - sc.clientHeight) < 200) {
                    sc.scrollTop = sc.scrollHeight;
                }
            });

            // Padding for chat is handled by CSS (.messages-container padding-bottom: 160px)

            // Initialize particle background
            initParticleBackground();

            // Initialize GSAP hover effects
            initCardHoverEffects();

            // Add ripple effects to primary/secondary buttons
            document.querySelectorAll('.btn-primary, .btn-secondary').forEach(addRippleEffect);
        });
    </script>

    <!-- Cerebro Custom Confirm Dialog -->
    <div class="cerebro-confirm-overlay" id="cerebro-confirm-overlay">
        <div class="cerebro-confirm-box">
            <div class="cerebro-confirm-header">
                <div class="cerebro-confirm-icon warn" id="cerebro-confirm-icon">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"/>
                        <line x1="12" y1="9" x2="12" y2="13"/>
                        <line x1="12" y1="17" x2="12.01" y2="17"/>
                    </svg>
                </div>
                <div class="cerebro-confirm-title" id="cerebro-confirm-title">Are you sure?</div>
            </div>
            <div class="cerebro-confirm-body" id="cerebro-confirm-body"></div>
            <div class="cerebro-confirm-actions">
                <button class="cerebro-confirm-btn cancel" id="cerebro-confirm-cancel">Cancel</button>
                <button class="cerebro-confirm-btn confirm" id="cerebro-confirm-ok">Confirm</button>
            </div>
        </div>
    </div>

    <script>
        // Custom confirm dialog - replaces browser confirm()
        function cerebroConfirm(message, options = {}) {
            return new Promise((resolve) => {
                const overlay = document.getElementById('cerebro-confirm-overlay');
                const titleEl = document.getElementById('cerebro-confirm-title');
                const bodyEl = document.getElementById('cerebro-confirm-body');
                const okBtn = document.getElementById('cerebro-confirm-ok');
                const cancelBtn = document.getElementById('cerebro-confirm-cancel');
                const iconEl = document.getElementById('cerebro-confirm-icon');

                titleEl.textContent = options.title || 'Are you sure?';
                // Support line breaks in message
                bodyEl.textContent = '';
                message.split('\n').forEach(function(line, i) {
                    if (i > 0) bodyEl.appendChild(document.createElement('br'));
                    bodyEl.appendChild(document.createTextNode(line));
                });
                okBtn.textContent = options.confirmText || 'Confirm';
                cancelBtn.style.display = '';
                cancelBtn.textContent = options.cancelText || 'Cancel';

                // Danger style
                if (options.danger) {
                    iconEl.className = 'cerebro-confirm-icon danger';
                    okBtn.className = 'cerebro-confirm-btn confirm danger';
                } else {
                    iconEl.className = 'cerebro-confirm-icon warn';
                    okBtn.className = 'cerebro-confirm-btn confirm';
                }

                overlay.classList.add('active');

                function cleanup(result) {
                    overlay.classList.remove('active');
                    okBtn.removeEventListener('click', onConfirm);
                    cancelBtn.removeEventListener('click', onCancel);
                    overlay.removeEventListener('click', onBackdrop);
                    document.removeEventListener('keydown', onKey);
                    resolve(result);
                }
                function onConfirm() { cleanup(true); }
                function onCancel() { cleanup(false); }
                function onBackdrop(e) { if (e.target === overlay) cleanup(false); }
                function onKey(e) { if (e.key === 'Escape') cleanup(false); if (e.key === 'Enter') cleanup(true); }

                okBtn.addEventListener('click', onConfirm);
                cancelBtn.addEventListener('click', onCancel);
                overlay.addEventListener('click', onBackdrop);
                document.addEventListener('keydown', onKey);

                okBtn.focus();
            });
        }

        // Custom alert dialog - replaces browser alert()
        function cerebroAlert(message, options = {}) {
            return cerebroConfirm(message, {
                title: options.title || 'Notice',
                confirmText: options.buttonText || 'OK',
                cancelText: '',
                danger: options.danger || false
            }).then(function() {
                // Hide cancel button for alerts (single-button)
                return true;
            });
        }
        // Override: hide cancel for alerts by wrapping cerebroConfirm
        var _origCerebroConfirm = cerebroConfirm;
        cerebroAlert = function(message, options) {
            options = options || {};
            return new Promise(function(resolve) {
                var overlay = document.getElementById('cerebro-confirm-overlay');
                var titleEl = document.getElementById('cerebro-confirm-title');
                var bodyEl = document.getElementById('cerebro-confirm-body');
                var okBtn = document.getElementById('cerebro-confirm-ok');
                var cancelBtn = document.getElementById('cerebro-confirm-cancel');
                var iconEl = document.getElementById('cerebro-confirm-icon');

                titleEl.textContent = options.title || 'Notice';
                bodyEl.textContent = '';
                message.split('\n').forEach(function(line, i) {
                    if (i > 0) bodyEl.appendChild(document.createElement('br'));
                    bodyEl.appendChild(document.createTextNode(line));
                });
                okBtn.textContent = options.buttonText || 'OK';
                cancelBtn.style.display = 'none';
                iconEl.className = options.danger ? 'cerebro-confirm-icon danger' : 'cerebro-confirm-icon warn';
                okBtn.className = options.danger ? 'cerebro-confirm-btn confirm danger' : 'cerebro-confirm-btn confirm';

                overlay.classList.add('active');

                function cleanup() {
                    overlay.classList.remove('active');
                    okBtn.removeEventListener('click', onOk);
                    overlay.removeEventListener('click', onBackdrop);
                    document.removeEventListener('keydown', onKey);
                    resolve(true);
                }
                function onOk() { cleanup(); }
                function onBackdrop(e) { if (e.target === overlay) cleanup(); }
                function onKey(e) { if (e.key === 'Escape' || e.key === 'Enter') cleanup(); }

                okBtn.addEventListener('click', onOk);
                overlay.addEventListener('click', onBackdrop);
                document.addEventListener('keydown', onKey);
                okBtn.focus();
            });
        };

        // Custom prompt dialog  replaces browser prompt()
        // Returns Promise<string|null> (null if cancelled)
        function cerebroPrompt(message, defaultValue, options) {
            options = options || {};
            return new Promise(function(resolve) {
                var overlay = document.getElementById('cerebro-confirm-overlay');
                var titleEl = document.getElementById('cerebro-confirm-title');
                var bodyEl = document.getElementById('cerebro-confirm-body');
                var okBtn = document.getElementById('cerebro-confirm-ok');
                var cancelBtn = document.getElementById('cerebro-confirm-cancel');
                var iconEl = document.getElementById('cerebro-confirm-icon');

                titleEl.textContent = options.title || message;
                bodyEl.textContent = '';

                // Add message text if title is custom
                if (options.title) {
                    var msgP = document.createElement('div');
                    msgP.style.cssText = 'margin-bottom:12px;color:var(--text-secondary);font-size:0.85rem;';
                    msgP.textContent = message;
                    bodyEl.appendChild(msgP);
                }

                // Add text input
                var input = document.createElement('input');
                input.type = 'text';
                input.value = defaultValue || '';
                input.placeholder = options.placeholder || '';
                input.style.cssText = 'width:100%;padding:10px 12px;background:var(--bg-primary);border:1px solid var(--border);border-radius:8px;color:var(--text-primary);font-size:0.9rem;font-family:inherit;outline:none;box-sizing:border-box;';
                input.addEventListener('focus', function() {
                    this.style.borderColor = 'rgba(139, 92, 246, 0.5)';
                });
                input.addEventListener('blur', function() {
                    this.style.borderColor = 'var(--border)';
                });
                bodyEl.appendChild(input);

                okBtn.textContent = options.confirmText || 'OK';
                cancelBtn.style.display = '';
                cancelBtn.textContent = options.cancelText || 'Cancel';
                iconEl.className = 'cerebro-confirm-icon warn';
                okBtn.className = 'cerebro-confirm-btn confirm';

                overlay.classList.add('active');

                function cleanup(result) {
                    overlay.classList.remove('active');
                    okBtn.removeEventListener('click', onConfirm);
                    cancelBtn.removeEventListener('click', onCancel);
                    overlay.removeEventListener('click', onBackdrop);
                    document.removeEventListener('keydown', onKey);
                    input.removeEventListener('keydown', onInputKey);
                    resolve(result);
                }
                function onConfirm() {
                    var val = input.value.trim();
                    cleanup(val || null);
                }
                function onCancel() { cleanup(null); }
                function onBackdrop(e) { if (e.target === overlay) cleanup(null); }
                function onKey(e) { if (e.key === 'Escape') cleanup(null); }
                function onInputKey(e) { if (e.key === 'Enter') { e.preventDefault(); onConfirm(); } }

                okBtn.addEventListener('click', onConfirm);
                cancelBtn.addEventListener('click', onCancel);
                overlay.addEventListener('click', onBackdrop);
                document.addEventListener('keydown', onKey);
                input.addEventListener('keydown', onInputKey);

                // Focus input and select text
                setTimeout(function() { input.focus(); input.select(); }, 100);
            });
        }
    </script>

    <!-- Voice Screenshot Overlay -->
    <div class="voice-screenshot-overlay" id="voiceScreenshotOverlay" onclick="if(event.target===this) closeVoiceScreenshotOverlay();">
        <button class="vs-overlay-close" onclick="closeVoiceScreenshotOverlay()">&times;</button>
        <img id="vsOverlayImg" src="" alt="Voice Screenshot" />
        <div class="vs-overlay-bar">
            <span class="vs-window-title" id="vsOverlayTitle"></span>
        </div>
    </div>

    <script>
        function showVoiceScreenshotOverlay(src, title) {
            var overlay = document.getElementById('voiceScreenshotOverlay');
            document.getElementById('vsOverlayImg').src = src;
            document.getElementById('vsOverlayTitle').textContent = title;
            overlay.classList.add('active');
            document.body.classList.add('modal-open');
        }
        function closeVoiceScreenshotOverlay() {
            var overlay = document.getElementById('voiceScreenshotOverlay');
            overlay.classList.remove('active');
            document.body.classList.remove('modal-open');
        }
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                var overlay = document.getElementById('voiceScreenshotOverlay');
                if (overlay && overlay.classList.contains('active')) {
                    closeVoiceScreenshotOverlay();
                }
            }
        });
    </script>

</body>
</html>
